<?xml version="1.0" encoding="utf-8"?>
<posts>
  <row Id="1" PostTypeId="1" AcceptedAnswerId="18" CreationDate="2018-03-12T17:00:45.567" Score="52" ViewCount="1163" Body="&lt;p&gt;I know that a &lt;a href=&quot;https://en.wikipedia.org/wiki/Turing_machine&quot; rel=&quot;noreferrer&quot;&gt;Turing machine&lt;/a&gt;&lt;sup&gt;1&lt;/sup&gt; can theoretically simulate &quot;anything&quot;, but I don't know whether it could simulate something as fundamentally different as a quantum-based computer.  Are there any attempts to do this, or has anybody proved it possible/not possible?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I've googled around, but I'm not an expert on this topic, so I'm not sure where to look. I've found the Wikipedia article on &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_Turing_machine&quot; rel=&quot;noreferrer&quot;&gt;quantum Turing machine&lt;/a&gt;, but I'm not certain how exactly it differs from a classical TM. I also found the paper &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0701108&quot; rel=&quot;noreferrer&quot;&gt;&lt;em&gt;Deutsch's Universal Quantum Turing Machine&lt;/em&gt;&lt;/a&gt;, by&#xA;W. Fouché et al., but it is rather difficult to understand for me.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;sub&gt;&#xA;1. In case it is not clear, by Turing machine I mean the theoretical concept, not a physical machine (i.e. an implementation of the theoretical concept).&lt;/sub&gt;&lt;/p&gt;&#xA;" OwnerUserId="7" LastEditorUserId="26" LastEditDate="2018-03-16T15:40:38.227" LastActivityDate="2018-04-29T21:10:40.053" Title="Can a Turing machine simulate a quantum computer?" Tags="&lt;simulation&gt;&lt;quantum-turing-machine&gt;" AnswerCount="3" CommentCount="1" FavoriteCount="9" />
  <row Id="3" PostTypeId="1" CreationDate="2018-03-12T17:12:07.927" Score="32" ViewCount="732" Body="&lt;p&gt;Quantum computers are known to be able to crack &lt;a href=&quot;https://en.wikipedia.org/wiki/Time_complexity#Polynomial_time&quot; rel=&quot;noreferrer&quot;&gt;in polynomial time&lt;/a&gt; a broad range of cryptographic algorithms which were previously thought to be solvable only by resources increasing exponentially with the bit size of the key. An example for that is &lt;a href=&quot;https://en.wikipedia.org/wiki/Shor%27s_algorithm&quot; rel=&quot;noreferrer&quot;&gt;Shor's algorithm&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But, as far I know, not all problems fall into this category. On &lt;a href=&quot;https://physics.aps.org/synopsis-for/10.1103/PhysRevA.94.012320&quot; rel=&quot;noreferrer&quot;&gt;Making Hard Problems for Quantum Computers&lt;/a&gt;, we can read&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Researchers have developed a computer algorithm that doesn’t solve problems but instead creates them for the purpose of evaluating quantum computers.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Can we still expect &lt;strong&gt;a new cryptographic algorithm which will be hard to crack using even a quantum computer&lt;/strong&gt;?&#xA;&lt;em&gt;For clarity: the question refers to specifically to the design of new algorithms&lt;/em&gt;. &lt;/p&gt;&#xA;" OwnerUserId="27" LastEditorUserId="1847" LastEditDate="2018-04-10T05:24:10.430" LastActivityDate="2018-06-19T16:48:13.740" Title="Is it possible for an encryption method to exist which is impossible to crack, even using quantum computers?" Tags="&lt;cryptography&gt;&lt;complexity-theory&gt;&lt;post-quantum-crypto&gt;" AnswerCount="4" CommentCount="7" FavoriteCount="5" />
  <row Id="4" PostTypeId="1" AcceptedAnswerId="84" CreationDate="2018-03-12T17:16:15.717" Score="14" ViewCount="256" Body="&lt;p&gt;Quantum gates are represented by matrices, which represent the transformations applied to qubits (states).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Suppose we have some quantum gate which operates on $2$ qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;How does the quantum gate &lt;em&gt;affect&lt;/em&gt; (not necessarily change it) the result of measuring the state of the qubits (as the measurement result is affected greatly by the probabilities of each possible state)? More specifically, is it possible to know, in advance, how the probabilities of each state change due to the quantum gate?&lt;/p&gt;&#xA;" OwnerUserId="13" LastEditorUserId="13" LastEditDate="2018-03-12T19:55:11.083" LastActivityDate="2018-03-29T10:43:33.000" Title="How do the probabilities of each state change after a transformation of a quantum gate?" Tags="&lt;qubit&gt;&lt;quantum-gate&gt;" AnswerCount="4" CommentCount="7" FavoriteCount="2" />
  <row Id="5" PostTypeId="2" ParentId="1" CreationDate="2018-03-12T17:18:12.873" Score="5" Body="&lt;p&gt;To simulate the collapse of the wave function you'd need a source of randomness. So you'd need a &lt;a href=&quot;https://en.wikipedia.org/wiki/Probabilistic_Turing_machine&quot; rel=&quot;noreferrer&quot;&gt;probabilistic Turing machine&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="29" LastActivityDate="2018-03-12T17:18:12.873" CommentCount="6" />
  <row Id="6" PostTypeId="1" AcceptedAnswerId="48" CreationDate="2018-03-12T17:21:02.420" Score="8" ViewCount="127" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;The minimum size of a computer that could simulate the universe would&#xA;  be the universe itself.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;This is quite a pretty big theory in classical computing and physics because to contain the information of the whole universe, you require a minimum information storage space that is of the size of the universe itself.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But, quantum computing computes and stores data in parallel to other data and thus while being efficient is actually more compact. We are talking ideal systems, so cooling mechanisms don't count as part of the computer. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Then, could such a system simulate the whole universe?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(I thought of a solution that I don't know how to actually prove. My logic is mostly based on the many worlds interpretation of quantum mechanics and that a quantum computer actually uses different universes to compute in parallel, thus increasing memory space and speed).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Any inputs will be gladly received and is highly appreciated.&lt;/p&gt;&#xA;" OwnerUserId="14" LastEditorUserId="26" LastEditDate="2018-03-12T17:42:23.107" LastActivityDate="2018-03-12T20:07:31.787" Title="Simulating a system inside a system" Tags="&lt;simulation&gt;&lt;memory-space&gt;" AnswerCount="1" CommentCount="4" FavoriteCount="2" />
  <row Id="7" PostTypeId="1" AcceptedAnswerId="89" CreationDate="2018-03-12T17:21:33.720" Score="15" ViewCount="167" Body="&lt;p&gt;Recent researches indicate that quantum algorithms are able to solve typical cryptology problems much faster than classic algorithms.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Have any quantum algorithms &lt;strong&gt;for encryption&lt;/strong&gt; been developed?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I'm aware about &lt;a href=&quot;https://en.wikipedia.org/wiki/BB84&quot; rel=&quot;noreferrer&quot;&gt;BB84&lt;/a&gt;, but it only seems to be a partial solution for solving the networking.&lt;/p&gt;&#xA;" OwnerUserId="31" LastEditorUserId="31" LastEditDate="2018-03-12T17:36:51.233" LastActivityDate="2018-03-15T19:15:03.470" Title="How is quantum cryptography different from cryptography used nowadays?" Tags="&lt;cryptography&gt;" AnswerCount="2" CommentCount="8" FavoriteCount="1" />
  <row Id="8" PostTypeId="1" CreationDate="2018-03-12T17:22:39.400" Score="11" ViewCount="116" Body="&lt;ol&gt;&#xA;&lt;li&gt;The enthusiast-level, inaccurate knowledge about quantum computers is that they can solve many exponentially solvable problems in polynomial time.&lt;/li&gt;&#xA;&lt;li&gt;The enthusiast-level, inaccurate knowledge about &lt;a href=&quot;https://en.wikipedia.org/wiki/Chaos_theory&quot; rel=&quot;nofollow noreferrer&quot;&gt;chaotic systems&lt;/a&gt; is that being highly sensitive to initial conditions, their prediction and control is very hard above a - typically, not enough - accuracy.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Today, one of the most famous practical usage of chaotic systems is the problem of modeling the weather of the Earth.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Putting (1) and (2) together, I think using quantum computers, we may have a significant (polynomial to exponential) step to handle them. Is it correct?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Do we have any essential advantage to handle chaos even more than this?&lt;/p&gt;&#xA;" OwnerUserId="27" LastEditorUserId="13" LastEditDate="2018-03-21T10:59:10.130" LastActivityDate="2018-03-21T10:59:10.130" Title="Does quantum computing have an essential advantage in analyzing/controlling chaotic systems?" Tags="&lt;quantum-computer&gt;&lt;applications&gt;" AnswerCount="2" CommentCount="1" />
  <row Id="10" PostTypeId="2" ParentId="8" CreationDate="2018-03-12T17:30:10.817" Score="5" Body="&lt;p&gt;Not always. Some problems are non-deterministic (their solution). Apart from that, some problems are, as you say, so sensitive to changes in initial conditions, that most solutions are too localized.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But there are cases where quantum computers can provide insightful results, that might shed light on different approaches to solutions. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Another point to consider is the use of Numerical methods in chaotic systems. Some methods are more optimal than others, at the cost of accuracy. With quantum computers, computation time decreases by a lot (acc. to theory), which may allow more accurate calculations, leading to a better understanding of the more difficult chaotic systems.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To clarify: Quantum computers might not be able to give an analytical solution (even to problems that &lt;em&gt;might&lt;/em&gt; have such solutions), but a more accurate approximation can often lead to a new understanding of the problem, which is a way to handle problems.&lt;/p&gt;&#xA;" OwnerUserId="13" LastEditorUserId="13" LastEditDate="2018-03-12T17:36:42.897" LastActivityDate="2018-03-12T17:36:42.897" CommentCount="0" />
  <row Id="11" PostTypeId="2" ParentId="8" CreationDate="2018-03-12T17:31:24.650" Score="4" Body="&lt;p&gt;No.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Chaos (as described in chaotic systems) is deterministic, and the evolution of such a system can be calculated using classical deterministic equations. The problem is the strong divergence of the different trajectories that even small differences in initial values can lead to large differences in the final values.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quantum computing does not help in this situation.&lt;/p&gt;&#xA;" OwnerUserId="18" LastActivityDate="2018-03-12T17:31:24.650" CommentCount="0" />
  <row Id="12" PostTypeId="1" AcceptedAnswerId="24" CreationDate="2018-03-12T17:36:27.727" Score="55" ViewCount="1635" Body="&lt;p&gt;Is there any way to emulate a quantum computer in my normal computer, so that I will be able to test and try quantum programming languages (such as &lt;a href=&quot;https://docs.microsoft.com/en-us/quantum/quantum-qr-intro?view=qsharp-preview&quot; rel=&quot;noreferrer&quot;&gt;Q#&lt;/a&gt;)? I mean something that I can really test my hypothesis and gets the most accurate results.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; I'm not really looking for simulating a quantum computer, but I'm not sure if its possible to efficiently emulate one on a normal non-quantum based PC.&lt;/p&gt;&#xA;" OwnerUserId="40" LastEditorUserId="40" LastEditDate="2018-03-28T11:21:32.470" LastActivityDate="2018-03-28T11:21:32.470" Title="Are there emulators for quantum computers?" Tags="&lt;quantum-computer&gt;&lt;simulation&gt;&lt;q#&gt;&lt;emulation&gt;" AnswerCount="6" CommentCount="3" FavoriteCount="9" />
  <row Id="13" PostTypeId="2" ParentId="3" CreationDate="2018-03-12T17:40:28.427" Score="20" Body="&lt;p&gt;I suppose there is a type of encryption that is not crackable using quantum computers: a &lt;a href=&quot;https://en.wikipedia.org/wiki/One-time_pad&quot; rel=&quot;noreferrer&quot;&gt;one-time pad&lt;/a&gt; such as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher&quot; rel=&quot;noreferrer&quot;&gt;Vigenère cipher&lt;/a&gt;. This is a cipher with a keypad that has at least the length of the encoded string and will be used only once. This cipher is impossible to crack even with a quantum computer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I will explain why:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's assume our plaintext is &lt;code&gt;ABCD&lt;/code&gt;. The corresponding key could be &lt;code&gt;1234&lt;/code&gt;. If you encode it then you get &lt;code&gt;XYZW&lt;/code&gt;. Now you can use &lt;code&gt;1234&lt;/code&gt; to get &lt;code&gt;ABCD&lt;/code&gt; or &lt;code&gt;4678&lt;/code&gt; to get &lt;code&gt;EFGH&lt;/code&gt; what might be a valid sentence too.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So the problem is that nobody can decide whether you meant &lt;code&gt;ABCD&lt;/code&gt; or &lt;code&gt;EFGH&lt;/code&gt; without knowing your key.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The only reason this kind of encryption can be cracked is that the users are lazy and use a key twice. And then you can try to crack it. Other problems are, as @peterh stated that one-time-pads require a secret channel to be shared&lt;/p&gt;&#xA;" OwnerUserId="11" LastEditorUserId="253" LastEditDate="2018-04-02T08:42:35.387" LastActivityDate="2018-04-02T08:42:35.387" CommentCount="5" />
  <row Id="14" PostTypeId="2" ParentId="3" CreationDate="2018-03-12T17:45:21.307" Score="15" Body="&lt;p&gt;Yes, there are a lot of proposals for &lt;a href=&quot;https://en.wikipedia.org/wiki/Post-quantum_cryptography&quot; rel=&quot;noreferrer&quot;&gt;Post-quantum cryptographical&lt;/a&gt; algorithms that provide the cryptographic primitives that we are used to (including asymmetric encryption with private and public keys).&lt;/p&gt;&#xA;" OwnerUserId="18" LastEditorUserId="18" LastEditDate="2018-03-12T18:11:13.767" LastActivityDate="2018-03-12T18:11:13.767" CommentCount="1" />
  <row Id="17" PostTypeId="2" ParentId="7" CreationDate="2018-03-12T17:50:46.827" Score="2" Body="&lt;p&gt;There is a cryptographic primitive that is only realisable with quantum computation: A &lt;a href=&quot;https://eprint.iacr.org/2013/606.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;revocable timelock&lt;/a&gt;. The base idea is to set up a problem that needs a certain time to be solved on a quantum computer, but the quantum computation can be cancelled in a &lt;em&gt;provable&lt;/em&gt; way.&lt;/p&gt;&#xA;" OwnerUserId="18" LastActivityDate="2018-03-12T17:50:46.827" CommentCount="1" />
  <row Id="18" PostTypeId="2" ParentId="1" CreationDate="2018-03-12T17:59:39.560" Score="36" Body="&lt;p&gt;&lt;strong&gt;&lt;em&gt;Yes&lt;/em&gt;&lt;/strong&gt;, a &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_computer&quot; rel=&quot;noreferrer&quot;&gt;quantum computer&lt;/a&gt; could be simulated by a &lt;a href=&quot;https://en.wikipedia.org/wiki/Turing_machine&quot; rel=&quot;noreferrer&quot;&gt;Turing machine&lt;/a&gt;, though this shouldn't be taken to imply that real-world quantum computers couldn't enjoy &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_supremacy&quot; rel=&quot;noreferrer&quot;&gt;quantum advantage&lt;/a&gt;, i.e. a significant implementation advantage over real-world classical computers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As a rule-of-thumb, if a human could manually describe or imagine how something ought to operate, that imagining can be implemented on a Turing machine.  Quantum computers fall into this category.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;At current, a big motivation for quantum computing is that &lt;a href=&quot;https://en.wikipedia.org/wiki/Qubit&quot; rel=&quot;noreferrer&quot;&gt;qubits&lt;/a&gt; can exist in &lt;a href=&quot;https://en.wikipedia.org/wiki/Qubit#Qubit_states&quot; rel=&quot;noreferrer&quot;&gt;superpositions&lt;/a&gt;,$$&#xA;\left| \psi \right&amp;gt; = \alpha \left| 0 \right&amp;gt; + \beta \left| 1 \right&amp;gt;, \tag{1}&#xA;$$essentially allowing for massively parallel computation.  Then there's &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_annealing&quot; rel=&quot;noreferrer&quot;&gt;quantum annealing&lt;/a&gt; and other little tricks that are basically &lt;a href=&quot;https://en.wikipedia.org/wiki/Analog_computer&quot; rel=&quot;noreferrer&quot;&gt;analog computing&lt;/a&gt; tactics.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But, those benefits are about efficiency.  In some cases, that efficiency is beyond astronomical, enabling stuff that wouldn't have been practical on classical hardware.  This causes quantum computing to have major applications in &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_cryptography&quot; rel=&quot;noreferrer&quot;&gt;cryptography&lt;/a&gt; and such.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, quantum computing isn't currently motivated by a desire for things that we fundamentally couldn't do before.  If a quantum computer can perform an operation, then a classical Turing machine could perform a simulation of a quantum computer performing that operation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Randomness isn't a problem.  I guess two big reasons:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Randomness can be more precisely captured by using &lt;a href=&quot;https://en.wikipedia.org/wiki/Distribution_(mathematics)#Operations_on_distributions&quot; rel=&quot;noreferrer&quot;&gt;distribution math&lt;/a&gt; anyway.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Randomness isn't a real &quot;&lt;em&gt;thing&lt;/em&gt;&quot; to begin with; it's merely ignorance.  And we can always produce ignorance.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="15" LastEditorUserId="15" LastEditDate="2018-04-29T21:10:40.053" LastActivityDate="2018-04-29T21:10:40.053" CommentCount="20" />
  <row Id="20" PostTypeId="1" CreationDate="2018-03-12T18:02:31.377" Score="5" ViewCount="213" Body="&lt;p&gt;Quantum computing can be used to &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_simulator&quot; rel=&quot;noreferrer&quot;&gt;efficiently simulate&lt;/a&gt; quantum many-body systems.&#xA;Solving such a problem is classically hard because its complexity grows exponentially with the problem size (roughly with the degree of freedoms), which is an inherent consequence of the Schroedinger-equation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My intuitive understanding of this fact is that using quantum computers, we can essentially simulate the quantum many-body system, thus making the theoretical calculation essentially an experiment.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What about the reverse problem?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;More specifically, consider the situation in which&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;we have a description of a quantum many-body system, i.e. we know a formalized set of requirements whose behavior it should follow,&lt;/li&gt;&#xA;&lt;li&gt;and we are trying to find the actual system for this description?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;In a practical example, we have the required properties of a chemical compound. The goal is to find a chemical formula which fulfills the requirements.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This looks for me a harder task as to calculate the physical properties of a known compound (which is, in essence, &quot;only&quot; a solution of the Schroedinger-equation).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, such a description of a practical problem in human language would be this:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;I want a room temperature superconductor.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;And the output would be:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The formula is: ...&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h3&gt;Extension:&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Clarification, for @glS's comment:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;@glS We have the dynamics, or some type of the behavior of the system. In the case of chemical compounds, it could be, for example, excitation spectrum or superconductivity transition temperature. The important thing is that we have here a different direction: not from a given QM system do we want to calculate the behavior (= Schroedinger equation), but we have a wanted behavior (now: superconductivity transition temperature), we have a nearly-infinite set of possible compounds, and we are looking for the compound which fulfill the selection criteria ($T_c &amp;gt;= 300K$).&lt;/p&gt;&#xA;" OwnerUserId="27" LastEditorUserId="55" LastEditDate="2018-03-29T13:02:31.067" LastActivityDate="2018-04-13T07:43:38.933" Title="Can we synthesize quantum many body systems with quantum computers quickly in the general case?" Tags="&lt;quantum-computer&gt;&lt;many-body-systems&gt;" AnswerCount="3" CommentCount="19" />
  <row Id="21" PostTypeId="1" AcceptedAnswerId="178" CreationDate="2018-03-12T18:04:22.563" Score="-4" ViewCount="170" Body="&lt;p&gt;Quantum entanglement is 2 atoms that are paired together and when you stop one from spinning the other also stops with the same spin. Can you use these pairs to have FTL communication between 2 computers?&lt;/p&gt;&#xA;" OwnerUserId="61" LastEditorUserId="76" LastEditDate="2018-03-13T13:16:38.000" LastActivityDate="2018-03-18T18:16:16.363" Title="Quantum entanglement for FTL network communication?" Tags="&lt;quantum-computer&gt;&lt;faster-than-light&gt;&lt;quantum-entanglement&gt;" AnswerCount="1" CommentCount="7" />
  <row Id="22" PostTypeId="2" ParentId="4" CreationDate="2018-03-12T18:06:32.387" Score="4" Body="&lt;p&gt;Yes, it is possible. The &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_gate&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum gates&lt;/a&gt; are designed such that given input states are transformed to well defined output states with computable probabilities. The transformation does not constitute a &lt;em&gt;measurement&lt;/em&gt; in the sense of quantum mechanics, this means that we can have entangled states in the output of a quantum gate and use these states for further computation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note also that the input states are no longer accessible after being transformed by a quantum gate. If you want to get them back, you have to apply an inverse gate.&lt;/p&gt;&#xA;" OwnerUserId="18" LastEditorUserId="18" LastEditDate="2018-03-12T18:09:51.643" LastActivityDate="2018-03-12T18:09:51.643" CommentCount="3" />
  <row Id="23" PostTypeId="1" AcceptedAnswerId="25" CreationDate="2018-03-12T18:12:22.420" Score="22" ViewCount="358" Body="&lt;p&gt;Similar to the question &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1/could-a-turing-machine-simulate-a-quantum-computer&quot;&gt;Could a Turing Machine simulate a quantum computer?&lt;/a&gt;: given a 'classical' algorithm, is it always possible to formulate an equivalent algorithm which can be performed on a quantum computer? If yes, is there some kind of procedure we can follow for this? The resulting algorithm will probably not take full advantage of the possibilities of quantum computing, it's more of a theoretical question.&lt;/p&gt;&#xA;" OwnerUserId="45" LastActivityDate="2018-03-13T14:22:31.013" Title="Can a quantum computer simulate a normal computer?" Tags="&lt;simulation&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="2" />
  <row Id="24" PostTypeId="2" ParentId="12" CreationDate="2018-03-12T18:12:25.120" Score="36" Body="&lt;p&gt;Yes, it's possible (but slow). There are a couple of existing (this is only a partial list) emulators:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;http://thegreves.com/david/QDD/qdd.html&quot; rel=&quot;noreferrer&quot;&gt;QDD: A Quantum Computer Emulation Library&lt;/a&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;QDD is a C++ library which provides a relatively intuitive set of quantum computing constructs within the context of the C++ programming environment. QDD is unique in that the its emulation of quantum computing is based upon a Binary Decision Diagram (BDD) representation of the quantum state.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;http://jquantum.sourceforge.net/&quot; rel=&quot;noreferrer&quot;&gt;jQuantum&lt;/a&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;jQuantum is a program which simulates a quantum computer. You can design quantum circuits with it and let them run. The current state of the quantum register is illustrated. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;http://www.compphys.org/QCE/&quot; rel=&quot;noreferrer&quot;&gt;QCE&lt;/a&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;QCE is a software tool that emulates various hardware designs of Quantum Computers. QCE simulates the physical processes that govern the operation of a hardware quantum processor, strictly according to the laws of quantum mechanics. QCE also provides an environment to debug and execute quantum algorithms under realistic experimental conditions.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;(In addition, Q# only works with MS's &lt;a href=&quot;https://www.microsoft.com/en-us/quantum/development-kit&quot; rel=&quot;noreferrer&quot;&gt;QDK&lt;/a&gt;, thanks @Pavel)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The downside to all of these is simple: they still run on binary (non-quantum) circuits.  To the best of my knowledge, there's no easily accessible quantum &lt;em&gt;computer&lt;/em&gt; to use for running these things. And since it takes multiple binary bits to express a single qubit, the amount of computational power needed to simulate a quantum program gets large very quickly.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I'll quote a paper on the subject (&lt;a href=&quot;https://www.doc.ic.ac.uk/teaching/distinguished-projects/2010/s.allcock.pdf&quot; rel=&quot;noreferrer&quot;&gt;J. Allcock, 2010&lt;/a&gt;):&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Our evaluation shows that our implementations are very accurate, but at the same time we use a significant amount of additional memory in order to achieve this. Reducing our aims for accuracy would allow us to decrease representation size, and therefore emulate more qubits with the same amount of memory.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;p 89, section 5.1&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As our implementations get more accurate, they also get slower.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;TL;DR: it's possible, and some emulators exist, but none are very efficient for large amounts of qubits.&lt;/p&gt;&#xA;" OwnerUserId="7" LastEditorUserId="7" LastEditDate="2018-03-12T19:27:02.733" LastActivityDate="2018-03-12T19:27:02.733" CommentCount="3" />
  <row Id="25" PostTypeId="2" ParentId="23" CreationDate="2018-03-12T18:21:34.100" Score="18" Body="&lt;p&gt;Yes, it can do so in a rather trivial way: Use only reversible classical logical gates to simulate computations using boolean logic (for instance, using TOFFOLI to simulate NAND gates), use only the standard basis states $\lvert 0\rangle$ and $\lvert 1\rangle$ as input, and only perform standard basis state measurements at the output. In this way you can simulate  exactly the same calculations as the classical computer does, on a gate-by-gate basis.&lt;/p&gt;&#xA;" OwnerUserId="18" LastEditorUserId="124" LastEditDate="2018-03-13T14:22:31.013" LastActivityDate="2018-03-13T14:22:31.013" CommentCount="0" />
  <row Id="26" PostTypeId="1" CreationDate="2018-03-12T18:22:45.063" Score="-11" ViewCount="192" Body="&lt;p&gt;The title pretty much sums it up – How are quantum computers different from normal ones? i.e. Do all quantum computers need to be supercooled, whereas normal computers just need fans? and similar.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am aware that these things are &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_computing&quot; rel=&quot;nofollow noreferrer&quot;&gt;documented&lt;/a&gt; on other sites too (e.g. Wikipedia), but I think these questions could serve as a good reference of answers from experts in the field, which this (new) site might benefit from. &lt;/p&gt;&#xA;" OwnerUserId="71" LastEditorUserId="7" LastEditDate="2018-03-12T19:30:36.817" LastActivityDate="2018-03-12T19:35:37.960" Title="What are the main differences between normal and quantum computers?" Tags="&lt;quantum-computer&gt;" AnswerCount="1" CommentCount="6" ClosedDate="2018-03-12T21:16:31.863" />
  <row Id="27" PostTypeId="2" ParentId="12" CreationDate="2018-03-12T18:25:08.263" Score="16" Body="&lt;p&gt;If you're specifically looking at Q#, then it's super easy to use with an emulator -- in fact, it's not possible to have Q# but not have the emulator, they're bundled together. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;To get started, first you need to download .NET Core from &lt;a href=&quot;https://www.microsoft.com/net/learn/get-started/&quot; rel=&quot;noreferrer&quot;&gt;Microsoft's website&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When you download Microsoft's Quantum Development Kit through &lt;code&gt;dotnet new -i &quot;Microsoft.Quantum.ProjectTemplates::0.2-*&quot;&lt;/code&gt; or Microsoft's website, it downloads both the language and Microsoft's own emulator together. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Creating a new Q# project (&lt;code&gt;dotnet new console -lang Q#&lt;/code&gt;) will automatically configure it to use the emulator, so when you type in some Q# and run the project it &quot;just works&quot;.&lt;/p&gt;&#xA;" OwnerUserId="70" LastActivityDate="2018-03-12T18:25:08.263" CommentCount="0" />
  <row Id="29" PostTypeId="2" ParentId="26" CreationDate="2018-03-12T18:26:49.407" Score="2" Body="&lt;p&gt;Computers based on classical physics, are essentially systems where the degree of freedoms (= the number of variables describing the system) grows linearly with the count of the elements.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In quantum computers, the degree of freedoms in the system grows exponentially with the count of the elements. It has a strong physical reason based on the quantum mechanics.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thus, quantum computers have the promise to be able to solve computing tasks with currently unimaginable complexity.&lt;/p&gt;&#xA;" OwnerUserId="27" LastActivityDate="2018-03-12T18:26:49.407" CommentCount="2" />
  <row Id="30" PostTypeId="2" ParentId="12" CreationDate="2018-03-12T18:56:11.537" Score="25" Body="&lt;p&gt;Yes, it is possible to simulate a quantum computer on a normal one – But you most likely have to sacrifice efficiency. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The dimension of the state space rises exponentially with the number of qubits ($2^n$, where $n$ is the number of qubits), so the linear algebra you will be dealing with won't be too light – You'll encounter very large matrices and the algorithm you use (regardless of how efficient it is) will likely become &lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_growth&quot; rel=&quot;noreferrer&quot;&gt;exponentially-scaling&lt;/a&gt; pretty fast. However, emulating a QC on a normal machine is definitely possible.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h3&gt;Resources&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;You may be interested in Q# as other answers noted. Some more emulators:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.quantumplayground.net/#/home&quot; rel=&quot;noreferrer&quot;&gt;Quantum Computing Playground&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Quantum Computing Playground is a browser-based WebGL Chrome Experiment. It features a GPU-accelerated quantum computer with a simple IDE interface, and its own scripting language with debugging and 3D quantum state visualization features. Quantum Computing Playground can efficiently simulate quantum registers up to 22 qubits, run Grover's and Shor's algorithms, and has a variety of quantum gates built into the scripting language itself.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://quantum-studio.net/&quot; rel=&quot;noreferrer&quot;&gt;QX Simulator&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The QX Simulator is a universal quantum computer simulator developped at QuTech by Nader Khammassi. The QX allows quantum algorithm designers to simulate the execution of their quantum circuits on a quantum computer. The simulator defines a low-level quantum assembly language namely Quantum Code which allows the users to describe their circuits in a simple textual source code file. The source code file is then used as the input of the simulator which executes its content.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/vsoftco/qpp&quot; rel=&quot;noreferrer&quot;&gt;Quantum++&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Quantum++ is a modern C++11 general purpose quantum computing library, composed solely of template header files. Quantum++ is written in standard C++11 and has very low external dependencies, using only the Eigen 3 linear algebra header-only template library and, if available, the OpenMP multi-processing library.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://tph.tuwien.ac.at/~oemer/qcl.html&quot; rel=&quot;noreferrer&quot;&gt;Quantum Computer Language&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Despite many common concepts with classical computer science, quantum computing is still widely considered as a special discipline within the broad field of theoretical physics. [...] QCL (Quantum Computation Language) tries to fill this gap: QCL is a high level, architecture independent programming language for quantum computers, with a syntax derived from classical procedural languages like C or Pascal. This allows for the complete implementation and simulation of quantum algorithms (including classical components) in one consistent formalism.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;More relevant emulators can be found on &lt;a href=&quot;https://www.quantiki.org/wiki/list-qc-simulators&quot; rel=&quot;noreferrer&quot;&gt;Quantiki&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="35" LastEditorUserId="35" LastEditDate="2018-03-12T21:22:26.110" LastActivityDate="2018-03-12T21:22:26.110" CommentCount="0" />
  <row Id="31" PostTypeId="5" CreationDate="2018-03-12T18:58:42.597" Score="0" Body="&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_computing&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum computers&lt;/a&gt; are devices which, exploiting intrinsically quantum mechanical phenomena, are believed to be able to perform certain operations more efficiently.&#xA;While the basic unit of information that is manipulated by classical computers is the &lt;em&gt;bit&lt;/em&gt;, quantum computers manipulate &lt;em&gt;quantum states&lt;/em&gt;, often in the form two-level quantum systems typically referred to as &lt;em&gt;qubits&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Several models for quantum computation have been proposed and are actively researched.&#xA;Being the field of quantum computation still not yet fully mature, no computational model is indisputably superior to the others.&#xA;Arguably the most known one is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_circuit&quot; rel=&quot;nofollow noreferrer&quot;&gt;circuit model&lt;/a&gt;.&#xA;Among the others, there are measurement-based quantum computation, quantum annealing, and continuous variable quantum computation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In gate-based quantum computation, gates are represented by matrices, and include types such as the Pauli X (also termed &quot;NOT&quot;), Y, and Z (pronounced &quot;zed&quot;) gates, which are single-qubit gates, multiple-qubit gates like the controlled-NOT or CNOT gate and Toffoli gate, and others. The set of single-qubit gates plus the CNOT gate forms a set of universal gates.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The quantum computer's entire state can be represented by a single vector:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$|\psi\rangle = \alpha|0...0\rangle + \beta|0...1\rangle + .... \zeta|1...1\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Where $\alpha$ through $\zeta$ (and there can be more beyond this) represent the amplitudes of the state, and determine the probability of a particular state resulting upon collapse of the wavefunction upon measurement. Each of the items between the $|\,\rangle$ represents a particular possible state that can occur upon measurement.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When measurement occurs, the qubits become normal, classical bits, which is part of what makes writing algorithms for quantum computers so difficult. The advantage in a quantum computer lies in the fact that the whole system can be, and in fact must be, represented by a single vector. This means that all the qubits share information, and further, any one gate, even if a single-qubit gate, has repercussions on the whole system. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are many different physical realizations of the quantum computer. There are optical quantum computers, which use photons as qubits, and things like Fabry-Perot cavities, mirrors, beamsplitters, phase shifters, and so forth for gates. There are superconducting quantum computers, which use Josephson Junctions. There are ion-trap quantum computers, which use ions for qubits and hold those still with strong magnetic fields, and then manipulate the state of the ions with lasers. A list of realizations can be found &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_computing#External_links&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt; under &quot;Quantum Computer Science&quot; and &quot;Physical Implementations&quot;.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Resources/Notes&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_computing&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wikipedia article&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;Nielsen and Chuang's &lt;em&gt;Quantum Computing and Quantum Information&lt;/em&gt; is the standard textbook for the field.&lt;/li&gt;&#xA;&lt;li&gt;Michael Nielsen has a series of videos on YouTube called &lt;a href=&quot;https://www.youtube.com/playlist?list=PL1826E60FD05B44E4&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Computing for the Determined&lt;/a&gt;.&lt;/li&gt;&#xA;&lt;li&gt;It is recommended that you have a base understanding of linear algebra in particular if you wish to learn this subject. Some understanding of quantum mechanics and computer science will be highly useful and something you will at minimum have to learn upon the way.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="91" LastEditorUserId="55" LastEditDate="2018-03-29T19:15:22.427" LastActivityDate="2018-03-29T19:15:22.427" CommentCount="0" />
  <row Id="32" PostTypeId="4" CreationDate="2018-03-12T18:58:42.597" Score="0" Body="For questions about computers that run on a quantum architecture. This is for questions about the machines themselves, not just any computing that could take place on one." OwnerUserId="7" LastEditorUserId="26" LastEditDate="2018-04-15T07:42:56.793" LastActivityDate="2018-04-15T07:42:56.793" CommentCount="0" />
  <row Id="33" PostTypeId="5" CreationDate="2018-03-12T19:00:02.607" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-12T19:00:02.607" LastActivityDate="2018-03-12T19:00:02.607" CommentCount="0" />
  <row Id="34" PostTypeId="4" CreationDate="2018-03-12T19:00:02.607" Score="0" Body="For questions about simulating either quantum computers or simulating things on quantum computers. " OwnerUserId="7" LastEditorUserId="3" LastEditDate="2018-03-13T19:29:48.787" LastActivityDate="2018-03-13T19:29:48.787" CommentCount="0" />
  <row Id="35" PostTypeId="5" CreationDate="2018-03-12T19:01:10.427" Score="0" Body="&lt;p&gt;Quantum cryptography is the science of exploiting quantum mechanical properties to perform cryptographic tasks. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Reference: &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_cryptography&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://en.wikipedia.org/wiki/Quantum_cryptography&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-14T19:08:41.890" LastActivityDate="2018-03-14T19:08:41.890" CommentCount="0" />
  <row Id="36" PostTypeId="4" CreationDate="2018-03-12T19:01:10.427" Score="0" Body="For questions about cryptography as it relates directly to quantum computing. Not for general cryptographic methods. " OwnerUserId="7" LastEditorUserId="26" LastEditDate="2018-03-14T19:08:49.750" LastActivityDate="2018-03-14T19:08:49.750" CommentCount="0" />
  <row Id="37" PostTypeId="5" CreationDate="2018-03-12T19:02:34.337" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-12T19:02:34.337" LastActivityDate="2018-03-12T19:02:34.337" CommentCount="0" />
  <row Id="38" PostTypeId="4" CreationDate="2018-03-12T19:02:34.337" Score="0" Body="Emulation is the practice of exactly replicating the function of something.  Use this tag for when you are emulating a quantum computer or things on one. Use [simulation] if an exact replica isn't essential." OwnerUserId="7" LastEditorUserId="7" LastEditDate="2018-03-12T19:52:42.760" LastActivityDate="2018-03-12T19:52:42.760" CommentCount="0" />
  <row Id="39" PostTypeId="1" AcceptedAnswerId="51" CreationDate="2018-03-12T19:10:23.483" Score="20" ViewCount="317" Body="&lt;p&gt;At a very basic level, reading or measuring a qubit forces it to be in one state or the other, so operation of a QC to gain a result collapses the state into one of many possibilities.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But as the state of each qubit is probabilistic, surely this means the result can actually be any of those possibilities, with varying likelihood. If I re-run the programme - should I expect to see different results?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;How can I be sure I have the &quot;best&quot; result? What provides that confidence? I assume it cannot be the interim measurements as described in &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/4/67&quot;&gt;this question&lt;/a&gt; as they do not collapse the output.&lt;/p&gt;&#xA;" OwnerUserId="67" LastEditorUserId="26" LastEditDate="2018-05-07T13:21:42.590" LastActivityDate="2018-05-07T13:21:42.590" Title="What level of &quot;confidence&quot; of the result from a Quantum Computer is possible?" Tags="&lt;qubit&gt;&lt;quantum-error-correction&gt;&lt;fault-tolerance&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="41" PostTypeId="1" AcceptedAnswerId="62" CreationDate="2018-03-12T19:53:58.863" Score="18" ViewCount="180" Body="&lt;p&gt;Is a dilution refrigerator the only way to cool superconducting qubits down to 10 millikelvin? If not, what other methods are there, and why is dilution refrigeration the primary method?&lt;/p&gt;&#xA;" OwnerUserId="91" LastEditorUserId="26" LastEditDate="2018-03-16T01:12:55.663" LastActivityDate="2018-03-16T01:12:55.663" Title="What cryogenic systems are suitable for superconducting qubits?" Tags="&lt;architecture&gt;&lt;superconducting-quantum-computing&gt;&lt;dilution-refrigerator&gt;" AnswerCount="1" CommentCount="1" FavoriteCount="3" />
  <row Id="42" PostTypeId="5" CreationDate="2018-03-12T19:55:01.877" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-12T19:55:01.877" LastActivityDate="2018-03-12T19:55:01.877" CommentCount="0" />
  <row Id="43" PostTypeId="4" CreationDate="2018-03-12T19:55:01.877" Score="0" Body="For questions about the physical implementation of a quantum computer. Use with tags for whatever realization you are thinking of." OwnerUserId="91" LastEditorUserId="91" LastEditDate="2018-03-13T13:16:26.390" LastActivityDate="2018-03-13T13:16:26.390" CommentCount="0" />
  <row Id="44" PostTypeId="5" CreationDate="2018-03-12T19:56:32.707" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-12T19:56:32.707" LastActivityDate="2018-03-12T19:56:32.707" CommentCount="0" />
  <row Id="45" PostTypeId="4" CreationDate="2018-03-12T19:56:32.707" Score="0" Body="For questions involving the device used to cool things (especially qubits) down to very low temperatures (millikelvin)." OwnerUserId="91" LastEditorUserId="91" LastEditDate="2018-03-13T13:16:46.457" LastActivityDate="2018-03-13T13:16:46.457" CommentCount="0" />
  <row Id="46" PostTypeId="5" CreationDate="2018-03-12T19:58:17.810" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-12T19:58:17.810" LastActivityDate="2018-03-12T19:58:17.810" CommentCount="0" />
  <row Id="47" PostTypeId="4" CreationDate="2018-03-12T19:58:17.810" Score="0" Body="For questions involving the realization of quantum computing which uses superconducting qubits.. This tag can be used either for the theory behind the realization or the physical implementation of the realization (in which case, consider using the [tag:construction] tag)." OwnerUserId="91" LastEditorUserId="3" LastEditDate="2018-03-13T13:21:48.290" LastActivityDate="2018-03-13T13:21:48.290" CommentCount="0" />
  <row Id="48" PostTypeId="2" ParentId="6" CreationDate="2018-03-12T20:07:31.787" Score="4" Body="&lt;p&gt;&lt;strong&gt;&lt;em&gt;tl;dr&lt;/em&gt;-&lt;/strong&gt;  Quantum computers can't really help us to simulate the whole universe as the universe is likely vastly more complex than even quantum mechanics can capture, plus we can't even begin to guess how big it is or many other basic fundamental features.  In short, simulating the whole universe is beyond sci-fi.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;We can't really simulate the entire universe, in large part because we have no idea what the universe is.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I mean, at current, we have a vague picture of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Observable_universe&quot; rel=&quot;nofollow noreferrer&quot;&gt;observable universe&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/File:Observable_Universe_with_Measurements_01.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/9/98/Observable_Universe_with_Measurements_01.png&quot; alt=&quot;Observable universe&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And we've got the &lt;a href=&quot;https://en.wikipedia.org/wiki/The_standard_model&quot; rel=&quot;nofollow noreferrer&quot;&gt;Standard Model&lt;/a&gt; that describes our current best guess at describing much of what we can see.  But, beyond that, we don't know much.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Examples of stuff we don't know:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Is the observable universe a significant part of the larger universe?  Or is it unimaginably small compared to the whole?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Is there a lot of &lt;a href=&quot;https://en.wikipedia.org/wiki/Weakly_interacting_massive_particles&quot; rel=&quot;nofollow noreferrer&quot;&gt;weakly-interacting&lt;/a&gt; stuff out there, e.g. &lt;a href=&quot;https://en.wikipedia.org/wiki/Dark_matter&quot; rel=&quot;nofollow noreferrer&quot;&gt;dark matter&lt;/a&gt;, that might compose what'd kinda be like a parallel world?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Suppose dark matter is real (which many physicists currently believe).  Then, what if something weakly interacts with dark matter, but only with normal matter indirectly through affecting dark matter?  And what if that's a recursive relationship - do we even know a non-trivial portion of what exists within the domain of the observable universe?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;What exists &lt;a href=&quot;https://en.wikipedia.org/wiki/There%27s_Plenty_of_Room_at_the_Bottom&quot; rel=&quot;nofollow noreferrer&quot;&gt;at the bottom&lt;/a&gt;?  We really don't know much beneath the &lt;a href=&quot;https://en.wikipedia.org/wiki/Planck_length&quot; rel=&quot;nofollow noreferrer&quot;&gt;Planck scale&lt;/a&gt;; it could be the case that what seem to be fundamental particles to us are actually unimaginably large universes themselves!&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Extra-dimensions, what's-in-black-holes, string theory, etc., etc..&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Basically, we know essentially nothing about the larger universe other than that we're part of it.  Given this unimaginable ignorance, merely having quantum computers won't really help us simulate the whole thing.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;That said, what quantum computers &lt;em&gt;can&lt;/em&gt; do is help us simulate quantum systems of comparable size as well as a bunch of other interesting problems.  Presumably we'll gain a better understanding of the possibilities as time goes on.&lt;/p&gt;&#xA;" OwnerUserId="15" LastActivityDate="2018-03-12T20:07:31.787" CommentCount="0" />
  <row Id="49" PostTypeId="1" CreationDate="2018-03-12T20:19:27.003" Score="7" ViewCount="137" Body="&lt;p&gt;I don't have any specific task or algorithm in mind, so depending on how they were tested – Is there any research which shows just how the &lt;a href=&quot;https://en.wikipedia.org/wiki/D-Wave_Two&quot; rel=&quot;nofollow noreferrer&quot;&gt;D-Wave Two&lt;/a&gt; computer was faster (in terms of computation performance) than its predecessor (D-Wave One)? &lt;/p&gt;&#xA;" OwnerUserId="99" LastEditorUserId="26" LastEditDate="2018-03-26T16:01:45.120" LastActivityDate="2018-03-26T16:01:45.120" Title="How much faster is “D-Wave Two” compared to its predecessor?" Tags="&lt;quantum-computer&gt;&lt;performance&gt;&lt;quantum-annealing&gt;&lt;d-wave&gt;" AnswerCount="2" CommentCount="4" />
  <row Id="50" PostTypeId="1" AcceptedAnswerId="66" CreationDate="2018-03-12T20:25:01.510" Score="0" ViewCount="159" Body="&lt;p&gt;This &lt;a href=&quot;https://www.cs.auckland.ac.nz/research/groups/CDMTCS/&quot; rel=&quot;nofollow noreferrer&quot;&gt;CDMTCS&lt;/a&gt; Report 514, 2017 entitled &quot;&lt;a href=&quot;https://arxiv.org/abs/1712.01356&quot; rel=&quot;nofollow noreferrer&quot;&gt;The Road to Quantum Computational Supremacy&lt;/a&gt;&quot; states (in Section 6) that the amount of memory needed to simulate random quantum circuits on classical computers increases rapidly with the number of qubits of the circuit. A circuit on 48 qubits would require a huge amount of memory to be stored.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;How much is it exactly? And how can you calculate it?&lt;/p&gt;&#xA;" OwnerUserId="99" LastEditorUserId="1847" LastEditDate="2018-04-16T10:05:20.317" LastActivityDate="2018-04-16T10:05:20.317" Title="How much memory is required to simulate a 48-qubit circuit?" Tags="&lt;simulation&gt;&lt;classical-computing&gt;&lt;memory-space&gt;" AnswerCount="1" CommentCount="4" FavoriteCount="2" />
  <row Id="51" PostTypeId="2" ParentId="39" CreationDate="2018-03-12T20:26:20.733" Score="13" Body="&lt;p&gt;The majority of useful/relatively efficient algorithms&lt;sup&gt;1&lt;/sup&gt; for quantum computers belong to the &lt;a href=&quot;https://en.wikipedia.org/wiki/BQP&quot; rel=&quot;noreferrer&quot;&gt;'bounded-error quantum polynomial time' (BQP)&lt;/a&gt; complexity class. By this definition, you want the 'failure rate' of any quantum algorithm to be $\leq\frac{1}{3}$, or $\mathbb{P}\left(\text{success}\right) \geq \frac{2}{3}$, although the result may still be within some small error. A non-probabilistic algorithm (that can run in polynomial time) will still be in this complexity class, with the only difference being that it &lt;em&gt;always&lt;/em&gt; returns the correct result&lt;sup&gt;2&lt;/sup&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, as you can run an algorithm an arbitrary number of times, this is equivalent to having a success probability of at least $\frac{1}{2} + n^{-c}$ for an input of length $n$ and any positive constant $c$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, the 'correct' result is the one that appears at least two thirds of the time, unless you want a 'one-shot' computation such as if you want to generate random numbers, or if you want to do something such as benchmark the quantum chip, where the statistics matter and are part of the 'result'. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Aside from these (or other algorithms that don't have a single 'correct result'), if you find an algorithm with a success rate below a half, it is no longer 'bounded error' and it may not be possible for the user to know the correct result - there may simply be a wrong answer with a higher probability of occurring than the correct one.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Yes, you may see a different result each time you run a calculation. The confidence in the result is provided by: &lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;The quantum algorithm itself ensuring that the correct result happens with high probability and; &lt;/li&gt;&#xA;&lt;li&gt;Repeating the algorithm a number of times in order to find the most probable result.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;1 Here, algorithms that can be computed in polynomial time to give a solution with 'high probability', although for the purposes of this answer, the time complexity is of lesser importance&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;2 Well, idealistically, at least&lt;/sup&gt;&lt;/p&gt;&#xA;" OwnerUserId="23" LastEditorUserId="23" LastEditDate="2018-03-13T00:19:51.817" LastActivityDate="2018-03-13T00:19:51.817" CommentCount="2" />
  <row Id="52" PostTypeId="2" ParentId="49" CreationDate="2018-03-12T20:30:29.887" Score="11" Body="&lt;p&gt;As Troyer and Lidar saw no speed increase with the D-Wave 1 compared to classical computers, the D-Wave 2 &lt;a href=&quot;https://en.wikipedia.org/wiki/D-Wave_Systems#cite_note-44&quot; rel=&quot;noreferrer&quot;&gt;benchmark figure reported in 2013&lt;/a&gt; of 3600 times as fast as CPLEX (the best algorithm on a conventional machine) suggests the D-Wave 2 is 3600 times as fast as the D-Wave 1.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;the results are in a pretty restricted set of parameters, so this may not be relevant for other parameters. (as an example, the benchmark figures for the D-Wave 2000Q only take constant factor performance gains into account)&lt;/li&gt;&#xA;&lt;li&gt;the configuration of the CPLEX may not compare directly to the classical computers used to benchmark the D-Wave 1 &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="67" LastActivityDate="2018-03-12T20:30:29.887" CommentCount="0" />
  <row Id="53" PostTypeId="1" AcceptedAnswerId="111" CreationDate="2018-03-12T20:32:49.977" Score="16" ViewCount="190" Body="&lt;h2&gt;Background&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Recently I came upon a research article entitled &lt;a href=&quot;https://arxiv.org/pdf/1110.1381.pdf&quot; rel=&quot;noreferrer&quot;&gt;Experimental Demonstration of Blind Quantum Computing&lt;/a&gt;. Within this research article, the scientists claimed that - through the proper choice of a generic structure - a data engineer can hide the information about how the data was calculated.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Question&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;If a scientist were to use a BQC &lt;em&gt;(Blind Quantum Computation)&lt;/em&gt; protocol to calculate private measurements, what types of variables would they have to use to formulate a generic structure for the blind quantum state?&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Thoughts&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;I would like to understand what types of variables could go into the generic structure in order to help keep the data calculations hidden from the server. If you select certain known generic variables, I do not understand why the selection of other known generic variables would prevent the data calculations from being hidden.&lt;/p&gt;&#xA;" OwnerUserId="82" LastEditorUserId="15" LastEditDate="2018-03-14T20:16:37.693" LastActivityDate="2018-05-10T10:37:43.227" Title="Blind Quantum Computing Generic Structure Variable Selection" Tags="&lt;cryptography&gt;&lt;bqc&gt;&lt;security&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="3" />
  <row Id="55" PostTypeId="5" CreationDate="2018-03-12T20:53:04.173" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-12T20:53:04.173" LastActivityDate="2018-03-12T20:53:04.173" CommentCount="0" />
  <row Id="56" PostTypeId="4" CreationDate="2018-03-12T20:53:04.173" Score="0" Body="BQC or Blind Quantum Computing is a term used when referring to a computation technique that prevents the servers from knowing how the task is being performed." OwnerUserId="82" LastEditorUserId="82" LastEditDate="2018-03-13T13:16:55.600" LastActivityDate="2018-03-13T13:16:55.600" CommentCount="0" />
  <row Id="57" PostTypeId="2" ParentId="4" CreationDate="2018-03-12T21:31:00.257" Score="3" Body="&lt;p&gt;As you said, the probabilities of measurements are obtained from the state. And the gates operate unitarily on the states. Consider the POVM element $\Pi$, a state $\rho$ and a gate $U$. Then the probability for the outcome associated with $\Pi$ is $p=\mathrm{tr} (\Pi \rho)$, and the probability after the gate is $p'=\mathrm{tr}(\Pi U \rho U^\dagger)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I just want to stress that it is impossible to know the probability of the outcome after the gate only from the probability of it before the gate. You need to consider the probability amplitudes (the quantum states)!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let me make another remark: You are talking about two qubits, so the state after the gate might be entangled. In this case it will not be possible to have &quot;individual&quot; probability distributions for each qubit for all measurements in the sense that the joint probability distribution will not factor into the two marginal distributions.&lt;/p&gt;&#xA;" OwnerUserId="104" LastActivityDate="2018-03-12T21:31:00.257" CommentCount="0" />
  <row Id="59" PostTypeId="2" ParentId="12" CreationDate="2018-03-12T23:21:05.300" Score="21" Body="&lt;p&gt;Yes, it is possible to simulate quantum computations on a classical computer. But the cost of simulations grows exponentially with qubit count and/or circuit depth and/or particular operation counts.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For trying ideas quickly, my simulator &lt;a href=&quot;http://algassert.com/quirk&quot; rel=&quot;noreferrer&quot;&gt;Quirk&lt;/a&gt; is great. It's an &lt;a href=&quot;https://github.com/Strilanc/Quirk&quot; rel=&quot;noreferrer&quot;&gt;open-source&lt;/a&gt; drag-and-drop quantum circuit simulator that runs in your web browser. You can access a live version at &lt;a href=&quot;http://algassert.com/quirk&quot; rel=&quot;noreferrer&quot;&gt;algassert.com/quirk&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here is a screenshot of Quirk's example Grover circuit, which is instrumented with intermediate state displays to track the &quot;hidden&quot; state becoming more likely:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/DkSMI.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/DkSMI.png&quot; alt=&quot;Screenshot of Quirk&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-03-14T03:48:19.327" LastActivityDate="2018-03-14T03:48:19.327" CommentCount="3" />
  <row Id="60" PostTypeId="2" ParentId="39" CreationDate="2018-03-13T00:35:00.087" Score="7" Body="&lt;p&gt;Elaborating somewhat on &lt;code&gt;Mithrandir24601&lt;/code&gt;'s response &amp;mdash;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The feature you're worried about, that a quantum computer might produce a different answer on the next run of the computation, is also a feature of randomised computation. It is good in some ways to be able to obtain a single answer repeatably, but in the end it is enough to be able to obtain a correct answer with high enough confidence. Just as with a randomised algorithm, what is important is that you can be sure of the chances of getting the correct answer in any given run of the computation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For instance, your quantum computer might give you the correct answer to a YES&amp;nbsp;/&amp;nbsp;NO question two times out of every three. This might seem like a poor performance, but what this means is that if you run it many times, you can simply take the majority answer and be &lt;em&gt;very&lt;/em&gt; confident that the majority rule gives you the correct answer. (The same is true for normal randomised computation as well.) The way that the confidence increases with the number of rune, means that so long as any one run gives an answer which has significantly more than &lt;em&gt;just a 50% chance&lt;/em&gt; of being correct, you can make your confidence as high as you like just by doing a modest number of repeated runs (though more runs are required, the closer the chances of a correct answer in any one run are to 50%).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In theoretical terms, we give the name &lt;strong&gt;BQP&lt;/strong&gt; to the collection of problems which are solvable in $\mathrm{poly}(n)$ computational steps by a quantum computer, for input sizes which can be specified by an $n$-bit string, where the answer is correct with probability at least 2/3; by the argument above, the exact same set of problems is given if you demand that the answer be correct with probability 999/1000, or (1&amp;nbsp;&amp;minus;&amp;nbsp;1e-8).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For problems which have more elaborate answers than YES&amp;nbsp;/&amp;nbsp;NO questions, we can't necessarily assume that the same answer will be produced more than once so that we can take a majority vote. (If you are using a quantum computer to sample from an exponential number of outcomes, it is possible that there are some smaller but still exponentially many quantity of answers which are correct and useful!) Suppose that you are trying to solve an optimisation problem: it might not be easy to verify that you have found the optimal solution, or a nearly-optimal solution &amp;mdash; or that the answer that you've gotten is even the best that the quantum computer can do (what if the next run gives you a better answer by chance?). In this case, what is important is to determine what you know about the problem, whether there is an independent way to verify a solution (is your problem in &lt;strong&gt;NP&lt;/strong&gt;, meaning that you can in principle efficiently check any answer you're given?), and what quality of solution you would be happy with.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Again, this is all true for randomised algorithms as well &amp;mdash; the difference being that we expect quantum computers to be able to solve problems that a randomised computer alone could not easily solve.&lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-03-13T10:00:49.930" LastActivityDate="2018-03-13T10:00:49.930" CommentCount="0" />
  <row Id="61" PostTypeId="1" AcceptedAnswerId="67" CreationDate="2018-03-13T00:50:59.097" Score="11" ViewCount="137" Body="&lt;p&gt;I'm researching SPDC's efficacy for use in an optical quantum computing model and I've been trying to figure out exactly what state the photons are in when they come out (as represented by a vector, for example), if I'm using type 1 SPDC and I'm looking at the polarization of the photons.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Please provide any references used =)&lt;/p&gt;&#xA;" OwnerUserId="91" LastEditorUserId="104" LastEditDate="2018-03-16T15:49:47.903" LastActivityDate="2018-03-16T15:49:47.903" Title="State produced by spontaneous parametric down-conversion (SPDC)" Tags="&lt;qubit&gt;&lt;optical-quantum-computing&gt;&lt;spdc&gt;&lt;qubit-state&gt;" AnswerCount="2" CommentCount="7" />
  <row Id="62" PostTypeId="2" ParentId="41" CreationDate="2018-03-13T04:09:42.057" Score="18" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Is a dilution refrigerator the only way to cool superconducting qubits down to 10 millikelvin?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There's another type of refrigerator that can get to 10 mK: the &lt;a href=&quot;https://www.cryogenicsociety.org/resources/defining_cryogenics/adiabatic_demagnetization_refrigeration/&quot; rel=&quot;noreferrer&quot;&gt;adiabatic demagnetization refrigerator&lt;/a&gt; (ADR).$^{[a]}$&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;why is dilution refrigeration the primary method?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;To understand that, let's talk about one of the main limitations of the ADR.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;How an ADR works&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;An ADR usually gets to about 3K with a helium compressor.&#xA;That compressor can run all the time, so the refrigerator can sit at 3K indefinitely.&#xA;To get down to mK temperatures, the ADR works like this:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Raise the magnetic field surrounding a solid with nuclear spins. This aligns the spins.&lt;/li&gt;&#xA;&lt;li&gt;Slowly turn the field off. This allows the spins to randomize their direction, which absorbs entropy from the surroundings and lowers the temperature.&lt;/li&gt;&#xA;&lt;li&gt;Once the field is back to zero, we've sucked enough heat out of the surroundings to bring them to mK temperatures.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;ADR limitations&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;This is all great and it really works, but it's a &quot;one-shot&quot; process.&#xA;Once the field is down to zero, you can't go any lower.&#xA;Heat from the surroundings, such as the room temperature outer parts of the refrigerator, leak heat into the part you're trying to keep cold, and since we've already lowered the magnetic field to zero, we can't do anything to remove that heat.&#xA;Therefore, after cooling the ADR, it starts to warm up (hopefully slowly enough to run your experiment).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It's typical for an ADR to stay below 100mK for maybe twelve hours, although that number depends a lot on how many wires you have running to the cold part of the ADR.&#xA;After the temperature rises above what you want, you have to raise the magnetic field again and slowly lower it to re-cool.&#xA;Raising and lowering the field takes a while and heats up the refrigerator, and that big magnetic field is often incompatible with superconducting qubit experiments, so you can't run experiments while you're in that stage of the process.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;ADR vs. dilution refrigerator&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;The dilution refrigerator, on the other hand, runs continuously, so you have as long as you need to run your experiment.&#xA;That's a pretty big reason that they're in common use.&#xA;Note, however, that other refrigerators aside from the ADR &lt;em&gt;are&lt;/em&gt; used in many superconducting qubit labs for tasks where the benefits of a dilution refrigerator aren't needed and the shorter cold time of an ADR is ok.&#xA;For example, ADR's are common for experiments with superconducting resonators, which are used to test the quality of materials that may later be used for a qubit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$[a]$: Apologies for not finding a better link. Edits on that are welcome.&lt;/p&gt;&#xA;" OwnerUserId="32" LastActivityDate="2018-03-13T04:09:42.057" CommentCount="3" />
  <row Id="63" PostTypeId="1" CreationDate="2018-03-13T06:40:05.623" Score="7" ViewCount="156" Body="&lt;p&gt;In this &lt;a href=&quot;https://arxiv.org/abs/1409.3093&quot; rel=&quot;nofollow noreferrer&quot;&gt;paper&lt;/a&gt; and this &lt;a href=&quot;https://arxiv.org/abs/1211.0417&quot; rel=&quot;nofollow noreferrer&quot;&gt;paper&lt;/a&gt;, the &quot;Noise Stability of Qubits&quot; (the stability of qubits to external noise) has been discussed. In the first one, Gil Kalai states that it is difficult to create a quantum computer since the noise produced in creating a few qubits is enough to reach the threshold for corrupting the entire system of qubits. What can be done to reduce the noise and increase stability of the qubits?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;EDIT&lt;/strong&gt;: To clarify the doubts mentioned in  the comments, I want to add that IBM, Rigetti and some other companies have already started manufacturing Quantum Computers with 4-6 qubits. How have they overcome or what are they working on to face this problem of noise sensitivity?&lt;/p&gt;&#xA;" OwnerUserId="137" LastEditorUserId="7" LastEditDate="2018-03-14T10:25:40.183" LastActivityDate="2018-03-14T10:25:40.183" Title="How to make qubits more stable towards noise?" Tags="&lt;quantum-computer&gt;&lt;qubit&gt;&lt;noise&gt;" AnswerCount="0" CommentCount="20" ClosedDate="2018-03-14T13:27:12.590" />
  <row Id="64" PostTypeId="1" AcceptedAnswerId="130" CreationDate="2018-03-13T07:06:51.700" Score="13" ViewCount="159" Body="&lt;p&gt;According to &lt;a href=&quot;https://www.alibabacloud.com/press-room/alibaba-cloud-and-cas-launch-one-of-the-worlds-most&quot; rel=&quot;noreferrer&quot;&gt;this press announcement&lt;/a&gt; from March 1st 2018, the Alibaba Cloud offers access to an 11 qubit quantum computer via their cloud services. Quote:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Alibaba Cloud, [...] and Chinese Academy of Sciences (CAS) [...] have launched the superconducting quantum computing cloud, featuring a quantum processor with 11 quantum bits (qubits) of power. [...]&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Users can now access the superconducting quantum computing cloud through Alibaba Cloud’s quantum computing cloud platform to efficiently run and test custom built quantum codes and download the results.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;However, I have been unable to find any mention of this service anywhere else on their site than in the press announcement. No documentation. No mention in the &quot;Products&quot; overview. Nothing. Does anyone know, how to get started here?&lt;/p&gt;&#xA;" OwnerUserId="138" LastEditorUserId="26" LastEditDate="2018-03-16T15:36:51.643" LastActivityDate="2018-03-16T15:36:51.643" Title="How to get started with the Alibaba Cloud Quantum Computing Service?" Tags="&lt;alibaba-cloud&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="65" PostTypeId="1" AcceptedAnswerId="68" CreationDate="2018-03-13T07:12:53.293" Score="17" ViewCount="258" Body="&lt;p&gt;The term &quot;quantum supremacy&quot; - to my understanding - means that one can create and run algorithms to solve problems on quantum computers that can't be solved in realistic times on binary computers. However, that is a rather vague definition - what would count as &quot;realistic time&quot; in this context? Does it have to be the same algorithm or just the same problem? Not being able to simulate quantum computers of certain sizes surely can't be the best measure.&lt;/p&gt;&#xA;" OwnerUserId="138" LastEditorUserId="26" LastEditDate="2018-03-27T09:57:30.017" LastActivityDate="2018-03-27T09:57:30.017" Title="When will we know that quantum supremacy has been reached?" Tags="&lt;quantum-speedup&gt;&lt;quantum-supremacy&gt;" AnswerCount="2" CommentCount="5" />
  <row Id="66" PostTypeId="2" ParentId="50" CreationDate="2018-03-13T07:28:54.323" Score="2" Body="&lt;p&gt;This doesn't exactly answer your question, but it may aid you in understanding the problem and possibly the solution:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In their paper &lt;em&gt;&quot;&lt;a href=&quot;https://arxiv.org/abs/1710.05867&quot; rel=&quot;nofollow noreferrer&quot;&gt;Breaking the 49-Qubit Barrier in the Simulation of Quantum Circuits&lt;/a&gt;&quot;&lt;/em&gt; (arXiv:1710.05867), the authors describe simulating a 49-qubit and a 56-qubit quantum computer. According to the paper, they required 4.5 Terrabytes of RAM for the 49-qubit simulation; this did however depend on the exact algorithm they ran. That said, also according to this paper with competing simulation methods they would have been at about 8 Petabytes of RAM for that simulation.&lt;/p&gt;&#xA;" OwnerUserId="138" LastActivityDate="2018-03-13T07:28:54.323" CommentCount="0" />
  <row Id="67" PostTypeId="2" ParentId="61" CreationDate="2018-03-13T09:24:34.043" Score="9" Body="&lt;h2&gt;Background&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;First of all, I'll use $\lvert H\rangle$ as a horizontally polarised state and $\lvert V\rangle$ as a vertically polarised state&lt;sup&gt;1&lt;/sup&gt;. There are three modes of light involved in the system: pump (p), taken to be a coherent light source (a laser); as well as signal and idler (s/i), the two generated photons&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Hamiltonian for SPDC is given by $H = \hbar g\left(a^{\dagger}_sa^{\dagger}_ia_p + a^{\dagger}_pa_ia_s\right)$, where g is a coupling constant dependent on the $\chi^{\left(2\right)}$ nonlinearity of the crystal and $a\left(a^{\dagger}\right)$ is the annihilation (creation) operator. That is, there is a possibility of a pump photon getting annihilated and generating two photons&lt;sup&gt;2&lt;/sup&gt; as well as a possibility of the reverse.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The phase matching conditions for frequencies, $\omega_p = \omega_s + \omega_i$ and wave vectors, $\mathbf{k}_p = \mathbf{k}_s + \mathbf{k}_i$ must also be satisfied.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Type 1 SPDC&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;This is where the two generated (s and i) photons have parallel polarisations, perpendicular to the polarisation of the pump, which can only be used to perform SPDC when the pump is polarised along the extraordinary axis of the crystal.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This means that defining the extraordinary axis as the vertical (horizontal) direction and inputting coherent light along that axis will generate pairs of photons in the state $\lvert HH\rangle\, \left(\lvert VV\rangle\right)$. This is not of much use, so to generate an entangled pair of photons, two crystals are placed next to each other, with extraordinary axes in orthogonal directions. The coherent source is then input with a polarisation of $45^\circ$ to this, such that if the first crystal has an extraordinary axis along the vertical (horizontal) direction, there is a probability of generating photons in the state $\lvert HH\rangle\, \left(\lvert VV\rangle\right)$ as before from the first crystal, as well as a probability of generating photons in the state $\lvert VV\rangle\, \left(\lvert HH\rangle\right)$ from the second crystal.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, as the light from the pump is travelling through a material, it will also acquire a phase in the first crystal, such that the final state is $$\lvert\psi\rangle = \frac{1}{\sqrt{2}}\left(\lvert HH\rangle + e^{i\phi}\lvert VV\rangle\right).$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Due to the phase matching conditions, the emitted photon pairs will be emitted at opposite points on a cone, as shown below in Figure 1.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/4i63J.jpg&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/4i63J.jpg&quot; alt=&quot;Type 1 SPDC&quot;&gt;&lt;/a&gt;Figure 1: A laser beam is input into two type 1 SPDC crystals, with orthogonal extraordinary axes. This results in a probability of emitting a pair of entangled photons at opposite points on a cone. Image taken from Wikipedia.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;1 This can be mapped to qubit states using e.g. $\lvert H\rangle = \lvert 0\rangle$ and $\lvert V\rangle = \lvert 1\rangle$&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;2 called signal and idler for historical reasons&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;References:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;http://iopscience.iop.org/article/10.1143/JJAP.46.7175/meta&quot; rel=&quot;noreferrer&quot;&gt;Keiichi Edamatsu 2007 Jpn. J. Appl. Phys. 46 7175&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.60.R773&quot; rel=&quot;noreferrer&quot;&gt;Kwiat, P.G., Waks, E., White, A.G., Appelbaum, I. and Eberhard, P.H., 1999.  Physical Review A, 60(2)&lt;/a&gt; - and the &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9810003v3&quot; rel=&quot;noreferrer&quot;&gt;arXiv version&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="23" LastActivityDate="2018-03-13T09:24:34.043" CommentCount="0" />
  <row Id="68" PostTypeId="2" ParentId="65" CreationDate="2018-03-13T09:27:09.100" Score="13" Body="&lt;p&gt;The term &lt;code&gt;quantum supremacy&lt;/code&gt; &lt;em&gt;doesn't necessarily&lt;/em&gt; mean that one can run &lt;code&gt;algorithms&lt;/code&gt;, as such, on a quantum computer that are impractical to run on a classical computer. It just means that a quantum computer can do &lt;em&gt;something&lt;/em&gt; that a classical computer will find difficult to simulate.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You might ask (and rightly so) what I might possibly mean by talking about something done by a quantum computer which is not an &lt;code&gt;algorithm&lt;/code&gt;. What I mean by this is that we can have a quantum computer perform a process which&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;does not necessarily have very well-understood behaviour &amp;mdash; in particular, there are very few things we can prove about that process;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;in particular, that process does not 'solve' any problem of practical interest &amp;mdash; the answer to the computation doesn't necessarily answer a question that you are interested in.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;When I say that the process doesn't necessarily have well-understood behaviour, this does not mean that we don't know what the computer is doing: we will have a good description of the operations that it does. But we won't necessarily have an acute understanding of the &lt;em&gt;cumulative effect on the state of the system&lt;/em&gt; of those operations. (The very promise of quantum computation was originally proposed because &lt;em&gt;quantum mechanical systems are difficult to simulate&lt;/em&gt;, which meant that it might be able to simulate other systems which are difficult to simulate.)&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;You might ask what the point is of having a quantum computer do something which is difficult to simulate if the only reason is &lt;em&gt;only&lt;/em&gt; that it is difficult to simulate. The reason of this is: it demonstrates a proof of principle. Suppose that you can build quantum systems with 35 qubits, with 40 qubits, with 45 qubits, 50 qubits, and so forth &amp;mdash; each built according to the same engineering principles, each of them simulatable in practise, and each &lt;strong&gt;behaving the way that the simulation predicts&lt;/strong&gt; (up to good tolerances), but where each simulation is much more resource-intensive than the last. Then once you have a system on 55 or 60 qubits that you can't simulate with the world's largest supercomputer, you could argue that you have an architecture that builds reliable quantum computers (based on the sizes you can simulate), and which can be used to build quantum computers large enough that no known simulation technique can predict their behaviour (and where perhaps no such technique is even possible).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This stage in itself is not necessarily &lt;em&gt;useful&lt;/em&gt; for anything, but it is a necessary condition to being able to solve interesting problems on a quantum computer more quickly than you can on a classical computer. The fact that you can't necessarily solve 'interesting' problems at this stage is one reason why people are sometimes dissatisfied with the term 'supremacy'. (There are other reasons to do with political connotations, which are justified in my opinion but off-topic here.) Call it &quot;quantum ascendancy&quot;, if you prefer &amp;mdash; meaning that it marks a point at which quantum technologies are definitely becoming significant in power, while not yet in any danger of replacing the mobile phone in your pocket,  desktop computers, or even necessarily industrial supercomputers &amp;mdash; but it is a point of interest in the developmental curve of any quantum computational technology.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;But the bottom line is that, yes, &quot;quantum supremacy&quot; is &lt;strong&gt;precisely&lt;/strong&gt; about &quot;not being able to simulate quantum computers of certain sizes&quot;, or at least not being able to simulate certain specific processes that you can have them perform, and this benchmark depends not only on quantum technology but on the best available classical technology and the best available classical techniques. It is a blurry boundary which, if we are being serious about things, we will only be confident that we have passed a year or two after the fact. But it is an important boundary to cross.&lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="58" LastEditDate="2018-03-14T15:51:08.523" LastActivityDate="2018-03-14T15:51:08.523" CommentCount="3" />
  <row Id="69" PostTypeId="1" AcceptedAnswerId="94" CreationDate="2018-03-13T10:05:43.737" Score="13" ViewCount="217" Body="&lt;p&gt;The strengthened version of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis&quot; rel=&quot;noreferrer&quot;&gt;Church-Turing thesis&lt;/a&gt; states that:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Any algorithmic process can be simulated efficiently using a Turing machine.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, on page 5 (chapter 1), the book &lt;em&gt;Quantum Computation and Quantum Information: 10th Anniversary Edition By Michael A. Nielsen, Isaac L. Chuang&lt;/em&gt; goes on to say that:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;One class of challenge to the the strong Church Turing thesis comes&#xA;  from the field of &lt;em&gt;analog computation&lt;/em&gt;. In the years since Turing,&#xA;  many different teams of researchers have noticed that certain types of&#xA;  analog computers can efficiently solve problems believed to have no&#xA;  efficient solution on a Turing machine. At the first glance these&#xA;  analog computers appear to violate the strong form of the&#xA;  Church-Turing thesis. Unfortunately for analog computation it turns&#xA;  out that when realistic assumptions about the presence of &lt;strong&gt;noise&lt;/strong&gt; in&#xA;  analog computers are made, their power disappears in all known&#xA;  instances; they cannot efficiently solve problems which are not&#xA;  solvable on a Turing machine. This lesson – that the effects of&#xA;  realistic &lt;strong&gt;noise&lt;/strong&gt; must be taken into account in evaluating the&#xA;  efficiency of a computational model – was one of the great early&#xA;  challenges of quantum computation and quantum information, a challenge&#xA;  successfully met by the development of a theory of quantum&#xA;  error-correcting codes and fault-tolerant quantum computation. Thus,&#xA;  unlike analog computation, quantum computation can in principle&#xA;  tolerate a finite amount of &lt;strong&gt;noise&lt;/strong&gt; and still retain its computational&#xA;  advantages.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;What exactly is meant by noise in this context? Do they mean &lt;a href=&quot;https://en.wikipedia.org/wiki/Johnson%E2%80%93Nyquist_noise&quot; rel=&quot;noreferrer&quot;&gt;thermal noise&lt;/a&gt;? It's strange that the  authors did not define or clarify what they mean by &lt;em&gt;noise&lt;/em&gt; in the previous pages of the textbook.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I was wondering if they were referring to &lt;em&gt;noise&lt;/em&gt; in a more generalized setting. Like, even if we get rid of the conventional &lt;em&gt;noise&lt;/em&gt; - like industrial &lt;em&gt;noise&lt;/em&gt;, vibrational &lt;em&gt;noise&lt;/em&gt;, thermal &lt;em&gt;noise&lt;/em&gt; (or reduce them to negligible levels), &lt;em&gt;noise&lt;/em&gt; could still refer to the uncertainties in amplitude, phase, etc, which arise due to the underlying quantum mechanical nature of the system.&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-16T15:35:57.370" LastActivityDate="2018-03-16T15:35:57.370" Title="What exactly is meant by &quot;noise&quot; in the following context?" Tags="&lt;noise&gt;" AnswerCount="3" CommentCount="0" FavoriteCount="1" />
  <row Id="70" PostTypeId="1" CreationDate="2018-03-13T10:12:45.070" Score="9" ViewCount="137" Body="&lt;p&gt;A quantum computer can efficiently solve problems lying in the complexity class &lt;a href=&quot;https://en.wikipedia.org/wiki/BQP&quot; rel=&quot;noreferrer&quot;&gt;BQP&lt;/a&gt;. I have seen a claim the one can (potentially, because we don't know whether BQP is a proper subset or equal to PP) increase the efficiency of a quantum computer by applying &lt;em&gt;postselection&lt;/em&gt; and that the class of efficiently solvable problems becomes now postBQP = &lt;a href=&quot;https://en.wikipedia.org/wiki/PP_(complexity)&quot; rel=&quot;noreferrer&quot;&gt;PP&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What does &lt;em&gt;postselection&lt;/em&gt; mean here?&lt;/p&gt;&#xA;" OwnerUserId="18" LastActivityDate="2018-04-11T09:48:56.377" Title="What is postselection in quantum computing?" Tags="&lt;complexity-theory&gt;&lt;postselection&gt;&lt;bqp&gt;&lt;terminology&gt;" AnswerCount="2" CommentCount="2" FavoriteCount="1" />
  <row Id="71" PostTypeId="2" ParentId="70" CreationDate="2018-03-13T10:45:13.640" Score="11" Body="&lt;p&gt;&quot;Postselection&quot; refers to the process of conditioning on the outcome of a measurement on some other qubit. (This is something that you can think of for classical probability distributions and statistical analysis as well: it is not a concept special to quantum computation.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Postselection has featured quite often (up to this point) in quantum mechanics experiments, because &amp;mdash; for experiments on very small systems, involving not very many particles &amp;mdash; it is a relatively easy way to simulate having good quantum control or feedforward. However, it is not a practical way of realising computation, because you have to condition on an outcome of one or more measurements which may occur with &lt;em&gt;very low&lt;/em&gt; probability.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Actually 'selecting' a measurement outcome is nothing you can do easily in quantum mechanics &amp;mdash; what one actually does is throw away any outcome which does not allow you to do what you want to do. If the outcome which you are trying to select has probability $0 &amp;lt; p &amp;lt; 1$, you will have to try an expected number $1/p$ times before you manage to obtain the outcome you are trying to select. If $p = 1/2^n$ for some large integer $n$, you may be waiting a very long time.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The result that postselection 'increases' (as you say) the power of bounded-error quantum computation from &lt;strong&gt;BQP&lt;/strong&gt; to &lt;strong&gt;PP&lt;/strong&gt; is a well-liked result in the theory of quantum computation, not because it is &lt;em&gt;practical&lt;/em&gt;, but because it is a simple and crisp result of a sort which is rare in computational complexity, and is useful for informing intuitions about quantum computation &amp;mdash; it has led onward to ideas of &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/65/124&quot;&gt;&quot;quantum supremacy&quot; experiments&lt;/a&gt;, for example. But it is not something which you should think of as an operation which is freely available to quantum computers as a practical technique, unless you can show that the outcomes which you are trying to postselect are few enough and of high-enough probability (or, as with measurement-based computation, that you can simulate the 'desirable' outcome by a suitable adaptation of your procedure if you obtain one of the 'undesirable' outcomes).&lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-03-13T11:38:10.027" LastActivityDate="2018-03-13T11:38:10.027" CommentCount="0" />
  <row Id="72" PostTypeId="5" CreationDate="2018-03-13T10:57:08.753" Score="0" Body="&lt;p&gt;Spontaneous parametric down conversion (SPDC) is as an optical quantum process in which an incident photon is converted into pairs of entangled photons by a non-linear medium.&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-13T13:17:05.640" LastActivityDate="2018-03-13T13:17:05.640" CommentCount="0" />
  <row Id="73" PostTypeId="4" CreationDate="2018-03-13T10:57:08.753" Score="0" Body="For questions related to spontaneous parametric down conversion " OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-13T13:16:59.893" LastActivityDate="2018-03-13T13:16:59.893" CommentCount="0" />
  <row Id="74" PostTypeId="1" CreationDate="2018-03-13T11:07:05.207" Score="22" ViewCount="502" Body="&lt;p&gt;It seems that quantum computing is often taken to mean the quantum circuit method of computation, where a register of qubits is acted on by a circuit of quantum gates and measured at the output (and possibly at some intermediate steps). Quantum annealing at least seems to be an altogether different method to computing with quantum resources&lt;sup&gt;1&lt;/sup&gt;, as it does not involve quantum gates.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What different methods of quantum computation are there? What makes them different?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To clarify, I am not asking what different physical implementations qubits have, I mean the description of different ideas of how to compute outputs from inputs&lt;sup&gt;2&lt;/sup&gt; using quantum resources.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;sub&gt;&#xA;1. Anything that is inherently non-classical, like entanglement and coherence.&lt;br&gt;&#xA;2. A process which transforms the inputs (such as qubits) to outputs (results of the computation).&#xA;&lt;/sub&gt;&lt;/p&gt;&#xA;" OwnerUserId="144" LastEditorUserId="26" LastEditDate="2018-03-25T12:49:59.237" LastActivityDate="2018-03-29T11:03:47.783" Title="What are the methods of quantum computation?" Tags="&lt;quantum-computing-models&gt;&lt;architecture&gt;" AnswerCount="5" CommentCount="15" FavoriteCount="6" />
  <row Id="75" PostTypeId="1" CreationDate="2018-03-13T13:24:24.397" Score="17" ViewCount="251" Body="&lt;p&gt;Which quantum error correction code currently holds the record in terms of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_threshold_theorem&quot; rel=&quot;noreferrer&quot;&gt;highest threshold for fault-tolerance&lt;/a&gt;? I know that the &lt;a href=&quot;https://arxiv.org/abs/1208.0928&quot; rel=&quot;noreferrer&quot;&gt;surface code&lt;/a&gt; is pretty good ($\approx10^{-2}$?), but finding exact numbers is difficult. I also read about some &lt;a href=&quot;https://arxiv.org/abs/1409.4880&quot; rel=&quot;noreferrer&quot;&gt;generalizations of the surface code to 3D clusters&lt;/a&gt; (topological quantum error correction). I guess the main motivation for this research was to increase the threshold for calculations of arbitrary length. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is: Which quantum error correction code has the highest threshold (as proven at the time of writing this)?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In order to judge this value it would be nice to know what threshold is theoretically achievable. So if you know of (non-trivial) upper bounds on thresholds for arbitrary quantum error correction codes that would be nice.&lt;/p&gt;&#xA;" OwnerUserId="104" LastEditorUserId="26" LastEditDate="2018-05-07T13:21:29.163" LastActivityDate="2018-05-07T13:21:29.163" Title="Which quantum error correction code has the highest threshold (as proven at the time of writing this)?" Tags="&lt;quantum-error-correction&gt;&lt;noise&gt;&lt;fault-tolerance&gt;" AnswerCount="3" CommentCount="7" />
  <row Id="76" PostTypeId="5" CreationDate="2018-03-13T13:38:17.170" Score="0" Body="&lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Qubit&quot; rel=&quot;nofollow noreferrer&quot;&gt;qubit&lt;/a&gt; (quantum binary digit) is the quantum analogue of the classical bit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As such, it is a two-level system and some example physical systems that can be used as a qubit include:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;the ground and first excited state of an atom, or other equivalent system&lt;/li&gt;&#xA;&lt;li&gt;polarisation of a photon&lt;/li&gt;&#xA;&lt;li&gt;two spatial or temporal modes of a photon&lt;/li&gt;&#xA;&lt;li&gt;spin of an electron/atom/&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_dot&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum dot&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;charge or (direction of) current of a system&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Squeezed_coherent_state&quot; rel=&quot;nofollow noreferrer&quot;&gt;squeezed light&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Mathematically, a qubit lives on a 2-dimensional Hilbert space. The 'computational basis' is denoted by the states $$\left|0\right&amp;gt; = \begin{pmatrix}1 \\\ 0 \end{pmatrix} \quad \text{and}\quad\left|1\right&amp;gt;=\begin{pmatrix}0 \\\ 1\end{pmatrix},$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;so that any single qubit state can be written as $\left|\psi\right&amp;gt; = \alpha\left|0\right&amp;gt;+\beta\left|1\right&amp;gt;$ (known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_superposition&quot; rel=&quot;nofollow noreferrer&quot;&gt;superposition&lt;/a&gt;), with the constraint that $\lvert\alpha\rvert^2+\lvert\beta\rvert^2=1$. Taking out a global phase allows these to be written as $\alpha=\cos\frac{\theta}{2}$ and $\beta=e^{i\phi}\sin\frac{\theta}{2}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_entanglement&quot; rel=&quot;nofollow noreferrer&quot;&gt;Entangling&lt;/a&gt; $n$ qubits allows for creation of larger states living in a $2^n$-dimensional Hilbert space. For more information, see also the &lt;a href=&quot;/questions/tagged/quantum-entanglement&quot; class=&quot;post-tag&quot; title=&quot;show questions tagged &amp;#39;quantum-entanglement&amp;#39;&quot; rel=&quot;tag&quot;&gt;quantum-entanglement&lt;/a&gt; tag.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Higher dimensional versions of the qubit, known as the &lt;a href=&quot;/questions/tagged/qutrit&quot; class=&quot;post-tag&quot; title=&quot;show questions tagged &amp;#39;qutrit&amp;#39;&quot; rel=&quot;tag&quot;&gt;qutrit&lt;/a&gt; and &lt;a href=&quot;/questions/tagged/qudit&quot; class=&quot;post-tag&quot; title=&quot;show questions tagged &amp;#39;qudit&amp;#39;&quot; rel=&quot;tag&quot;&gt;qudit&lt;/a&gt; also exist, although are less widely used.&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="23" LastEditDate="2018-06-15T19:16:08.397" LastActivityDate="2018-06-15T19:16:08.397" CommentCount="0" />
  <row Id="77" PostTypeId="4" CreationDate="2018-03-13T13:38:17.170" Score="0" Body="For questions related to quantum bits, quantum systems living in a 2-dimensional Hilbert space. Consider also using the 'qubit-state' tag when relevant" OwnerUserId="26" LastEditorUserId="23" LastEditDate="2018-06-15T19:16:08.397" LastActivityDate="2018-06-15T19:16:08.397" CommentCount="0" />
  <row Id="80" PostTypeId="2" ParentId="65" CreationDate="2018-03-13T13:45:31.797" Score="5" Body="&lt;p&gt;The term &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_supremacy&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;em&gt;quantum supremacy&lt;/em&gt;&lt;/a&gt;, as introduced by Preskill in 2012 (&lt;a href=&quot;https://arxiv.org/pdf/1203.5813.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;1203.5813&lt;/a&gt;), can be defined by the following sentence:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;We therefore hope to hasten the onset of the era of quantum supremacy, when we&#xA;  will be able to perform tasks with controlled quantum systems going beyond what&#xA;  can be achieved with ordinary digital computers.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Or, as wikipedia rephrases it, &lt;em&gt;quantum supremacy is the potential ability of quantum computing devices to solve problems that classical computers practically cannot&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It should be noted that this is &lt;em&gt;not&lt;/em&gt; a precise definition in the mathematical sense. What you can make precise statements on is how the complexity of a given problem scales with the dimension of the input (say, the number of qubits to be simulated, if one is dealing with a simulation problem).&#xA;Then, if it turns out that quantum mechanics allows solving the same problem more efficiently (and, crucially, you are able to prove it), then there is room for a quantum device to demonstrate (or rather, provide evidence towards) &lt;em&gt;quantum supremacy&lt;/em&gt; (or &lt;em&gt;quantum advantage&lt;/em&gt;, or however you prefer to call it, see for example the discussion in the comments &lt;a href=&quot;https://scirate.com/arxiv/1705.06768&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;So, in light of the above, &lt;strong&gt;&lt;em&gt;when exactly can one claim to have reached the quantum supremacy regime&lt;/em&gt;&lt;/strong&gt;? At the end of the day, there is no single &lt;em&gt;magic number&lt;/em&gt; that brings you from the &quot;classically simulatable regime&quot; to the &quot;quantum supremacy regime&quot;, and this is more of a continuous transition, in which one gathers more and more evidence towards the statements that quantum mechanics can do better than classical physics (and, in the process, provide evidence against the Extended Church-Turing thesis).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;On the one hand, there are regimes which obviously fall into the &quot;quantum supremacy regime&quot;. This is when you manage to solve a problem with a quantum device that you just &lt;em&gt;cannot&lt;/em&gt; solve with a classical device. For example, if you manage to factorize a huge number that would take the age of the universe to compute with any classical device (and assuming someone managed to &lt;em&gt;prove&lt;/em&gt; that Factoring is indeed classical hard, which is far from a given), then it seems hard to refute that quantum mechanics does indeed allow to solve some problems more efficiently than classical devices.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But the above is not a good way to think of quantum supremacy, mostly because one of the main points of quantum supremacy is as an intermediate step before being able to solve practical problems with quantum computers. Indeed, in the quest for quantum supremacy, one relaxes the requirement of trying to solve &lt;em&gt;useful&lt;/em&gt; problems and just tries to attack the principle that at least for &lt;em&gt;some&lt;/em&gt; tasks, quantum mechanics does indeed provide advantages.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When you do this and ask for the &lt;em&gt;simplest possible device that can demonstrate quantum supremacy&lt;/em&gt;, things start to get tricky. You want to find the threshold above which quantum devices are &lt;em&gt;better&lt;/em&gt; than classical ones, but this amounts to &lt;em&gt;compare two radically different kinds of devices, running radically different kinds of algorithms&lt;/em&gt;.&#xA;There is no easy (known?) way to do this.&#xA;For example, do you take into account how expensive it was to build the two different devices? And what about comparing a general purpose classical device with a special purpose quantum one? Is that fair?&#xA;What about &lt;em&gt;validating&lt;/em&gt; the output of the quantum device, is that required? Also, how strict do you require your complexity results to be?&#xA;A proposed reasonable list of criteria for a quantum supremacy experiment, as given by Harrow and Montanaro (&lt;a href=&quot;https://www.nature.com/articles/nature23458&quot; rel=&quot;nofollow noreferrer&quot;&gt;nature23458&lt;/a&gt;, paywalled), is$^1$:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;A well-defined computational problem.&lt;/li&gt;&#xA;&lt;li&gt;A quantum algorithm solving the problem which can run on a near-term hardware capable of dealing with noise and imperfections.&lt;/li&gt;&#xA;&lt;li&gt;A number of computational resources (time/space) allowed to any classical competitor.&lt;/li&gt;&#xA;&lt;li&gt;A small number of well-justified complexity-theoretic assumptions.&lt;/li&gt;&#xA;&lt;li&gt;a verification method that can efficiently distinguish between the performances of the quantum algorithm from any classical competitor using the allowed resources.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;To better understand the issue one may have a look at the discussions around D-Wave's claims in 2005 of a &quot;$10^8$ speedup&quot; with their device (which holds only when using appropriate comparisons).&#xA;See for example discussions on &lt;a href=&quot;https://www.scottaaronson.com/blog/?p=2555&quot; rel=&quot;nofollow noreferrer&quot;&gt;this Scott Aaronson's blog post&lt;/a&gt; and references therein (and, of course, the original paper by Denchev et al. (&lt;a href=&quot;https://arxiv.org/abs/1512.02206&quot; rel=&quot;nofollow noreferrer&quot;&gt;1512.02206&lt;/a&gt;)).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Also regarding the exact thresholds separating the &quot;classical&quot; from the &quot;quantum supremacy&quot; regime, one may have a look at the discussions around the number of photons required to claim quantum supremacy in a boson sampling experiment. &#xA;The reported number was initially around 20 and 30 (&lt;a href=&quot;https://arxiv.org/abs/1011.3245&quot; rel=&quot;nofollow noreferrer&quot;&gt;Aaronson 2010&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1203.5813&quot; rel=&quot;nofollow noreferrer&quot;&gt;Preskill 2012&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1505.03708&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bentivegna et al. 2015&lt;/a&gt;, among others), then briefly went as low as seven (&lt;a href=&quot;https://arxiv.org/abs/1610.02279&quot; rel=&quot;nofollow noreferrer&quot;&gt;Latmiral et al. 2016&lt;/a&gt;), and then up again as high as ~50 (&lt;a href=&quot;https://arxiv.org/abs/1705.00686&quot; rel=&quot;nofollow noreferrer&quot;&gt;Neville et al. 2017&lt;/a&gt;, and you may have a look at the brief discussion of this result &lt;a href=&quot;https://www.scottaaronson.com/blog/?p=3248&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are &lt;em&gt;many&lt;/em&gt; other similar examples that I didn't mention here. For example there is the whole discussion around quantum advantage via IQP circuits, or the number of qubits that are necessary before one cannot simulate classically a device (&lt;a href=&quot;https://arxiv.org/abs/1709.06678&quot; rel=&quot;nofollow noreferrer&quot;&gt;Neill et al. 2017&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1710.05867&quot; rel=&quot;nofollow noreferrer&quot;&gt;Pednault et al. 2017&lt;/a&gt;, and &lt;a href=&quot;https://www.scottaaronson.com/blog/?p=3512&quot; rel=&quot;nofollow noreferrer&quot;&gt;some&lt;/a&gt; &lt;a href=&quot;https://www.nature.com/news/race-for-quantum-supremacy-hits-theoretical-quagmire-1.22993&quot; rel=&quot;nofollow noreferrer&quot;&gt;other&lt;/a&gt; discussions on these results).&#xA;Another nice review I didn't include above is this &lt;a href=&quot;https://www.nature.com/articles/s41534-017-0018-2&quot; rel=&quot;nofollow noreferrer&quot;&gt;Lund et al. 2017&lt;/a&gt; paper.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(1) I'm using here the rephrasing of the criteria as given in Calude and Calude (&lt;a href=&quot;https://arxiv.org/pdf/1712.01356.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;1712.01356&lt;/a&gt;).&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="58" LastEditDate="2018-03-14T09:51:25.767" LastActivityDate="2018-03-14T09:51:25.767" CommentCount="0" />
  <row Id="82" PostTypeId="2" ParentId="69" CreationDate="2018-03-13T14:47:00.733" Score="2" Body="&lt;p&gt;Asking the author to clarify would give you the exact answer you are looking for. However, based upon the context provided I believe this may be related to the problem &lt;strong&gt;quantum noise spectroscopy&lt;/strong&gt; attempts to solve.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Noise&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;According to a team of Dartmouth researchers led by Professor Lorenza Viola, &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;These quantum properties are essential for quantum computing, but they are easily lost through decoherence, when quantum systems are subject to &quot;noise&quot; in an external environment.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The quantum properties she is referring too are quantum system properties such as the ability to be in a superposition of two different states simultaneously as stated in the same &lt;a href=&quot;https://www.sciencedaily.com/releases/2016/04/160418130648.htm&quot; rel=&quot;nofollow noreferrer&quot;&gt;article&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;My Conclusion&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Therefore, based upon both the context provided in the question and the context provided by the team of Dartmouth researchers, I would conclude that the &lt;em&gt;noise&lt;/em&gt; the book refers to is &lt;em&gt;environmental noise&lt;/em&gt;.&lt;/p&gt;&#xA;" OwnerUserId="82" LastActivityDate="2018-03-13T14:47:00.733" CommentCount="0" />
  <row Id="84" PostTypeId="2" ParentId="4" CreationDate="2018-03-13T15:29:44.657" Score="6" Body="&lt;h2&gt;Case I: The 2 qubits are not entangled.&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;You can write the states of the two qubits (say $\mathrm{A}$ and $\mathrm{B}$) as $|\psi_\mathrm{A}\rangle=a|0\rangle+b|1\rangle$ and $|\psi_\mathrm{B}\rangle = c|0\rangle+d|1\rangle$ where $a,b,c,d\in\Bbb{C}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The individual qubits reside in two dimensional complex vector spaces $\Bbb{C}^2$ (over a $\Bbb{C}$ field). But the state of the system is a &lt;em&gt;vector&lt;/em&gt; (or &lt;em&gt;point&lt;/em&gt;) residing in a four dimensional complex vector space $\Bbb{C}^4$(over a $\Bbb {C}$ field).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The state of the system can be written as a tensor product $|\psi_\mathrm{A}\rangle\otimes|\psi_\mathrm{B}\rangle$ i.e. $ac|00\rangle+ad|01\rangle+bc|10\rangle+bd|11\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Naturally, $|ac|^2+|ad|^2+|bc|^2+|bd|^2=1$ since the state vector has to be normalized. The reason as to why the square of the amplitude of a basis state gives the probability of that basis state occurring when measured in the corresponding basis lies in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Born_rule&quot; rel=&quot;noreferrer&quot;&gt;Born's rule&lt;/a&gt; of quantum mechanics (some physicists consider it to be a basic postulate of quantum mechanics). Now, probability of $|0\rangle$ occuring when the first qubit is measured is $|ac|^2+|ad|^2$. Similarly, probability of $|1\rangle$ occuring when the first qubit is measured is $|bc|^2+|bd|^2$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, what happens if we apply a quantum gate without performing any measurement on the previous state of the system? Quantum gates are unitary gates. Their action can be written as action of an unitary operator $U$ on the initial state of the system i.e. $ac|00\rangle+ad|01\rangle+bc|10\rangle+bd|11\rangle$ to produce a new state $A|00\rangle+B|01\rangle+C|10\rangle+D|11\rangle$ (where $A,B,C,D\in\Bbb{C}$). The magnitude of this new state vector: $|A|^2+|B|^2+|C|^2+|D|^2$ again equates to $1$, since the applied gate was &lt;em&gt;unitary&lt;/em&gt;. When the first qubit is measured, probability of $|0\rangle$ occurring is $|A|^2+|B|^2$ and similarly you can find it for occurrence of $|1\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But if we did perform a measurement, before the action of the unitary gate the result would be different. For example of you had measured the first qubit and it turned out to be in $|0\rangle$ state the intermediate state of the system would have &lt;em&gt;collapsed&lt;/em&gt; to $\frac{ac|00\rangle + ad|01\rangle}{\sqrt{(ac)^2+(ad)^2}}$ (according to the Copenhagen interpretation). So you can understand that applying the same quantum gate on &lt;em&gt;this&lt;/em&gt; state would have given a different final result.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Case II: The 2 qubits are entangled.&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;In case the state of the system is something like $\frac{1}{\sqrt{2}}|00\rangle + \frac{1}{\sqrt{2}}|11\rangle$ , you cannot represent it as a tensor product of states of two individual qubits (try!). There are plenty more such examples. The qubits are said to entangled in such a case.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Anyway, the basic logic still remains same. The probability of $|0\rangle$ occuring when the first qubit is measured is $|1/\sqrt{2}|^2=\frac{1}{2}$ and $|1\rangle$ occuring is $\frac{1}{2}$ too. Similarly you can find out the probabilities for measurement of the second qubit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Again if you apply a unitary quantum gate on this state, you'd end up with something like $A|00\rangle+B|01\rangle+C|10\rangle+D|11\rangle$, as before. I hope you can now yourself find out the probabilities of the different possibilities when the first and second qubits are measured.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Note: Normally the basis states of the 2-qubit sytem $|00\rangle,|01\rangle,|10\rangle,|11\rangle$ are considered as the four $4\times 1$ column vectors like $\begin{bmatrix} 1 \\ 0 \\ 0 \\ 0 \end{bmatrix}$, $\begin{bmatrix} 0 \\ 1 \\ 0 \\ 0 \end{bmatrix}$, etc. by mapping the four basis vectors to the standard basis of $\Bbb{R}^4$. And, the unitary transformations $U$ can be written as $4\times 4$ matrices which satisfy the property $UU^{\dagger}=U^{\dagger}U=I$.&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-13T16:51:25.723" LastActivityDate="2018-03-13T16:51:25.723" CommentCount="0" />
  <row Id="85" PostTypeId="2" ParentId="69" CreationDate="2018-03-13T15:57:07.180" Score="7" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Unfortunately for analog computation it turns out that when realistic assumptions about the presence of noise in analog computers are made, their power disappears in all known instances; they cannot efficiently solve problems which are not solvable on a Turing machine.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;em&gt;Noise&lt;/em&gt;&quot; appears to be used in the general sense of non-idealities in a signal:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;In &lt;a href=&quot;https://en.wikipedia.org/wiki/Signal_processing&quot; rel=&quot;nofollow noreferrer&quot;&gt;signal processing&lt;/a&gt;, noise is a general term for unwanted (and, in general, unknown) modifications that a &lt;a href=&quot;https://en.wikipedia.org/wiki/Signal_(signal_processing)&quot; rel=&quot;nofollow noreferrer&quot;&gt;signal&lt;/a&gt; may suffer during capture, storage, transmission, processing, or conversion.&lt;sup&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Noise_(signal_processing)#cite_note-1&quot; rel=&quot;nofollow noreferrer&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Sometimes the word is also used to mean signals that are random (unpredictable) and carry no useful information; even if they are not interfering with other signals or may have been introduced intentionally, as in &lt;a href=&quot;https://en.wikipedia.org/wiki/Comfort_noise&quot; rel=&quot;nofollow noreferrer&quot;&gt;comfort noise&lt;/a&gt;.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;-&lt;a href=&quot;https://en.wikipedia.org/wiki/Noise_(signal_processing)&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;Noise (signal processing)&quot;&lt;/a&gt;, Wikipedia&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;For an example of what they're talking about, let's consider a simple circuit:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;\require{enclose}&#xA;\def\place#1#2#3{\smash{\rlap{\hskip{#1pt}\raise{#2pt}{#3}}}}&#xA;%&#xA;\bbox[10pt]{\enclose{box}{\phantom{\Rule{250pt}{75pt}{0pt}}}}&#xA;%&#xA;\place{-275}{70}{\enclose{box}{\bbox[5pt,lightblue]{&#xA;\begin{array}{c}&#xA;\text{resistor} \\&#xA;\text{set resistance:}~R&#xA;\end{array}&#xA;}}}&#xA;%&#xA;\place{-270}{0}{&#xA;\enclose{box}{\bbox[5pt,lightblue]{&#xA;\begin{array}{c}&#xA;\text{power source} \\&#xA;\text{set voltage:}~V&#xA;\end{array}&#xA;}}}&#xA;%&#xA;\place{-55}{30}{&#xA;\enclose{box}{\bbox[5pt,lightblue]{&#xA;\begin{array}{c}&#xA;\text{current meter} \\&#xA;\text{measured current:}~I&#xA;\end{array}&#xA;}}}&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Since we can select both $V$ and $R$ and we know &lt;a href=&quot;https://en.wikipedia.org/wiki/Ohm%27s_Laws&quot; rel=&quot;nofollow noreferrer&quot;&gt;Ohm's law&lt;/a&gt;, $I=\frac{V}{R}$, we can use this circuit to divide numbers for us:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Select some division problem to perform, $\frac{a}{b}=?$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Set the voltage source to $V=a~\mathrm{V}$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Set the resistor to $R=b~\mathrm{\Omega}$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Measure $I=?~\mathrm{A}$ to get the result!&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;This is a simple analog computer that can divide numbers without need for us to perform the math in some other manner, e.g. digital logic.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But what's really cool about this?  If we're naive, we might believe that it can do &lt;a href=&quot;https://en.wikipedia.org/wiki/Real_computation&quot; rel=&quot;nofollow noreferrer&quot;&gt;real computation&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;In &lt;a href=&quot;https://en.wikipedia.org/wiki/Computability_theory&quot; rel=&quot;nofollow noreferrer&quot;&gt;computability theory&lt;/a&gt;, the theory of real computation deals with hypothetical computing machines using infinite-precision real numbers. They are given this name because they operate on the set of &lt;a href=&quot;https://en.wikipedia.org/wiki/Real_number&quot; rel=&quot;nofollow noreferrer&quot;&gt;real numbers&lt;/a&gt;. Within this theory, it is possible to prove interesting statements such as &quot;The complement of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mandelbrot_set&quot; rel=&quot;nofollow noreferrer&quot;&gt;Mandelbrot set&lt;/a&gt; is only partially decidable.&quot;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;These hypothetical computing machines can be viewed as idealised &lt;a href=&quot;https://en.wikipedia.org/wiki/Analog_computer&quot; rel=&quot;nofollow noreferrer&quot;&gt;analog computers&lt;/a&gt; which operate on real numbers, whereas &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_computer&quot; rel=&quot;nofollow noreferrer&quot;&gt;digital computers&lt;/a&gt; are limited to &lt;a href=&quot;https://en.wikipedia.org/wiki/Computable_numbers&quot; rel=&quot;nofollow noreferrer&quot;&gt;computable numbers&lt;/a&gt;.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;-&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_computation&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;Real computation&quot;&lt;/a&gt;, Wikipedia&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The thing's that Ohm's law uses real-number values, $\left\{V,I,R\right\}{\in}\mathbb{R}$.  If we believe that these values actually have infinite precision, then we can perform multiplication or division with infinite precision in finite time; this is a feat that a Turing machine can't perform with finite-time operations.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Anyway, back to the original quote:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Unfortunately for analog computation it turns out that when realistic assumptions about the presence of noise in analog computers are made, their power disappears in all known instances; they cannot efficiently solve problems which are not solvable on a Turing machine.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;They're basically saying that, whenever someone's come up with a scheme like this, the non-idealities of the situation (noise in the signals, design, etc.) tend to derail the idealistic expectations.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The quoted excerpt seems to use this as a jumping-off point to discuss how quantum computers aren't as limited by this problem as classical analog computers often seem to have been.&lt;/p&gt;&#xA;" OwnerUserId="15" LastEditorUserId="15" LastEditDate="2018-03-15T10:39:05.103" LastActivityDate="2018-03-15T10:39:05.103" CommentCount="1" />
  <row Id="86" PostTypeId="2" ParentId="3" CreationDate="2018-03-13T16:17:03.143" Score="18" Body="&lt;p&gt;The title of your question asks for techniques that are impossible to break, to which the &lt;a href=&quot;https://en.wikipedia.org/wiki/One-time_pad&quot; rel=&quot;nofollow noreferrer&quot;&gt;One Time Pad&lt;/a&gt; (OTP) is the correct answer, as pointed out in the other answers. The OTP is information-theoretically secure, which means that an adversaries computational abilities are inapplicable when it comes to finding the message.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, despite being perfectly secure &lt;em&gt;in theory&lt;/em&gt;, the OTP is of limited use in modern cryptography. It is extremely difficult &lt;a href=&quot;https://crypto.stackexchange.com/questions/15652/one-time-pad-why-is-it-useless-in-practice&quot;&gt;to use successfully &lt;em&gt;in practice&lt;/em&gt;&lt;/a&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The important question really is:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Can we still expect a new cryptographic algorithm which will be hard to crack using even a quantum computer?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;Asymmetric Cryptography&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Asymmetric cryptography includes Public-Key Encryption (PKE), Digital Signatures, and Key Agreement schemes. These techniques are vital to solve the problems of key distribution and key management. Key distribution and key management are non-negligible problems, they are largely what prevent the OTP from being usable in practice. The internet as we know it today would not function without the ability to create a secured communications channel from an insecure communications channel, which is one of the features that asymmetric algorithms offer.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Shor's algorithm&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Shor%27s_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;Shor's algorithm&lt;/a&gt; is useful for solving the problems of integer factorization and discrete logarithms. These two problems are what provide the basis for security of widely used schemes such as &lt;a href=&quot;https://en.wikipedia.org/wiki/RSA_(cryptosystem)&quot; rel=&quot;nofollow noreferrer&quot;&gt;RSA&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange&quot; rel=&quot;nofollow noreferrer&quot;&gt;Diffie-Hellman&lt;/a&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;NIST is &lt;a href=&quot;https://csrc.nist.gov/projects/post-quantum-cryptography/round-1-submissions&quot; rel=&quot;nofollow noreferrer&quot;&gt;currently evaluating submissions for Post-Quantum algorithms&lt;/a&gt; - algorithms that are based on problems that are believed to be resistant to quantum computers. These problems include:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Lattice-based_cryptography&quot; rel=&quot;nofollow noreferrer&quot;&gt;Lattice based problems&lt;/a&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Lattice_problems#Shortest_vector_problem_(SVP)&quot; rel=&quot;nofollow noreferrer&quot;&gt;Shortest vector problem&lt;/a&gt; (SVP)&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Lattice_problems#Shortest_vector_problem_(SVP)&quot; rel=&quot;nofollow noreferrer&quot;&gt;Closest vector problem&lt;/a&gt; (CVP)&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Multivariate_cryptography&quot; rel=&quot;nofollow noreferrer&quot;&gt;Multivariate equations&lt;/a&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Multivariate polynomial equations&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;http://hkumath.hku.hk/~ghan/WAM/Joachim.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Code based schemes&lt;/a&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Based on the hardness of decoding linear codes &lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Supersingular_Isogeny_Key_Exchange&quot; rel=&quot;nofollow noreferrer&quot;&gt;Supersingular Isogeny Diffie-Hellman&lt;/a&gt; (SIDH)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;It should be noted that classical algorithms for solving the above problems may &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;exist&lt;/a&gt;&lt;/em&gt;, it's just that the runtime/accuracy of these algorithms is prohibitive for solving large instances in practice. These problems don't appear to be solvable when given the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;ability to solve the problem of order finding&lt;/a&gt;, which is what the quantum part of Shor's algorithm does.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Symmetric Cryptography&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;http://twistedoakstudios.com/blog/Post2644_grovers-quantum-search-algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;Grover's algorithm&lt;/a&gt; provides a quadratic speedup when searching through an unsorted list. This is effectively the problem brute-forcing a symmetric encryption key. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Working around Grover's algorithm is relatively easy compared to working around Shor's algorithm: &lt;a href=&quot;https://crypto.stackexchange.com/a/23/29554&quot;&gt;Simply double the size of your symmetric key&lt;/a&gt;. A 256-bit key offers 128-bits of resistance against brute force to an adversary that uses Grover's algorithm.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Grover's algorithm is also &lt;a href=&quot;https://dsprenkels.com/files/grover.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;usable against hash functions&lt;/a&gt;. The solution again is simple: Double the size of your hash output (and capacity if you are using a hash based on a &lt;a href=&quot;https://keccak.team/sponge_duplex.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;sponge construction&lt;/a&gt;). &lt;/p&gt;&#xA;" OwnerUserId="162" LastEditorUserId="162" LastEditDate="2018-06-19T16:48:13.740" LastActivityDate="2018-06-19T16:48:13.740" CommentCount="0" />
  <row Id="89" PostTypeId="2" ParentId="7" CreationDate="2018-03-13T16:57:18.047" Score="9" Body="&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_cryptography&quot; rel=&quot;noreferrer&quot;&gt;Quantum cryptography&lt;/a&gt; relies on elaborate physical machinery to execute cryptographic protocols whose security rests upon axioms of quantum mechanics (theoretically, anyways).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To quote the wikipedia entry on the BB84 protocol:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The security of the protocol comes from encoding the information in non-orthogonal states. Quantum indeterminacy means that these states cannot in general be measured without disturbing the original state (see No cloning theorem).&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There is a good &lt;a href=&quot;https://crypto.stackexchange.com/q/51311/29554&quot;&gt;question&lt;/a&gt; and &lt;a href=&quot;https://crypto.stackexchange.com/a/51314/29554&quot;&gt;answers&lt;/a&gt; about &quot;What makes Quantum Cryptography secure?&quot; on crypto.stackexchange. They are verbose, so I will refrain from copying the content here.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Differences between Quantum Cryptography and Modern Cryptography&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Quantum cryptography requires specialized machinery in order to execute a run of the protocol. This is a non-negligible disadvantage compared to modern cryptography. If you want to use Quantum Cryptography, you'll need to pay one of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_key_distribution#Commercial&quot; rel=&quot;noreferrer&quot;&gt;commercial entities that offers the service&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Modern cryptography uses mathematical algorithms implemented in software, which can be performed by any old computer with sufficient resources (which are almost all computers in this day and age). The outputs of the algorithms can be transmitted via an arbitrary communications medium. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you see a green padlock next to the URL in your web browser, it means your connection to this very site is being secured by modern cryptography - which is effectively being done for free, as far as you were concerned.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Note&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/prCTD.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/prCTD.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quantum cryptography is often thought to be unconditionally unbreakable due to the laws of the universe. This sounds too good to be true, and it unfortunately is. There is nothing to stop someone from waiting for you to receive your message, then to &lt;a href=&quot;https://en.wikipedia.org/wiki/Rubber-hose_cryptanalysis&quot; rel=&quot;noreferrer&quot;&gt;threaten you until you reveal what the message was&lt;/a&gt;. There is also the issue of an adversaries ability to tamper with the hardware. For a rather scathing but in-depth review of these points, see the &lt;a href=&quot;https://blog.cr.yp.to/20160516-quantum.html&quot; rel=&quot;noreferrer&quot;&gt;blog post at cr.yp.to&lt;/a&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Basically, as with all &lt;a href=&quot;http://www.ams.org/notices/200708/tx070800972p.pdf&quot; rel=&quot;noreferrer&quot;&gt;provably&lt;/a&gt; &lt;a href=&quot;https://eprint.iacr.org/2004/152.pdf&quot; rel=&quot;noreferrer&quot;&gt;secure&lt;/a&gt; &lt;a href=&quot;https://eprint.iacr.org/2006/229.pdf&quot; rel=&quot;noreferrer&quot;&gt;cryptographic techniques&lt;/a&gt;, these guarantees are only provided within the framework of assumptions that the proofs rest upon. An adversary who finds a hole in these assumptions can circumvent the theoretical guarantees that the algorithms offer. That's not to say that QC is totally worthless and overtly non-functional, but that &quot;provable security&quot;, as always, needs to be understood to rest on certain sets of assumptions that could be violated in practice.&lt;/p&gt;&#xA;" OwnerUserId="162" LastEditorUserId="162" LastEditDate="2018-03-15T19:15:03.470" LastActivityDate="2018-03-15T19:15:03.470" CommentCount="6" />
  <row Id="91" PostTypeId="1" AcceptedAnswerId="104" CreationDate="2018-03-13T17:21:04.793" Score="16" ViewCount="739" Body="&lt;p&gt;Quantum algorithms frequently use bra-ket notation in their description. What do all of these brackets and vertical lines mean? For example: $|ψ⟩=α|0⟩+β|1⟩$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;While this is arguably a question about mathematics, this type of notation appears to be used frequently when dealing with quantum computation specifically. I'm not sure I have ever seen it used in any other contexts. &lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Edit&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;By the last part, I mean that it is possible to denote vectors and inner products using standard notation for linear algebra, and some other fields that use these objects and operators do so without the use of bra-ket notation. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This leads me to conclude that there is some difference/reason why bra-ket is especially handy for denoting quantum algorithms. It is not an assertion of fact, I meant it as an observation. &quot;I'm not sure I have seen it used elsewhere&quot; is not the same statement as &quot;It is not used in any other contexts&quot;.&lt;/p&gt;&#xA;" OwnerUserId="162" LastEditorUserId="58" LastEditDate="2018-03-14T14:48:29.070" LastActivityDate="2018-03-15T11:09:31.183" Title="How does bra-ket notation work?" Tags="&lt;notation&gt;" AnswerCount="5" CommentCount="2" FavoriteCount="7" />
  <row Id="92" PostTypeId="2" ParentId="91" CreationDate="2018-03-13T17:38:40.387" Score="16" Body="&lt;p&gt;You could think of $|0\rangle$ and $|1\rangle$ as two orthonormal basis states (represented by &quot;ket&quot;s) of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Qubit&quot; rel=&quot;noreferrer&quot;&gt;quantum bit&lt;/a&gt; which resides in a two  dimensional complex vector space. The lines and brackets you see is basically  the &lt;em&gt;bra-ket notation&lt;/em&gt; a.k.a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation&quot; rel=&quot;noreferrer&quot;&gt;Dirac notation&lt;/a&gt; which is commonly used in quantum mechanics.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As an example $|0\rangle$ could represent the spin-down state of an electron while $|1\rangle$ could represent the spin-up state. But actually the electron can be in a linear superposition of those two states i.e. $|\psi\rangle_{\text{electron}} = a|0\rangle + b|1\rangle$ (this is usually normalized like $\frac{a|0\rangle + b|1\rangle}{\sqrt{|a|^2+|b|^2}}$) where $a,b\in \Bbb{C}$.&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-14T08:17:25.440" LastActivityDate="2018-03-14T08:17:25.440" CommentCount="6" />
  <row Id="93" PostTypeId="2" ParentId="61" CreationDate="2018-03-13T19:07:30.017" Score="10" Body="&lt;p&gt;The existing answer does a good job at describing the state that comes from a SPDC configuration at &lt;em&gt;low&lt;/em&gt; conversion efficiency, but it's also worth noting that the single-photon behaviour is not all there is to the process. Thus, in particular, if your conversion efficiency (or you detection time / efficiency / SNR) is good enough that you can detect (and &lt;a href=&quot;https://arxiv.org/abs/1305.6627&quot; rel=&quot;noreferrer&quot;&gt;discriminate&lt;/a&gt;) the emission of multiple photons in the same mode, then those two-photon events &lt;em&gt;also&lt;/em&gt; share quantum correlations between the two modes, as do all higher orders of the photon-statistics distribution.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To be more specific (and ignoring all the polarization, momentum, and phase-matching problems already alluded to by Mithrandir), the light that comes out of a Type II SPDC source in the signal and idler ports is in a &lt;a href=&quot;https://en.wikipedia.org/wiki/Squeezed_coherent_state#Two-mode_squeezed_states&quot; rel=&quot;noreferrer&quot;&gt;two-mode squeezed state&lt;/a&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{align}&#xA; |{\text{TMSV}}\rangle &amp;amp; =S_{2}(\zeta )|0\rangle =\exp(\zeta ^{*}{\hat {a}}{\hat {b}}-\zeta {\hat {a}}^{\dagger }{\hat {b}}^{\dagger })|0\rangle &#xA;\\&amp;amp;  ={\frac {1}{\cosh r}}\sum _{n=0}^{\infty }(\tanh r)^{n}|nn\rangle &#xA;\\ &amp;amp; \approx \operatorname{sech}(r)\left[|00\rangle + \tanh(r)|11\rangle + \tanh^2(r)|22\rangle + \tanh^3(r) |33\rangle  +  \cdots \right],&#xA;\end{align}&#xA;i.e. just as a detection of a single photon on the signal port is completely (and coherently) correlated with a single photon on the idler port, so too does the observation of a two-photon signal state imply that the idler's mode has been collapsed onto a two-photon state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Generally, the folks running SPDC setups as single-photon sources run them in a regime where $\tanh(r)$ is small (so most of the time you get vacuum, except when you do get a click on the signal that guarantees a single photon's presence in the idler mode) in order to eliminate the contribution of the higher-order photon-statistics channels, but they're still there, they can be important, and if you don't control appropriately for them then they might overwhelm the single-photon component of your signal.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I should also say that the details change from configuration to configuration (so e.g. Type I SPDC only produces single-mode squeezed vacua, if I understand correctly) but the higher-order terms will generally always occur.&lt;/p&gt;&#xA;" OwnerUserId="176" LastActivityDate="2018-03-13T19:07:30.017" CommentCount="0" />
  <row Id="94" PostTypeId="2" ParentId="69" CreationDate="2018-03-14T00:21:51.643" Score="8" Body="&lt;p&gt;As an addition to &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/85/23&quot;&gt;Nat's answer&lt;/a&gt;, it's worth mentioning that 'noise' is a specific concept&lt;sup&gt;1&lt;/sup&gt; in quantum computing. This answer will use &lt;a href=&quot;http://www.theory.caltech.edu/people/preskill/ph219/chap3_15.pdf&quot; rel=&quot;noreferrer&quot;&gt;Preskill's lecture notes&lt;/a&gt; as a basis.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In essence, noise is indeed considered to be something that could be described as 'thermal noise', although it should be noted that it is an &lt;em&gt;interaction&lt;/em&gt; with a thermal environment &lt;em&gt;causing&lt;/em&gt; noise, as opposed to noise in and of itself. Approximations are made that means this noise can be described using quantum channels, which is what &lt;em&gt;Nielsen &amp;amp; Chuang&lt;/em&gt; seem to be referring to, as they discuss this in chapter 8.3 of that very textbook. The most common types of noise described in this manner are: depolarising, dephasing and amplitude damping, which will be very briefly explained below.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;In a bit more detail&lt;sup&gt;2&lt;/sup&gt;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Start with a system with Hilbert space $\mathcal{H}_S$, coupled to a (thermal) bath with Hilbert space $\mathcal{H}_B$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Take the density matrix of the system and 'course grain' it into chunks of $\rho\left(t + n\,\delta t\right)$. Make the assumption that the interaction is Markovian, that is, the environment 'forgets' much quicker than the coarse graining time and that whatever you're trying to observe occurs over a time much longer than the coarse graining time.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Express the density matrix at $t+\delta t$ as a channel acting on the density matrix at time $t$: $\rho\left(t + \delta t\right) = \varepsilon_{\delta t}\left(\rho\left(t\right)\right)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Expand this to first order in $\delta t$ to get $\varepsilon_{\delta t} = \mathrm{I} + \delta t\,\mathcal{L}$. As a channel, it must be completely positive and trace preserving, so $\varepsilon_{\delta t}\left(\rho\left(t\right)\right) = \sum_aM_a\rho\left(t\right)M_a^\dagger$ and satisfies $\sum_aM_a^\dagger M_a = \mathrm{I}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This gives a non-unitary quantum channel described by the &lt;em&gt;Lindblad Master equation&lt;/em&gt; $$\dot\rho = -i\left[H, \rho\right] + \sum_{a&amp;gt;0} \gamma_a\left(L_a\rho L_a^\dagger - \frac{1}{2}\lbrace L^\dagger_aL_a, \rho\rbrace\right),$$ where $\gamma_a$'s are always positive for Markovian evolution.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This can also be written as $H_{eff} = H - \frac{i}{2}\sum_a\gamma_aL_a^{\dagger}L_a$, with an additional term, such that the evolution can be written as $$\dot\rho = -i\left[H_{eff}, \rho\right] + \sum_{a&amp;gt;0} \gamma_aL_a\rho L_a^\dagger.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This now looks equivalent to the Kraus operator representation of a channel, with Kraus operators $K_a \propto L_a$ (as well as an additional Kraus operator to satisfy $\left[H_{eff}, \rho\right]$). Any non-trivial Lindbladian can then be described as noise, although in reality, it is an approximation of evolution of an open system.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Some common types of noise&lt;sup&gt;3&lt;/sup&gt;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Trying out various different forms of $L_a$ gives different behaviours&#xA;of the system, which give different possible noises, of which there are a few common ones (in the single qubit case, anyway):&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Dephasing&lt;/strong&gt;: Causes the system to decohere - this gets rid/reduces the entanglement (i.e. coherence) of the system, necessarily making it more mixed, unless already maximally mixed&#xA;$$\varepsilon\left(\rho\right) = \left(1-\frac{p}{2}\right)\rho + \frac{1}{2}\sigma_z\rho\sigma_z$$&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Depolarising&lt;/strong&gt;: Upon measuring, either a bit flip ($\sigma_x$), phase flip ($\sigma_z$), or both bit and phase ($\sigma_y$) will have occurred with some probability&#xA;$$\varepsilon\left(\rho\right) = \left(1-p\right)\rho + \frac{p}{3}\left(\sigma_x\rho\sigma_x + \sigma_y\rho\sigma_y + \sigma_z\rho\sigma_z\right)$$&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Amplitude Damping&lt;/strong&gt;: Represents the system decaying from $\lvert 1\rangle$ to $\lvert 0\rangle$, such as when an atom emits a photon. Leads to a simple version of the coherence times $T_1$ (decay of $\lvert 1\rangle$ to $\lvert 0\rangle$) and $T_2$ (decay of the off-diagonal terms). Described by the Kraus operators $$M_0 = \begin{pmatrix}1 &amp;amp; 0 \\ 0 &amp;amp; \sqrt{1-p}\end{pmatrix} \text{ and } M_1 = \begin{pmatrix}0 &amp;amp; \sqrt{p} \\ 0 &amp;amp; 0\end{pmatrix},$$ giving $$\varepsilon\left(\rho\right) = M_0\rho M_0^\dagger + M_1\rho M_1^\dagger$$&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;1 Or rather, several very broad concepts resulting from the same fundamental idea&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;2 I wouldn't go around calling this rigorous or anything&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;3 Within this context, naturally&lt;/sup&gt;&lt;/p&gt;&#xA;" OwnerUserId="23" LastActivityDate="2018-03-14T00:21:51.643" CommentCount="0" />
  <row Id="95" PostTypeId="5" CreationDate="2018-03-14T01:17:24.723" Score="0" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Noise is a general term for unwanted modifications that a signal may suffer during capture, storage, transmission, processing, or conversion. [1]&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;In the context of Quantum Computing, noise can be a number of different things, although generally either arises as a result of an interaction with an environment, also sometimes referred to as a &lt;em&gt;bath&lt;/em&gt;, or as a result of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Heisenberg%27s_uncertainty_principle&quot; rel=&quot;nofollow noreferrer&quot;&gt;Heisenberg uncertainty principle&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Representing noise&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Shot noise&lt;/strong&gt;: Is Poissonian noise that arises from a process such as &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_tunnelling&quot; rel=&quot;nofollow noreferrer&quot;&gt;tunnelling&lt;/a&gt; electrons or fluctuations in the number of photons as a result of the uncertainty principle. Using e.g. squeezed light states can give &lt;em&gt;sub-poissonian&lt;/em&gt; statistics (where the variance is less than that of Poissonian statistics with the same mean), often referred to as &lt;em&gt;below the shot noise limit&lt;/em&gt;. Similarly, can also have &lt;em&gt;super-Poissonian&lt;/em&gt; statistics.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Markovian noise&lt;/strong&gt;: Where the environment is unable to 'remember' what has happened in the past. Often a good approximation. Leads to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Lindbladian&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;em&gt;Lindblad Master equation&lt;/em&gt;&lt;/a&gt;, also known as the &lt;em&gt;Lindbladian&lt;/em&gt;. Can either be described in a 'coarse grained' manner (useful for simulations) or a more continuous manner.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Kraus operators&lt;/strong&gt;: Described using a &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_channel&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;em&gt;quantum channel&lt;/em&gt;&lt;/a&gt; where (usually) a single operation of the Kraus operators is performed.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Non-Markovian noise&lt;/strong&gt;: A more realistic noise model than Markovian; the assumption that the environment forgets the past is forgotten. As a result, the environment can act not entirely dissimilarly to some form of memory. Can lead to phenomena such as &lt;em&gt;entanglement revival&lt;/em&gt; and other effects where noise that arises from Markovian noise is reversed to a certain extent.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;Common types of noise on qubits&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Dephasing&lt;/strong&gt;: Causes the system to &lt;em&gt;decohere&lt;/em&gt; - this gets rid of/reduces the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_entanglement&quot; rel=&quot;nofollow noreferrer&quot;&gt;entanglement&lt;/a&gt; (i.e. coherence) of the system, necessarily making it more &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_state#Mixed_states&quot; rel=&quot;nofollow noreferrer&quot;&gt;mixed&lt;/a&gt;, unless already maximally mixed.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Depolarising&lt;/strong&gt;: Upon measuring, either a &lt;em&gt;bit flip&lt;/em&gt; ($\sigma_x$), &lt;em&gt;phase flip&lt;/em&gt; ($\sigma_z$), or both bit and phase flip ($\sigma_y$) will have occurred with some probability.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Amplitude Damping&lt;/strong&gt;: Represents the system decaying from one state to a different state, such as when an atom emits a photon. Leads to a simple version of &lt;a href=&quot;https://en.wikipedia.org/wiki/Atomic_coherence&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;em&gt;coherence times&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;Measuring noise&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Fidelity_of_quantum_states&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;strong&gt;Fidelity&lt;/strong&gt;&lt;/a&gt;: Measures how much two quantum states overlap. Often used to characterise quantum processors by comparing the final output state with the ideal result. Is a number between $0$ and $1$.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Other distance measures&lt;/strong&gt;: Other measures, such as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Trace_distance&quot; rel=&quot;nofollow noreferrer&quot;&gt;1-norm/trace distance&lt;/a&gt; also exist, which measure the difference between two states.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;One of the biggest challenges currently facing quantum computing is that of reducing (by a myriad of experimental techniques) and mitigating (by &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_error_correction&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;em&gt;quantum error correction&lt;/em&gt;&lt;/a&gt;) the amount of noise on a system.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;References and further reading:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[1] Wikipedia page on &lt;a href=&quot;https://en.wikipedia.org/wiki/Noise_(signal_processing)&quot; rel=&quot;nofollow noreferrer&quot;&gt;Noise (signal processing)&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Nielsen, M.A. and Chuang, I.L., 2010. Quantum computation and quantum information. Cambridge university press.&lt;/p&gt;&#xA;" OwnerUserId="23" LastEditorUserId="23" LastEditDate="2018-03-15T14:03:21.903" LastActivityDate="2018-03-15T14:03:21.903" CommentCount="0" />
  <row Id="96" PostTypeId="4" CreationDate="2018-03-14T01:17:24.723" Score="0" Body="For questions about different types of noise a quantum computer (or qubits) may experience; how this affects the outcome of the computation; how to reduce a specific type of noise on a specific implementation of quantum computer; or how to simulate noise" OwnerUserId="23" LastEditorUserId="3" LastEditDate="2018-03-14T15:50:47.750" LastActivityDate="2018-03-14T15:50:47.750" CommentCount="0" />
  <row Id="97" PostTypeId="1" CreationDate="2018-03-14T01:32:52.570" Score="15" ViewCount="233" Body="&lt;p&gt;Why do you need error correction? My understanding is that error correction removes errors from noise, but noise should average itself out. To make clear what I'm asking, why can't you, instead of involving error correction, simply run the operations, say, a hundred times, and pick the average/most common answer?&lt;/p&gt;&#xA;" OwnerUserId="91" LastEditorUserId="26" LastEditDate="2018-05-07T13:21:14.293" LastActivityDate="2018-05-07T13:21:14.293" Title="Is error correction necessary?" Tags="&lt;quantum-error-correction&gt;&lt;noise&gt;" AnswerCount="4" CommentCount="0" FavoriteCount="1" />
  <row Id="98" PostTypeId="2" ParentId="97" CreationDate="2018-03-14T02:27:21.323" Score="15" Body="&lt;p&gt;That doesn't scale well. After a moderately long calculation you're basically left with the maximally mixed state or whatever fixed point your noise has. To scale to arbitrary long calculations you need to correct errors before they become too big.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here's some short calculation for the intuition given above. Consider the simple white noise model (depolarizing noise),&#xA;$$\rho'(\varepsilon)= (1-\varepsilon)\rho + \varepsilon \frac{\mathbb{I}}{\operatorname{tr} \mathbb{I}},$$&#xA;where $\rho$ is the ideal state (&lt;a href=&quot;https://quantumcomputing.meta.stackexchange.com/q/54/104&quot;&gt;standard notation&lt;/a&gt; applies). If you concatenate $n$ such noisy processes, the new noise parameter is $\varepsilon'=1-(1-\varepsilon)^n$, which increases exponentially in the number of gates (or other error sources). If you repeat the experiment $m$-times and assume that the standard error scales as $\frac{1}{\sqrt{m}}$ you see that the number of runs $m$ would be exponentially in the length of your calculation!&lt;/p&gt;&#xA;" OwnerUserId="104" LastEditorUserId="104" LastEditDate="2018-03-15T12:15:30.760" LastActivityDate="2018-03-15T12:15:30.760" CommentCount="0" />
  <row Id="99" PostTypeId="2" ParentId="91" CreationDate="2018-03-14T04:47:21.553" Score="12" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;What do all of these brackets and vertical lines mean?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The notation $\left \lvert v \right \rangle$ means &lt;em&gt;exactly&lt;/em&gt; the same thing as $\vec{v}$ or $\textbf{v}$, i.e. it denotes a vector whose name is &quot;v&quot;.&#xA;That's it.&#xA;There is no further mystery or magic, at all.&#xA;The symbol $\left \lvert \psi \right \rangle$ denotes a vector called &quot;psi&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The symbol $\left \lvert \cdot \right \rangle$ is called a &quot;ket&quot;, but it could just as well (and in my opinion should) be called a &quot;vector&quot; with absolutely no loss of meaning at all.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;While this is arguably a question about mathematics, this type of notation appears to be used frequently when dealing with quantum computation specifically.&#xA;  I'm not sure I have ever seen it used in any other contexts.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The notation was invented by a physicist (&lt;a href=&quot;https://en.wikipedia.org/wiki/Paul_Dirac&quot; rel=&quot;noreferrer&quot;&gt;Paul Dirac&lt;/a&gt;) and is called &quot;Dirac notation&quot; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation&quot; rel=&quot;noreferrer&quot;&gt;&quot;bra-ket notation&quot;&lt;/a&gt;.&#xA;As far as I know, Dirac probably invented it while studying quantum mechanics, and so historically the notation has &lt;em&gt;mostly&lt;/em&gt; been used to denote the vectors that show up in quantum mechanics, i.e. quantum states.&#xA;Bra-ket notation is the standard in &lt;em&gt;any&lt;/em&gt; quantum mechanics context, not just quantum computation.&#xA;For example, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Schr%C3%B6dinger_equation&quot; rel=&quot;noreferrer&quot;&gt;Schrodinger equation&lt;/a&gt;, which has to do with dynamics in quantum systems and predates quantum computation by decades, is written using bra-ket notation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Furthermore, the notation is pretty convenient in other linear algebra contexts and is used outside of quantum mechanics.&lt;/p&gt;&#xA;" OwnerUserId="32" LastActivityDate="2018-03-14T04:47:21.553" CommentCount="0" />
  <row Id="100" PostTypeId="2" ParentId="97" CreationDate="2018-03-14T09:31:40.683" Score="9" Body="&lt;p&gt;Now, adding to &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/98/26&quot;&gt;M. Stern's answer&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The primary reason as to why error correction is needed for quantum computers, is because qubits have a &lt;strong&gt;continuum of states&lt;/strong&gt; (I'm considering qubit-based quantum computers only, at the moment, for sake of simplicity). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In quantum computers, unlike classical computers each bit doesn't exist in only two possible states. For instance a likely source of error is over-rotation: $\alpha|0\rangle+\beta|1\rangle$ might be supposed to become $\alpha|0\rangle + \beta e^{i\phi}|1\rangle$ but actually becomes $\alpha|0\rangle+\beta e^{i(\phi+\delta)}|1\rangle$. The actual state is close to the correct state but still wrong. If we don't do something about this the small errors will build up over the course of time and eventually become a big error. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Moreover, quantum states are very delicate, and any interaction with the environment can cause &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_decoherence&quot; rel=&quot;noreferrer&quot;&gt;decoherence&lt;/a&gt; and collapse of a state like $\alpha|0\rangle+\beta|1\rangle$ to $|0\rangle$ with probability $|\alpha|^2$ or $|1\rangle$ with probability $|\beta|^2$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In a classical computer if say a bit's value is being replicated n-times as follows:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$0 \to 00000...\text{n times}$$ and $$1 \to 11111...\text{n times}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In case after the step something like $0001000100$ is produced it can be corrected by the classical computer to give $0000000000$ because majority of the bits were $0's$ and most probably the intended aim of the initial operation was replicating the $0$-bit $10$ times.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But, for qubits such a error correction method won't work, because first of all duplicating qubits directly is not possible due to the &lt;a href=&quot;https://en.wikipedia.org/wiki/No-cloning_theorem&quot; rel=&quot;noreferrer&quot;&gt;No-Cloning theorem&lt;/a&gt;. And secondly, even if you could replicate $|\psi\rangle = \alpha |0\rangle +\beta |1\rangle$ 10-times it's highly probably that you'd end up with something like $(\alpha|0\rangle + \beta |1\rangle)\otimes (\alpha e^{i\epsilon}|0\rangle + \beta e^{i\epsilon'}|1\rangle)\otimes (\alpha e^{i\epsilon_2}|0\rangle + \beta e^{i\epsilon_2'}|1\rangle)\otimes ...$ i.e. with errors in the phases, where all the qubits would be in different states (due to the errors). That is, the situation is no-longer binary. A quantum computer, unlike a classical computer can no longer say that: &quot;Since majority of the bits are in $0$-state let me convert the rest to $0$ !&quot;, to correct any error which occurred during the operation. That's because all the $10$ states of the $10$ different qubits might be different from each other, after the so-called &quot;replication&quot; operation. The number of such possible errors will keep increasing rapidly as more and more operations are performed on a system of qubits. M. Stern has indeed used the right terminology in their answer to your question i.e. &quot;that doesn't &lt;strong&gt;scale well&lt;/strong&gt;&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, you need a &lt;em&gt;different breed&lt;/em&gt; of error correcting techniques to deal with errors occurring during the operation of a quantum computer, which can deal not only with bit flip errors but also phase shift errors. Also, it has to be resistant against unintentional decoherence. One thing to keep in mind is that most quantum gates will not be &quot;perfect&quot;, even though with right number of &quot;universal quantum gates&quot; you can get &lt;em&gt;arbitrarily close&lt;/em&gt; to building &lt;em&gt;any&lt;/em&gt; quantum gate which performs (in theory) an unitary transformation. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Niel de Beaudrap &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/101/26&quot;&gt;mentions&lt;/a&gt; that there are clever ways to apply classical error correction techniques in ways such that they can correct many of the errors which occur during quantum operations, which is indeed correct, and is exactly what current day quantum error correcting codes do. I'd like to add the following from &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_error_correction&quot; rel=&quot;noreferrer&quot;&gt;Wikipedia&lt;/a&gt;, as it might give some clarity about how quantum error correcting codes deal with the problem described above: &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Classical error correcting codes use a &lt;em&gt;syndrome measurement&lt;/em&gt; to&#xA;  diagnose which error corrupts an encoded state. We then reverse an&#xA;  error by applying a corrective operation based on the &lt;em&gt;syndrome&lt;/em&gt;.&#xA;  Quantum error correction also employs syndrome measurements. We&#xA;  perform a multi-qubit measurement that does not disturb the quantum&#xA;  information in the encoded state but retrieves information about the&#xA;  error. A syndrome measurement can determine whether a qubit has been&#xA;  corrupted, and if so, which one. What is more, the outcome of this&#xA;  operation (the syndrome) tells us not only which physical qubit was&#xA;  affected, but also, in which of several possible ways it was affected.&#xA;  The latter is counter-intuitive at first sight: Since noise is&#xA;  arbitrary, how can the effect of noise be one of only few distinct&#xA;  possibilities? In most codes, the effect is either a bit flip, or a&#xA;  sign (of the phase) flip, or both (corresponding to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Pauli_matrices&quot; rel=&quot;noreferrer&quot;&gt;Pauli matrices&lt;/a&gt;&#xA;  X, Z, and Y). The reason is that the measurement of the syndrome has&#xA;  the projective effect of a quantum measurement. So even if the error&#xA;  due to the noise was arbitrary, it can be expressed as a superposition&#xA;  of basis operations—the error basis (which is here given by the Pauli&#xA;  matrices and the identity). The syndrome measurement &quot;forces&quot; the&#xA;  qubit to &quot;decide&quot; for a certain specific &quot;Pauli error&quot; to &quot;have&#xA;  happened&quot;, and the syndrome tells us which, so that we can let the&#xA;  same Pauli operator act again on the corrupted qubit to revert the&#xA;  effect of the error.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;The syndrome measurement tells us as much as possible about the error&#xA;  that has happened, but nothing at all about the value that is stored&#xA;  in the logical qubit—as otherwise the measurement would destroy any&#xA;  quantum superposition of this logical qubit with other qubits in the&#xA;  quantum computer.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: I haven't given any example of actual quantum error correcting techniques. There are plenty of good textbooks out there which discuss this topic. However, I hope this answer will give the readers a basic idea of why we need error correcting codes in quantum computation.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Recommended Further Readings:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/0904.2557&quot; rel=&quot;noreferrer&quot;&gt;An Introduction to Quantum Error Correction and&#xA;Fault-Tolerant Quantum Computation - Daniel Gottesman&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.52.R2493&quot; rel=&quot;noreferrer&quot;&gt;Scheme for reducing decoherence in quantum computer memory - Peter Shor&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Recommended Video Lecture:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=hV5FTsyKE8A&quot; rel=&quot;noreferrer&quot;&gt;Mini Crash Course: Quantum Error Correction by Ben Reichardt, University of Southern California&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-15T12:51:11.100" LastActivityDate="2018-03-15T12:51:11.100" CommentCount="5" />
  <row Id="101" PostTypeId="2" ParentId="97" CreationDate="2018-03-14T10:22:23.340" Score="8" Body="&lt;p&gt;If the error rate were low enough, you &lt;em&gt;could&lt;/em&gt; run a computation a hundred times and take the most common answer. For instance, this would work if the error rate were low enough that the expected number of errors per computation was something very small &amp;mdash; which means that how well this strategy works would depend on how long and complicated a computation you would like to do.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Once the error rate or the length of your computation become sufficiently high, you can no longer have any confidence that the most likely outcome is that there were zero errors: at a certain point it becomes more likely that you have one, or two, or more errors, than that you have zero. In this case, there is nothing to prevent the majority of the cases from giving you an incorrect answer. What then?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;These issues are not special to quantum computation: they also apply to classical computation &amp;mdash; it just happens that almost all of our technology is at a sufficiently advanced state of maturity that these issues do not concern us in practise; that there may be a greater chance of your computer being struck by a meteorite mid-computation (or it running out of battery power, or you deciding to switch it off) than of there being a hardware error. What is (temporarily) special about quantum computation is that the technology is not yet mature enough for us to be so relaxed about the possibility of error.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In those times when classical computation &lt;em&gt;has&lt;/em&gt; been at a stage when error correction was both practical and necessary, we were able to make use of certain mathematical techniques &amp;mdash; error correction &amp;mdash; which made it possible to suppress the effective error rate, and in principle to make it as low as we liked. The same techniques surprisingly can be used for quantum error correction &amp;mdash; with a little bit of extension, to accommodate the difference between quantum and classical information. At first, before the mid-1990s, it was thought that quantum error correction was impossible because of the continuity of the space of quantum states. But as it turns out, by applying classical error correction techniques in the right way to the different ways a qubit could be measured (usually described as &quot;bit&quot; and &quot;phase&quot;), you can in principle suppress many kinds of noise on quantum systems as well. These techniques are not special to qubits, either: the same idea can be used for quantum systems of any finite dimension (though for models such as adiabatic computation, it may then get in the way of actually performing the computation you wish to perform).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;At the time I'm writing this, individual qubits are so difficult to build and to marshall that people are hoping to get away with doing proof-of-principle computations without any error correction at all. That's fine, but it will limit how long their computations can be until the number of accumulated errors is large enough that the computation stops being meaningful. There are two solutions: to get better at suppressing noise, or to apply error correction. Both are good ideas, but it is possible that error correction is easier to perform in the medium- and long-term than suppressing sources of noise.&lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-03-14T10:27:25.670" LastActivityDate="2018-03-14T10:27:25.670" CommentCount="4" />
  <row Id="104" PostTypeId="2" ParentId="91" CreationDate="2018-03-14T11:01:52.777" Score="12" Body="&lt;p&gt;As already explained by others, a &lt;em&gt;ket&lt;/em&gt; $\left|\psi\right&amp;gt;$ is just a vector. A &lt;em&gt;bra&lt;/em&gt; $\left&amp;lt;\psi\right|$ is the Hermitian conjugate of the vector. You can multiply a vector with a number in the usual way.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now comes the fun part: You can write the scalar product of two vectors $\left|\psi\right&amp;gt;$ and $\left|\phi\right&amp;gt;$ as $\left&amp;lt;\phi\middle|\psi\right&amp;gt;$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can apply an operator to the vector (in finite dimensions this is just a matrix multiplication) $X\left|\psi\right&amp;gt;$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;All in all, the notation is very handy and intuitive. For more information, see the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation&quot; rel=&quot;noreferrer&quot;&gt;Wikipedia article&lt;/a&gt; or a textbook on Quantum Mechanics.&lt;/p&gt;&#xA;" OwnerUserId="18" LastEditorUserId="15" LastEditDate="2018-03-14T13:37:40.833" LastActivityDate="2018-03-14T13:37:40.833" CommentCount="2" />
  <row Id="105" PostTypeId="1" AcceptedAnswerId="110" CreationDate="2018-03-14T14:58:46.433" Score="14" ViewCount="326" Body="&lt;p&gt;Online descriptions of quantum computers often discuss how they must be kept near absolute zero $\left(0~\mathrm{K}~\text{or}~-273.15~{\left. {}^{\circ}\mathrm{C} \right.}\right)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Questions:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Why must quantum computers operate under such extreme temperature conditions?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Is the need for extremely low temperatures the same for all quantum computers, or does it vary by architecture?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;What happens if they overheat?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;Sources : &lt;a href=&quot;https://www.youtube.com/watch?v=7jT5rbE69ho&quot; rel=&quot;noreferrer&quot;&gt;Youtube&lt;/a&gt;, &lt;a href=&quot;https://www.dwavesys.com/tutorials/background-reading-series/introduction-d-wave-quantum-hardware&quot; rel=&quot;noreferrer&quot;&gt;D-Wave&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&#xA;" OwnerUserId="58" LastEditorUserId="253" LastEditDate="2018-03-26T15:44:46.110" LastActivityDate="2018-04-18T06:32:25.713" Title="Why must quantum computers be kept near absolute zero?" Tags="&lt;quantum-computer&gt;&lt;architecture&gt;&lt;experimental-results&gt;" AnswerCount="2" CommentCount="6" FavoriteCount="3" />
  <row Id="106" PostTypeId="5" CreationDate="2018-03-14T15:55:05.567" Score="0" Body="&lt;p&gt;In computer science, the computational complexity, or simply complexity of an algorithm is the amount of resources required for running it. The computational complexity of a problem is the minimum of the complexities of all possible algorithms for this problem (including the unknown algorithms).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quantum complexity theory is a part of computational complexity theory in theoretical computer science. It studies complexity classes defined using quantum computers and quantum information which are computational models based on quantum mechanics. It studies the hardness of problems in relation to these complexity classes, and the relationship between quantum complexity classes and classical (i.e., non-quantum) complexity classes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;References:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Computational_complexity_theory&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://en.wikipedia.org/wiki/Computational_complexity_theory&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_complexity_theory&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://en.wikipedia.org/wiki/Quantum_complexity_theory&lt;/a&gt; &lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-14T19:09:03.000" LastActivityDate="2018-03-14T19:09:03.000" CommentCount="0" />
  <row Id="107" PostTypeId="4" CreationDate="2018-03-14T15:55:05.567" Score="0" Body="For questions related to complexity of quantum algorithms. For questions on the relative perfomance wrt. to classical computers, (also) use the [quantum-speedup] tag." OwnerUserId="26" LastEditorUserId="253" LastEditDate="2018-03-24T22:45:05.337" LastActivityDate="2018-03-24T22:45:05.337" CommentCount="0" />
  <row Id="108" PostTypeId="5" CreationDate="2018-03-14T15:56:14.313" Score="0" Body="&lt;p&gt;Quantum error correction (QEC) is used in quantum computing to protect quantum information from errors due to decoherence and other quantum noise. Quantum error correction is essential if one is to achieve fault-tolerant quantum computation that can deal not only with noise on stored quantum information, but also with faulty quantum gates, faulty quantum preparation, and faulty measurements.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Reference: &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_error_correction&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://en.wikipedia.org/wiki/Quantum_error_correction&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-14T19:08:20.123" LastActivityDate="2018-03-14T19:08:20.123" CommentCount="0" />
  <row Id="109" PostTypeId="4" CreationDate="2018-03-14T15:56:14.313" Score="0" Body="For questions related to quantum error correction" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-14T19:08:14.493" LastActivityDate="2018-03-14T19:08:14.493" CommentCount="0" />
  <row Id="110" PostTypeId="2" ParentId="105" CreationDate="2018-03-14T17:03:27.697" Score="15" Body="&lt;p&gt;Well, first, not all systems must be kept near absolute zero. It depends on the realization of your quantum computer. For example, optical quantum computers do not need to be kept near absolute zero, but superconducting quantum computers do. So, that answers your second question.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To answer your first question, superconducting quantum computers (for example) must be kept at low temperatures so that the thermal environment cannot induce fluctuations in the qubits' energies. Such fluctuations would be noise/errors in the qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(See Blue's question &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/117/why-do-optical-quantum-computers-not-have-to-be-kept-near-absolute-zero-while-su&quot;&gt;Why do optical quantum computers not have to be kept near absolute zero while superconducting quantum computers do?&lt;/a&gt; and Daniel Sank's answer for some follow up information.)&lt;/p&gt;&#xA;" OwnerUserId="91" LastEditorUserId="91" LastEditDate="2018-03-15T06:06:13.020" LastActivityDate="2018-03-15T06:06:13.020" CommentCount="8" />
  <row Id="111" PostTypeId="2" ParentId="53" CreationDate="2018-03-14T19:50:00.123" Score="5" Body="&lt;p&gt;It looks like you're asking about this part of the paper:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Therefore, a quantum computation is hidden as long as these measurements are successfully hidden. In order to achieve this, the BQC protocol exploits special resources called &lt;em&gt;blind cluster states&lt;/em&gt; that must be chosen carefully to be a generic structure that reveals nothing about the underlying computation (see Figure 1).&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;-&lt;a href=&quot;https://arxiv.org/pdf/1110.1381.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;Experimental Demonstration of Blind Quantum Computing&quot;&lt;/a&gt; (2011)&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;That last part, about how they want a &lt;strong&gt;&quot;&lt;em&gt;generic structure that reveals nothing about the underlying computation&lt;/em&gt;&quot;&lt;/strong&gt; might make a reader wonder about how a computer's structure could leak information about its computations.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As a simple example of structure leaking information about a cypto scheme, suppose that Bob asks Sally question to which we assume that Sally'll respond &lt;code&gt;yes&lt;/code&gt; or &lt;code&gt;no&lt;/code&gt;.  Sally directly encrypts her response using their shared &lt;a href=&quot;https://en.wikipedia.org/wiki/One-time_pad&quot; rel=&quot;nofollow noreferrer&quot;&gt;one-time pad (OTP)&lt;/a&gt;, resulting in the ciphertext &lt;code&gt;rk4&lt;/code&gt;.  Despite the OTP scheme having perfect secrecy in general, it's clear that Sally responded &lt;code&gt;yes&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In this case, the computer was structured to leak information about the length of a message given that message, which was especially disastrous in this contrived example.  In general, structure can leak information about the computation.  Avoiding such leaks would be necessary for a blind-computation server like the one the paper intends to discuss.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Generally speaking, attacks that operate like this are called &lt;a href=&quot;https://en.wikipedia.org/wiki/Side-channel_attack&quot; rel=&quot;nofollow noreferrer&quot;&gt;side-channel attacks&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the case of this paper (disclaiming that I just skimmed it quickly), it looks like they're basically talking about creating a generic computational structure that doesn't leak information through its structural traits.  For example, if the structure behaved differently in any way based on a secret aspect of the message, then it may leak secret information to the server when the server observes its own computational behavior.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The paper appears to be trying to point out that the computational unit needs to be designed to avoid such information leaks.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Later in the paper, they discuss stuff about &lt;a href=&quot;https://en.wikipedia.org/wiki/Blinding_(cryptography)&quot; rel=&quot;nofollow noreferrer&quot;&gt;blinding&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;In &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptography&quot; rel=&quot;nofollow noreferrer&quot;&gt;cryptography&lt;/a&gt;, &lt;strong&gt;blinding&lt;/strong&gt; is a technique by which an agent can provide a service to (i.e., compute a &lt;a href=&quot;https://en.wikipedia.org/wiki/Function_(mathematics)&quot; rel=&quot;nofollow noreferrer&quot;&gt;function&lt;/a&gt; for) a client in an encoded form without knowing either the real input or the real output. Blinding techniques also have applications to preventing &lt;a href=&quot;https://en.wikipedia.org/wiki/Side-channel_attack&quot; rel=&quot;nofollow noreferrer&quot;&gt;side-channel attacks&lt;/a&gt; on encryption devices.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;-&lt;a href=&quot;https://en.wikipedia.org/wiki/Blinding_(cryptography)&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;Blinding (cryptography)&quot;&lt;/a&gt;, Wikipedia&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;And, really, blinding's what this paper's all about: figuring out a way to have a server do work for clients without the clients revealing their secrets to the server.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One way to enable blind computation is for the client to use &lt;a href=&quot;https://en.wikipedia.org/wiki/Homomorphic_encryption&quot; rel=&quot;nofollow noreferrer&quot;&gt;homomorphic encryption&lt;/a&gt; on its job request before sending it to the server:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;Homomorphic encryption&lt;/strong&gt; is a form of &lt;a href=&quot;https://en.wikipedia.org/wiki/Encryption&quot; rel=&quot;nofollow noreferrer&quot;&gt;encryption&lt;/a&gt; that allows &lt;a href=&quot;https://en.wikipedia.org/wiki/Computation&quot; rel=&quot;nofollow noreferrer&quot;&gt;computation&lt;/a&gt; on &lt;a href=&quot;https://en.wikipedia.org/wiki/Ciphertext&quot; rel=&quot;nofollow noreferrer&quot;&gt;ciphertexts&lt;/a&gt;, generating an encrypted result which, when decrypted, matches the result of the operations as if they had been performed on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Plaintext&quot; rel=&quot;nofollow noreferrer&quot;&gt;plaintext&lt;/a&gt;. The purpose of homomorphic encryption is to allow computation on encrypted data.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;-&lt;a href=&quot;https://en.wikipedia.org/wiki/Homomorphic_encryption&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;Homomorphic encryption&quot;&lt;/a&gt;, Wikipedia&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="15" LastEditorUserId="15" LastEditDate="2018-03-16T13:42:50.563" LastActivityDate="2018-03-16T13:42:50.563" CommentCount="4" />
  <row Id="112" PostTypeId="1" AcceptedAnswerId="116" CreationDate="2018-03-14T19:59:21.727" Score="11" ViewCount="921" Body="&lt;p&gt;As I understand it, the main difference between quantum and non-quantum computers is that quantum computers use qubits while non-quantum computers use (classical) bits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What is the difference between qubits and classical bits?&lt;/p&gt;&#xA;" OwnerUserId="11" LastEditorUserId="26" LastEditDate="2018-03-16T15:33:41.427" LastActivityDate="2018-08-31T15:59:55.370" Title="What is the difference between a qubit and classical bit?" Tags="&lt;qubit&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="5" />
  <row Id="113" PostTypeId="5" CreationDate="2018-03-14T20:14:01.497" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-14T20:14:01.497" LastActivityDate="2018-03-14T20:14:01.497" CommentCount="0" />
  <row Id="114" PostTypeId="4" CreationDate="2018-03-14T20:14:01.497" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-14T20:14:01.497" LastActivityDate="2018-03-14T20:14:01.497" CommentCount="0" />
  <row Id="115" PostTypeId="1" AcceptedAnswerId="1502" CreationDate="2018-03-14T20:48:23.707" Score="16" ViewCount="162" Body="&lt;p&gt;The crucial role of &lt;a href=&quot;https://en.wikipedia.org/wiki/Random-access_memory&quot; rel=&quot;noreferrer&quot;&gt;random access memories&lt;/a&gt; (RAMs) in the context of classical computation makes it natural to wonder how one can generalise such a concept to the quantum domain.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Arguably the most notable (and first?) work proposing an efficient QRAM architecture is &lt;a href=&quot;https://arxiv.org/abs/0708.1879&quot; rel=&quot;noreferrer&quot;&gt;Giovannetti et al. 2007&lt;/a&gt;. &#xA;In this work it was shown that their &quot;bucket brigate&quot; approach allows access to the content of the memory with $\mathcal O(\log N)$ operations, where $N$ is the number of memory slots. This is an exponential improvement with respect to alternative approaches, which require $\mathcal O(N^{\alpha})$ operations.&#xA;Implementing this architecture is however highly nontrivial from an experimental point of view.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is the above the only known way to implement a QRAM? Or have there been other theoretical works in this direction? If so, how do they compare (pros and cons) with the Giovannetti et al. proposal?&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="26" LastEditDate="2018-03-16T15:34:41.867" LastActivityDate="2018-03-30T09:42:57.463" Title="What protocols have been proposed to implement quantum RAMs?" Tags="&lt;quantum-memory&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="2" />
  <row Id="116" PostTypeId="2" ParentId="112" CreationDate="2018-03-14T21:25:56.837" Score="10" Body="&lt;p&gt;A bit is a binary unit of information used in classical computation. It can take two possible values, typically taken to be $0$ or $1$. Bits can be implemented with devices or physical systems that can be in two possible states. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;To compare and contrast bits with qubits, let's introduce a vector notation for bits as follows: a bit is represented by a column vector of two elements $(\alpha,\beta)^T$, where $\alpha$ stands for $0$ and $\beta$ for $1$. Now the bit $0$ is represented by the vector $(1,0)^T$ and the bit $1$ by $(0,1)^T$. Just like before, there are only two possible values.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;While this kind of representation is redundant for classical bits, it is now easy to introduce qubits: a qubit is simply any $(\alpha,\beta)^T$ where the complex number elements satisfy the normalization condition $|\alpha|^2+|\beta|^2=1$. The normalization condition is necessary to interpret $|\alpha|^2$ and $|\beta|^2$ as probabilities for measurement outcomes, as will be seen. Some call qubit the unit of quantum information. Qubits can be implemented as the (pure) states of quantum devices or quantum systems that can be in two possible states, that will form the so called computational basis, and additionally in a coherent superposition of these. Here the quantumness is necessary to have qubits other than the classical $(1,0)^T$ and $(0,1)^T$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The usual operations that are carried out on qubits during a quantum computation are quantum gates and measurements. A (single qubit) quantum gate takes as input a qubit and gives as output a qubit that is a linear transformation of the input qubit. When using the above vector notation for qubits, gates should then be represented by matrices that preserve the normalization condition; such matrices are called unitary matrices. Classical gates may be represented by matrices that keep bits as bits, but notice that matrices representing quantum gates do not in general satisfy this requirement.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A measurement on a bit is understood to be a classical one. By this I mean that an &lt;em&gt;a priori&lt;/em&gt; unknown value of bit can in principle be correctly found out with certainty. This is not the case for qubits: measuring a generic qubit $(\alpha,\beta)^T$ in the computational basis $[ (1,0)^T,(0,1)^T]$ will result in $(1,0)^T$ with probability $|\alpha|^2$ and in $(0,1)^T$ with probability $|\beta|^2$. In other words, while qubits can be in states other than computational basis states before measurement, measuring can still have only two possible outcomes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1541/144&quot;&gt;There is not much one can do with a single bit or qubit&lt;/a&gt;. The full computational power of either comes from using many, which leads to the final difference between them that will be covered here: multiple qubits can be entangled. Informally speaking, entanglement is a form of correlation much stronger than classical systems can have. Together, superposition and entanglement allow one to design algorithms realized with qubits that cannot be done with bits. Of greatest interest are algorithms that allow the completion of a task with reduced computational complexity when compared to best known classical algorithms.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Before concluding, it should be mentioned that a &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1/can-a-turing-machine-simulate-a-quantum-computer&quot;&gt;qubit can be simulated with bits&lt;/a&gt; (and &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/23/can-a-quantum-computer-simulate-a-normal-computer&quot;&gt;vice versa&lt;/a&gt;), but the number of bits required grows rapidly with the number of qubits. Consequently, without reliable quantum computers quantum algorithms are of theoretical interest only.&lt;/p&gt;&#xA;" OwnerUserId="144" LastEditorUserId="144" LastEditDate="2018-04-01T10:11:08.240" LastActivityDate="2018-04-01T10:11:08.240" CommentCount="0" />
  <row Id="117" PostTypeId="1" AcceptedAnswerId="119" CreationDate="2018-03-14T21:54:25.037" Score="18" ViewCount="847" Body="&lt;p&gt;&lt;strong&gt;&lt;em&gt;This is a follow-up question to &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/110/26&quot;&gt;@heather's answer&lt;/a&gt; to the question : &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/105/why-must-quantum-computers-be-kept-near-absolute-zero&quot;&gt;Why must quantum computers be kept near absolute zero?&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;What I know:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Superconducting quantum computing&lt;/strong&gt;: It is an implementation of a quantum computer in a superconducting electronic circuit. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Optical quantum computing&lt;/strong&gt;: It uses photons as information carriers, and linear optical elements to process quantum information, and uses photon detectors and quantum memories to detect and store quantum information.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Superconducting_quantum_computing&quot; rel=&quot;noreferrer&quot;&gt;Next, this is what Wikipedia goes on to say about superconducting quantum computing&lt;/a&gt;: &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Classical computation models rely on physical implementations&#xA;  consistent with the laws of classical mechanics. It is known, however,&#xA;  that the classical description is only accurate for specific cases,&#xA;  while the more general description of nature is given by the quantum&#xA;  mechanics. Quantum computation studies the application of quantum&#xA;  phenomena, that are beyond the scope of classical approximation, for&#xA;  information processing and communication. Various models of quantum&#xA;  computation exist, however the most popular models incorporate the&#xA;  concepts of qubits and quantum gates. A qubit is a generalization of a&#xA;  bit - a system with two possible states, that can be in a quantum&#xA;  superposition of both. A quantum gate is a generalization of a logic&#xA;  gate: it describes the transformation that one or more qubits will&#xA;  experience after the gate is applied on them, given their initial&#xA;  state. The physical implementation of qubits and gates is difficult,&#xA;  for the same reasons that quantum phenomena are hard to observe in&#xA;  everyday life. &lt;strong&gt;One approach is to implement the quantum computers in&#xA;  superconductors, where the quantum effects become macroscopic, though&#xA;  at a price of extremely low operation temperatures.&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;This does make some sense! However, I was looking for why optical quantum computers don't need &quot;extremely low temperatures&quot; unlike superconducting quantum computers. Don't they suffer from the same problem i.e. aren't the quantum phenomena in optical quantum computers &lt;em&gt;difficult to observe&lt;/em&gt; just as for superconducting quantum computers? Are the quantum effects already macroscopic at room temperatures, in such computers? Why so?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I was going through the &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_optical_quantum_computing&quot; rel=&quot;noreferrer&quot;&gt;description of Linear optical quantum computing on Wikipedia&lt;/a&gt;, but found no reference to &quot;temperature&quot; as such. &lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-07-05T09:39:41.033" Title="Why do optical quantum computers not have to be kept near absolute zero while superconducting quantum computers do?" Tags="&lt;quantum-computer&gt;&lt;optical-quantum-computing&gt;&lt;architecture&gt;&lt;superconducting-quantum-computing&gt;" AnswerCount="3" CommentCount="0" FavoriteCount="4" />
  <row Id="118" PostTypeId="2" ParentId="117" CreationDate="2018-03-14T22:11:22.460" Score="7" Body="&lt;p&gt;Because light, at the right frequencies, interacts weakly with matter.&#xA;In the quantum regime, this translates to single photons being largely free of the noise and decoherence that is the main obstacle with other QC architectures.&#xA;The surrounding temperature doesn't disturb the quantum state of a photon as much as it does when the quantum information is carried by matter (atoms, ions, electrons, superconducting circuits etc.).&#xA;For example, reliable transmission of photonic qubits (more precisely, a QKD protocol) between China and Austria, using a low-orbit satellite as link, was recently demonstrated (see e.g. &lt;a href=&quot;https://physics.aps.org/articles/v11/7&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Unfortunately, light also interacts &lt;em&gt;extremely&lt;/em&gt; weakly (as in, it basically doesn't) with other light.&#xA;Different photons not interacting with each other is what makes optical quantum computation somewhat tricky.&#xA;For example, basic quantum computation components like two-qubit gates, when the qubits are carried by different photons, require some form of nonlinearity to be implemented&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-03-15T11:01:15.673" LastActivityDate="2018-03-15T11:01:15.673" CommentCount="0" />
  <row Id="119" PostTypeId="2" ParentId="117" CreationDate="2018-03-14T22:42:21.837" Score="23" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;I was looking for why optical quantum computers don't need &quot;extremely low temperatures&quot; unlike superconducting quantum computers.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Superconducting qubits usually work in the frequency range 4 GHz to 10 GHz.&#xA;The energy associated with a transition frequency $f_{10}$ in quantum mechanics is $E_{10} = h f_{10}$ where $h$ is Planck's constant.&#xA;Comparing the qubit transition energy to the thermal energy $E_\text{thermal} = k_b T$ (where $k_b$ is Boltzmann's constant), we see that the qubit energy is above the thermal energy when&#xA;$$f_{10} &amp;gt; k_b T / h \, .$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Looking up Boltzmann's and Planck's constants, we find&#xA;$$h/k_b = 0.048 \, \text{K / GHz} \, .$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Therefore, we can write&#xA;$$f_{10} &amp;gt; 1 \, \text{GHz} \, \,\frac{T}{0.048 \, \text{K}}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, for the highest frequency superconducting qubit at 10 GHz, we need $T &amp;lt; 0.48 \, \text{K}$ in order for there to be a low probability that the qubit is randomly excited or de-excited due to thermal interactions.&#xA;This is why superconducting qubits are usually operated in dilution refrigerators at ~15 milliKelvin.&#xA;Of course, we also need the temperature to be low enough to get the metals superconducting, but for aluminum that happens at 1 K so actually the constraint we already talked about is more important.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;On the other hand, suppose the two states of the optical qubit $\left \lvert 0 \right \rangle$ and $\left \lvert 1 \right \rangle$ the presence and absence of an optical photon.&#xA;An optical photon has a frequency of around $10^{14}$ Hz, which corresponds to a temperature of 14,309 Kelvin.&#xA;Therefore, there's an extremely low probability of the thermal environment changing the qubit state by creating or removing a photon.&#xA;This is why optical light is sort of intrinsically quantum mechanical in nature.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Don't they suffer from the same problem i.e. aren't the quantum phenomena in optical quantum computers difficult to observe just as for superconducting quantum computers?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Well, the difficulties between superconducting quantum computers and optical quantum computers are &lt;em&gt;different&lt;/em&gt;.&#xA;Optical photons essentially don't interact with each other.&#xA;To get an effective interaction between two photons, you have to either put them through a nonlinear crystal, or do some kind of photodetection measurement.&#xA;The challenge with nonlinear crystals is that they very inefficient; only a very small fraction of photons that go in actually undero the nonlinear process that causes interaction.&#xA;The challenge with photodetection is that it's hard to build a photodetector that has high detection efficiency and low dark counts$^{[a]}$.&#xA;In fact, the best photo-detectors actually need to be operated in cryogenic environments anyway, so some optical quantum computing architectures need cryogenic refrigeration despite the fact that the qubits themselves have very high frequency.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;P.S. This answer could be expanded quite a bit. If someone has a particular aspect they'd like to know more about, please leave a comment.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$[a]$: Dark counts means the times a photodetector thinks it saw a photon even though there really wasn't one. In other words, is't the rate that the detector counts photons when its in the dark.&lt;/p&gt;&#xA;" OwnerUserId="32" LastEditorUserId="32" LastEditDate="2018-03-14T22:55:55.947" LastActivityDate="2018-03-14T22:55:55.947" CommentCount="7" />
  <row Id="121" PostTypeId="1" AcceptedAnswerId="123" CreationDate="2018-03-15T00:02:12.367" Score="15" ViewCount="304" Body="&lt;p&gt;This is a question I was inspired to ask based on &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/74/what-are-the-methods-of-quantum-computation&quot;&gt;this question&lt;/a&gt;, which notes that quantum annealing is an entirely different model for computation than the usual circuit model. I've heard this before, and it's my understanding that the gate-model does not apply to quantum-annealing, but I've never quite understood why that is, or how to parse the computations that an annealer can do. As I understand from several talks (some by D-wave themselves!) the fact that the annealers are confined to a specific Hamiltonian plays into it. &lt;/p&gt;&#xA;" OwnerUserId="236" LastActivityDate="2018-03-15T13:43:28.800" Title="Why can't quantum annealing be described by a gate model?" Tags="&lt;d-wave&gt;&lt;quantum-annealing&gt;&lt;circuit-model&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="122" PostTypeId="2" ParentId="121" CreationDate="2018-03-15T00:18:52.247" Score="12" Body="&lt;p&gt;Annealing's more of an analog tactic.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The gist is that you have some weird function that you want to optimize.  So, you bounce around it.  At first, the &quot;&lt;em&gt;temperature&lt;/em&gt;&quot; is very high, such that the selected point can bounce around a lot.  Then as the algorithm &quot;&lt;em&gt;cools&lt;/em&gt;&quot;, the temperature goes down, and the bouncing becomes less aggressive.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Ultimately, it settles down to a local optima which, ideally, is favorably like the global optima.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here's an animation for &lt;a href=&quot;https://en.wikipedia.org/wiki/Simulated_annealing&quot; rel=&quot;noreferrer&quot;&gt;simulated annealing&lt;/a&gt; (non-quantum):&#xA;&lt;a href=&quot;https://en.wikipedia.org/wiki/File:Hill_Climbing_with_Simulated_Annealing.gif&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/d/d5/Hill_Climbing_with_Simulated_Annealing.gif&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But, it's pretty much the same concept for &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_annealing&quot; rel=&quot;noreferrer&quot;&gt;quantum annealing&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/File:Quant-annl.jpg&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/1/12/Quant-annl.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;By contrast, gate-logic is far more digital than analog.  It's concerned with qubits and logical operations rather than merely finding a result after chaotic bouncing-around.&lt;/p&gt;&#xA;" OwnerUserId="15" LastEditorUserId="15" LastEditDate="2018-03-15T00:24:34.193" LastActivityDate="2018-03-15T00:24:34.193" CommentCount="6" />
  <row Id="123" PostTypeId="2" ParentId="121" CreationDate="2018-03-15T01:10:23.243" Score="15" Body="&lt;p&gt;A Quantum Annealer, such as a D-Wave machine is a physical representation of the Ising model and as such has a 'problem' Hamiltonian of the form $$H_P = \sum_{J=1}^nh_j\sigma_j^z + \sum_{i, j}J_{ij}\sigma_i^z\sigma_j^z.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Essentially, the problem to be solved is mapped to the above Hamiltonian. The system starts with the Hamiltonian $H_I = \sum_{J=1}^nh'_j\sigma_j^x$ and the annealing parameter, $s$ is used to map the initial Hamiltonian $H_I$ to the problem Hamiltonian $H_P$ using $H\left(s\right) = \left(1-s\right)H_I + sH_P$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As this is an anneal, the process is done slowly enough to stay near the ground state of the system while the Hamiltonian is varied to that of the problem, using tunnelling to stay near the ground state as described in &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/122/23&quot;&gt;Nat's answer&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, why can't this be used to describe a gate model QC? The above is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Quadratic_unconstrained_binary_optimization&quot; rel=&quot;noreferrer&quot;&gt;Quadratic unconstrained binary optimization (QUBO)&lt;/a&gt; problem, which is NP-hard... Indeed, &lt;a href=&quot;https://www.frontiersin.org/articles/10.3389/fphy.2014.00005/full&quot; rel=&quot;noreferrer&quot;&gt;here's an article mapping a number of NP problems to the Ising model&lt;/a&gt;. Any problem in NP can be mapped to any NP-hard problem in polynomial time and integer factorisation is indeed an NP problem.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Well, the temperature is non-zero, so it's not going to be in the ground state throughout the anneal and as a result, the solution is still only an approximate one. Or, in different terms, the probability of failure is greater than a half (it's nowhere near having a decent probability of success compared with what a universal QC considers 'decent' - judging from graphs I've seen, the probability of success for the current machine is around $0.2\%$ and this will only get worse with increasing size), and the anneal algorithm is not bounded error. At all. As such, there's no way of knowing whether or not you've got the correct solution with something such as integer factorisation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What it (in principle) does is get very close to the exact result, very quickly, but this doesn't help for anything where the exact result is required as going from 'nearly correct' to 'correct' is still an extremely difficult (i.e. presumably still NP in general, when the original problem is in NP) problem in this case, as the parameters that are/give a 'nearly correct' solution aren't necessarily going to be distributed anywhere near the parameters that are/give the correct solution.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Edit for clarification: what this means is that a quantum annealer (QA) still takes exponential time (albeit potentially a faster exponential time) to solve NP problems such as integer factorisation, where a universal QC gives an exponential speed up and can solve the same problem in poly time. This is what implies a QA cannot simulate a universal QC in poly time (otherwise it could solve problems in poly time that it can't). As pointed out in the comments, this is &lt;em&gt;not&lt;/em&gt; the same as saying that a QA cannot give the same speedup in other problems, such as database search.&lt;/p&gt;&#xA;" OwnerUserId="23" LastEditorUserId="23" LastEditDate="2018-03-15T13:43:28.800" LastActivityDate="2018-03-15T13:43:28.800" CommentCount="6" />
  <row Id="124" PostTypeId="2" ParentId="91" CreationDate="2018-03-15T02:20:46.153" Score="9" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;This leads me to conclude that there is some difference/reason why bra-ket is especially handy for denoting quantum algorithms.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There's already an accepted answer and an answer that explains 'ket', 'bra' and the scalar product notation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I'll try add a bit more to the highlighted entry. What makes it a useful/handy notation?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The first thing that bra-ket notation is really used a lot for is to denote very simply the eigenvectors of a (usually Hermitian) operator associated with an eigenvalue. Suppose we have an eigenvalue equation $A(v)=\lambda v$, this can be denoted as $A\left|\lambda\right\rangle=\lambda \left|\lambda\right\rangle$, and probably some extra label $k$ if there is some degeneracy $A\left|\lambda,k\right\rangle=\lambda \left|\lambda,k\right\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You see this employed all over quantum mechanics, momentum eigenstates tend to be labelled as $\left|\vec{k}\right\rangle$ or $\left|\vec{p}\right\rangle$ depending on units, or with multiple particle states $\left|\vec{p}_1,\vec{p}_2,\vec{p}_3\ldots\right\rangle$; occupation number representation for bose and fermi system many body systems $\left|n_1,n_2,\ldots\right\rangle$; a spin half particle taking the eigenstates usually of the $S_z$ operator, written sometimes as $\left|+\right\rangle$ and $\left|-\right\rangle$ or $\left|\uparrow\,\right\rangle$ and $\left|\downarrow\,\right\rangle$, etc as shorthand for $\left|\pm \hbar/2\right\rangle$; spherical harmonics as eigenfunctions of the $L^2$ and $L_z$ functions are conveniently written as $\left|l,m\right\rangle$ with $l=0,1,2,\ldots$ and $m=-l,-l+1,\ldots,l-1,l.$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So convenience of notation is one thing, but there's also a kind of 'lego' feeling to algebraic manipulations with dirac notation, take for instance the $S_x$ spin half operator in dirac notation as &#xA;$S_x=\frac{\hbar}{2}(\left|\uparrow\right\rangle\left\langle\downarrow\right|+\left|\downarrow\right\rangle\left\langle\uparrow\right|)$, acting on a state like $\left|\uparrow\right\rangle$ one simply does&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$S_x\left|\uparrow\right\rangle=\frac{\hbar}{2}\left(\left|\uparrow\rangle\langle\downarrow\right|+\left|\downarrow\rangle\langle\uparrow\right|\right)\left|\uparrow\right\rangle=\frac{\hbar}{2}\left|\uparrow\rangle\langle\downarrow\mid\uparrow\right\rangle+\frac{\hbar}{2}\left|\downarrow\rangle\langle\uparrow\mid\uparrow\right\rangle=\frac{\hbar}{2}\left|\downarrow\right\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;since $\left\langle\uparrow\mid\uparrow\right\rangle=1$ and $\left\langle\downarrow\mid\uparrow\right\rangle=0$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;What makes it handy for quantum algorithms?&lt;/em&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Say we have a suitable two level system for a qubit; this forms a two dimensional complex vector space $V$ say whose basis is denoted as $\left|0\right\rangle$ and $\left|1\right\rangle$. When we consider say $n$ qubits of this form, the states of the system live in a bigger space the tensor product space, $V^{\otimes n}$. Dirac notation can be rather handy here, the basis states will be labelled by strings of ones and zeros and one usually denotes a state e.g. $\left|1\right\rangle\otimes\left|0\right\rangle\otimes\left|0\right\rangle\otimes\left|1\right\rangle\equiv\left|1001\right\rangle$, and say we have a bit flip operator $X_i$ which interchanges $1\leftrightarrow 0$ on the $i$'th bit, this can act rather simply on the above strings e.g. $X_3\left|1001\right\rangle=\left|1011\right\rangle$, and taking a sum of operators or acting on a superposition of states works just as simply.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Slight caution:&lt;/em&gt; a state written as $\left|a,b\right\rangle$ doesn't always mean $\left|a\right\rangle\otimes\left|b\right\rangle$, for instance when you have two identical fermions with wave functions say $\phi_{k_1}(\vec{r}_1)$ and $\phi_{k_2}(\vec{r}_2)$, with labels indexing some basis set, then one might write the slater determinant state of the fermions $$\frac{1}{\sqrt{2}}\left(\phi_{k_1}(\vec{r}_1)\phi_{k_2}(\vec{r}_2)-\phi_{k_1}(\vec{r}_2)\phi_{k_2}(\vec{r}_1)\right)$$ in a shorthand as $\left|\phi_{k_1},\phi_{k_2}\right\rangle$ or even $\left|k_1,k_2\right\rangle\neq \left|k_1\right\rangle\otimes \left|k_2\right\rangle$.&lt;/p&gt;&#xA;" OwnerUserId="197" LastEditorUserId="23" LastEditDate="2018-03-15T11:09:31.183" LastActivityDate="2018-03-15T11:09:31.183" CommentCount="0" />
  <row Id="125" PostTypeId="2" ParentId="91" CreationDate="2018-03-15T02:21:16.520" Score="5" Body="&lt;p&gt;The &lt;strong&gt;ket&lt;/strong&gt; notation $|\psi\rangle$ means a &lt;strong&gt;vector&lt;/strong&gt; in whatever vector space we're working in, such as the space of all complex linear combinations of the eight 3-bit strings $000$, $001$, $010$, &lt;em&gt;etc.&lt;/em&gt;, as we might use to represent the states of a quantum computer.  Unadorned $\psi$ means exactly the same thing—the $|\psi\rangle$ ket notation is useful partly to emphasize that, for example, $|010\rangle$ is an element of the vector space of interest, and partly for its cuteness in combination with the &lt;em&gt;bra&lt;/em&gt; notation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &lt;strong&gt;bra&lt;/strong&gt; notation $\langle\psi|$ means the &lt;strong&gt;dual vector&lt;/strong&gt; or &lt;strong&gt;covector&lt;/strong&gt;—a &lt;strong&gt;linear functional&lt;/strong&gt;, or linear map from vectors to scalars, whose value at a vector $|\phi\rangle$ is the &lt;strong&gt;inner product&lt;/strong&gt; of $\psi$ with $\phi$, cutely written $\langle\psi|\phi\rangle$.  Here we assume the existence of an inner product, which is not a given in arbitrary vector spaces, but in quantum physics we usually work in &lt;strong&gt;Hilbert spaces&lt;/strong&gt; which by definition have an inner product.  The dual of a vector is sometimes also called its &lt;strong&gt;(Hermitian) transpose&lt;/strong&gt;, because in matrix representation, a vector corresponds to a column and a covector corresponds to a row, and when you multiply $\mathrm{row} \times \mathrm{column}$ you get a scalar.  (The Hermitian part means in addition to transposing the matrix, we take the complex conjugate of its entries—which is really just further transposing the matrix representation $\scriptstyle\begin{bmatrix}a&amp;amp;b\\-b&amp;amp;a\end{bmatrix}$ of the complex number $a + b i$.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When written the other way, $|\psi\rangle\langle\phi|$, you get the &lt;strong&gt;outer product&lt;/strong&gt; of $\psi$ with $\phi$, defined to be the linear transformation of the vector space to itself given by $|\theta\rangle \mapsto (\langle\phi|\theta\rangle) |\psi\rangle$.  That is, given a vector $\theta$, it scales the vector $\psi$ by the scalar given by the inner product $\langle\phi|\theta\rangle$.  Since the operations in question are associative, we can remove the parentheses and unambiguously write $$(|\psi\rangle\langle\phi|)|\theta\rangle = |\psi\rangle\langle\phi|\theta\rangle = \langle\phi|\theta\rangle|\psi\rangle = (\langle\phi|\theta\rangle)|\psi\rangle.$$  The operations involved are &lt;em&gt;not&lt;/em&gt; commutative in general, however: reversing the order yields the complex conjugate$\langle\psi|\phi\rangle = \langle\phi|\psi\rangle^*$, replacing $a + b i$ by $a - b i$.  There may be other transformations of the spaces involved thrown in the mix too, like $\langle\psi|A|\phi\rangle$, which can be read equivalently as the precomposition of the linear functional $\langle\psi|$ by the linear transformation $A$, applied to the vector $|\phi\rangle$, or as the evaluation of the linear functional $\langle\psi|$ at the vector obtained by transforming $|\phi\rangle$ by the linear transformation $A$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The notation is used mainly in quantum physics; mathematicians tend to just write $\psi$ where physicists might write $|\psi\rangle$; $\psi^*$ for the covector $\langle\psi|$; either $\langle\psi,\phi\rangle$ or $\psi^*\phi$ for the inner product; and $\psi^*A\phi$ for what physicists would notate by $\langle\psi|A|\phi\rangle$.&lt;/p&gt;&#xA;" OwnerUserId="238" LastActivityDate="2018-03-15T02:21:16.520" CommentCount="0" />
  <row Id="126" PostTypeId="1" CreationDate="2018-03-15T06:17:50.517" Score="17" ViewCount="102" Body="&lt;p&gt;My understanding is that there seems to be some confidence that quantum annealing will provide a speedup for problems like the traveling salesman, due to the efficiency provided by, ex, quantum tunneling. Do we know, however, around how much of a speedup is provided?&lt;/p&gt;&#xA;" OwnerUserId="91" LastEditorUserId="26" LastEditDate="2018-03-15T14:02:45.297" LastActivityDate="2018-03-15T14:02:45.297" Title="Level of advantage provided by annealing for traveling salesman" Tags="&lt;quantum-annealing&gt;&lt;quantum-speedup&gt;&lt;quantum-algorithms&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="127" PostTypeId="5" CreationDate="2018-03-15T07:35:18.557" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-15T07:35:18.557" LastActivityDate="2018-03-15T07:35:18.557" CommentCount="0" />
  <row Id="128" PostTypeId="4" CreationDate="2018-03-15T07:35:18.557" Score="0" Body="For questions related to building of quantum computers and discussion of the hardware aspects" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-15T13:24:31.810" LastActivityDate="2018-03-15T13:24:31.810" CommentCount="0" />
  <row Id="129" PostTypeId="2" ParentId="126" CreationDate="2018-03-15T10:23:16.513" Score="15" Body="&lt;p&gt;First, let me note that quantum annealing, or more precisely the adiabatic quantum computation model is &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0405098&quot; rel=&quot;noreferrer&quot;&gt;polynomially equivalent to the conventional gate-based quantum computation model&lt;/a&gt;. Second, the general &lt;a href=&quot;https://en.wikipedia.org/wiki/Travelling_salesman_problem&quot; rel=&quot;noreferrer&quot;&gt;traveling salesman problem is NP complete&lt;/a&gt;. Third, it is generally believed that the with gate-based quantum computation one &lt;a href=&quot;http://www.cs.virginia.edu/~robins/The_Limits_of_Quantum_Computers.pdf&quot; rel=&quot;noreferrer&quot;&gt;cannot solve in polinomial time NP complete problems&lt;/a&gt;.&#xA;All this means that it is regarded highly unlikely that with quantum annealing one could solve in polynomial time the general traveling salesman problem. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Despite that it is believed that the general problem can be only solved in exponential time also with quantum annealing, there could still be some speed up, for instance, a polynomial speed-up. Not too much is known about this for the general case. However, there is a very nice recent work that shows that &lt;a href=&quot;https://arxiv.org/abs/1612.06203&quot; rel=&quot;noreferrer&quot;&gt;there are bounded-error quantum algorithms which provide a quadratic quantum speedup&lt;/a&gt; when the degree of each vertex (in the travailing salesman problem) is at most 3.&lt;/p&gt;&#xA;" OwnerUserId="86" LastEditorUserId="86" LastEditDate="2018-03-15T10:44:15.777" LastActivityDate="2018-03-15T10:44:15.777" CommentCount="1" />
  <row Id="130" PostTypeId="2" ParentId="64" CreationDate="2018-03-15T10:49:05.593" Score="2" Body="&lt;p&gt;The website where you could access this 11-qubit quantum computer via a cloud service is not public yet. When it becomes public, the, of course, it will be posted here.&lt;/p&gt;&#xA;" OwnerUserId="86" LastEditorUserId="86" LastEditDate="2018-03-15T10:55:22.270" LastActivityDate="2018-03-15T10:55:22.270" CommentCount="1" />
  <row Id="131" PostTypeId="1" AcceptedAnswerId="132" CreationDate="2018-03-15T10:58:34.123" Score="13" ViewCount="151" Body="&lt;p&gt;Quantum gates are said to be unitary and reversible. However, classical gates can be irreversible, like the logical AND and logical OR gates. Then, how is it possible to model irreversible classical AND and OR gates using quantum gates?&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-15T15:06:33.667" LastActivityDate="2018-03-15T15:06:33.667" Title="If quantum gates are reversible how can they possibly perform irreversible classical AND and OR operations?" Tags="&lt;quantum-gate&gt;&lt;unitarity&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="132" PostTypeId="2" ParentId="131" CreationDate="2018-03-15T10:58:34.123" Score="13" Body="&lt;p&gt;Let's say we have a function $f$ which maps $n$ bits to $m$ bits (where $m&amp;lt;n$).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$f: \{0,1\}^{n} \to \{0,1\}^{m}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We could of course design a classical circuit to perform this operation. Let's call it $C_f$. It takes in as input $n$-bits. Let's say it takes as input $X$ and it outputs $f(X)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, we would like to do the same thing using a quantum circuit. Let's call it $U_f$, which takes as input $|X\rangle$ and outputs $|f(X)\rangle$. Now remember that since quantum mechanics is linear the input qubits could of course be in a superposition of all the $n$-bit strings. So the input could be in some state $\sum_{X\in\{0,1\}^{n}}\alpha_X|X\rangle$. By linearity the output is going to be $\sum_{X\in\{0,1\}^{n}}\alpha_X|f(X)\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Evolution in quantum mechanics is &lt;a href=&quot;https://en.wikipedia.org/wiki/Unitarity_(physics)&quot; rel=&quot;noreferrer&quot;&gt;unitary&lt;/a&gt;. And because it is unitary, it is reversible. This essentially means that if you apply a quantum gate $U$ on an input state $|x\rangle$ and get an ouput state $U|x\rangle$, you can always apply an inverse gate $U^{\dagger}$ to get back to the state $|x\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/hSnaX.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/hSnaX.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Notice, carefully in the above picture that the number of input lines (i.e. six) is exactly same as the number of output lines at each step. This is because of the unitarity of the operations. Compare this to classical operations like the &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_conjunction&quot; rel=&quot;noreferrer&quot;&gt;logical AND&lt;/a&gt; where $0\wedge1$ gives a single bit output $0$. You can't reconstruct the initial bits $0$ and $1$ from the output, since even $0\wedge 0$ and $1\wedge0$ would have mapped to the same output $0$. But, consider the classical NOT gate. If the input is $0$ it ouputs $1$, while if the input is $1$ it outputs $0$. Since this mapping is one-one, it can be easily implemented as a reversible unitary gate,  namely, &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_gate#Pauli-X_gate_(=_NOT_gate)&quot; rel=&quot;noreferrer&quot;&gt;the Pauli-X gate&lt;/a&gt;. However, for implementing a classical AND or a classical OR gate we need to think a bit more.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Consider the &lt;a href=&quot;https://en.wikipedia.org/wiki/Fredkin_gate&quot; rel=&quot;noreferrer&quot;&gt;CSWAP gate&lt;/a&gt;. Here's a rough diagram showing the scheme:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/4t7ko.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/4t7ko.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the SWAP gate depending on the control bit, we the other two may or may not get swapped. Notice that there are three input lines and three output lines. So, it can be modeled as a unitary quantum gate. Now, if $z=0$: If $x=0$, output  is $0$, while if $x=1$, output is $y$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/CJNuJ.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/CJNuJ.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you notice, if $x=0$, we are outputting $\bar{x}\wedge y$ while if $x=1$ we are outputting $x\wedge y$. So we could successfully generate the output $x\wedge y$ which we wanted although we ended up with some &quot;junk&quot; outputs $\bar{x}\wedge y$ and $x$. An interesting fact is that the inverse of the CSWAP gate is the CSWAP gate itself (check!).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;That's all! Remember that all classical gates can be constructed with the &lt;a href=&quot;https://en.wikipedia.org/wiki/NAND_gate&quot; rel=&quot;noreferrer&quot;&gt;NAND gate&lt;/a&gt;, which can of course be constructed an AND and a NOT gate. We effectively modelled the classical NOT and the classical AND gate using reversible quantum gates. Just to be on the safe side we can also add the qauntum &lt;a href=&quot;https://en.wikipedia.org/wiki/Controlled_NOT_gate&quot; rel=&quot;noreferrer&quot;&gt;CNOT gate&lt;/a&gt; to our list, because using CNOT we can copy bits. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Hence, the basic message is that using the quantum CSWAP, CNOT and the NOT gates we can replicate &lt;em&gt;any&lt;/em&gt; classical gate. BTW, there's a clever trick to get rid of the &quot;junk&quot; bits which are produced when quantum gates are used, but that's another story. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;P.S: It's very important to get rid of the &quot;junk&quot; bits or else they can cause computational errors!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Reference &amp;amp; Image Credits: &lt;a href=&quot;https://www.edx.org/course/quantum-mechanics-quantum-computation-uc-berkeleyx-cs-191x&quot; rel=&quot;noreferrer&quot;&gt;Quantum Mechanics and Quantum Computation MOOC&lt;/a&gt; offered by UC Berkeley on edX.&lt;/em&gt;&lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-03-15T10:58:34.123" CommentCount="2" />
  <row Id="133" PostTypeId="1" AcceptedAnswerId="134" CreationDate="2018-03-15T13:27:54.457" Score="15" ViewCount="137" Body="&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_annealing&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum annealing&lt;/a&gt; is an optimization protocol that, thanks to quantum tunneling, allows in given circumstances to maximize/minimize a given function more efficiently than classical optimization algorithms.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A crucial point of quantum annealing is the adiabaticity of the algorithm, which is required for the state to stay in the ground state of the time-dependent Hamiltonian.&#xA;This is however also a problem, as it means that find a solution can require very long times.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;How long do these times have to be for a given Hamiltonian?&#xA;More precisely, given a problem Hamiltonian $\mathcal H$ of which we want to find the ground state, are there results saying how long would it take a quantum annealer to reach the solution?&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-04-02T19:20:48.823" LastActivityDate="2018-04-02T19:20:48.823" Title="How long does quantum annealing take to find the solution to a given problem?" Tags="&lt;quantum-speedup&gt;&lt;quantum-annealing&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="1" />
  <row Id="134" PostTypeId="2" ParentId="133" CreationDate="2018-03-15T13:38:01.490" Score="14" Body="&lt;p&gt;The time to solution (tts) is highly dependent on the Hamiltonian of the problem one would like to solve. The D-Wave uses a spin-glass-like Hamiltonian which can be in the NP-Complete complexity class. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Due to having to run the annealing process multiple times, tts measures are typically quantified by how long it takes to find the ground state some percent of the time. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1711.01368&quot; rel=&quot;noreferrer&quot;&gt;Here's a paper&lt;/a&gt; by some colleagues that explains tts (see especially equation 3). &lt;/p&gt;&#xA;" OwnerUserId="54" LastEditorUserId="91" LastEditDate="2018-03-15T14:46:23.343" LastActivityDate="2018-03-15T14:46:23.343" CommentCount="0" />
  <row Id="135" PostTypeId="1" CreationDate="2018-03-15T13:58:19.720" Score="24" ViewCount="362" Body="&lt;p&gt;It is generally believed and claimed that quantum computers can outperform classical devices in at least some tasks.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One of the most commonly cited examples of a problem in which quantum computers would outperform classical devices is $\text{Factoring}$, but then again, it is also not known whether $\text{Factoring}$ is also efficiently solvable with a classical computer (that is, whether $\text{Factoring}\in \text{P}$).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For other commonly cited problems in which quantum computers are known to provide an advantage, such as database search, the speedup is only polynomial.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Are there known instances of problems in which it can be shown (either proved or proved under strong computational complexity assumptions) that quantum computers would provide an exponential advantage?&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="26" LastEditDate="2018-03-16T19:08:33.173" LastActivityDate="2018-04-07T04:54:48.500" Title="Are there problems in which quantum computers are known to provide an exponential advantage?" Tags="&lt;complexity-theory&gt;&lt;quantum-speedup&gt;" AnswerCount="4" CommentCount="15" FavoriteCount="4" />
  <row Id="136" PostTypeId="1" CreationDate="2018-03-15T15:02:47.357" Score="19" ViewCount="383" Body="&lt;p&gt;All quantum operations must be unitary to allow reversibility, but what about measurement? Measurement can be represented as a matrix, and that matrix is applied to qubits, so that seems equivalent to the operation of a quantum gate. That's definitively not reversible. Are there any situations where non-unitary gates might be allowed?&lt;/p&gt;&#xA;" OwnerUserId="91" LastEditorUserId="26" LastEditDate="2018-03-29T18:13:16.523" LastActivityDate="2018-04-11T23:17:18.603" Title="If all quantum gates must be unitary, what about measurement?" Tags="&lt;quantum-gate&gt;&lt;measurement&gt;&lt;unitarity&gt;" AnswerCount="6" CommentCount="10" FavoriteCount="1" />
  <row Id="137" PostTypeId="1" AcceptedAnswerId="139" CreationDate="2018-03-15T15:12:04.687" Score="11" ViewCount="165" Body="&lt;p&gt;Are there any encryption suites that can be cracked by usual computers or super computers, but not quantum computers?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If that's possible, what assumptions will it depend on? (Factorizing big numbers, $a^b\pmod d$ $a^c\pmod d$ $a^{bc}\pmod d$ etc...)&lt;/p&gt;&#xA;" OwnerUserId="248" LastEditorUserId="253" LastEditDate="2018-04-02T08:23:41.800" LastActivityDate="2018-04-02T08:23:41.800" Title="Are there any encryption suites which can be cracked by classical computers but not quantum computers?" Tags="&lt;quantum-speedup&gt;&lt;cryptography&gt;&lt;complexity-theory&gt;&lt;post-quantum-crypto&gt;" AnswerCount="1" CommentCount="5" />
  <row Id="138" PostTypeId="2" ParentId="135" CreationDate="2018-03-15T16:21:44.340" Score="10" Body="&lt;p&gt;Not sure if this is strictly what you're looking for; and I don't know that I'd qualify this as &quot;exponential&quot; (I'm also not a computer scientist so my ability to do algorithm analysis is more or less nonexistent...), but a recent result by Bravyi et. al presented a class of '2D Hidden Linear Function problems' that provably use fewer resources on a quantum parallel device. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The paper is on the arxiv &lt;a href=&quot;https://arxiv.org/abs/1704.00690&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;, but here's a quick summary. The quantum advantage is in the depth of the parallel circuit, so the number of threads one can split the problem into under bounded fan-in. The problem is given a $N\times N$ matrix $A$ and an input vector $b$, one can define a quadratic form $q$ and a special subspace for that form. The &quot;hidden linear function problem&quot;'s goal is to find a linearization for that quadratic function on a special subspace.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A classical probablistic circuit is constrained to ~$\log{N}$ depth, if you want your computation to succeed with probability $&amp;gt;7/8$ (you probably want it to succeed with at least this probability). A quantum circuit can do it with constant depth, so that's a big improvement. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The proof essentially amounts to a specific graph state being difficult for a classical circuit to simulate, this sub-result was &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0603032&quot; rel=&quot;noreferrer&quot;&gt;proven slightly earlier&lt;/a&gt;. Then the rest of the paper shows that the greater class of problems contains this difficult problem. &lt;/p&gt;&#xA;" OwnerUserId="236" LastActivityDate="2018-03-15T16:21:44.340" CommentCount="1" />
  <row Id="139" PostTypeId="2" ParentId="137" CreationDate="2018-03-15T16:41:03.480" Score="13" Body="&lt;p&gt;This is not a very enlightening concept, because most interesting quantum algorithms, such as Shor's algorithm, involve some classical computations as well.  While &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/25/238&quot; title=&quot;jknappen, Answer to ‘Can a quantum computer simulate a normal computer?’, quantumcomputing.stackexchange.com, 2018-03-13.&quot;&gt;you can always shoehorn a classical computation into a quantum computer&lt;/a&gt;, it would be at unnecessarily exorbitant cost.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We don't yet know, of course, exactly what problems will be hard to solve even if given a quantum computer—the &lt;a href=&quot;https://nist.gov/pqcrypto&quot; rel=&quot;noreferrer&quot; title=&quot;United States National Institute of Standards and Technology: Post-Quantum Cryptography.&quot;&gt;NIST PQCRYPTO&lt;/a&gt; competition is in progress right now to study that question.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, even then, it likely won't be &lt;em&gt;answered definitively&lt;/em&gt; any more than we can answer definitively what cryptography we can't break with classical computers: nobody has found a realistically efficient classical algorithm for factoring a product $n$ of uniform random 1024-bit primes whose totient $\phi(n)$ is coprime with 3, nor has anyone found a realistically efficient classical algorithm for computing cube roots modulo $n$, nor has anyone even ascertained whether factoring is harder than computing cube roots (though certainly it's not &lt;em&gt;easier&lt;/em&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;At best, we can say that a lot of smart people have been well-funded to think very hard about it, and we can choose parameter sizes that thwart the best attacks they have come up with.  The outcome of the NIST PQCRYPTO competition will be the same, with any luck—unless someone clever thinks of ways to break every single one of the dozens of candidates.&lt;/p&gt;&#xA;" OwnerUserId="238" LastActivityDate="2018-03-15T16:41:03.480" CommentCount="0" />
  <row Id="140" PostTypeId="2" ParentId="136" CreationDate="2018-03-15T17:26:49.327" Score="11" Body="&lt;h2&gt;Short Answer&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Quantum operations &lt;em&gt;do not&lt;/em&gt; need to be unitary.&#xA;In fact, many quantum algorithms and protocols make use of non-unitarity.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Long Answer&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Measurements are arguably the most obvious example of non-unitary transitions being a fundamental component of algorithms (in the sense that a &quot;measurement&quot; is equivalent to sampling from the probability distribution obtained after the decoherence operation $\sum_k c_k\lvert k\rangle\mapsto\sum_k |c_k|^2\lvert k\rangle\langle k\rvert$).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;More generally, any quantum algorithm that involves probabilistic steps requires non-unitary operations. A notable example that comes to mind is HHL09's algorithm to solve linear systems of equations (see &lt;a href=&quot;https://arxiv.org/abs/0811.3171&quot; rel=&quot;nofollow noreferrer&quot;&gt;0811.3171&lt;/a&gt;).&#xA;A crucial step in this algorithm is the mapping $|\lambda_j\rangle\mapsto C\lambda_j^{-1}|\lambda_j\rangle$, where $|\lambda_j\rangle$ are eigenvectors of some operator. This mapping is necessarily probabilistic and therefore non-unitary.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Any algorithm or protocol that makes use of (classical) feed-forward is also making use of non-unitary operations. This is the whole of &lt;a href=&quot;https://en.wikipedia.org/wiki/One-way_quantum_computer&quot; rel=&quot;nofollow noreferrer&quot;&gt;one-way quantum computation&lt;/a&gt; protocols (which, as the name suggests, require non-reversible operations).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The most notable schemes for optical quantum computation with single photons also require measurements and sometimes post-selection to entangle the states of different photons.&#xA;For example, the &lt;a href=&quot;https://en.wikipedia.org/wiki/KLM_protocol&quot; rel=&quot;nofollow noreferrer&quot;&gt;KLM protocol&lt;/a&gt; produces probabilistic gates, which are therefore at least partly non-reversible. &#xA;A nice review on the topic is &lt;a href=&quot;https://arxiv.org/pdf/quant-ph/0512071.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;quant-ph/0512071&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Less intuitive examples are provided by dissipation-induced quantum state engineering (e.g. &lt;a href=&quot;https://arxiv.org/pdf/1402.0529.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;1402.0529&lt;/a&gt; or &lt;a href=&quot;https://www.nature.com/articles/srep10656.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;srep10656&lt;/a&gt;).&#xA;In these protocols, one uses an open map dissipative dynamic, and engineers the interaction of the state with the environment in such a way that that the long-time stationary state of the system is the desired one.&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="58" LastEditDate="2018-04-11T23:17:18.603" LastActivityDate="2018-04-11T23:17:18.603" CommentCount="0" />
  <row Id="141" PostTypeId="2" ParentId="136" CreationDate="2018-03-15T18:59:23.027" Score="10" Body="&lt;p&gt;At risk of going off-topic from quantum computing and into physics, I'll answer what I think is a relevant subquestion of this topic, and use it to inform the discussion of unitary gates in quantum computing. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The question here is: Why do we want unitarity in quantum gates? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The less specific answer is as above, it gives us 'reversibility', or as physicists often talk about it, a type of symmetry for the system. I'm taking a course in quantum mechanics right now, and the way unitary gates cropped up in that course was motivated by the desire to have physical transformations $\hat{U}$: that act as symmetries. This imposed two conditions on the transformation $\hat{U}$: &lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;The transformations should act linearly on the state (this is what gives us a matrix representation).&lt;/li&gt;&#xA;&lt;li&gt;The transformations should preserve probability, or more specifically &lt;em&gt;inner product&lt;/em&gt;. This means that if we define:&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;$$|\psi '\rangle = U |\psi\rangle, |\phi'\rangle = U |\phi\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Preservation of inner product means that $\langle \phi | | \psi \rangle= \langle \phi' | | \psi'\rangle$. From this second specification, unitarity can be derived (for full details see Dr. van Raamsdonk's notes &lt;a href=&quot;http://www.phas.ubc.ca/~mav/Phys402/lecture5.pdf&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;So this answers the question of why operations that keep things &quot;reversible&quot; have to be unitary. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The question of why measurement itself is not unitary is more related to quantum computation. A measurement is a projection on to a basis; in essence, it must &quot;answer&quot; with one or more basis states as the state itself. It also leaves the state in a way that is consistent with the &quot;answer&quot; to the measurement, and &lt;em&gt;not&lt;/em&gt; consistent with the underlying probabilities that the state began with. So the operation satisfies specification 1. of our transformation $U$, but definitively does not satisfy specification 2. Not all matrices are created equal!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To round things back to quantum computation, the fact that measurements are destructive and projective (ie. we can only reconstruct the superposition through repeated measurements of identical states, and every measurement only gives us a 0/1 answer), is part of what makes the separation between quantum computing and regular computing subtle (and part of why it's difficult to pin that down). One might assume quantum computing is more powerful because of the mere size of the Hilbert space, with all those state superpositions available to us. But our ability to extract that information is heavily limited. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;As far as I understand it this shows that for information storage purposes, a qubit is only as good as a regular bit, and no better. But we can be clever in quantum computation with the way that information is traded around, because of the underlying linear-algebraic structure. &lt;/p&gt;&#xA;" OwnerUserId="236" LastEditorUserId="236" LastEditDate="2018-03-15T20:40:23.053" LastActivityDate="2018-03-15T20:40:23.053" CommentCount="2" />
  <row Id="142" PostTypeId="1" AcceptedAnswerId="145" CreationDate="2018-03-15T19:10:27.307" Score="12" ViewCount="175" Body="&lt;p&gt;Post-quantum cryptography like &lt;a href=&quot;https://en.wikipedia.org/wiki/Lattice-based_cryptography&quot; rel=&quot;nofollow noreferrer&quot;&gt;lattice-based cryptography&lt;/a&gt; is designed to be secure even if quantum computers are available. It resembles currently employed encryptions, but is based on problems which are most likely not efficiently solvable by a quantum computer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Obviously research on quantum key distribution (QKD) continues. &lt;strong&gt;But what exactly are advantages of quantum key distribution over post-quantum cryptography?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The development of a new technology like QKD can have great side effects, and maybe QKD will be more cost-efficient or faster in the very long term, but I doubt that this is the main reason.&lt;/p&gt;&#xA;" OwnerUserId="104" LastEditorUserId="609" LastEditDate="2018-03-27T18:27:58.617" LastActivityDate="2018-03-27T18:27:58.617" Title="Advantage of quantum key distribution over post-quantum cryptography" Tags="&lt;cryptography&gt;&lt;post-quantum-crypto&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="143" PostTypeId="2" ParentId="136" CreationDate="2018-03-15T19:28:36.153" Score="18" Body="&lt;p&gt;Unitary operations are only a special case of &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_operation&quot; rel=&quot;noreferrer&quot;&gt;quantum operations&lt;/a&gt;, which are linear, completely positive maps (&quot;channels&quot;) that map density operators to density operators. This becomes obvious in the Kraus-representation of the channel, $$\Phi(\rho)=\sum_{i=1}^n K_i \rho K_i^\dagger,$$ where the so-called Kraus operators $K_i$ fulfill $\sum_{i=1}^n K_i^\dagger K_i\leq \mathbb{I}$ (&lt;a href=&quot;https://quantumcomputing.meta.stackexchange.com/q/54/104&quot;&gt;notation&lt;/a&gt;). Often one considers only trace-preserving quantum operations, for which equality in the previous inequality holds. If additionally there is only one Kraus operator (so $n=1$), then we see that the quantum operation is unitary.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, &lt;em&gt;quantum gates&lt;/em&gt; are unitary, because they are implemented via the action of a Hamiltonian for a specific time, which gives a unitary time evolution according to the Schrödinger equation.&lt;/p&gt;&#xA;" OwnerUserId="104" LastActivityDate="2018-03-15T19:28:36.153" CommentCount="1" />
  <row Id="144" PostTypeId="2" ParentId="142" CreationDate="2018-03-15T19:43:15.777" Score="13" Body="&lt;p&gt;Quantum key distribution requires that you wholesale replace your entire communications infrastructure built out of 5 EUR ethernet cables and 0.50 EUR CPUs by multimillion-euro dedicated fiber links and specialized computers that actually just do classical secret-key cryptography anyway.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Plus you have to authenticate the shared secret keys you negotiate with quantum key distribution, which you will probably do using classical public-key cryptography unless you're rich enough to afford couriers with suitcases handcuffed to their wrists.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://crypto.stackexchange.com/a/51314/29554&quot; title=&quot;François Grieu, Answer to ‘What makes Quantum Cryptography secure?’, crypto.stackexchange.com, 2017-09-05.&quot;&gt;More details from François Grieu on crypto.se about what makes quantum cryptography secure.&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The crux of the technical difference—costs and deployability and politics and class divisions aside—is that the physical protocol of a QKD system is intended to be designed so that it need not leave a physical trace that future mathematical breakthroughs could enable to retroactively recover the shared secret negotiated over these dedicated fiber links.  In contrast, with classical cryptography, public-key key agreements over the internet, where an eavesdropper records every bit over the wire, could in principle be broken by future mathematical breakthroughs.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then, in both cases, the peers use the shared secret they negotiated, whether with quantum key distribution or with classical public-key key agreement, as a secret key for classical secret-key cryptography, which could in principle be broken by future mathematical breakthroughs.  (But very smart well-funded people haven't made those breakthroughs after trying for decades.)  And &lt;a href=&quot;https://cr.yp.to/papers.html#holographic&quot; rel=&quot;noreferrer&quot; title=&quot;Daniel J. Bernstein, ‘Is the security of quantum cryptography guaranteed by the laws of physics?’, manuscript, 2016-03-26.&quot;&gt;this doesn't mean that &lt;em&gt;practical implementations&lt;/em&gt; of QKD won't leave physical traces either&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;All that said, QKD is quantum, so it is sexy and makes a good sell to rich governments and banks, who have multimillion-euro discretionary funds for useless toys like QKD.  The physics is also pretty cool for nerds to play with.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;M. Stern calls to mind another advantage of QKD: It operates at the &lt;em&gt;link layer&lt;/em&gt;, negotiating a secret key shared by the two endpoints of a fiber link—which might be one legitimate user and the MITM who spliced into that fiber link with a rogue QKD device.  If, in the era of quantum supremacy, we &lt;em&gt;replaced&lt;/em&gt; all the world's classical public-key key agreement by QKD, then where applications currently negotiate secret keys with their &lt;em&gt;peer&lt;/em&gt; across the internet for &lt;em&gt;end-to-end&lt;/em&gt; authenticated encryption over &lt;a href=&quot;https://en.wikipedia.org/wiki/IP_over_Avian_Carriers&quot; rel=&quot;noreferrer&quot; title=&quot;Wikipedia: IP over Avian Carriers.  Retrieved 2018-03-16.&quot;&gt;any routable medium&lt;/a&gt;, they would instead have to negotiate secret keys with their &lt;em&gt;ISP&lt;/em&gt;, who would negotiate secrets with their upstream ISP, and so on, for &lt;em&gt;hop-by-hop&lt;/em&gt; authenticated encryption.  This would be a boon for the good guys in major world governments trying to (retroactively) monitor user communications to root out terrorists and activists and journalists and other inconvenient elements of society, because the ISPs would then necessarily have the secret keys ready to turn over to the police.&lt;/p&gt;&#xA;" OwnerUserId="238" LastEditorUserId="238" LastEditDate="2018-03-17T02:27:02.867" LastActivityDate="2018-03-17T02:27:02.867" CommentCount="12" />
  <row Id="145" PostTypeId="2" ParentId="142" CreationDate="2018-03-15T20:41:01.900" Score="8" Body="&lt;p&gt;If it is proven that a given &lt;a href=&quot;https://en.wikipedia.org/wiki/Public-key_cryptosystem&quot; rel=&quot;noreferrer&quot;&gt;asymmetric encryption protocol&lt;/a&gt; relies on a problem which cannot be solved efficiently even by a quantum computer, then quantum cryptography becomes largely irrelevant.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The point is that, as of today, no one was able to do this.&#xA;Indeed, such a result would be a serious breakthrough, as it would prove the existence of $\text{NP}$ problems which are not efficiently solvable on a quantum computer&#xA;(while this is generally believed to be the case, it is still unknown whether there are problems in $\text{NP}\!\setminus\!\text{BQP}$).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Generally speaking, all classical asymmetric encryption protocols are safe under the assumption that a given problem is hard to solve, but in no case, to my knowledge, it has been proven (in the computational complexity sense) that that problem is indeed exponentially hard to solve with a quantum computer (and for many not even that the problem is not efficiently solvable with a &lt;em&gt;classical&lt;/em&gt; computer).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I think this is nicely explained by Bernstein in his review of post-quantum cryptography (&lt;a href=&quot;http://www.pqcrypto.org/www.springer.com/cda/content/document/cda_downloaddocument/9783540887010-c1.pdf&quot; rel=&quot;noreferrer&quot;&gt;Link&lt;/a&gt;).&#xA;Quoting from the first section in the above, where he just talked about a number of classical encryption protocols:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Is there a better attack on these systems? Perhaps. This is a familiar&#xA;  risk in cryptography. This is why the community invests huge amounts&#xA;  of time and energy in cryptanalysis. Sometimes cryptanalysts find a&#xA;  devastating attack, demonstrating that a system is useless for&#xA;  cryptography; for example, every usable choice of parameters for the&#xA;  Merkle–Hellman knapsack public-key encryption system is easily&#xA;  breakable. Sometimes cryptanalysts find attacks that are not so&#xA;  devastating but that force larger key sizes. Sometimes cryptanalysts&#xA;  study systems for years without finding any improved attacks, and the&#xA;  cryptographic community begins to build confidence that the best&#xA;  possible attack has been found—or at least that real-world attackers&#xA;  will not be able to come up with anything better.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;On the other hand, the security of QKD does, &lt;em&gt;ideally&lt;/em&gt;, not rely on conjectures (or, as it is often put, QKD protocols provide in principle &lt;em&gt;information-theoretic security&lt;/em&gt;). If the two parties share a secure key, then the communication channel is unconditionally secure, and QKD provides an unconditionally secure way for them to exchange such a key (of course, still under the assumption of quantum mechanics being right). &#xA;In Section 4 of the above-mentioned review, the author presents a direct (if possibly somewhat biased) comparison of QKD vs Post-Quantum cryptography.&#xA;It is important to note that of course &quot;unconditional security&quot; is here to be meant in the information-theoretic sense, while in the real world &lt;a href=&quot;https://xkcd.com/538/&quot; rel=&quot;noreferrer&quot;&gt;there may be more important security aspects to consider&lt;/a&gt;.&#xA;It is also to be noted that the real-world security and practicality of QKD is not believed to be factual by some (see e.g. Bernstein &lt;a href=&quot;https://cr.yp.to/papers.html#holographic&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt; and the related discussion on QKD on &lt;a href=&quot;https://crypto.stackexchange.com/q/51311/57005&quot;&gt;crypto.SE&lt;/a&gt;), and that the &lt;a href=&quot;https://en.wikipedia.org/wiki/Information-theoretic_security&quot; rel=&quot;noreferrer&quot;&gt;information-theoretic&lt;/a&gt; security of QKD protocols is only true if they are properly followed, which in particular means that the shared key has to be used as a &lt;a href=&quot;https://en.wikipedia.org/wiki/One-time_pad&quot; rel=&quot;noreferrer&quot;&gt;one-time pad&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Finally, in reality, also many QKD protocols may be broken. The reason is that experimental imperfection of specific implementations can be exploited to break the protocol (see e.g. &lt;a href=&quot;https://arxiv.org/abs/1505.05303&quot; rel=&quot;noreferrer&quot;&gt;1505.05303&lt;/a&gt;, and pag.6 of &lt;a href=&quot;https://www.nature.com/articles/npjqi201625&quot; rel=&quot;noreferrer&quot;&gt;npjqi201625&lt;/a&gt;).&#xA;It is still possible to ensure the security against such attacks using device-independent QKD protocols, whose security relies on Bell's inequalities violations and can be proven to not depend on the implementation details.&#xA;The catch is that these protocols are even harder to implement than regular QKD.&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-03-17T00:51:19.637" LastActivityDate="2018-03-17T00:51:19.637" CommentCount="12" />
  <row Id="146" PostTypeId="5" CreationDate="2018-03-15T20:42:19.687" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-15T20:42:19.687" LastActivityDate="2018-03-15T20:42:19.687" CommentCount="0" />
  <row Id="147" PostTypeId="4" CreationDate="2018-03-15T20:42:19.687" Score="0" Body="It is a metaheuristic for finding the global minimum of a given objective function over a given set of candidate solutions (candidate states), by a process using quantum fluctuations." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T07:43:03.483" LastActivityDate="2018-04-15T07:43:03.483" CommentCount="0" />
  <row Id="148" PostTypeId="5" CreationDate="2018-03-15T20:44:28.597" Score="0" Body="&lt;p&gt;An ideal quantum gate can be described by a unitary matrix. That is, any (ideal) gate acting on $n$ qubits can be described as an element of (the matrix representation of) $\mathrm U\left(2^n\right)$. For a gate acting on $n$, $d$-dimensional, qudits this becomes $\mathrm U\left(d^n\right)$. The result of a gate $U$ acting on state $\left|\psi\right&amp;gt;$ is $U\left|\psi\right&amp;gt;$. When the state is being described by a density matrix $\rho$, this becomes $U\rho U^\dagger$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Gates are usually denoted with respect to the &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/1410/23&quot;&gt;computational basis&lt;/a&gt; and any basis change on the state also has to be applied to the matrix representing the gate.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Gates can act on single, two or more qubits (or qudits). Some common examples are:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Single qubit gates:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Hadamard: $$H = \frac{1}{\sqrt{2}}\begin{pmatrix}1 &amp;amp; 1 \\\ 1 &amp;amp; -1\end{pmatrix}$$&lt;/li&gt;&#xA;&lt;li&gt;Pauli gates: $$X = \begin{pmatrix}0 &amp;amp; 1 \\\ 1 &amp;amp; 0\end{pmatrix},\quad Y = \begin{pmatrix}0 &amp;amp; -i \\\ i &amp;amp; 0\end{pmatrix},\quad Z = \begin{pmatrix}1 &amp;amp; 0 \\\ 0 &amp;amp; -1\end{pmatrix}$$&lt;/li&gt;&#xA;&lt;li&gt;$\sqrt{\text{NOT}} = \sqrt X$: $$\sqrt X = \frac 12\begin{pmatrix}1+i &amp;amp; 1-i \\\ 1-i &amp;amp; 1+i\end{pmatrix}$$&lt;/li&gt;&#xA;&lt;li&gt;Phase: $$R_\phi = \begin{pmatrix}1 &amp;amp; 0 \\\ 0 &amp;amp; e^{i\phi}\end{pmatrix}$$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Two qubit gates:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Controlled gates: $$\text{CNOT} = \begin{pmatrix}1&amp;amp;0&amp;amp;0&amp;amp;0\\\ 0&amp;amp;1&amp;amp;0&amp;amp;0 \\\ 0&amp;amp;0&amp;amp;0&amp;amp;1 \\\ 0&amp;amp;0&amp;amp;1&amp;amp;0\end{pmatrix},\quad CU = \begin{pmatrix}I_2 &amp;amp; 0 \\\ 0 &amp;amp; U\end{pmatrix}$$&lt;/li&gt;&#xA;&lt;li&gt;SWAP: $$\text{SWAP} = \begin{pmatrix}1&amp;amp;0&amp;amp;0&amp;amp;0\\\ 0&amp;amp;0&amp;amp;1&amp;amp;0 \\\ 0&amp;amp;1&amp;amp;0&amp;amp;0 \\\ 0&amp;amp;0&amp;amp;0&amp;amp;1\end{pmatrix}$$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Multiple qubit gates/transformations:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Toffoli/CCNOT: $$\text{CCNOT} = \begin{pmatrix}I_6 &amp;amp; 0 \\\ 0 &amp;amp; X\end{pmatrix}$$&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_Fourier_transform&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Fourier Transform (QFT)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;(multiple qubit) Hadamard/Discrete Fourier Transform: This is defined by the recursive relation $H^{\otimes n} = H\otimes H^{\otimes \left(n-1\right)}$, where $H = H^{\otimes 1}$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;However, currently, gates aren't perfect and an actual implementation of a gate can't recreate the exact, ideal gate. To quantify how 'close' an implemented gate is to the ideal one, &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0205035&quot; rel=&quot;nofollow noreferrer&quot;&gt;gate fidelity&lt;/a&gt; is often used.&lt;/p&gt;&#xA;" OwnerUserId="-1" LastEditorUserId="23" LastEditDate="2018-08-11T16:07:56.667" LastActivityDate="2018-08-11T16:07:56.667" CommentCount="0" />
  <row Id="149" PostTypeId="4" CreationDate="2018-03-15T20:44:28.597" Score="0" Body="For questions regarding usage, performance, implementation, application or theory related to quantum gates" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-16T01:10:37.547" LastActivityDate="2018-03-16T01:10:37.547" CommentCount="0" />
  <row Id="150" PostTypeId="5" CreationDate="2018-03-15T20:45:31.920" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-15T20:45:31.920" LastActivityDate="2018-03-15T20:45:31.920" CommentCount="0" />
  <row Id="151" PostTypeId="4" CreationDate="2018-03-15T20:45:31.920" Score="0" Body="For questions about the meaning and usage of vocabulary specific to quantum computing or quantum information" OwnerUserId="26" LastEditorUserId="3" LastEditDate="2018-03-16T01:16:58.853" LastActivityDate="2018-03-16T01:16:58.853" CommentCount="0" />
  <row Id="152" PostTypeId="5" CreationDate="2018-03-15T20:46:38.577" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-15T20:46:38.577" LastActivityDate="2018-03-15T20:46:38.577" CommentCount="0" />
  <row Id="153" PostTypeId="4" CreationDate="2018-03-15T20:46:38.577" Score="0" Body="For questions about the ability of quantum computing to solve problems that classical computers (practically) cannot" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-17T00:19:15.333" LastActivityDate="2018-03-17T00:19:15.333" CommentCount="0" />
  <row Id="154" PostTypeId="5" CreationDate="2018-03-15T20:48:59.893" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-15T20:48:59.893" LastActivityDate="2018-03-15T20:48:59.893" CommentCount="0" />
  <row Id="155" PostTypeId="4" CreationDate="2018-03-15T20:48:59.893" Score="0" Body="For question related to the unitarity (unitary evolution) of quantum systems, as applicable to quantum computing or quantum information" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-16T01:13:39.877" LastActivityDate="2018-03-16T01:13:39.877" CommentCount="0" />
  <row Id="156" PostTypeId="5" CreationDate="2018-03-15T20:51:04.030" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-15T20:51:04.030" LastActivityDate="2018-03-15T20:51:04.030" CommentCount="0" />
  <row Id="157" PostTypeId="4" CreationDate="2018-03-15T20:51:04.030" Score="0" Body="A quantum computing company, based in Burnaby, British Columbia, Canada, mostly known for their quantum annealing computers. An early rendition of these, D-Wave One, was the first commercially available quantum computer." OwnerUserId="26" LastEditorUserId="23" LastEditDate="2018-04-14T16:46:50.293" LastActivityDate="2018-04-14T16:46:50.293" CommentCount="0" />
  <row Id="158" PostTypeId="5" CreationDate="2018-03-15T20:52:47.930" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-15T20:52:47.930" LastActivityDate="2018-03-15T20:52:47.930" CommentCount="0" />
  <row Id="159" PostTypeId="4" CreationDate="2018-03-15T20:52:47.930" Score="0" Body="For questions about the specific realization of quantum computing that uses photons as qubits. Examples of gates include the Fabry-Perot cavity or linear optical components like beamsplitters. Questions with this tag can ask about both theory and practice, as long as it relates to this specific realization." OwnerUserId="91" LastEditorUserId="91" LastEditDate="2018-03-25T17:19:26.063" LastActivityDate="2018-03-25T17:19:26.063" CommentCount="0" />
  <row Id="160" PostTypeId="5" CreationDate="2018-03-15T20:54:01.030" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-15T20:54:01.030" LastActivityDate="2018-03-15T20:54:01.030" CommentCount="0" />
  <row Id="161" PostTypeId="4" CreationDate="2018-03-15T20:54:01.030" Score="0" Body="Questions about the superconducting realization of quantum computers. Questions can be about both the implementation of this realization or the theory behind this realization. If you are asking about a specific aspect of superconducting quantum computers, please also tag with that (i.e., if you are also asking about the Josephson junction, tag with that)." OwnerUserId="91" LastEditorUserId="91" LastEditDate="2018-03-25T17:23:23.963" LastActivityDate="2018-03-25T17:23:23.963" CommentCount="0" />
  <row Id="162" PostTypeId="1" CreationDate="2018-03-16T01:10:30.233" Score="15" ViewCount="132" Body="&lt;p&gt;Often, when comparing two density matrices, $\rho$ and $\sigma$ (such as when $\rho$ is an experimental implementation of an ideal $\sigma$), the closeness of these two states is given by the &lt;a href=&quot;https://en.wikipedia.org/wiki/Fidelity_of_quantum_states&quot; rel=&quot;noreferrer&quot;&gt;quantum state fidelity&lt;/a&gt; $$F = tr\left(\sqrt{\sqrt{\rho}\sigma\sqrt{\rho}}\right),$$ with infidelity defined as $1-F$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Similarly, when comparing how close an implementation of a gate is with an ideal version, the fidelity becomes $$F\left( U, \tilde U\right) = \int\left[tr\left(\sqrt{\sqrt{U\left|\psi\rangle\langle\psi\right|U^\dagger}\tilde U\left|\psi\rangle\langle\psi\right|\tilde U^\dagger\sqrt{U\left|\psi\rangle\langle\psi\right|U^\dagger}}\right)\right]^2\,d\psi,$$ where $d\psi$ is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Haar_measure&quot; rel=&quot;noreferrer&quot;&gt;Haar measure&lt;/a&gt; over pure states. Unsurprisingly, this can get relatively unpleasant to work with.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, let's define a matrix $M = \rho - \sigma$ in the case of density matrices, or $M = U - \tilde U$ when working with gates. Then, the Schatten norms&lt;sup&gt;1&lt;/sup&gt;, such as $\| M\|_1 = tr\left(\sqrt{M^\dagger M}\right)$, $\| M\|_2^2 = tr\left(M^\dagger M\right)$, or other norms, such as the &lt;a href=&quot;https://arxiv.org/abs/1004.4110v1&quot; rel=&quot;noreferrer&quot;&gt;diamond norm&lt;/a&gt; can be computed.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;These norms are often easier to compute&lt;sup&gt;2&lt;/sup&gt; than the above Fidelity. What makes matters worse is that in &lt;a href=&quot;https://arxiv.org/abs/0707.0963&quot; rel=&quot;noreferrer&quot;&gt;randomised benchmarking&lt;/a&gt; calculations, &lt;a href=&quot;https://arxiv.org/abs/1702.01853&quot; rel=&quot;noreferrer&quot;&gt;infidelity doesn't even appear to be a great measure&lt;/a&gt;, yet is the number that's used every time that I've seen when looking at benchmarking values for quantum processors.&lt;sup&gt;3&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, &lt;strong&gt;Why is (in)fidelity the go-to value for calculating gate errors in quantum processors (using randomised benchmarking), when it doesn't seem to have a helpful meaning and other methods, such as Schatten norms, are easier to calculate on a classical computer?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;1 The Schatten p-norm of $M$ is $\| M\|_p^p = tr\left(\sqrt{M^\dagger M}^p\right)$ &lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;2 i.e. plug in a noise model on a (classical) computer and simulate&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;3 Such as &lt;a href=&quot;https://github.com/QISKit/ibmqx-backend-information/blob/master/backends/ibmqx5/README.md&quot; rel=&quot;noreferrer&quot;&gt;IBM's QMX5&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&#xA;" OwnerUserId="23" LastEditorUserId="26" LastEditDate="2018-03-26T15:09:56.640" LastActivityDate="2018-03-26T15:09:56.640" Title="Purpose of using Fidelity in Randomised Benchmarking" Tags="&lt;fidelity&gt;&lt;distance-measures&gt;&lt;randomised-benchmarking&gt;&lt;quantum-information&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="163" PostTypeId="1" AcceptedAnswerId="169" CreationDate="2018-03-16T05:43:16.650" Score="13" ViewCount="309" Body="&lt;p&gt;If one wants to start building a quantum computer from scratch inside simulations (like how people get to build a classical computer from scratch in the &lt;a href=&quot;http://nand2tetris.org/&quot; rel=&quot;noreferrer&quot;&gt;Nand2Tetris course&lt;/a&gt;), is it possible? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If yes, what would be some possible approaches?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Also, what will be the limits of such a simulated machine, given a specific amount of classical computing power? For instance, if we were to pick your average desktop/laptop, what will be the limit? If we take a supercomputer (like Titan) then what would be the limit?&lt;/p&gt;&#xA;" OwnerUserId="261" LastEditorUserId="26" LastEditDate="2018-03-29T18:12:16.160" LastActivityDate="2018-03-30T11:35:20.970" Title="Building a quantum computer in simulation" Tags="&lt;quantum-computer&gt;&lt;simulation&gt;&lt;performance&gt;" AnswerCount="3" CommentCount="2" FavoriteCount="3" />
  <row Id="164" PostTypeId="5" CreationDate="2018-03-16T05:44:46.157" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-16T05:44:46.157" LastActivityDate="2018-03-16T05:44:46.157" CommentCount="0" />
  <row Id="165" PostTypeId="4" CreationDate="2018-03-16T05:44:46.157" Score="0" Body="For questions regarding faster than light communication or information transfer as relevant to quantum computing or quantum information" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-17T00:19:32.683" LastActivityDate="2018-03-17T00:19:32.683" CommentCount="0" />
  <row Id="166" PostTypeId="5" CreationDate="2018-03-16T05:48:24.920" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-16T05:48:24.920" LastActivityDate="2018-03-16T05:48:24.920" CommentCount="0" />
  <row Id="167" PostTypeId="4" CreationDate="2018-03-16T05:48:24.920" Score="0" Body="For questions related to measurement and its effects as relevant to quantum computation and quantum information " OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-17T00:19:22.487" LastActivityDate="2018-03-17T00:19:22.487" CommentCount="0" />
  <row Id="168" PostTypeId="2" ParentId="163" CreationDate="2018-03-16T06:22:29.440" Score="5" Body="&lt;p&gt;Well, I'm working on a simulator of a quantum computer currently. The basic idea of quantum computing, of course, is gates represented by matrices applied to qubits represented by vectors. Using Python's numpy package, this isn't that hard to program in the most basic sense.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;From there, one might expand upon, of course, the interface. One might also consider trying to make it a simulator of a nonideal quantum computer, that is, taking into account decoherence times and error correction.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then, you get into heavily uncharted territory. How do you construct the instruction set for a quantum computer? Who knows. You'll have to figure out. You'll also have to figure out your version of assembly, and even your version of higher level programming languages.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, limitations of a classical computer in this? Well, this is a really complicated question (and worth asking separately, imho) but here's a quick summary:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;we don't know if quantum computers are actually better than classical computers; the algorithms for classical computers could just not be good enough yet (quantum supremacy)&lt;/li&gt;&#xA;&lt;li&gt;let's say, as seems decently likely, that quantum computers &lt;em&gt;are&lt;/em&gt; better than classical computers. that improvement will depend heavily on the problem - quantum computers might see, for example, a much higher speed improvement in finding prime factorizations than in checking email. (see also &lt;a href=&quot;https://physics.stackexchange.com/questions/29307/simulate-a-quantum-computer-on-a-normal-one&quot;&gt;this&lt;/a&gt; P.SE q/a.)&lt;/li&gt;&#xA;&lt;li&gt;to provide some sort of numerical value, if we consider the current fastest algorithm for classical prime factorization finding, i.e., the general number sieve, we have an O-time of $O\Big(e^{\sqrt{\frac{64}{9}}(\log N)^{\frac 13}(\log\log N)^{\frac 23}}\Big)$ which is clearly rather gross. Shor's algorithm, on the other hand, works in  $O((\log N)^2(\log \log N)(\log \log \log N))$ which is obviously a lot faster.&lt;/li&gt;&#xA;&lt;li&gt;I can run a bunch of qubits on my computer as long as I keep them in the $|0\rangle$ or $|1\rangle$ states - i.e., effectively classical. So in some senses, your question is again, kind of ill-defined.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="91" LastActivityDate="2018-03-16T06:22:29.440" CommentCount="3" />
  <row Id="169" PostTypeId="2" ParentId="163" CreationDate="2018-03-16T06:31:55.180" Score="5" Body="&lt;p&gt;The first part of your question seems like a duplicate of an existing QC SE post: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/12/are-there-emulators-for-quantum-computers&quot;&gt;Are there emulators for quantum computers?&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I'm not completely sure what you mean by &lt;strong&gt;&lt;em&gt;building&lt;/strong&gt; a quantum computer &lt;strong&gt;from scratch&lt;/strong&gt; inside simulations&lt;/em&gt;. However, yes, you can make software simulations of a quantum computer using your average laptop/desktop. The exact &quot;limit&quot; will depend on the computer specifications. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Since a quantum computer does not violate the &lt;a href=&quot;https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis&quot; rel=&quot;noreferrer&quot;&gt;Church-Turing thesis&lt;/a&gt;, in theory it is definitely possible to simulate a quantum computer using an &lt;em&gt;ideal&lt;/em&gt; Turing machine. The obvious approach to simulate such a system requires exponential time on a classical computer and the space complexity is an exponential function of the number of quantum bits simulated. Say, you simulate a $n$-bit quantum computer, you'd need to store about $2^{n}$ bits of information in your classical computer at every instant. Moreover, implementation of quantum gates will again take a huge amount of resources in terms of time and space complexity. An implementation of a quantum gate operating on $n$-qubits would have to store about $4^{n}$ (because you can represent all quantum gate operations as a matrix of size $2^{n}\times2^{n}$) bits of information. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can sort of estimate the &quot;limit&quot; depending on the specifications of the classical computer. For example if the (accessible) memory size of your classical computer is around $1$ TB I'd expect you can simulate a $\log_4(8\times 10^{12})\approx 21$ bit quantum computer (to be on the safe side let's say $20$). However, keep in mind that classical computers would take much larger time to &lt;em&gt;access&lt;/em&gt; all the individual bits of information, compared to an actual quantum computer (depending on the hardware of the quantum computer). So it's going to be &lt;em&gt;slower&lt;/em&gt; than an actual quantum computer! Some other limitations are that after each action of a $n$-qubit gate you need to keep track of which output qubits are entangled, which is a &lt;a href=&quot;https://stackoverflow.com/a/23327816/8605708&quot;&gt;NP-hard&lt;/a&gt; problem. Also, &lt;em&gt;measurement&lt;/em&gt; cannnot be accurately simulated on a classical computer, because classically there is no &lt;em&gt;truly random&lt;/em&gt; number generator. &lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-16T07:37:06.100" LastActivityDate="2018-03-16T07:37:06.100" CommentCount="0" />
  <row Id="170" PostTypeId="2" ParentId="163" CreationDate="2018-03-16T11:18:43.683" Score="1" Body="&lt;p&gt;I feel like this answer mostly rests on an underlying misunderstanding of what it means to &quot;simulate&quot; something.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Generally speaking, to &quot;simulate&quot; a complex system means to reproduce certain features of such system with a platform that is easier to control (often, but not always, a classical computer).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Therefore, the question of whether &quot;one can simulate a quantum computer in a classical computer&quot; is somewhat ill-posed.&#xA;If you mean that you want to replicate every possible aspect of a &quot;quantum computer&quot;, then that is never going to happen, just like you are never going to be able to simulate every aspect of any classical system (unless you use the same identical system of course).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;On the other hand, you certainly &lt;em&gt;can&lt;/em&gt; simulate many aspects of a complex device like a &quot;quantum computer&quot;. For example, one may want to simulate the evolution of a state within a quantum circuit.&#xA;Indeed, this can be exceedingly easy to do! For example, if you have python on your computer, just run the following&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import numpy as np&#xA;identity_2d = np.diag([1, 1])&#xA;pauliX_gate = np.array([[0, 1], [1, 0]])&#xA;hadamard_gate = np.array([[1, 1], [1, -1]]) / np.sqrt(2)&#xA;&#xA;cnot_gate = np.kron(identity_2d, pauliX_gate)&#xA;H1_gate = np.kron(hadamard_gate, identity_2d)&#xA;&#xA;awesome_entangling_gate = np.dot(cnot_gate, H1_gate)&#xA;&#xA;initial_state = np.array([1, 0, 0, 0])&#xA;final_state = np.dot(awesome_entangling_gate, initial_state)&#xA;print(final_state)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Congratulation, you just &quot;simulated&quot; the evolution of a separable two-qubit state into a Bell state!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, if you try to do the same with, say, 40 qubits and a nontrivial gate, you are not going to be able to pull it off this easily.&#xA;The naive reason is that to even just store the state of an $n$-qubit (non sparse) state you need to specify  ~$2^n$ complex numbers, and this start taking a lot of memory very quickly.&#xA;I say &quot;naive&quot; here because in many cases there may be tricks that allow you to avoid this problem$^{(1)}$.&#xA;This is why many people work on trying to find clever tricks to simulate quantum circuits (and other types of quantum systems) with classical computers, and why this is far from trivial to do$^{(2)}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Other answers already touched on various aspects of this hardness, and the answers to &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/12/55&quot;&gt;this other question&lt;/a&gt; already mention many available platforms to simulate/emulate various aspects of quantum algorithms, so I will not go there.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;(1)&lt;/strong&gt;&#xA;An interesting example of this is the problem of simulating a &lt;a href=&quot;https://en.wikipedia.org/wiki/Boson_sampling&quot; rel=&quot;nofollow noreferrer&quot;&gt;boson sampling device&lt;/a&gt; (this is not a quantum algorithm in the sense of a state evolving through a series of gates, but it is nonetheless an example of a nontrivial quantum device). BosonSampling is a &lt;em&gt;sampling problem&lt;/em&gt;, in which one is tasked with the problem of &lt;em&gt;sampling&lt;/em&gt; from a specific probability distribution, and this has been shown (under likely assumptions) to be impossible to do efficiently with a classical device. Although it was never shown to be a fundamental aspect of this hardness, a certainly nontrivial issue associated with simulating a boson sampling device was that of having to compute an exponentially large number of probabilities from which to sample. However, it was recently shown that indeed one does not need to compute the whole set of probabilities to sample from them (&lt;a href=&quot;https://arxiv.org/abs/1705.00686&quot; rel=&quot;nofollow noreferrer&quot;&gt;1705.00686&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/pdf/1706.01260.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;1706.01260&lt;/a&gt;).&#xA;This is not far in principle from simulating the evolution of a lot of qubits in a quantum circuit without having to store the whole state of the system at any given point.&#xA;Regarding more directly quantum circuits, examples of recent breakthrough in simulation capabilities are &lt;a href=&quot;https://arxiv.org/abs/1704.01127&quot; rel=&quot;nofollow noreferrer&quot;&gt;1704.01127&lt;/a&gt; &#xA;and &lt;a href=&quot;https://arxiv.org/abs/1710.05867&quot; rel=&quot;nofollow noreferrer&quot;&gt;1710.05867&lt;/a&gt; (also a super-recent one, not yet published, is &lt;a href=&quot;https://arxiv.org/abs/1802.06952&quot; rel=&quot;nofollow noreferrer&quot;&gt;1802.06952&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;(2)&lt;/strong&gt;&#xA;In fact, it has been shown (or rather, strong evidence has been provided for the fact) that it is not possible to efficiently simulate most quantum circuits, see &lt;a href=&quot;https://arxiv.org/abs/1504.07999&quot; rel=&quot;nofollow noreferrer&quot;&gt;1504.07999&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-03-30T11:35:20.970" LastActivityDate="2018-03-30T11:35:20.970" CommentCount="0" />
  <row Id="171" PostTypeId="1" AcceptedAnswerId="172" CreationDate="2018-03-16T17:35:59.370" Score="33" ViewCount="1070" Body="&lt;p&gt;I'm admittedly a novice in this field, but I have read that, while the D-wave (one) is an interesting device, there is some skepticism regarding it being 1) useful and 2) actually a 'quantum computer'.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, Scott Aaronson has expressed multiple times that he is skeptical about whether the 'quantum' parts in the D-wave are actually useful: &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;It remains true, as I’ve reiterated here for years, that we have no direct evidence that quantum coherence is playing a role in the observed speedup, or indeed that entanglement between qubits is ever present in the system.  &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Exerpt from &lt;a href=&quot;https://www.scottaaronson.com/blog/?p=954&quot; rel=&quot;noreferrer&quot;&gt;this blog&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Additionally, the relevant &lt;a href=&quot;https://en.wikipedia.org/wiki/D-Wave_Systems#Controversy&quot; rel=&quot;noreferrer&quot;&gt;Wikipedia section&lt;/a&gt; on skepticism against the D-wave is a mess.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, I ask: &lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;I know that D-wave claims to use some sort of quantum annealing. Is there (dis)proof of the D-wave actually using quantum annealing (with effect) in its computations? &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Has it been conclusively shown that the D-wave is (in)effective? If not, is there a clear overview of the work to attempt this?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="253" LastEditorUserId="253" LastEditDate="2018-03-26T15:38:48.193" LastActivityDate="2018-04-03T16:02:14.413" Title="Is there proof that the D-wave (one) is a quantum computer and is effective?" Tags="&lt;performance&gt;&lt;quantum-annealing&gt;&lt;d-wave&gt;&lt;classical-computing&gt;&lt;experimental-results&gt;" AnswerCount="2" CommentCount="8" FavoriteCount="3" />
  <row Id="172" PostTypeId="2" ParentId="171" CreationDate="2018-03-16T18:54:03.090" Score="22" Body="&lt;p&gt;There is still a search for problems where the D-Wave shows improvement over classical algorithms. One might recall media splashes where the D-Wave solved some instances $10^8$ times faster than a classical algorithms but forgot to mention that the problem can be solved in polynomial time using minimum weight perfect matching. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Denchev showing $10^8$ speedup&#xA;&lt;a href=&quot;https://arxiv.org/abs/1512.02206&quot; rel=&quot;noreferrer&quot;&gt;https://arxiv.org/abs/1512.02206&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Mandra using MWPM&#xA;&lt;a href=&quot;https://arxiv.org/pdf/1703.00622.pdf&quot; rel=&quot;noreferrer&quot;&gt;https://arxiv.org/pdf/1703.00622.pdf&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There is some evidence that there are indeed some quantum effects used by the D-Wave. Notably a study by Katzgraber et al. that compares the D-Wave with simulated annealing and the effects of reducing barrier thickness in the energy landscape (to make tunneling more probable). In Fig. 5 of the following paper the barrier thickness is reduced and the D-Wave shows improvement on the class of problems while Simulated Annealing shows no improvement. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1505.01545.pdf&quot; rel=&quot;noreferrer&quot;&gt;https://arxiv.org/pdf/1505.01545.pdf&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Full disclosure: Katzgraber was my PhD advisor so I am most familiar with his work.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;On the other hand, there have been a few papers on the topic of the D-Wave being a simple thermal annealer with no quantum effects, notably the papers by Smolin although they are a bit dated now. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1305.4904.pdf&quot; rel=&quot;noreferrer&quot;&gt;https://arxiv.org/pdf/1305.4904.pdf&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1401.7087.pdf&quot; rel=&quot;noreferrer&quot;&gt;https://arxiv.org/pdf/1401.7087.pdf&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;More recently Albash et al. discussed the finite temperature as a reason for quantum annealers not functioning competitively.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1703.03871.pdf&quot; rel=&quot;noreferrer&quot;&gt;https://arxiv.org/pdf/1703.03871.pdf&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="54" LastEditorUserId="54" LastEditDate="2018-03-18T20:36:24.380" LastActivityDate="2018-03-18T20:36:24.380" CommentCount="9" />
  <row Id="173" PostTypeId="5" CreationDate="2018-03-16T19:23:40.217" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-16T19:23:40.217" LastActivityDate="2018-03-16T19:23:40.217" CommentCount="0" />
  <row Id="174" PostTypeId="4" CreationDate="2018-03-16T19:23:40.217" Score="0" Body="For questions about the performance of quantum computers and quantum computer emulators." OwnerUserId="11" LastEditorUserId="11" LastEditDate="2018-03-17T00:19:36.850" LastActivityDate="2018-03-17T00:19:36.850" CommentCount="0" />
  <row Id="175" PostTypeId="1" AcceptedAnswerId="176" CreationDate="2018-03-17T02:26:32.157" Score="18" ViewCount="307" Body="&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Grover%27s_algorithm&quot; rel=&quot;noreferrer&quot;&gt;Grover's search algorithm&lt;/a&gt; provides a provable polynomial speed-up for unsorted database search.&#xA;The algorithm is usually expressed by the following quantum circuit:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/a/ae/Grovers_algorithm.svg&quot;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In most representations, a crucial part of the protocol is the &quot;oracle gate&quot; $U_\omega$, which &quot;magically&quot; performs the operation $|x\rangle\mapsto(-1)^{f(x)}|x\rangle$.&#xA;It is however often left unsaid how difficult realizing such a gate would actually be.&#xA;Indeed, it could seem like this use of an &quot;oracle&quot; is just a way to sweep the difficulties under the carpet.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;How do we know whether such an oracular operation is indeed realizable?&#xA;And if so, what is its complexity (for example in terms of complexity of gate decomposition)?&lt;/p&gt;&#xA;" OwnerUserId="55" LastActivityDate="2018-03-29T11:38:57.710" Title="How is the oracle in Grover's search algorithm implemented?" Tags="&lt;complexity-theory&gt;&lt;circuit-model&gt;&lt;quantum-algorithms&gt;" AnswerCount="2" CommentCount="2" FavoriteCount="2" />
  <row Id="176" PostTypeId="2" ParentId="175" CreationDate="2018-03-17T02:45:21.413" Score="16" Body="&lt;p&gt;The function $f$ is simply an arbitrary boolean function of a bit string: $f\colon \{0,1\}^n \to \{0,1\}$.  For applications to breaking cryptography, such as &lt;a href=&quot;https://eprint.iacr.org/2017/811&quot; rel=&quot;noreferrer&quot; title=&quot;Scott Fluhrer, ‘Reassessing Grover&amp;#39;s Algorithm’, IACR Cryptology ePrint Archive: Report 2017/811, 2017-08-27.&quot;&gt;[1]&lt;/a&gt;, &lt;a href=&quot;https://cr.yp.to/papers.html#grovernfs&quot; rel=&quot;noreferrer&quot; title=&quot;Daniel J. Bernstein, Jean-François Biasse, and Michele Mosca, ‘A low-resource quantum factoring algorithm’, in Tanja Lange and Tsuyoshi Takagi, _eds._, _Proceedings of Post-quantum cryptography—8th international workshop, PQCrypto 2017_, Utrecht, the Netherlands, June 26–28, 2017, Springer LNCS 10346, pp. 330–346.&quot;&gt;[2]&lt;/a&gt;, or &lt;a href=&quot;https://blog.cr.yp.to/20171017-collisions.html&quot; rel=&quot;noreferrer&quot; title=&quot;Daniel J. Bernstein, ‘Quantum algorithms to find collisions’, cr.yp.to blog, 2017-10-17.&quot;&gt;[3]&lt;/a&gt;, this is not actually a ‘database lookup’, which would necessitate storing the entire database as a quantum circuit somehow, but rather a function such as&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{equation*}&#xA;  x \mapsto \begin{cases}&#xA;    1, &amp;amp; \text{if $\operatorname{SHA3-256}(x) = y$;} \\&#xA;    0, &amp;amp; \text{otherwise,}&#xA;  \end{cases}&#xA;\end{equation*}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;for fixed $y$, which has no structure we can exploit for a classical search, unlike, say, the function&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{equation*}&#xA;  x \mapsto \begin{cases}&#xA;    1, &amp;amp; \text{if $2^x \equiv y \pmod{2^{2048} - 1942289}$}, \\&#xA;    0, &amp;amp; \text{otherwise},&#xA;  \end{cases}&#xA;\end{equation*}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;which has &lt;a href=&quot;https://crypto.stackexchange.com/a/1389/49826&quot; title=&quot;Samuel Neves, Answer to ‘Are safe primes $p = 2k\pm s$ with $s$ small less recommandable than others as a discrete log modulus?’, crypto.stackexchange.com, 2011-12-01.&quot;&gt;structure that can be exploited&lt;/a&gt; to invert it faster even on a classical computer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The question of the particular &lt;em&gt;cost&lt;/em&gt; can't be answered in general because $f$ can be any circuit—it's just a matter of &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/25/238&quot; title=&quot;jknappen, Answer to ‘Can a quantum computer simulate a normal computer?’, quantumcomputing.stackexchange.com, 2018-03-12.&quot;&gt;making a quantum circuit out of a classical circuit&lt;/a&gt;.  But usually, as in the example above, the function $f$ is very cheap to evaluate on a classical computer, so it shouldn't pose a particularly onerous burden on a quantum computer for which everything else about Grover's algorithm is within your budget.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The only general cost on top of $f$ is an extra conditional NOT gate $$C\colon \left|a\right&amp;gt; \left|b\right&amp;gt; \to \left|a\right&amp;gt; \left|a \oplus b\right&amp;gt;$$ where $\oplus$ is xor, and an extra ancillary qubit for it.  In particular, if we have a circuit $$F\colon \left|x\right&amp;gt; \left|a\right&amp;gt; \lvert\mathit{junk}\rangle \mapsto \left|x\right&amp;gt; \left|a \oplus f(x)\right&amp;gt; \lvert\mathit{junk}'\rangle$$ built out of $C$ and the circuit for $f$, then if we apply it to $\left|x\right&amp;gt;$ together with an ancillary qubit initially in the state $\left|-\right&amp;gt; = H\left|1\right&amp;gt; = (1/\sqrt{2})(\left|0\right&amp;gt; - \left|1\right&amp;gt;)$ where $H$ is a Hadamard gate, then we get&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{align*}&#xA;  F\left|x\right&amp;gt; \left|-\right&amp;gt; \lvert\mathit{junk}\rangle&#xA;   &amp;amp;= \frac{1}{\sqrt{2}}\bigl(&#xA;        F\left|x\right&amp;gt; \left|0\right&amp;gt; \lvert\mathit{junk}\rangle&#xA;        - F\left|x\right&amp;gt; \left|1\right&amp;gt; \lvert\mathit{junk}\rangle&#xA;      \bigr) \\&#xA;   &amp;amp;= \frac{1}{\sqrt{2}}\bigl(&#xA;        \left|x\right&amp;gt; \left|f(x)\right&amp;gt; \lvert\mathit{junk}'\rangle&#xA;        - \left|x\right&amp;gt; \left|1 \oplus f(x)\right&amp;gt; \lvert\mathit{junk}'\rangle&#xA;      \bigr).&#xA;\end{align*}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If $f(x) = 0$ then $1 \oplus f(x) = 1$, so by simplifying we obtain $$F\left|x\right&amp;gt; \left|-\right&amp;gt; \lvert\mathit{junk}\rangle = \left|x\right&amp;gt; \left|-\right&amp;gt; \lvert\mathit{junk}'\rangle,$$ whereas if $f(x) = 1$ then $1 \oplus f(x) = 0$, so $$F\left|x\right&amp;gt; \left|-\right&amp;gt; \lvert\mathit{junk}\rangle = -\left|x\right&amp;gt; \left|-\right&amp;gt; \lvert\mathit{junk}'\rangle,$$ and thus in general $$F\left|x\right&amp;gt; \left|-\right&amp;gt; \lvert\mathit{junk}\rangle = (-1)^{f(x)} \left|x\right&amp;gt; \left|-\right&amp;gt; \lvert\mathit{junk}'\rangle.$$&lt;/p&gt;&#xA;" OwnerUserId="238" LastEditorUserId="238" LastEditDate="2018-03-17T20:14:55.663" LastActivityDate="2018-03-17T20:14:55.663" CommentCount="4" />
  <row Id="177" PostTypeId="1" AcceptedAnswerId="179" CreationDate="2018-03-17T06:30:57.343" Score="10" ViewCount="132" Body="&lt;p&gt;I'm writing with respect to &lt;a href=&quot;https://www.youtube.com/watch?v=APJwgjl_cUQ&quot; rel=&quot;noreferrer&quot;&gt;part I&lt;/a&gt; and &lt;a href=&quot;https://www.youtube.com/watch?v=__4qlnCnSDk&quot; rel=&quot;noreferrer&quot;&gt;part II&lt;/a&gt; of the Fourier sampling video lectures by Professor Umesh Vazirani.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In part I they start with:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;In the Hadamard Transform:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/wxqaw.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/wxqaw.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$|0...0\rangle \to \sum_{\{0,1\}^n}\frac{1}{2^{n/2}}|x\rangle$$&#xA;$$|u\rangle =|u_1...u_n\rangle \to \sum_{\{0,1\}^n}\frac{(-1)^{u.x}}{2^{n/2}}|x\rangle \quad \text{(where $u.x=u_1x_1+u_2x_2+...+u_nx_n$)}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;In Fourier Sampling:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$|\psi\rangle=\sum_{\{0,1\}}^{n}\alpha_x|x\rangle \to \sum_{x}\hat{\alpha_x}|x\rangle=|\hat{\psi}\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When $|\hat{\psi}\rangle$ is measured we see $x$ with probability $|\hat{\alpha_x}|^2$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In part II:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;The Parity Problem:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;We are given a function $f:\{0,1\}^n\to\{0,1\}$ as a black box. We&#xA;  know that $f(x)=u.x$ (i.e. $u_1x_1+u_2x_2+...+u_nx_n (\text{mod 2})$) for some hidden $u\in\{0,1\}^{n}$. How do we&#xA;  figure out $u$ with as few queries to $f$ as possible?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/wymTY.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/wymTY.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;They say that we need to follow a two step procedure for figuring out $u$ in minimum possible number of steps.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Set up a superposition $\frac{1}{2^{n/2}}\sum_{x}(-1)^{f(x)}|x\rangle$&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Fourier sample to obtain $u$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;This is where I got lost. I don't understand what exactly they mean by &quot;set up a superposition...&quot;. &lt;strong&gt;Why&lt;/strong&gt; should we do it? And how does Fourier sampling (as described) help to determine $u$ ?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;They further build a quantum gate like this:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/zZWSw.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/zZWSw.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Even this doesn't make sense to me. They're performing Hadamard transforms on a set of n-qubits having state $|0\rangle$ and then bit flip and again Hadamard transform. So we get back to where we were initially. How does an extra $|-\rangle$ state input help by outputting $- \oplus f(0...0)$? I'm not even sure what operation $\oplus$ stand for, here.&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-17T06:43:38.533" LastActivityDate="2018-04-15T08:58:10.037" Title="How does Fourier sampling actually work (and solve the parity problem)?" Tags="&lt;quantum-gate&gt;&lt;fourier-sampling&gt;" AnswerCount="1" CommentCount="4" FavoriteCount="1" />
  <row Id="178" PostTypeId="2" ParentId="21" CreationDate="2018-03-17T09:24:24.417" Score="5" Body="&lt;p&gt;There seems to be some debate about wether or not this question should be allowed but as it's one of the first examples in Nielsen &amp;amp; Chuang I'll go ahead and type out their explanation here for anyone else that is interested in entanglement for faster than light communication. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The following is an abridged version of Nielsen &amp;amp; Chuang section 1.3.7 entitled 'Example: quantum teleportation'&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Quantum teleportation is a technique for moving quantum states around,&#xA;  even in the absence of a quantum commincations channel linking the&#xA;  sender of the quantum state to the recipient. &lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Here’s how quantum teleportation works. Alice and Bob met long ago but&#xA;  now live far apart. While together they generated an EPR pair, each&#xA;  taking one qubit of the EPR pair (also known as Bell states) when they&#xA;  separated. Many years later, Bob is in hiding, and Alice’s mission,&#xA;  should she choose to accept it, is to deliver a qubit $\lvert \psi&#xA; \rangle$ to Bob. She does not know the state of the qubit, and&#xA;  moreover can only send classical information to Bob. Should Alice&#xA;  accept the mission?&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Intuitively, things look pretty bad for Alice. She doesn’t know the&#xA;  state $\lvert \psi \rangle$ of the qubit she has to send to Bob, and&#xA;  the laws of quantum mechanics prevent her from determining the state&#xA;  when she only has a single copy of $\lvert \psi \rangle$ in her&#xA;  possession. What’s worse, even if she did know the state $\lvert \psi&#xA; \rangle$, describing it precisely takes an infinite amount of&#xA;  classical information since $\lvert \psi \rangle$ takes values in a&#xA;  continuous space. So even if she did know $\lvert \psi \rangle$, it&#xA;  would take forever for Alice to describe the state to Bob. It’s not&#xA;  looking good for Alice. Fortunately for Alice, quantum teleportation&#xA;  is a way of utilizing the entangled EPR pair in order to send $\lvert&#xA; \psi \rangle$ to Bob, with only a small overhead of classical&#xA;  communication.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;In outline, the steps of the solution are as follows: Alice interacts&#xA;  the qubit $\lvert&#xA; \psi \rangle$ with her half of the EPR pair, and then measures the two&#xA;  qubits in her possession, obtaining one of four possible classical&#xA;  results, 00, 01, 10, and 11. She sends this information to Bob.&#xA;  Depending on Alice’s classical message, Bob performs one of four&#xA;  operations on his half of the EPR pair. Amazingly, by doing this he&#xA;  can recover the original state $\lvert&#xA; \psi \rangle$!&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Skipping some of the details...&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;First, doesn’t teleportation allow one to transmit quantum states faster than light? This would be rather peculiar, because the theory of relativity implies that faster than light information transfer could be used to send information backwards in time. Fortunately, quantum teleportation does not enable faster than light communication, because to complete the teleportation Alice must transmit her measurement result to Bob over a classical communications channel. The classical channel is limited by the speed of light, so it follows that quantum teleportation cannot be accomplished faster than the speed of light, resolving the apparent paradox.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="54" LastEditorUserId="54" LastEditDate="2018-03-18T18:16:16.363" LastActivityDate="2018-03-18T18:16:16.363" CommentCount="10" />
  <row Id="179" PostTypeId="2" ParentId="177" CreationDate="2018-03-17T11:15:08.020" Score="7" Body="&lt;p&gt;Starting from the beginning (a very good place to start, after all), the state $\left| 0\right\rangle^{\otimes n}\left| -\right\rangle$ is input into $H^{\otimes n}\otimes I$ (here, called the 'Fourier sample'). This generates the state $$\left(\sum_{x=\{0,1\}^n}\frac{1}{2^{n/2}}|x\rangle\right)\left|-\right\rangle = \frac{1}{2^{n/2}}\left(\left|0\right\rangle + \left|1\right\rangle\right)^{\otimes n}\left|-\right\rangle$$. Now, we apply the operation $U_f$ (in this case, the &lt;em&gt;bit oracle&lt;/em&gt;) to give $$U_f\left(\sum_{x=\{0,1\}^n}\frac{1}{2^{n/2}}|x\rangle\right)\left|-\right\rangle = \sum_{x=\{0,1\}^n}\frac{1}{2^{n/2}}|x\rangle\left|-\oplus f\left(x\right)\right\rangle.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The first point to note is that $\oplus$ &lt;strong&gt;is the classical XOR operation&lt;/strong&gt;. What this gives is actually the &lt;em&gt;phase oracle&lt;/em&gt;, so that we get $$\left(\sum_{x=\{0,1\}^n}\frac{1}{2^{n/2}}\left(-1\right)^{f\left(x\right)}\left|x\right\rangle\right)\left|-\right\rangle.$$ This is because $U_f\left|x\right\rangle\left(\left|0\right\rangle - \left|1\right\rangle\right) = \left|x\right\rangle\left|f\left(x\right)\right\rangle - \left|1\oplus f\left(x\right)\right\rangle = \left(-1\right)^{f\left(x\right)}\left|x\right\rangle\left(\left|0\right\rangle - \left|1\right\rangle\right)$. This is the 'set up a superposition...' point - all this means is to &lt;strong&gt;perform the operations required to set the qubits in the above state, which is a superposition of all possible states (with phase factors, in this case)&lt;/strong&gt;. In this case, this is just Hadamard, followed by a phase oracle.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, $x$ is just a classical bit string: $x = \prod_ix_i$, so $$H\left|x_i\right\rangle = \frac{1}{\sqrt{2}}\left(\left|0\right\rangle + \left(-1\right)^{x_i}\left|1\right\rangle\right) = \frac{1}{\sqrt{2}}\sum_{y=\left\lbrace0, 1\right\rbrace}\left(-1\right)^{x_i.y}\left|y\right\rangle.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This gives the property $$H^{\otimes n}\left| x\right\rangle = \frac{1}{2^{n/2}}\sum_{y\in\left\lbrace0, 1\right\rbrace^n}\left(-1\right)^{x.y}\left|y\right\rangle.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This gives the final state as $$\frac{1}{2^n}\left(\sum_{x, y=\{0,1\}^n}\left(-1\right)^{f\left(x\right) \oplus x.y}\left|y\right\rangle\right)\left|-\right\rangle.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We know that $f\left(x\right) = u.x = x.u$, giving $\left(-1\right)^{f\left(x\right) \oplus x.y} = \left(-1\right)^{x.\left(u\oplus y\right)}$. Summing over the $x$ terms gives that $\sum_x\left(-1\right)^{x.\left(u\oplus y\right)} = 0,\, \forall\, u\oplus y \neq 0$. This means that we're left with the term for $u\oplus y = 0$, which means that $u=y$, giving the output as $\left|u\right\rangle\left|-\right\rangle$, which is measured to obtain $u$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As for &lt;strong&gt;&lt;em&gt;why&lt;/em&gt; we want to set up a superposition&lt;/strong&gt;: This is where the power of quantum computing comes into play - In less mathematical terms, applying the Hadamard transformation is performing a rotation on the qubit states to get into the state $\left|+\right\rangle^{\otimes n}$. You then rotate each qubit in this superposition state using an operation equivalent to XOR (in this new basis), so that when performing the Hadamard transformation again, you're now just rotating back onto the state $\left|u\right\rangle$. Another way of looking at this is to consider it as a reflection or inversion that achieves the same result. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The point is that, using superposition, we can do this to all the qubits at the same time, instead of having to individually check each qubit as in the classical case.&lt;/p&gt;&#xA;" OwnerUserId="23" LastEditorUserId="23" LastEditDate="2018-04-15T08:58:10.037" LastActivityDate="2018-04-15T08:58:10.037" CommentCount="3" />
  <row Id="180" PostTypeId="1" CreationDate="2018-03-17T11:19:10.620" Score="8" ViewCount="78" Body="&lt;p&gt;How much of a role does the type of hardware used to implement the building blocks (like qubits, the circuits, the communication channels,quantum RAM etc.) have to play when designing the architecture for a full scale quantum computer?   &lt;/p&gt;&#xA;&#xA;&lt;p&gt;My own thoughts on the matter: Architecture should not depend on the way the hardware is realised. Because if it did, then every time someone came up with a novel design for the hardware, it would require rethinking the architecture - not a bad idea if you are looking to improve your architecture but that rethinking should be born out of a desire to improve the computer in general and not simply accommodate some new RAM implementation.&lt;/p&gt;&#xA;" OwnerUserId="261" LastEditorUserId="55" LastEditDate="2018-03-19T15:36:44.000" LastActivityDate="2018-03-19T15:36:44.000" Title="Dependency of architecture on hardware" Tags="&lt;quantum-computer&gt;&lt;architecture&gt;" AnswerCount="2" CommentCount="2" />
  <row Id="181" PostTypeId="2" ParentId="162" CreationDate="2018-03-17T13:00:27.177" Score="5" Body="&lt;p&gt;Nielsen and Chuang in their book &quot;Quantum Computation and Quantum Information&quot; have section (Chapter 9) on distance measures for quantum information. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Surprisingly they say in Section 9.3 &quot; How well does a quantum channel preserve information?&quot; that when comparing fidelity to the trace norm:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Using the properties of the trace distance established in the last section it is not difficult, for the most part, to give a parallel development based upon the trace distance. However, it turns out that the fidelity is an easier tool to calculate with, and for that reason we restrict ourselves to considerations based upon the fidelity.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I imagine this is in part why fidelity is used. It seems it's fairly useful as a static measure of distance.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There also seems to be relatively straightforward extensions of fidelity to ensembles of states&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$F =\sum_j p_jF(\rho_j,\mathcal{E}(\rho_j))^2,$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$p_j$ the probability of preparing the system in states $\rho_j$, and $\mathcal{E}$ the particular noisy channel of interest, $0\leq F\leq 1$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;There's also an extension to entanglement fidelity, to measure how well a channel preserves entanglement. Given a state $Q$ assumed to be entangled to the external world in some way, and a purification of the state (fictitious system $R$), such that $RQ$ is pure. The state is subjected to dynamics in the channel $\mathcal{E}$. The primes indicate the state after the application of quantum operation. $\mathcal{I}_R$ is the identity map on system $R$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$F(\rho,\mathcal{E}) ≡ F(RQ,R′Q′)^2= ⟨RQ| \left(\mathcal{I}_R \otimes \mathcal{E}\right)\left(|RQ⟩⟨RQ|\right) |RQ⟩$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There's some formulas derived to simplify computations of fidelity and entanglement fidelity also given in the chapter.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;One of the attractive properties of the entanglement fidelity is that there is a very simple formula which enables it to be calculated exactly.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;$$F(\rho,\mathcal{E})=\sum_i\operatorname{tr}|(\rho E_i)|^2 $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;where the 'operation elements' $E_i$ satisfy a completeness relation. Maybe someone else can comment on more practical implementations, but this is what I've gathered from reading.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Update 1: Re M.Stern&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It's the same reference Nielsen and Chuang. They comment on that by saying &quot;You may wonder why the fidelity appearing on the right hand side of the definition is squared. There are two answers to this question, one simple, and one complex. The simple answer is that including this square term makes the ensemble fidelity more naturally related to the entanglement fidelity, as defined below. The more complex answer is that quantum information is, at present, in a state of infancy and it is not entirely clear what the ‘correct’ definitions for notions such as information preservation are! Nevertheless, as we shall see in Chapter 12, the ensemble average fidelity and the entanglement fidelity give rise to a rich theory of quantum information, which leads us to believe that these measures are on the right track, even though a complete theory of quantum information has not yet been developed.&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To answer your second question as to why not look at the fidelity of $\bar{\rho}$, there's a nice point mentioned in &quot;Distinguishability measures between ensembles of quantum states&quot; which I think is in PhysRevA but there's an arXiv version &lt;a href=&quot;https://arxiv.org/pdf/0812.3832.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The point they mention on pg 4, is suppose you have two ensembles $rho$ and $\sigma$ which happen to have the same ensemble average density matrix, $\bar{\rho}=\bar{\sigma}$, then the fidelity $F(\bar{\rho},\bar{\sigma})$ can't &#xA;distinguish between them.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Update 2: Re Mithrandir24601&lt;/strong&gt;&#xA;So one definition for gate fidelity is motivated by thinking what's the worst-case behaviour of a channel $\mathcal{E}$, for a given input state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$F_{min}=\min_{|\psi\rangle}F(|\psi\rangle\langle\psi|,\mathcal{E}(|\psi\rangle\langle\psi|))\equiv\min_{|\psi\rangle}F(|\psi\rangle,\mathcal{E}(|\psi\rangle\langle\psi|))$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Due to concavity in both arguments you can restrict to pure states in this minimising, the equivalence in the second part is just notation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In defining how well a gate is implemented one can look as well at a worst case implementation of a unitary gate $U$ by a channel $\mathcal{E}$  by defining&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$F(U,\mathcal{E})=\min_{|\psi\rangle}F(U|\psi\rangle,\mathcal{E}(|\psi\rangle\langle\psi|))$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the formula you've given and the paper you've linked, they integrate over $\psi$, with an appropriate measure$^*$. This makes me think this should be regarded instead as an average fidelity $\bar{F}(U,\tilde{U})$, which you can imagine might be more useful in practical experiments, especially if you're repeating the experiment. It's probably unlikely to achieve the exact minimum.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There's an arXiv version of a paper &lt;a href=&quot;https://arxiv.org/pdf/quant-ph/0205035.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt; by Michael Nielsen where he talks about average gate fidelity.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The only extra difference between fidelity for a gate and average fidelity of a gate mentioned vs the formula you initially provided, is the square of the trace: $[\operatorname{trace}]^2$ you have. As in &lt;strong&gt;Update 1&lt;/strong&gt; some people prefer to use $F^2$ as the fidelity rather than $F$, as it can supposedly be connected more readily to entanglement fidelity. I do need to read a bit more about that to comment properly.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;($\,^*$) &lt;em&gt;Aside&lt;/em&gt;: I think calling it a 'Haar measure' might be misleading, I've seen in it in papers as well. As far as I know, the space of pure states is usually topologically $\Bbb{CP}^n$, for an $n$-dimensional hilbert space. Apparently the measure they use is inherited from the haar measure on $U(n)$ by a quotient or so I've read here: &lt;a href=&quot;https://physics.stackexchange.com/a/98869/41998&quot;&gt;https://physics.stackexchange.com/a/98869/41998&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="197" LastEditorUserId="197" LastEditDate="2018-03-26T11:34:41.037" LastActivityDate="2018-03-26T11:34:41.037" CommentCount="5" />
  <row Id="182" PostTypeId="2" ParentId="136" CreationDate="2018-03-17T13:22:42.823" Score="4" Body="&lt;p&gt;I'll add a small bit complementing the other answers, just about the idea of measurement. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Measurement is usually taken as a postulate of quantum mechanics. There's usually some preceding postulates about hilbert spaces, but following that&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Every measurable physical quantity $A$ is described by an operator $\hat{A}$ acting on a Hilbert space $\mathcal{H}$. This operator is called an observable, and it's eigenvalues are the possibly outcomes of a measurement.&lt;/li&gt;&#xA;&lt;li&gt;If a measurement is made of the observable $A$, in the state of the system $\psi$, and the outcome is $a_n$, then the state of the system immediately after measurement is $$\frac{\hat{P}_n|\psi\rangle}{\|\hat{P}_n|\psi\rangle\|},$$ where $\hat{P}_n$ is the projector onto the eigen-subspace of the eigenvalue $a_n$.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Normally the projection operators themselves should satisfy $\hat{P}^\dagger=\hat{P}$ and $\hat{P}^2=\hat{P}$, which means they themselves are observables by the above postulates, and their eigenvalues $1$ or $0$. Supposing we take one of the $\hat{P}_n$ above, we can interpret the $1,0$ eigenvalues as a binary yes/no answer to whether the observable quantity $a_n$ is available as an outcome of measurement of the state $|\psi\rangle$.&lt;/p&gt;&#xA;" OwnerUserId="197" LastActivityDate="2018-03-17T13:22:42.823" CommentCount="0" />
  <row Id="1182" PostTypeId="1" AcceptedAnswerId="1203" CreationDate="2018-03-17T14:03:05.840" Score="13" ViewCount="192" Body="&lt;p&gt;Since access to quantum devices capable of quantum computing is still extremely limited, it is of interest to &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/163/building-a-quantum-computer-in-simulation&quot;&gt;simulate quantum computations on a classical computer&lt;/a&gt;. Representing the state of $n$ qubits as a vector takes $2^n$ elements, which greatly restricts the number of qubits one can consider in such simulations.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Can one use a representation&lt;sup&gt;1&lt;/sup&gt; that is more compact, in the sense that it uses less memory and/or computational power than the simple vector representation? How does it work?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;While easy to implement, it is clear that the vector representation is wasteful for states that exhibit sparsity and/or redundancy in their vector representation. For a concrete example, consider the 3-qubit state $(1/\sqrt{3}, 1/\sqrt{3},0,0,0,-1/\sqrt{3}, 0,0)^T$. It has $2^3$ elements but they only assume $3$ possible values, with most of the elements being $0$. Of course, to be useful in simulating a quantum computation we would also need to consider how to represent gates and the action of gates on qubits, and including something about these would be welcome, but I would be happy to hear just about qubits too.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sub&gt;&#xA;1. Notice that I am asking about the representations, not software, libraries or articles that might utilize/present such representations. If you present and explain a representation you are very welcome to mention where it is already used though. &#xA;&lt;/sub&gt;&lt;/p&gt;&#xA;" OwnerUserId="144" LastEditorUserId="23" LastEditDate="2018-03-17T23:13:51.883" LastActivityDate="2018-04-05T09:15:38.153" Title="How to compactly represent multiple qubit states?" Tags="&lt;simulation&gt;&lt;qubit&gt;" AnswerCount="3" CommentCount="3" FavoriteCount="2" />
  <row Id="1183" PostTypeId="2" ParentId="1182" CreationDate="2018-03-17T15:06:27.663" Score="8" Body="&lt;p&gt;$\newcommand{\ket}[1]{\left|#1\right&amp;gt;}$I'm not sure using sparsity is a good approach here: even single-qubit gates could easily turn a sparse state into a dense one.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But you can use the stabilizer formalism if you only use &lt;a href=&quot;https://en.wikipedia.org/wiki/Gottesman%E2%80%93Knill_theorem&quot; rel=&quot;nofollow noreferrer&quot;&gt;Clifford gates&lt;/a&gt;. Here is a short recap (&lt;a href=&quot;https://quantumcomputing.meta.stackexchange.com/q/54/104&quot;&gt;notation&lt;/a&gt;):&lt;br&gt;&#xA;The single-qubit &lt;a href=&quot;https://en.wikipedia.org/wiki/Pauli_group&quot; rel=&quot;nofollow noreferrer&quot;&gt;Pauli group&lt;/a&gt; is $G_1=\langle X, Y, Z\rangle$, i.e. all possible products of Pauli matrices (including $\mathbb{I}$). The Pauli group of several qubits is the tensor product space of $G_1$, $G_n=G_1^{\otimes n}$. The stabilizer of a state $\ket{\psi}$ is the subgroup of the Pauli group of all operators that stabilize $\ket{\psi}$, which means $s \ket{\psi} = \ket{\psi}$. It is important to note that this only works for specific (but important) states. I will give an example below. The restriction to elements of the Pauli group is not necessary but common. The stabilizer is generated by operators $s_1$, $s_2$, ... $s_n$. The stabilizer uniquely defines the state and is an efficient description: instead of $2^n-1$ complex numbers we can use $4n^2$ bits ($G_1$ has 16 elements). When we apply a gate $U$, the stabilizer generators update according to $s_i \to U^\dagger s_i U$. A gate that maps Pauli operators to Pauli operators is called Clifford gates. So these are the gates that will not &quot;mess up&quot; our description of the state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Graph states are an important example for the stabilizer formalism described above. Consider an (undirected) mathematical graph, which consists of $n$ vertices $V$ and edges $E\subset V\times V$. Each vertex corresponds to one qubit. Let us denote the graph by $G=(V,E)$. A graph state is produced from the state $\ket{+}^{\otimes n}$, where $\ket{+}=\frac{1}{\sqrt{2}} (\ket{0}+\ket{1})$ by applying a controlled-phase gate $C_Z$ for each pair of vertices which are connected. The stabilizer is generated by $$s_v= X_v \prod_{\substack{w\in V\\ (v,w)\in E}} Z_w.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example start with the two-qubit state $\ket{\phi}=\ket{+}\otimes \ket{+}$. The stabilizer is $\langle X\otimes \mathbb{I}, \mathbb{I}\otimes X \rangle$. Now apply the $C_Z$ gate to obtain $\langle X \otimes Z, Z \otimes X \rangle$. (The state is $\ket{\phi'}=\frac{1}{2}(1,1,1,-1)^T$, which is local unitary equivalent to a Bell state)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The stabilizer formalism also plays an important role in quantum error correction.&lt;/p&gt;&#xA;" OwnerUserId="104" LastEditorUserId="104" LastEditDate="2018-03-19T13:34:21.730" LastActivityDate="2018-03-19T13:34:21.730" CommentCount="0" />
  <row Id="1184" PostTypeId="2" ParentId="180" CreationDate="2018-03-17T18:31:27.890" Score="5" Body="&lt;p&gt;It's a not-so-ideal-world and in short, &lt;strong&gt;architecture of quantum computers depends A LOT on the &quot;hardware&quot; used&lt;/strong&gt;. There are currently several &quot;models&quot; for physical implementation of quantum computers and all of them require considerably distinct architecture. For example superconducting quantum computers have to be kept at close to absolute zero temperature. In trapped ion quantum computers there are lasers applied to induce coupling between the qubit states. For optical quantum computers you need  linear optical elements (including beam splitters, phase shifters, and mirrors) to process quantum information, and photon detectors and quantum memories to detect and store quantum information. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here's a list of the common architectures, as stated on &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_computing#Developments&quot; rel=&quot;noreferrer&quot;&gt;Wikipedia&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;ul&gt;&#xA;  &lt;li&gt;Superconducting quantum computing (qubit implemented by the state of small superconducting circuits (Josephson junctions))&lt;/li&gt;&#xA;  &lt;li&gt;Trapped ion quantum computer (qubit implemented by the internal state of trapped ions)&lt;/li&gt;&#xA;  &lt;li&gt;Optical lattices (qubit implemented by internal states of neutral atoms trapped in an optical lattice)&lt;/li&gt;&#xA;  &lt;li&gt;Quantum dot computer, spin-based (e.g. the Loss-DiVincenzo quantum computer) (qubit given by the spin states of trapped electrons)&lt;/li&gt;&#xA;  &lt;li&gt;Quantum dot computer, spatial-based (qubit given by electron position in double quantum dot)&lt;/li&gt;&#xA;  &lt;li&gt;Nuclear magnetic resonance on molecules in solution (liquid-state NMR) (qubit provided by nuclear spins within the dissolved molecule)&lt;/li&gt;&#xA;  &lt;li&gt;Solid-state NMR Kane quantum computers (qubit realized by the nuclear spin state of phosphorus donors in silicon)&lt;/li&gt;&#xA;  &lt;li&gt;Electrons-on-helium quantum computers (qubit is the electron spin)&lt;/li&gt;&#xA;  &lt;li&gt;Cavity quantum electrodynamics (CQED) (qubit provided by the internal state of trapped atoms coupled to high-finesse cavities)&lt;/li&gt;&#xA;  &lt;li&gt;Molecular magnet (qubit given by spin states)&lt;/li&gt;&#xA;  &lt;li&gt;Fullerene-based ESR quantum computer (qubit based on the electronic spin of atoms or molecules encased in fullerenes)&lt;/li&gt;&#xA;  &lt;li&gt;Linear optical quantum computer (qubits realized by processing states of different modes of light through linear elements e.g.&#xA;  mirrors, beam splitters and phase shifters)&lt;/li&gt;&#xA;  &lt;li&gt;Diamond-based quantum computer (qubit realized by electronic or nuclear spin of nitrogen-vacancy centers in diamond)&lt;/li&gt;&#xA;  &lt;li&gt;Bose–Einstein condensate-based quantum computer&lt;/li&gt;&#xA;  &lt;li&gt;Transistor-based quantum computer – string quantum computers with entrainment of positive holes using an electrostatic trap&lt;/li&gt;&#xA;  &lt;li&gt;Rare-earth-metal-ion-doped inorganic crystal based quantum computers(qubit realized by the internal electronic state of dopants&#xA;  in optical fibers)&lt;/li&gt;&#xA;  &lt;li&gt;Metallic-like carbon nanospheres based quantum computers.&lt;/li&gt;&#xA;  &lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-17T19:19:57.677" LastActivityDate="2018-03-17T19:19:57.677" CommentCount="0" />
  <row Id="1185" PostTypeId="1" AcceptedAnswerId="1186" CreationDate="2018-03-18T02:05:19.633" Score="14" ViewCount="203" Body="&lt;p&gt;Most reversible quantum algorithms use standard gates like Toffoli&amp;nbsp;gate (CCNOT) or Fredkin&amp;nbsp;gate (CSWAP). Since some operations require a constant $\left|0\right&amp;gt;$ as input and the number of inputs and outputs is equal, &lt;em&gt;garbage qubits&lt;/em&gt; (or &lt;em&gt;junk qubits&lt;/em&gt;) appear in the course of the computation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, a principal circuit like $\left|x\right&amp;gt;\mapsto\left|f(x)\right&amp;gt;$ actually becomes $\left|x\right&amp;gt;\left|0\right&amp;gt;\mapsto\left|f(x)\right&amp;gt;\left|g\right&amp;gt;$,&lt;br&gt;&#xA;where $\left|g\right&amp;gt;$ stands for the garbage qubit(s).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Circuits that preserve the original value ends up with $\left|x\right&amp;gt;\left|0\right&amp;gt;\left|0\right&amp;gt;\mapsto\left|x\right&amp;gt;\left|f(x)\right&amp;gt;\left|g\right&amp;gt;$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I understand that garbage qubits are inevitable if we want the circuit to stay reversible, but many sources${}^1$ claim that it is important to eliminate them. &lt;strong&gt;Why is it so?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;${}^1$ Due to requests for sources, see for example &lt;a href=&quot;https://arxiv.org/pdf/quant-ph/9802065.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;this arXiv paper&lt;/a&gt;, pg 8, which says &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;However, each of these simple operations contains a number of additional, auxiliary qubits, which serve to store the intermediate results, but are not relevant at the end. In order not to waste any unneccesary [sic] space, it is therefore important to reset these qubits to 0 so that we are able to re–use them &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;or &lt;a href=&quot;https://arxiv.org/abs/1608.01228&quot; rel=&quot;nofollow noreferrer&quot;&gt;this arXiv paper&lt;/a&gt; which says&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The removal of garbage qubits and ancilla qubits are essential in designing an efficient quantum circuit.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;or the many other sources - a &lt;a href=&quot;https://www.google.com/search?q=important+to+get+rid+of+garbage+qubits&amp;amp;rlz=1CAACAJ_enUS746US747&amp;amp;oq=important+to+get+rid+of+garbage+qubits&amp;amp;aqs=chrome..69i57j0l5.4714j0j7&amp;amp;sourceid=chrome&amp;amp;ie=UTF-8&quot; rel=&quot;nofollow noreferrer&quot;&gt;google search&lt;/a&gt; produces many hits.&lt;/p&gt;&#xA;" OwnerUserId="31" LastEditorUserId="91" LastEditDate="2018-06-07T14:53:00.373" LastActivityDate="2018-06-07T14:59:39.733" Title="Why is it important to eliminate the garbage qubits?" Tags="&lt;qubit&gt;&lt;quantum-gate&gt;&lt;circuit-model&gt;&lt;universal-gates&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="4" />
  <row Id="1186" PostTypeId="2" ParentId="1185" CreationDate="2018-03-18T05:22:32.687" Score="12" Body="&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Wave_interference#Quantum_interference&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum interference&lt;/a&gt; is the heart and soul of quantum computation. Whenever you have junk qubits they're going to prevent interference. This is actually a very simple but very important point. Let's say we have a function $f:\{0,1\}\to\{0,1\}$ which maps a single bit to a single bit. Say $f$ is a very simple function, like $f(x)=x$. Let's say we had a circuit $C_f$ which inputs $x$ and outputs $f(x)$. Now, of course, this was a reversible circuit, and could be implemented using a unitary transformation $|x\rangle\to|x\rangle$. Now, we could feed in $\frac{1}{\sqrt{2}}|0\rangle + \frac{1}{\sqrt{2}}|1\rangle$ and the output would also be $\frac{1}{\sqrt{2}}|0\rangle + \frac{1}{\sqrt{2}}|1\rangle$. Let us now apply &lt;a href=&quot;https://en.wikipedia.org/wiki/Hadamard_transform&quot; rel=&quot;nofollow noreferrer&quot;&gt;Hadamard transform&lt;/a&gt; gate and measure what we get. If you apply the Hadamard transform to this state $\frac{1}{\sqrt{2}}|0\rangle + \frac{1}{\sqrt{2}}|1\rangle$, you get the $|0\rangle$ state, and you see $0$ with probability $1$. In this case there was no junk created in the intermediate steps, while converting the classical circuit to a quantum circuit. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;But, let's say we created some junk in an intermediate step when using a circuit like this one:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/3gwhz.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/3gwhz.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For this circuit, if we start off in the state $|x\rangle|0\rangle = \left(\frac{1}{\sqrt{2}}|0\rangle + \frac{1}{\sqrt{2}}|1\rangle \right)|0\rangle$, after the first step we get $\frac{1}{\sqrt{2}}|00\rangle + \frac{1}{\sqrt{2}}|11\rangle$. If we apply the Hadamard transform to the first qubit, we end up with:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\frac{1}{2}|00\rangle + \frac{1}{2}|01\rangle + \frac{1}{2}|10\rangle + \frac{1}{2}|11\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we make a measurement on the first qubit we get $0$ with probability $\frac{1}{2}$, unlike in the previous case where we could see $0$ with probability $1$! The only difference between the two cases was the creation of a junk bit in an intermediate step, which was not gotten rid of, thus leading to a difference in the final result of the computation (since the junk qubit got entangled with the other qubit). We will see a different interference pattern than in the previous case when the Hadamard transform is applied. This is exactly why we don't like to keep junk around when we are doing quantum computation: it prevents interference.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Source:&lt;/strong&gt; Professor Umesh Vazirani's &lt;a href=&quot;https://www.youtube.com/watch?v=S-SmDlcvpmw&quot; rel=&quot;nofollow noreferrer&quot;&gt;lecture&lt;/a&gt; on EdX.&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-06-07T14:59:39.733" LastActivityDate="2018-06-07T14:59:39.733" CommentCount="4" />
  <row Id="1187" PostTypeId="2" ParentId="171" CreationDate="2018-03-18T09:22:08.220" Score="5" Body="&lt;blockquote&gt;&#xA;  &lt;ul&gt;&#xA;  &lt;li&gt;Is there proof that the D-wave (one) is a quantum computer and is effective?&lt;/li&gt;&#xA;  &lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;D-Wave Video - Offers an explanation of: &quot;How do we know ...&quot;: &lt;a href=&quot;https://youtu.be/kq9VqR0ZGNc&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://youtu.be/kq9VqR0ZGNc&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One analogy you might make with the D-Wave One, an &lt;a href=&quot;https://en.wikipedia.org/wiki/Adiabatic_theorem#Diabatic_vs._adiabatic_processes&quot; rel=&quot;nofollow noreferrer&quot;&gt;adiabatic&lt;/a&gt; ('analog') computer, is to the &quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/South-pointing_chariot#Geometrical_properties&quot; rel=&quot;nofollow noreferrer&quot;&gt;south-pointing chariot&lt;/a&gt;&quot; or the &quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/Antikythera_mechanism&quot; rel=&quot;nofollow noreferrer&quot;&gt;Antikythera mechanism&lt;/a&gt;&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A lengthy explanation is offered in this Ars Technica (Wired) article: &quot;&lt;a href=&quot;https://arstechnica.com/science/2016/06/going-digital-may-make-analog-quantum-computer-scaleable/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Going digital may make analog quantum computer scaleable&lt;/a&gt;&quot;:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&quot;... They &lt;strong&gt;pretty much&lt;/strong&gt; all fall into &lt;strong&gt;two&lt;/strong&gt; categories. In most labs, researchers work on what could be called a &lt;strong&gt;digital quantum computer&lt;/strong&gt;, which has the quantum equivalent of logic gates, and qubits are based on well-defined and well-understood quantum states. The other camp works on &lt;strong&gt;analog&lt;/strong&gt; devices called &lt;strong&gt;adiabatic quantum computers&lt;/strong&gt;. In these devices, qubits do not perform discrete operations, but continuously evolve from some easily understood initial state to a final state that provides the answer to some problem&quot; (end quote), or &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_annealing&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum annealing&lt;/a&gt;. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&quot;Adiabatic quantum computers are inherently analog devices: each qubit is driven by how strongly it is coupled to every other qubit. Computation is performed by continuously adjusting these couplings between some starting and final value. Tiny errors in the coupling—due to environmental effects, for instance—tend to build up and throw off the final value.&quot;.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&quot;Digital quantum computing, which uses logic operations and quantum gates, offers the possibility of error correction. By encoding information in multiple qubits, you can detect and correct errors. Unfortunately, digital qubits are delicate things compared to those used in adiabatic quantum computers, and the ability to ...&quot;. (Go read the article if you don't want a condensed version).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&quot;What about a hybrid approach? That's the question asked by a international group of researchers in a recently-published paper in Nature. They’ve tested a system where the computation is performed by qubits that were operating as an adiabatic quantum computer, but with connections between the adiabatic qubits is controlled via a digital network of qubits. This allows the benefits of scale and flexibility that you get from adiabatic quantum computing, while also making the connections less susceptible to noise.&quot;.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;So, yes. It is a computer and uses quantum methods.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Adiabatic_quantum_computation&quot; rel=&quot;nofollow noreferrer&quot;&gt;Adiabatic quantum computation&lt;/a&gt; (AQC) is a form of quantum computing which relies on the adiabatic theorem to do calculations&lt;a href=&quot;https://en.wikipedia.org/wiki/Adiabatic_theorem#Diabatic_vs._adiabatic_processes&quot; rel=&quot;nofollow noreferrer&quot;&gt;1&lt;/a&gt; and is closely related to, and may be regarded as a subclass of, quantum annealing.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Another analogy, probably as &lt;em&gt;unfair&lt;/em&gt; as the last, is that AQC is a &lt;a href=&quot;https://en.wiktionary.org/wiki/one-trick-ponyism#English&quot; rel=&quot;nofollow noreferrer&quot;&gt;one-trick-ponyism&lt;/a&gt;. It's limited in what it can do, but it does it quickly and well.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;ul&gt;&#xA;  &lt;li&gt;&lt;p&gt;So, I ask:&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;I know that D-wave claims to use some sort of quantum annealing. Is there (dis)proof of the D-wave actually using quantum annealing (with effect) in its computations?&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Has it been conclusively shown that the D-wave is (in)effective? If not, is there a clear overview of the work to attempt this?&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There is  proof that  it is  effective when used correctly for doing what it was designed to do:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;a href=&quot;https://arxiv.org/abs/1802.10091&quot; rel=&quot;nofollow noreferrer&quot;&gt;Blockchain platform with proof-of-work based on analog Hamiltonian optimisers&lt;/a&gt;&quot; by Kirill P. Kalinin, Natalia G. Berloff, 27 Feb 2018.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;University of Cambridge, &quot;&lt;a href=&quot;http://www.damtp.cam.ac.uk/user/ngb23/polgraph.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Polariton Graph Simulator (Optimizer): an analog Hamiltonian simulaton&lt;/a&gt;&quot;, Natalia Berloff.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;a href=&quot;https://www.spiedigitallibrary.org/conference-proceedings-of-spie/9648/964816/Performance-of-quantum-annealing-hardware/10.1117/12.2202661.short&quot; rel=&quot;nofollow noreferrer&quot;&gt;Performance of quantum annealing hardware&lt;/a&gt;&quot; by Damian S. Steiger; Bettina Heim, 22 October 2015.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There exists important backers and some skeptics of D-Wave.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Address concerns expressed in comments - Update: 19 March 2018:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here is an article from  Nature.com entitled: &quot;&lt;a href=&quot;https://www.nature.com/articles/srep36847&quot; rel=&quot;nofollow noreferrer&quot;&gt;Triode for Magnetic Flux Quanta&lt;/a&gt;&quot; which explain the use of &lt;a href=&quot;https://en.wikipedia.org/wiki/Abrikosov_vortex&quot; rel=&quot;nofollow noreferrer&quot;&gt;Abrikosov vortices&lt;/a&gt; to hold quantized information bits, further clarified (or not) in the article: &quot;&lt;a href=&quot;https://www.nature.com/articles/ncomms9628&quot; rel=&quot;nofollow noreferrer&quot;&gt;Single Abrikosov vortices as quantized information bits&lt;/a&gt;&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;An &lt;strong&gt;oversimplified&lt;/strong&gt; analogy is that the &lt;a href=&quot;https://en.wikipedia.org/wiki/Qubit&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum qubits&lt;/a&gt; are (not at all) like &lt;a href=&quot;https://en.wikipedia.org/wiki/Magnetic-core_memory&quot; rel=&quot;nofollow noreferrer&quot;&gt;magnetic core memory&lt;/a&gt;, the difference is:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;A single magnetic core holds a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bit&quot; rel=&quot;nofollow noreferrer&quot;&gt;binary digit&lt;/a&gt;, a bit, (like a fraction of a letter in a book, so you would use 8 bits to represent more than just a letter but all of the &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot; rel=&quot;nofollow noreferrer&quot;&gt;ASCII&lt;/a&gt; Alphabet, letters digits and control codes). A bit would have to be in one state or the other.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;A qubit, by utilizing quantum mechanics, allows the qubit to be in a superposition of both states at the same time, a property that is fundamental to quantum computing. A qbit can be in one state, the other, or both; think of it as &lt;a href=&quot;https://en.wikipedia.org/wiki/Ternary_numeral_system&quot; rel=&quot;nofollow noreferrer&quot;&gt;trinary&lt;/a&gt; on steroids, because qubits can perform two calculations simultaneously (and that's why they are both comparable and incomparable, a superposition of both states; a new way if thinking).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Look at this image of a magnetic memory and a quantum processor - quite different from an x86 processor:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/E7fRe.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/E7fRe.jpg&quot; alt=&quot;Which is which?&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A simple explanation of the relevance and degree of proof is offered in this video by D-Wave called: &quot;D-Wave Lab Tour Part 3 (of 3) - The D-Wave Processor&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=AGByZoYUlU0&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://www.youtube.com/watch?v=AGByZoYUlU0&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="278" LastEditorUserId="278" LastEditDate="2018-04-03T16:02:14.413" LastActivityDate="2018-04-03T16:02:14.413" CommentCount="5" />
  <row Id="1188" PostTypeId="5" CreationDate="2018-03-18T14:36:55.763" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-18T14:36:55.763" LastActivityDate="2018-03-18T14:36:55.763" CommentCount="0" />
  <row Id="1189" PostTypeId="4" CreationDate="2018-03-18T14:36:55.763" Score="0" Body="For questions about security aspects relevant to quantum computing." OwnerUserId="11" LastEditorUserId="26" LastEditDate="2018-04-15T15:03:53.160" LastActivityDate="2018-04-15T15:03:53.160" CommentCount="0" />
  <row Id="1190" PostTypeId="5" CreationDate="2018-03-18T14:39:21.350" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-18T14:39:21.350" LastActivityDate="2018-03-18T14:39:21.350" CommentCount="0" />
  <row Id="1191" PostTypeId="4" CreationDate="2018-03-18T14:39:21.350" Score="0" Body="For questions asking about applications of quantum computers to solve practical problems" OwnerUserId="11" LastEditorUserId="26" LastEditDate="2018-07-05T09:13:35.893" LastActivityDate="2018-07-05T09:13:35.893" CommentCount="0" />
  <row Id="1192" PostTypeId="1" AcceptedAnswerId="1199" CreationDate="2018-03-18T21:53:20.003" Score="13" ViewCount="380" Body="&lt;p&gt;Daniel Sank mentioned in &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/171/is-there-proof-that-the-d-wave-one-is-a-quantum-computer-and-is-effective/172?noredirect=1#comment426_172&quot;&gt;a comment&lt;/a&gt;, responding to (my) opinion that the &lt;em&gt;constant&lt;/em&gt; speed-up of $10^8$ on a problem admitting a polynomial time algorithm is meager, that &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Complexity theory is way too obsessed with infinite size scaling limits. What matters in real life is how fast you get the answer to your problem. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;In Computer Science, it is common to ignore constants in algorithms, and all in all, this has turned out to work rather well. (I mean, there &lt;em&gt;are&lt;/em&gt; good and &lt;em&gt;practical&lt;/em&gt; algorithms. I hope you will grant me (theoretical) algorithms researchers have had a rather large hand in this!)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But, I do understand that this is a slightly different situation as now we are:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Not comparing two algorithms running on the same computer, but two (slightly) different algorithms on two &lt;em&gt;very different&lt;/em&gt; computers.&lt;/li&gt;&#xA;&lt;li&gt;We now are working with &lt;em&gt;quantum&lt;/em&gt; computers, for which perhaps traditional perfomance measurements may be insufficient.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;In particular, the methods of algorithm analysis are merely &lt;em&gt;methods&lt;/em&gt;. I think radically new computing methods calls for a critical review of our current performance evaluation methods!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, my question is:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When comparing the performance of algorithms on a quantum computer versus algorithms on a classical computer, is the practice of 'ignoring' constants a good practice?&lt;/p&gt;&#xA;" OwnerUserId="253" LastEditorUserId="26" LastEditDate="2018-03-29T18:12:47.570" LastActivityDate="2018-03-29T18:12:47.570" Title="Is the common Computer Science usage of 'ignoring constants' useful when comparing classical computing with quantum computing?" Tags="&lt;quantum-algorithms&gt;&lt;performance&gt;&lt;classical-computing&gt;" AnswerCount="3" CommentCount="5" FavoriteCount="1" />
  <row Id="1193" PostTypeId="5" CreationDate="2018-03-18T22:18:31.000" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-18T22:18:31.000" LastActivityDate="2018-03-18T22:18:31.000" CommentCount="0" />
  <row Id="1194" PostTypeId="4" CreationDate="2018-03-18T22:18:31.000" Score="0" Body="For questions about the relation of Quantum Computing and Classical Computing, such as their relative perfomance." OwnerUserId="253" LastEditorUserId="253" LastEditDate="2018-03-19T03:40:06.300" LastActivityDate="2018-03-19T03:40:06.300" CommentCount="0" />
  <row Id="1195" PostTypeId="1" AcceptedAnswerId="1211" CreationDate="2018-03-19T02:39:58.017" Score="7" ViewCount="98" Body="&lt;p&gt;Presently, how much information can a quantum computer store, in how many qubits? What restrictions are there and how does it vary across realizations (efficiency of data storage, ease of reading and writing, etc)?&lt;/p&gt;&#xA;" OwnerUserId="92" LastEditorUserId="92" LastEditDate="2018-03-19T17:31:56.110" LastActivityDate="2018-03-19T22:10:09.547" Title="State of the art in quantum memory" Tags="&lt;quantum-computer&gt;&lt;quantum-memory&gt;" AnswerCount="1" CommentCount="6" />
  <row Id="1196" PostTypeId="1" AcceptedAnswerId="1242" CreationDate="2018-03-19T05:50:31.297" Score="14" ViewCount="87" Body="&lt;p&gt;I'm interested in the model of quantum computation by magic state injection, that is where we have access to the Clifford gates, a cheap supply of ancilla qubits in the computational basis, and a few expensive-to-distill &lt;em&gt;magic states&lt;/em&gt; (usually those that implement S, T gates). I've found that the best scaling is logarithmic in the accuracy $\varepsilon$, specifically $O(\log^{1.6}(1/\varepsilon)$ is what a &lt;a href=&quot;https://arxiv.org/pdf/1209.2426.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;2012 paper offers&lt;/a&gt; to get the accuracy we need in the $S,T$ states. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is this enough to calculate most of the problems we're interested in? Are there any problems that specifically resist QCSI (Quantum Computation by State Injection) because of high overhead, but are more solvable in other models of computation?&lt;/p&gt;&#xA;" OwnerUserId="236" LastEditorUserId="26" LastEditDate="2018-05-07T13:20:43.970" LastActivityDate="2018-05-07T13:20:43.970" Title="How does magic state distillation overhead scale compare to quantum advantages?" Tags="&lt;quantum-speedup&gt;&lt;quantum-error-correction&gt;&lt;qcsi-model&gt;&lt;state-distillation&gt;" AnswerCount="1" CommentCount="3" />
  <row Id="1197" PostTypeId="5" CreationDate="2018-03-19T10:11:25.630" Score="0" Body="&lt;p&gt;As per the paper &lt;a href=&quot;https://arxiv.org/abs/1401.2910&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;em&gt;Defining and detecting quantum speedup&lt;/em&gt;&lt;/a&gt;, the definition of quantum speedup has a few variants:&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Device dependent definition&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Denoting the time for a specific implementation of an algorithm on a classical device to solve a problem of size $N$ as $C\left(N\right)$ and the time for a specific implementation of an algorithm on a quantum device as $Q\left(N\right)$, the first definition of quantum speedup is $$S\left(N\right) = \frac{C\left(N\right)}{Q\left(N\right)}$$&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;Device independent definitions&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Here, independent of devices, a classical algorithm is compared with a quantum algorithm and speedup is the same ratio as for 1. comparing the quantum algorithm, taking time $Q\left(N\right)$, with the classical algorithm, taking time $C\left(N\right)$.&lt;/p&gt;&#xA;&#xA;&lt;ol start=&quot;2&quot;&gt;&#xA;&lt;li&gt;&lt;strong&gt;Provable quantum speedup&lt;/strong&gt;:&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;there exists a proof that no classical algorithm can outperform a given quantum algorithm&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;e.g. &lt;a href=&quot;https://en.wikipedia.org/wiki/Grover%27s_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;Grover's algorithm&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;ol start=&quot;3&quot;&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Strong quantum speedup&lt;/strong&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;using the performance of the best classical algorithm ... whether  such  an  algorithm  is  known  or  not&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Quantum speedup&lt;/strong&gt;: &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;comparing to the&#xA;  best available&#xA;  classical algorithm instead of the best possible classical&#xA;  algorithm&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Potential quantum speedup&lt;/strong&gt;:&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;compared to a specific classical algorithm or a set of classical algorithms&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Limited  quantum speedup&lt;/strong&gt;:&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;comparing specifically with classical algorithms that “correspond” to the quantum algorithm in the sense that they implement the same  algorithmic  approach,  but  on  classical  hardware.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;e.g. comparing &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_annealing&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum annealing&lt;/a&gt; with &lt;a href=&quot;https://en.wikipedia.org/wiki/Simulated_annealing&quot; rel=&quot;nofollow noreferrer&quot;&gt;simulated annealing&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="23" LastEditorUserId="23" LastEditDate="2018-03-19T14:06:09.000" LastActivityDate="2018-03-19T14:06:09.000" CommentCount="0" />
  <row Id="1198" PostTypeId="4" CreationDate="2018-03-19T10:11:25.630" Score="0" Body="For questions about either: comparing the performance of a quantum algorithm with a classical algorithm (or set of classical algorithms) independent of devices; or  the ratio of time to solution of a quantum device running a specific algorithm to a classical device running a specific algorithm" OwnerUserId="23" LastEditorUserId="23" LastEditDate="2018-03-19T14:06:18.737" LastActivityDate="2018-03-19T14:06:18.737" CommentCount="0" />
  <row Id="1199" PostTypeId="2" ParentId="1192" CreationDate="2018-03-19T11:35:37.937" Score="8" Body="&lt;p&gt;The common Computer Science usage of 'ignoring constants' is only useful where the differences in performance of various kinds of hardware architecture or software can be ignored with a little bit of massaging. But even in classical computation, it is important to be aware of the impact of architecture (caching behaviour, hard disk usage) if you want to solve difficult problems, or large problems.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The practise of ignoring constants isn't a practise which is motivated (in the sense of being continually affirmed) from an implementation point of view. It is driven mostly by an interest in an approach to the study of algorithms which is well-behaved under composition and admits simple characterisations, in a manner close to pure mathematics. The speed-up theorems for Turing Machines meant that any sensible definition couldn't attempt to pin down the complexity of problems too precisely in order to arrive at a sensible theory; and besides, in the struggle to find good algorithms for difficult problems, the constant factors weren't the mathematically interesting part...&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This more abstract approach to the study of algorithms was and is largely fruitful. But now we are confronted with a situation where we have two models of computation, where &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;One is in an advanced state of technological maturity (classical computation); and&lt;/li&gt;&#xA;&lt;li&gt;One is in a very immature state, but is attempting to realise a theoretical model which can lead to significant asymptotic improvements (quantum computation).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;In this case, we can ask whether it even makes sense to consider the asymptotic benefit, &lt;em&gt;with or without&lt;/em&gt; careful accounting of the constant factors. Because of the extra effort which may be required to perform scalable quantum computing, not only scalar factors but &lt;em&gt;polynomial&lt;/em&gt; &quot;speedups&quot; in theoretical performance may be washed out once all of the overhead in realising a quantum algorithm is taken into account.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In these early days, there may also be significant differences in performance to different approaches to quantum architecture.&#xA;This could make the choice of architecture as important (if not more important) to how well an algorithm performs than asymptotic analysis &amp;mdash; just as it would matter a lot to you whether you do your conventional computation on a von Neumann machine or a highly distributed network with significant latencies.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The actually important thing for practical computation is &amp;mdash; and has always been &amp;mdash; not just algorithms, but &lt;em&gt;implementations of algorithms&lt;/em&gt;: an algorithm realised in a certain way, on a certain architecture. The common practise of asymptotic analysis which ignores constant factors allows us to pay attention to the systematic, mathematical reasons for differences in the performance of algorithms, and is practically motivated on those occasions when the architectural differences are not so large as to dominate the practical performance.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;With respect to quantum technologies, we are not in that happy situation where we can safely gloss over constant factors in any practical context. But perhaps one day we will be able to do so. This is the long game of quantum information technologies &amp;mdash; until now, nearly the only game that academic computer scientists have ever played, as far as quantum information technology is concerned. Anticipating that day when quantum technology finds its footing, it will be good for us to continue pursuing asymptotic analysis, as &lt;em&gt;one line of investigation&lt;/em&gt; in the performance of quantum algorithms.&lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-03-27T17:10:38.717" LastActivityDate="2018-03-27T17:10:38.717" CommentCount="3" />
  <row Id="1200" PostTypeId="2" ParentId="1192" CreationDate="2018-03-19T11:53:58.923" Score="6" Body="&lt;p&gt;First, there are no scaling analyses of quantum devices like we have for algorithms on CMOS hardware. So talking about $O\left(f\left[N\right]\right)$ is flawed. Second, given the lack of theoretical backing, we have to do scaling analyses with experiments. However, the currently accessible problem sizes ($N$) are rather limited. As such, we do not even know if we are in the asymptotic limit (&quot;the true behavior of the device&quot;). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Therefore, neglecting prefactors (i.e. constant factors) might be premature. Purists will argue that only an improvement in the scaling (&quot;change in slope&quot;) is true speedup. I agree, however, if your quantum device scales as well as the best classical algorithms yet has a $10^{10}$ prefactor, I would call it useful for applications. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Unfortunately, the current state of the art is D-Wave scaling as good as the best algorithms, but with only a $\approx300$ factor advantage over code run on a &lt;em&gt;single&lt;/em&gt; core. Moreover, this is a synthetic benchmark problem and not an application of interest. Far from disruptive... See &lt;a href=&quot;https://arxiv.org/abs/1711.01368&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/1711.01368&lt;/a&gt; for more information.&lt;/p&gt;&#xA;" OwnerDisplayName="user306" LastEditorUserId="23" LastEditDate="2018-03-19T14:54:12.853" LastActivityDate="2018-03-19T14:54:12.853" CommentCount="4" />
  <row Id="1202" PostTypeId="2" ParentId="180" CreationDate="2018-03-19T12:17:14.957" Score="3" Body="&lt;p&gt;At the current state of the art, quite a bit.&#xA;As pointed out by &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1184/55&quot;&gt;the other answer&lt;/a&gt;, different architectures implement qubits in different physical substrates, which results in radically different techniques to generate, evolve, interact and measure the qubits.&#xA;Moreover, different operations are easier in some architectures than in others.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To get something more similar to how we usually program classical computers one needs some kind of &lt;em&gt;compilation pipeline&lt;/em&gt;, mapping a given computation, expressed in an abstract high-level language, down to the specific hardware details of a given architecture.&#xA;This is still a work in progress, but there are people working in this direction. A relevant work that comes to mind is &lt;a href=&quot;https://arxiv.org/abs/1604.01401.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;1604.01401&lt;/a&gt;. Here is the pipeline proposed in this paper:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/6kV3L.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/6kV3L.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In theory, having software suites implementing such a pipeline would allow to write abstract code and have automatically compiled down to work on, say, superconducting chips as well as optical or ion-trap quantum computers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In practice, there are so many things to still work out (first of all how to actually make scalable quantum computers) that it is hard to say how such scheme will work.&lt;/p&gt;&#xA;" OwnerUserId="55" LastActivityDate="2018-03-19T12:17:14.957" CommentCount="0" />
  <row Id="1203" PostTypeId="2" ParentId="1182" CreationDate="2018-03-19T13:08:47.433" Score="7" Body="&lt;p&gt;There are many possible ways to compactly represent a state, the usefulness of which strongly depend on the context.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;First of all, it is important to notice that it is not possible to have a procedure that can map any state into a more efficient representation of the same state (for the same reason why it is obviously not possible to faithfully compress any 2-bit string as a 1-bit string, with a mapping that does not depend on the string).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, as soon as you start making some assumptions, you can find more efficient ways to represent a state in a given context.&#xA;There is a multitude of possible ways to do this, so I'll just mention a few that come to mind:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Already the standard vector representation of a ket state can be thought of as a &quot;compressed representation&quot;, that works under the assumption of the state being &lt;em&gt;pure&lt;/em&gt;. Indeed, you need $4^n-1$ real degrees of freedom to represent an arbitrary (generally mixed) $n$-qubit state, but only $2^{n+1}-2$ to represent a pure one.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;If you assume a state $\rho$ to be &lt;em&gt;almost&lt;/em&gt; pure, that is, such that $\rho$ is sparse in some representation (equivalently, $\rho$ is low rank), then again the state can be efficiently characterised. For a $d$-dimensional system (so $d=2^n$ for an $n$-qubit system), instead of using ~$d^2$ parameters, you can have a faithful representation using only $\mathcal O(r d \log^2 d)$, where $r$ is the sparsity of the state (see &lt;a href=&quot;https://arxiv.org/abs/0909.3304&quot; rel=&quot;nofollow noreferrer&quot;&gt;0909.3304&lt;/a&gt; and the works that came after that).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;If you are only interested in a limited number $|S|$ of expectation values, you can find a compressed representation of an $n$-qubit state of size $\mathcal O(n\log(n)\log(|S|))$. Note that this amounts to an &lt;em&gt;exponential reduction&lt;/em&gt;.  This was shown (I think) in &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0402095&quot; rel=&quot;nofollow noreferrer&quot;&gt;quant-ph/0402095&lt;/a&gt;, but the introduction given in &lt;a href=&quot;https://arxiv.org/pdf/1801.05721.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;1801.05721&lt;/a&gt; may be more accessible for a physicist (as well as presenting improvements in the optimisation method).&#xA;See references in this last paper for a number of similar results.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;If you know that the entanglement of the state is limited (in a sense that can be precisely defined), then again efficient representations can be found, in terms of tensor networks (an introduction is found e.g. in &lt;a href=&quot;https://arxiv.org/abs/1708.00006&quot; rel=&quot;nofollow noreferrer&quot;&gt;1708.00006&lt;/a&gt;). More recently, it was also shown that ground states of some notable Hamiltonians can be represented using &lt;a href=&quot;https://arxiv.org/abs/1606.02318&quot; rel=&quot;nofollow noreferrer&quot;&gt;machine-learning-inspired ansatze&lt;/a&gt; ( (&lt;a href=&quot;https://arxiv.org/abs/1606.02318&quot; rel=&quot;nofollow noreferrer&quot;&gt;1606.02318&lt;/a&gt; and many following works). This was also recently shown/claimed to be equivalent to a specific Tensor Network representation however (&lt;a href=&quot;https://arxiv.org/abs/1710.04045&quot; rel=&quot;nofollow noreferrer&quot;&gt;1710.04045&lt;/a&gt;) so I'm not sure whether it should go to a category of its own.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Note that in all of the above you can more efficiently represent a given state, but to then simulate the &lt;em&gt;evolution&lt;/em&gt; of the system you generally need do go back to the original inefficient representation.&#xA;If you want to efficiently represent the &lt;em&gt;dynamics&lt;/em&gt; of a state through a given evolution, you again need assumptions on the evolution for this to be possible.&#xA;The only result that comes to mind on this regard is the classical (as in enstablished, not as in &quot;non quantum&quot;) &lt;a href=&quot;https://en.wikipedia.org/wiki/Gottesman%E2%80%93Knill_theorem&quot; rel=&quot;nofollow noreferrer&quot;&gt;Gottesman-Knill theorem&lt;/a&gt;, which allows to efficiently simulate any Clifford quantum circuit.&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-04-05T09:15:38.153" LastActivityDate="2018-04-05T09:15:38.153" CommentCount="0" />
  <row Id="1206" PostTypeId="1" CreationDate="2018-03-19T16:31:15.507" Score="17" ViewCount="184" Body="&lt;p&gt;To represent a quantum computer's state, all the qubits contribute to one state vector (this is one of the major differences between quantum and classical computing as I understand it). My understanding is that it's possible to measure only one qubit out of a system of multiple qubits. How does measuring that one qubit affect the whole system (specifically, how does it affect the state vector)?&lt;/p&gt;&#xA;" OwnerUserId="91" LastActivityDate="2018-09-01T03:38:18.393" Title="How does measurement of one qubit affect the others?" Tags="&lt;qubit-state&gt;&lt;measurement&gt;" AnswerCount="3" CommentCount="0" FavoriteCount="2" />
  <row Id="1207" PostTypeId="2" ParentId="1206" CreationDate="2018-03-19T17:02:13.503" Score="12" Body="&lt;p&gt;There are a lot of different ways of looking at qubits, and the state vector formalism is just one of them. In a general linear-algebraic sense a measurement is projection onto a basis. Here I will provide insight with an example from the Pauli observable point of view, that is the usual circuit model of QC. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Firstly, it's of interest which basis the state vector is being provided in-- every measurement operator comes with a set of eigenstates, and whatever measurements you look at (eg. $X,Y,Z, XX, XZ$, etc.) determine the basis that might be best for you to write the state vector in. The easiest way to answer your question is if you know which basis is of interest to you, and more importantly, &lt;em&gt;whether it commutes with the measurement you just made&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So for simplicity's sake, let's say you start with two coupled qubits in an arbitrary state written in the $Z$-basis for both qubits:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$| \psi \rangle = a | 0_{Z} \rangle \otimes | 0_{Z} \rangle +b | 0_{Z} \rangle \otimes | 1_{Z} \rangle + c | 1_{Z} \rangle \otimes | 0_{Z} \rangle  + d | 1_{Z} \rangle \otimes | 1_{Z} \rangle $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The simplest possible measurements you could make would be $Z_{1}$, that is the $Z$ operator on the first qubit, followed by $Z_{2}$, the $Z$ operator on the second qubit. What does measurement do? It projects the state into one of the eigenstates. You can think of this as eliminating all possible answers that are inconsistent with the one we just measured. For instance, say we measure $Z_{1}$ and obtain the outcome $1$, then the resulting state we would have would be:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$| \psi \rangle = \frac{1}{\sqrt{|c|^{2} +|d|^{2}}} \left(c | 1_{Z} \rangle \otimes | 0_{Z} \rangle  + d | 1_{Z} \rangle \otimes | 1_{Z} \rangle \right) $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that the coefficient out front is just for renormalization. So our probability of measuring $Z_{2}=0$ is $\frac{1}{|c|^{2} +|d|^{2}} |c^{2}|$. Note this is different from the probability we had in the initial state, which was $|a|^{2}+|c|^{2}$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Suppose the next measurement you make does not commute with the previous one, however. This is trickier because you have to implement a change of basis on the state vector in order to understand the probabilities. With Pauli measurements, though, it tends to be easy since the eigenbases relate in a nice way, that is:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$| 0_{Z} \rangle = \frac{1}{\sqrt{2}} (|0_{X}\rangle + |1_{X} \rangle )$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$| 1_{Z} \rangle = \frac{1}{\sqrt{2}} (|0_{X}\rangle - |1_{X} \rangle )$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A good way to check your understanding: What is the probability of measuring $X= +1$ after the $Z_{1}=1$ measurement above? What is the probability if we have not made the $Z_{1}$ measurement? Then a more complicated question is to look at product operators that act on both qubits at once, for instance, how does a measurement of $Z_{1}Z_{2}=+1$ affect the initial state? Here $Z_{1}Z_{2}$ measures the product of the two operators. &lt;/p&gt;&#xA;" OwnerUserId="236" LastEditorUserId="104" LastEditDate="2018-03-20T15:57:08.703" LastActivityDate="2018-03-20T15:57:08.703" CommentCount="1" />
  <row Id="1208" PostTypeId="1" CreationDate="2018-03-19T18:06:32.863" Score="18" ViewCount="321" Body="&lt;p&gt;A lot of people believe that quantum computers can prove to be a pivotal step in creating new machine learning and AI algorithms that can give a huge boost to the field. There have even been studies that our brain may be a quantum computer, but so far there is no consensus among the researchers. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Given that I am completely new to the field, I wanted to know if there has been some research done in the application of quantum computers in AI that, theoretically speaking, may perform better at some task or converge faster than modern deep learning algorithms.&lt;/p&gt;&#xA;" OwnerUserId="320" LastEditorUserId="26" LastEditDate="2018-03-29T18:11:52.170" LastActivityDate="2018-04-01T08:14:11.497" Title="Is there any potential application of quantum computers in machine learning or AI?" Tags="&lt;quantum-computer&gt;&lt;machine-learning&gt;&lt;artificial-intelligence&gt;" AnswerCount="4" CommentCount="2" FavoriteCount="6" />
  <row Id="1209" PostTypeId="2" ParentId="1208" CreationDate="2018-03-19T18:34:24.690" Score="7" Body="&lt;p&gt;There are arguments that our brains are quantum mechanical, and arguments against, so that's a hotly debated topic. Fisher at UCSB has some speculative thinking about how brains might still use quantum effects even though they aren't quantum mechanical in nature. While there's no direct experimental evidence there are two references you might want to read:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1508.05929.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Cognition: The possibility of processing with nuclear spins in the brain&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.worldscientific.com/doi/pdf/10.1142/S0217979217430019&quot; rel=&quot;nofollow noreferrer&quot;&gt;Are we quantum computers, or merely clever robots?&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Now, on the subject of using quantum computing and machine learning, Rigetti Computing has demonstrated a clustering algorithm using their prototype quantum chips (19 qubits). They published their findings in a white paper on arXiv.org here:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1712.05771&quot; rel=&quot;nofollow noreferrer&quot;&gt;Unsupervised Machine Learning on a Hybrid Quantum Computer&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;So there's clearly an opportunity to advance machine learning, and eventually, AI using quantum computing imho.&lt;/p&gt;&#xA;" OwnerUserId="274" LastEditorUserId="15" LastEditDate="2018-03-20T02:11:39.083" LastActivityDate="2018-03-20T02:11:39.083" CommentCount="0" />
  <row Id="1210" PostTypeId="2" ParentId="75" CreationDate="2018-03-19T20:46:46.157" Score="3" Body="&lt;p&gt;I believe that the Centre for Engineered Quantum Systems, School of Physics, The University of Sydney and the Center for Theoretical Physics, Massachusetts Institute of Technology use of a tensor network decoder of Bravyi, Suchara and Vargo (BSV), to achieve the highest error correction threshold to date. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In their whitepaper from last December, &lt;a href=&quot;https://arxiv.org/pdf/1708.08474.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;Ultrahigh Error Threshold for Surface Codes with Biased Noise&quot;&lt;/a&gt;, the use of a tensor network decoder resulted in pure $Z$ noise of $p_c=43.7\left(1\right)\%$, which is a fourfold increase over the previous optimal surface code threshold for pure $Z$ noise of $10.9\%$. The $10.9\%$ number comes from S. Bravyi, M. Suchara, and A. Vargo, &lt;a href=&quot;https://arxiv.org/abs/1405.4883&quot; rel=&quot;nofollow noreferrer&quot;&gt;“Efficient algorithms for maximum likelihood decoding in the surface code”&lt;/a&gt;. &lt;/p&gt;&#xA;" OwnerUserId="274" LastEditorUserId="15" LastEditDate="2018-03-22T00:07:31.533" LastActivityDate="2018-03-22T00:07:31.533" CommentCount="2" />
  <row Id="1211" PostTypeId="2" ParentId="1195" CreationDate="2018-03-19T22:10:09.547" Score="3" Body="&lt;p&gt;Unfortunately the state of the technology regarding memories is not as developed as you seem to expect. When we talk about a memory, we think of a device that can store information for an infinite amount of time (for all practical purposes). So before we can think about the size of the memory in a quantum computer, we should look at whether a single quantum memory has been built. There is a lot of progress in this direction, but to my knowledge the &lt;a href=&quot;https://www.nature.com/articles/nature14025&quot; rel=&quot;nofollow noreferrer&quot;&gt;currently best &quot;memory&quot;&lt;/a&gt; achieved a coherence time of about 6 hours (which is amazing, but still not what we are used from classical computers). Although the fidelity of the retrieved state is in the high nineties, the success probability for storage and readout is very low.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There is also work on using error correction codes to built a memory, but those approaches do not give better results so far.&lt;/p&gt;&#xA;" OwnerUserId="104" LastActivityDate="2018-03-19T22:10:09.547" CommentCount="0" />
  <row Id="1212" PostTypeId="2" ParentId="1206" CreationDate="2018-03-19T22:41:47.840" Score="6" Body="&lt;p&gt;Suppose that, prior to measurement, your $n$-qubit system is in some state $\lvert \psi \rangle \in \mathcal H_2^{\otimes n}$, where $\mathcal H_2 \cong \mathbb C^2$ is the Hilbert space of a single qubit. Write&#xA;$$ \lvert \psi \rangle = \sum_{x \in \{0,1\}^n} u_x \lvert x \rangle $$&#xA;for some coefficients $u_x \in \mathbb C$ such that $\sum_x \lvert u_x \rvert^2 = 1$.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;If you are measuring the first qubit in the standard basis, define&#xA;$$\begin{aligned} \lvert \varphi_0 \rangle &amp;amp;= \!\!\!\!\!\sum_{x' \in \{0,1\}^{n-1}}\!\!\!\!\!\! u_{0x'} \,\lvert0\rangle \lvert x' \rangle,  \\  \lvert \varphi_1 \rangle &amp;amp;= \!\!\!\!\!\sum_{x' \in \{0,1\}^{n-1}}\!\!\!\!\!\! u_{1x'} \,\lvert1\rangle \lvert x' \rangle,\end{aligned}$$ and let $\lvert \psi_0 \rangle = \lvert \varphi_0 \rangle \big/\! \sqrt{\langle \varphi_0 \vert \varphi_0 \rangle}\,$ and $\,\lvert \psi_1 \rangle = \lvert \varphi_1 \rangle \big/\! \sqrt{\langle \varphi_1 \vert \varphi_1 \rangle}\,$. It is not too difficult to show that, if you measure the first qubit and obtain the state $\lvert 0 \rangle$, the state of the entire system &quot;collapses&quot; to $\lvert \psi_0 \rangle$, and if you obtain $\lvert 1 \rangle$ what you obtain is $\lvert \psi_1 \rangle$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is broadly analogous to the idea of conditional probability distributions: you might think of $\lvert \psi_0 \rangle$ as the state of the system conditioned on the first qubit being $\lvert 0 \rangle$, and $\lvert \psi_1 \rangle$ as the state of the system conditioned on the first qubit being $\lvert 1 \rangle$ (except of course that the story is a bit more complicated, on account of the fact that the first qubit is not &quot;secretly&quot; in either the state $0$ or $1$).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;The above is not strongly dependent on measuring the first qubit: we can define $\lvert \varphi_0 \rangle$ and $\lvert \varphi_1 \rangle$ in terms of fixing any particular bit in the bit string $x$ to either $0$ or $1$, summing over only those components which are consistent with either the choice $0$ or $1$, and proceeding as above.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;The above is also not strongly dependent on measuring in the standard basis, as Emily indicates. If we wish to consider measuring the first qubit in the basis $\lvert \alpha \rangle, \lvert \beta  \rangle$, where $\lvert \alpha \rangle = \alpha_0 \lvert 0 \rangle + \alpha_1 \lvert 1 \rangle$ and $\lvert \beta \rangle = \beta_0 \lvert 0 \rangle + \beta_1 \lvert 1 \rangle$, we define&#xA;$$\begin{aligned} \lvert \varphi_0 \rangle &amp;amp;= \Bigl(\lvert \alpha \rangle\!\langle \alpha \lvert \otimes I^{\otimes n-1}\Bigr)\lvert \psi\rangle =  \!\!\!\!\!\sum_{x' \in \{0,1\}^{n-1}}\!\!\!\!\!\! \bigl(\alpha_0^\ast u_{0x'} + \alpha_1^\ast u_{1x'}\bigr) \,\lvert\alpha\rangle \lvert x' \rangle\,,  \\  \lvert \varphi_1 \rangle &amp;amp;= \Bigl(\lvert \beta\rangle\!\langle \beta \lvert \otimes I^{\otimes n-1}\Bigr)\lvert \psi\rangle =  \!\!\!\!\!\sum_{x' \in \{0,1\}^{n-1}}\!\!\!\!\!\! \bigl(\beta_0^\ast u_{0x'} + \beta_1^\ast u_{1x'}\bigr) \,\lvert\beta\rangle \lvert x' \rangle\,, \end{aligned}$$&#xA;and then proceeding as above.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-03-20T14:23:13.823" LastActivityDate="2018-03-20T14:23:13.823" CommentCount="0" />
  <row Id="1213" PostTypeId="1" AcceptedAnswerId="1220" CreationDate="2018-03-19T23:00:47.297" Score="12" ViewCount="85" Body="&lt;p&gt;I understand that there is a &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0505030&quot; rel=&quot;noreferrer&quot;&gt;constructive proof&lt;/a&gt; that arbitrary gates can be approximated by a finite universal gate set, which is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Solovay%E2%80%93Kitaev_theorem&quot; rel=&quot;noreferrer&quot;&gt;Solovay–Kitaev Theorem&lt;/a&gt;.&lt;br&gt;&#xA;However, the approximation introduces an error, which would spread and accumulate in a long computation. This would presumably scale badly with the length of the calculation? Possibly one might apply the approximation algorithm to the complete circuit as a whole, not to a single gate. But how does this scale with the length of the computation (i.e. how does the approximation scale with the dimension of the gates)? How does the gate approximation relate to gate synthesis? Because I could imagine that this affects the final length of the computation?&lt;br&gt;&#xA;Even more disturbing to me: What happens if the length of the calculation is not known at the time when the gate sequence is compiled?&lt;/p&gt;&#xA;" OwnerUserId="104" LastActivityDate="2018-03-20T10:25:34.290" Title="How does approximating gates via universal gates scale with the length of the computation?" Tags="&lt;noise&gt;&lt;universal-gates&gt;&lt;fault-tolerance&gt;&lt;gate-synthesis&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="2" />
  <row Id="1214" PostTypeId="5" CreationDate="2018-03-20T00:08:00.113" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-20T00:08:00.113" LastActivityDate="2018-03-20T00:08:00.113" CommentCount="0" />
  <row Id="1215" PostTypeId="4" CreationDate="2018-03-20T00:08:00.113" Score="0" Body="For questions about finding (short) gate sequences to implement a specific unitary operation, for example decomposing a complicated multi-qubit gate into a sequence of basic gates. It might apply to optimizing circuits with respect to length or depth or finding gate sequences to implement an algorithm. " OwnerUserId="104" LastEditorUserId="3" LastEditDate="2018-03-20T16:04:50.717" LastActivityDate="2018-03-20T16:04:50.717" CommentCount="0" />
  <row Id="1216" PostTypeId="5" CreationDate="2018-03-20T00:12:57.353" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-20T00:12:57.353" LastActivityDate="2018-03-20T00:12:57.353" CommentCount="0" />
  <row Id="1217" PostTypeId="4" CreationDate="2018-03-20T00:12:57.353" Score="0" Body="Questions about achieving (almost) perfect logical operations with imperfect gates. The tag also applies to questions about the amount of tolerable noise in a quantum circuit, as well as designing circuits to prevent errors from spreading." OwnerUserId="104" LastEditorUserId="104" LastEditDate="2018-03-20T16:04:26.303" LastActivityDate="2018-03-20T16:04:26.303" CommentCount="0" />
  <row Id="1218" PostTypeId="2" ParentId="135" CreationDate="2018-03-20T01:54:13.660" Score="6" Body="&lt;p&gt;Suppose a function $f\colon {\mathbb F_2}^n \to {\mathbb F_2}^n$ has the following curious property: There exists $s \in \{0,1\}^n$ such that $f(x) = f(y)$ if and only if $x + y = s$.  If $s = 0$ is the only solution, this means $f$ is 1-to-1; otherwise there is a nonzero $s$ such that $f(x) = f(x + s)$ for all $x$, which, because $2 = 0$, means $f$ is 2-to-1.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What is the cost to any prescribed probability of success, on a classical or quantum computer, of distinguishing a uniform random 1-to-1 function from a uniform random 2-to-1 function satisfying this property, if each option (1-to-1 or 2-to-1) has equal probability?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;I.e.,&lt;/em&gt; I secretly flip a coin fairly; if I get heads I hand you a black box (classical or quantum, resp.) circuit for a uniform random 1-to-1 function $f$, whereas if I get tails I hand you a black box circuit for a uniform random 2-to-1 function $f$.  How much do you have to pay to get a prescribed probability of success $p$ of telling whether I got heads or tails?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is the scenario of &lt;a href=&quot;https://en.wikipedia.org/wiki/Simon&amp;#39;s_problem&quot; rel=&quot;nofollow noreferrer&quot; title=&quot;Wikipedia: Simon&amp;#39;s problem.  Retrieved 2018-03-19.&quot;&gt;Simon's algorithm&lt;/a&gt;.  It has esoteric applications in &lt;a href=&quot;https://eprint.iacr.org/2017/767&quot; rel=&quot;nofollow noreferrer&quot; title=&quot;Xavier Bonnetain, ‘Quantum Key-Recovery on full AEZ’, IACR Cryptology ePrint Archive: Report 2017/767, 2017-08-08.&quot;&gt;nonsensical cryptanalysis&lt;/a&gt;,&lt;sup&gt;*&lt;/sup&gt; and it was an early instrument in studying the complexity classes BQP and BPP and an early inspiration for Shor's algorithm.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Simon presented a &lt;a href=&quot;http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.51.5477&amp;amp;rep=rep1&amp;amp;type=pdf&quot; rel=&quot;nofollow noreferrer&quot; title=&quot;Daniel R. Simon, ‘On the Power of Quantum Computation’, in Proceedings of the 35th Annual Symposium on Foundations of Computer Science 1996, pp. 116–123.&quot;&gt;quantum algorithm&lt;/a&gt; (§3.1, p. 7) that costs $O(n + |f|)$ qubits and expected $O(n \cdot T_f(n) + G(n))$ time for probability near 1 of success, where $T_f(n)$ is the time to compute a &lt;em&gt;superposition&lt;/em&gt; of values of $f$ on an input of size $n$ and where $G(n)$ is the time to solve an $n \times n$ system of linear equations in $\mathbb F_2$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Simon further sketched a &lt;a href=&quot;http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.51.5477&amp;amp;rep=rep1&amp;amp;type=pdf&quot; rel=&quot;nofollow noreferrer&quot; title=&quot;Daniel R. Simon, ‘On the Power of Quantum Computation’, in Proceedings of the 35th Annual Symposium on Foundations of Computer Science 1996, pp. 116–123.&quot;&gt;proof&lt;/a&gt; (Theorem 3.1, p. 9) that a classical algorithm evaluating $f$ at no more than $2^{n/4}$ distinct &lt;em&gt;discrete&lt;/em&gt; values cannot guess the coin with advantage better than $2^{-n/2}$ over a uniform random guess.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In some sense, this answers your question positively: A quantum computation requiring a &lt;em&gt;linear&lt;/em&gt; number of evaluations of random function on a &lt;em&gt;quantum superposition&lt;/em&gt; of inputs can attain much better success probability than a classical computation requiring an &lt;em&gt;exponential&lt;/em&gt; number of evaluations of a random function on &lt;em&gt;discrete inputs&lt;/em&gt;, in the size of the inputs.  But in another sense it doesn't answer your question at all, because it could be that for &lt;em&gt;every particular&lt;/em&gt; function $f$ there is a faster way to compute the search.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm&quot; rel=&quot;nofollow noreferrer&quot; title=&quot;Wikipedia: Deutsch–Jozsa algorithm.  Retrieved 2018-03-19.&quot;&gt;Deutsch–Jozsa algorithm&lt;/a&gt; serves as a similar illustration for a slightly different artificial problem to study different complexity classes, P and EQP, figuring out the details of which is left as an exercise for the reader.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;sub&gt;&lt;sup&gt;*&lt;/sup&gt; Simon's is nonsensical for cryptanalysis because only an inconceivably confused idiot would feed their secret key into the adversary's quantum circuit to use on a quantum superposition of inputs, but for some reason it makes a splash every time someone publishes a new paper on using Simon's algorithm to break idiots' keys with imaginary hardware, which is how all these attacks work.  Exception: It is possible that this might break &lt;em&gt;white-box&lt;/em&gt; cryptography, but the security story for white-box cryptography even against classical adversaries is not promising.&lt;/sub&gt;&lt;/p&gt;&#xA;" OwnerUserId="238" LastEditorUserId="238" LastEditDate="2018-04-07T04:54:48.500" LastActivityDate="2018-04-07T04:54:48.500" CommentCount="2" />
  <row Id="1219" PostTypeId="2" ParentId="1182" CreationDate="2018-03-20T02:21:59.580" Score="2" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Can one use a representation that is more compact, in the sense that it uses less memory and/or computational power than the simple vector representation? How does it work?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Source: &quot;&lt;a href=&quot;https://docs.microsoft.com/en-us/quantum/quantum-concepts-5-multiplequbits?view=qsharp-preview&quot; rel=&quot;nofollow noreferrer&quot;&gt;Multiple Qubits&lt;/a&gt;&quot;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;A single qubit can be trivially modeled, simulating a fifty-qubit quantum computation would arguably push the limits of existing supercomputers. Increasing the size of the computation by only one additional qubit doubles the memory required to store the state and roughly doubles the computational time. This rapid doubling of computational power is why a quantum computer with a relatively small number of qubits can far surpass the most powerful supercomputers of today, tomorrow and beyond for some computational tasks.&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So you can't utilize a &lt;a href=&quot;https://en.wikipedia.org/wiki/Ponzi_scheme&quot; rel=&quot;nofollow noreferrer&quot;&gt;Ponzi scheme&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/To_rob_Peter_to_pay_Paul&quot; rel=&quot;nofollow noreferrer&quot;&gt;rob Peter to pay Paul&lt;/a&gt;. Compression will save memory at the cost of computational complexity, or representation in a more flexible space (larger) would reduce computational complexity but at a cost of memory. Essentially what is needed is more capable hardware or smarter algorithms.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Here are some methods:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Compression of the volume of sets of quantum states of the Qubit's metric:&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Fisher_information_metric&quot; rel=&quot;nofollow noreferrer&quot;&gt;Fisher information metric&lt;/a&gt; can be used to map the volume of the qubit using an information geometry approach as discussed in &quot;&lt;a href=&quot;https://arxiv.org/abs/1802.08835&quot; rel=&quot;nofollow noreferrer&quot;&gt;The Volume of Two-Qubit States by Information Geometry&lt;/a&gt;&quot;, &quot;&lt;a href=&quot;https://users.ece.cmu.edu/~yuejiec/papers/Fisher_ICASSP2013.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Analysis of Fisher Information and the Cramer-Rao Bound for Nonlinear Parameter Estimation After Compressed Sensing&lt;/a&gt;&quot;, and our &quot;&lt;a href=&quot;https://stats.stackexchange.com/questions/10578/intuitive-explanation-of-fisher-information-and-cramer-rao-bound&quot;&gt;Intuitive explanation of Fisher Information and Cramer-Rao bound&lt;/a&gt;&quot;.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Analogous to operand compression:&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Computing depth-optimal decompositions of logical operations: &quot;&lt;a href=&quot;https://arxiv.org/abs/1206.0758&quot; rel=&quot;nofollow noreferrer&quot;&gt;A meet-in-the-middle algorithm for fast synthesis of depth-optimal quantum circuits&lt;/a&gt;&quot; or this Quora discussion on &quot;&lt;a href=&quot;https://www.quora.com/Are-trinary-AKA-ternary-qubits-things-that-exist-in-computing&quot; rel=&quot;nofollow noreferrer&quot;&gt;Encoding the dimension of the particle&lt;/a&gt;&quot;.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Analogous to memory compression:&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Qutrit&quot; rel=&quot;nofollow noreferrer&quot;&gt;Qutrit&lt;/a&gt; factorization using ternary arithmetic: &quot;&lt;a href=&quot;https://arxiv.org/abs/1605.02756&quot; rel=&quot;nofollow noreferrer&quot;&gt;Factoring with Qutrits: Shor's Algorithm on Ternary and Metaplectic Quantum Architectures&lt;/a&gt;&quot; and &quot;&lt;a href=&quot;https://arxiv.org/abs/1205.2390&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Ternary Circuit Synthesis Using Projection Operations&lt;/a&gt;&quot;.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Analogous to traditional optimization &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;a href=&quot;https://www.researchgate.net/publication/224705154_A_Quantum_Algorithm_for_Finding_Minimum_Exclusive-Or_Expressions&quot; rel=&quot;nofollow noreferrer&quot;&gt;A Quantum Algorithm for Finding Minimum Exclusive-Or Expressions&lt;/a&gt;&quot;.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Other:&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Krull_dimension&quot; rel=&quot;nofollow noreferrer&quot;&gt;Krull Dimensions&lt;/a&gt; or axiomatisation and graph rewriting: &quot;&lt;a href=&quot;https://arxiv.org/abs/1801.07993&quot; rel=&quot;nofollow noreferrer&quot;&gt;Completeness of the ZX-calculus for Pure Qubit Clifford+T Quantum Mechanics&lt;/a&gt;&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;By combining those techniques you ought to be able to squeeze the foot into the shoe. That would permit emulation of larger systems on conventional processors, just don't ask me to explain doctoral level work or write the code. :)&lt;/p&gt;&#xA;" OwnerUserId="278" LastEditorUserId="278" LastEditDate="2018-03-21T06:50:03.400" LastActivityDate="2018-03-21T06:50:03.400" CommentCount="0" />
  <row Id="1220" PostTypeId="2" ParentId="1213" CreationDate="2018-03-20T02:26:57.057" Score="8" Body="&lt;p&gt;Throughout this answer, the norm of a matrix $A$, $\left\lVert A\right\rVert$ will be taken to be the spectral norm of $A$ (that is, the largest singular value of $A$). The &lt;strong&gt;solovay-Kitaev theorem&lt;/strong&gt; states that approximating a gate to within an error $\epsilon$ requires $$\mathcal O\left(\log^c\frac 1\epsilon\right)$$ gates, for $c&amp;lt;4$ in any fixed number of dimensions. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;For the first part:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;the approximation introduces an error, which would spread and accumulate in a long computation&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Well, it can be shown by induction that errors accumulating through using one matrix to approximate another are subadditive (see e.g. &lt;a href=&quot;https://www.cs.umd.edu/~amchilds/qa/&quot; rel=&quot;noreferrer&quot;&gt;Andrew Child's lecture notes&lt;/a&gt;). That is, for unitary matrices $U_i$ and $V_i$, $\left\lVert U_i - V_i\right\rVert &amp;lt; \epsilon\,\forall\, i \in \left\lbrace1, 2, \ldots, t\right \rbrace\implies \left\lVert U_t\ldots U_2U_1 - V_t\ldots V_2V_1\right\rVert \leq t\epsilon$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What this means in terms of implementation is that, for an overall error no more than $\epsilon$ to be achieved, each gate needs to be approximated to within $\epsilon/t$, or&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;applying the approximation to the circuit as a whole&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;is the same as applying the approximation to each individual gate, each with an individual error no more than that of the entire circuit divided by the number of gates that you're approximating.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In terms of gate synthesis, The algorithm is performed by taking products of the gate set $\Gamma$ to form a new gate set $\Gamma_0$ which forms an $\epsilon^2$ net for $\operatorname{SU}\left(d\right)$ (for any $A \in \operatorname{SU}\left(d\right),\, \exists U\in\Gamma_0\, s.t. \left\lVert A-U\right\rVert\leq\epsilon^2$). Starting from identity, a new unitary is recursively found from the new gate set in order to get a tighter net round the target unitary. Oddly enough, the time for a classical algorithm to perform this operation is also $\mathcal O\left(\mathit{poly} \log 1/\epsilon\right)$, which is sub-polynomial time. &lt;strong&gt;However&lt;/strong&gt;, as per &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0111031&quot; rel=&quot;noreferrer&quot;&gt;Harrow, Recht, Chuang&lt;/a&gt;, in $d$-dimensions, as a ball of radius $\epsilon$ around $\operatorname{SU}\left(d\right)$ has a volume $\propto \epsilon^{d^2-1}$, this scales exponentially in $d^2$ for a non-fixed number of dimensions.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This does have an affect on the final computation time. However, as the scaling in both number of gates and classical computational complexity is sub-polynomial, this doesn't change the complexity class of any algorithm, at least for the commonly considered classes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;For $t$ gates, the overall (time and gate) complexity is then&lt;/strong&gt; $$\mathcal O\left(t\, \mathit{poly} \log \frac t\epsilon\right)$$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When using the &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/78/23&quot;&gt;unitary circuit model&lt;/a&gt; without &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/79/23&quot;&gt;intermediary measurements&lt;/a&gt;, the number of gates to be implemented will always be known prior to the computation. However, it is feasible to assume this isn't the case when intermediary measurements are used, so when then number of gates that you want to approximate is unknown, this is saying that $t$ is unknown. and if you don't know what $t$ is, you obviously can't approximate each gate to an error $\epsilon/t$. &lt;strong&gt;If you know a bound on the number of gates&lt;/strong&gt; (say, $t_{\text{max}}$), then you could approximate each gate to within $\epsilon/t_{\text{max}}$ to get an overall error $\leq\epsilon$ and complexity $$\mathcal O\left(t\, \mathit{poly} \log \frac {t_{\text{max}}}{\epsilon}\right),$$ although &lt;strong&gt;if no upper bound on the number of gates is known&lt;/strong&gt;, then each gate would be approximated to some (smaller) $\epsilon'$, giving an overall error $\leq t'\epsilon$ for the resulting number of implemented gates (which is unknown at the start) $t'$, with an overall complexity of $$\mathcal O\left(t'\, \mathit{poly} \log \frac {1}{\epsilon'}\right).$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Of course, the total error of this is still unbounded, so one simple&lt;sup&gt;1&lt;/sup&gt; way of keeping the error bounded would be to reduce the error each time by a factor of, say, $2$, so that the $n^{th}$ gate would be implemented with error $\epsilon/2^n$. The complexity would then be $$\mathcal O\left(\mathit{poly} \log \frac {2^n}{\epsilon'}\right) = \mathcal O\left(\mathit{poly}\, n\log \frac {1}{\epsilon'}\right),$$ giving an overall (now polynomial) complexity $$\mathcal O\left(\mathit{poly}\, t \log \frac {1}{\epsilon}\right),$$ although this does have the advantage of guaranteeing a bounded error.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This isn't &lt;em&gt;too&lt;/em&gt; bad, so I would hope that (when the number of gates is unknown) classical computers would be able to keep coming up with the correct gates at least as fast as a quantum processor would need them. If not currently, then hopefully once quantum processors become good enough that this actually becomes a problem!&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;1 Although, likely not the most efficient&lt;/sup&gt;&lt;/p&gt;&#xA;" OwnerUserId="23" LastEditorUserId="23" LastEditDate="2018-03-20T10:25:34.290" LastActivityDate="2018-03-20T10:25:34.290" CommentCount="1" />
  <row Id="1221" PostTypeId="1" AcceptedAnswerId="1223" CreationDate="2018-03-20T07:41:17.380" Score="12" ViewCount="189" Body="&lt;p&gt;One of the many thing that confuse me in the field of QC is what makes the measurement of a qubit in a quantum computer any different than just choosing at random (in a classical computer) (that's not my actual question)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Suppose I have $n$ qubits, and my state is a vector of their amplitudes $(a_1,a_2,\dots,a_n)^\mathrm{T}$.&lt;sup&gt;1&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If I pass that state through some gates and do all sorts of quantum operations (except for measurement), and then I measure the state. I'll only get one of the options (with varying probabilities). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;So where's the difference between doing that, and generating a number randomly from some convoluted/complicated distribution? What makes quantum computations essentially different from randomized classical ones?&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;I hope I didn't misunderstand how states are represented. Confused about that, as well...&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="13" LastEditorUserId="15" LastEditDate="2018-03-20T08:55:56.113" LastActivityDate="2018-03-21T01:54:32.123" Title="What makes quantum computations different from randomized classical computations?" Tags="&lt;qubit-state&gt;&lt;measurement&gt;" AnswerCount="2" CommentCount="7" FavoriteCount="1" />
  <row Id="1222" PostTypeId="1" CreationDate="2018-03-20T07:52:06.983" Score="6" ViewCount="95" Body="&lt;p&gt;The title says most of it: What are the implications of &lt;a href=&quot;https://en.wikipedia.org/wiki/Bremermann%27s_limit&quot; rel=&quot;noreferrer&quot;&gt;Bremermann's limit&lt;/a&gt; for quantum computing?&#xA;The Wikipedia page says that the limit applies to any self-contained system, but in the last few lines they also claim that &quot;access to quantum memory enables computational algorithms that require arbitrarily small amount of energy/time per one elementary computation step&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;These statements seem contradictory (unless requiring arbitrarily small amount of energy/time also requires the amount of mass going to infinity). So how does the Bremermann's limit actually affect quantum computing?&lt;/p&gt;&#xA;" OwnerUserId="346" LastActivityDate="2018-03-21T05:20:45.070" Title="What are the implications of Bremermann's limit for quantum computing?" Tags="&lt;quantum-speedup&gt;&lt;bremermanns-limit&gt;" AnswerCount="1" CommentCount="1" />
  <row Id="1223" PostTypeId="2" ParentId="1221" CreationDate="2018-03-20T14:25:07.830" Score="12" Body="&lt;p&gt;The question is, how did you get to your final state?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The magic is in the gate operations that transformed your initial state to your final state.  If we knew the final state to begin with, we wouldn't need a quantum computer - we'd have the answer already and could, as you suggest, simply sample from the corresponding probability distribution. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Unlike Monte Carlo methods that take a sample from some probability distribution and change it to a sample from some other distribution, the quantum computer is taking an initial state vector and transforming it to another state vector via gate operations.  The key difference is that quantum states undergo &lt;a href=&quot;https://en.wikipedia.org/wiki/Wave_interference#Quantum_interference&quot; rel=&quot;noreferrer&quot;&gt;coherent interference&lt;/a&gt;, which means that the vector amplitudes add as complex numbers.  Wrong answers add destructively (and have low probability), while right answers add constructively (and have high probability).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The end result, if all goes well, is a final quantum state that yields the right answer with high probability upon measurement, but it took all those gate operations to get there in the first place.&lt;/p&gt;&#xA;" OwnerUserId="356" LastEditorUserId="15" LastEditDate="2018-03-21T01:08:46.320" LastActivityDate="2018-03-21T01:08:46.320" CommentCount="4" />
  <row Id="1224" PostTypeId="2" ParentId="1192" CreationDate="2018-03-20T15:46:21.140" Score="1" Body="&lt;p&gt;While other answers provide good points, I feel that I still disagree a bit. So, I will share my own thoughts on this point.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In short, I think featuring the constant 'as is' is a wasted opportunity at best. Perhaps it is the best we are able to get for now, but it is far from ideal.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But first, I think a brief excursion is nessecary.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;When do we have an effective algorithm?&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;When Daniel Sank asked me what I would do if there was an algorithm for factoring prime numbers with a $10^6$ factor speedup on a test set of serious instances, I first replied that I doubt this would be due to algorithmic improvements, but other factors (either the machine or the implementation). But I think I have a different response now. Let me give you a trivial algorithm that can factor very large numbers within milliseconds and is nevertheless &lt;em&gt;very ineffective&lt;/em&gt;:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Take a set $P$ of (pretty big) primes.&lt;/li&gt;&#xA;&lt;li&gt;Compute $P^2$, the set of all composites with exactly two factors from $P$. For each composite, store which pair of primes is used to construct it.&lt;/li&gt;&#xA;&lt;li&gt;Now, when given an instance from $P^2$, simply look at the factorization in our table and report it. Otherwise, report 'error'&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;I hope it is obvious that this algorithm is rubbish, as it works only correctly when our input is in $P^2$. However, can we see this when given the algorithm as a black box &lt;em&gt;and&lt;/em&gt; &quot;by coincide&quot; only test with inputs from $P$? Sure, we can try to test a lot of examples, but it is very easy to make $P$ very big without the algorithm being ineffective on inputs from $P^2$ (perhaps we want to use a hash-map or something). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, it isn't unreasonable that our rubbish algorithm might be coincidentally seem to have 'miraculous' speedups. Now, of course there are many experiment design techniques that can mitigate the risk, but perhaps more clever 'fast' algorithms that still fail in many, but not enough examples can trick us! (also note that I'm assuming no researcher is &lt;em&gt;malicious&lt;/em&gt;, which makes matters even worse!)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, I would now reply: &quot;Wake me up when there is a better performance metric&quot;.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;How can we do better, then?&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;If we can afford to test our 'black box' algorithm to on all cases, we cannot be fooled by the above. However, this is impossible for practical situations. (This &lt;em&gt;can&lt;/em&gt; be done in theoretical models!)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What we &lt;em&gt;can&lt;/em&gt; instead do is to create a statistical &lt;em&gt;hypothesis&lt;/em&gt; for some &lt;em&gt;parameterized&lt;/em&gt; running time (usually for the input size) to test this, perhaps adapt our hypothesis and test again, until we get a hypothesis we like and rejecting the null seems reasonable. (Note that there are likely other factors involved I'm ignoring. I'm practically a mathematician. Experiment design is not something within my expertise)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The advantage of statistically testing on a parameterization (e.g. is our algorithm $O(n^3)$? ) is that the model is more &lt;em&gt;general&lt;/em&gt; and hence it is harder to be 'cheated' like in the previous section. It is not impossible, but at least the statistical claims on whether this is reasonable can be justified.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;So, what to do with the constants?&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;I think &lt;em&gt;only&lt;/em&gt; stating &quot;$10^9$ speedup, wow!&quot; is a bad way of dealing this case. But I also think completely disregarding this result is bad as well.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I think it is most useful to regard the curious constant as an &lt;em&gt;anomaly&lt;/em&gt;, i.e. it is a claim that in itself warrants further investigation. I think that creating hypotheses based on more general models than simply 'our algorithm takes X time' is a good tool to do this. So, while I don't think we can simply take over CS conventions here, completely disregarding the 'disdain' for constants is a bad idea as well.&lt;/p&gt;&#xA;" OwnerUserId="253" LastActivityDate="2018-03-20T15:46:21.140" CommentCount="0" />
  <row Id="1225" PostTypeId="1" AcceptedAnswerId="1331" CreationDate="2018-03-20T18:46:10.267" Score="7" ViewCount="103" Body="&lt;p&gt;This &lt;a href=&quot;https://www.ibm.com/blogs/research/2017/10/quantum-computing-barrier/&quot; rel=&quot;nofollow noreferrer&quot;&gt;new algorithm&lt;/a&gt; for QC calculation was introduced recently (2017 4Q) by IBM/ Pednault et al. to great fanfare. The paper seems more couched in the language of physics. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Are there any basic overview/analyses of this by computer scientists about the general &quot;design pattern&quot; utilized, vs the prior algorithmic techniques for the problem, or can someone provide one? What about the complexity analysis of the techniques?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1710.05867&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;Breaking the 49-Qubit Barrier in the Simulation of Quantum Circuits&quot;&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="377" LastEditorUserId="15" LastEditDate="2018-03-22T00:45:01.283" LastActivityDate="2018-03-25T19:12:10.960" Title="New algorithm for faster QC simulation by IBM" Tags="&lt;simulation&gt;&lt;quantum-gate&gt;&lt;quantum-speedup&gt;&lt;quantum-algorithms&gt;" AnswerCount="1" CommentCount="1" FavoriteCount="2" />
  <row Id="1226" PostTypeId="1" CreationDate="2018-03-21T00:20:54.037" Score="10" ViewCount="160" Body="&lt;p&gt;Which technological path seems most promising to produce a quantum processor with a greater &lt;a href=&quot;https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/community-documents/quatnum-volumehp08co1vbo0cc8fr.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum volume&lt;/a&gt; (preferring fewer errors per qubit over more qubits), than &lt;a href=&quot;https://en.wikipedia.org/wiki/Majorana_fermion&quot; rel=&quot;nofollow noreferrer&quot;&gt;Majorana fermions&lt;/a&gt;?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The preferred format for the answer would be similar to:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;Group ABC's method DEF has demonstrated better QV than using MF; as proven independently in paper G on page x, paper H on page y, and paper I on page z&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;On &lt;a href=&quot;https://www.nature.com/articles/nphys4110&quot; rel=&quot;nofollow noreferrer&quot;&gt;Majorana fermions&lt;/a&gt; Landry Bretheau &lt;a href=&quot;https://news.mit.edu/2017/superconductors-graphene-exotic-electronic-states-quantum-computing-0505&quot; rel=&quot;nofollow noreferrer&quot;&gt;says&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;These particles could be the elementary brick of topological quantum computers, with very strong protection against errors. Our work is an initial step in this direction.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Example of an insufficient (but interesting) answer:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In their paper &quot;&lt;a href=&quot;https://arxiv.org/abs/1405.4052&quot; rel=&quot;nofollow noreferrer&quot;&gt;Robust quantum metrological schemes based on protection of quantum Fisher information&lt;/a&gt;&quot;, Xiao-Ming Lu, Sixia Yu, and C.H. Oh construct a family of $2t+1$ qubits metrological schemes being immune to $t$-qubit errors after the signal sensing. In comparison at least five qubits are required for correcting arbitrary 1-qubit errors in standard quantum error correction.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[Note: This theory of robust metrological schemes preserves the quantum Fisher information instead of the quantum states themselves against noise. That results in a good effective volume &lt;strong&gt;if&lt;/strong&gt; they can construct a device utilizing their techniques and show that it &lt;strong&gt;scales&lt;/strong&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;While that might seem like one promising answer it's a single link (without multiple concurring sources) and there's no device built to show scalability. A low qubit device that's error free and unscalable &lt;strong&gt;or&lt;/strong&gt; a device with many error-prone qubits has a low volume (and thus is &quot;Not An Answer&quot;).]&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Additional references:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Paper explaining &lt;a href=&quot;https://ibm.biz/BdiaQe&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Volume&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/ekkrL.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/ekkrL.jpg&quot; alt=&quot;Qubits vs. Error Rate&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;After doing some research it looks like Graphene sandwiched between superconductors to produce Majorana fermions is the leading edge - is there something better? [&quot;better&quot; means currently possible,  not theoretically possible or ridiculously expensive]. The graphic illustrates that over a hundred qubits with less 0.0001 error rate is wonderful,  lesser answers are acceptable.&lt;/p&gt;&#xA;" OwnerUserId="278" LastEditorUserId="26" LastEditDate="2018-05-07T13:20:26.410" LastActivityDate="2018-05-07T13:20:26.410" Title="What is the leading edge technology for creating a quantum computer with the fewest errors?" Tags="&lt;quantum-computer&gt;&lt;quantum-error-correction&gt;&lt;fault-tolerance&gt;" AnswerCount="1" CommentCount="4" FavoriteCount="1" />
  <row Id="1227" PostTypeId="2" ParentId="1221" CreationDate="2018-03-21T01:42:04.873" Score="3" Body="&lt;p&gt;You're right - if we had a bunch of linear probabilities and just kept combining them in a big superposition, we may as well just do randomized classical computation, which'd basically be describable in terms of &lt;a href=&quot;https://en.wikipedia.org/wiki/Bayesian_probability&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bayesian mechanics&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\hspace{3cm}$&lt;a href=&quot;https://en.wikipedia.org/wiki/File:Bayes_theorem_drugs_example_tree.svg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/8/88/Bayes_theorem_drugs_example_tree.svg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And since classical systems can already operate like this, that'd be disinteresting.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The trick's in that &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_gate&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum gates&lt;/a&gt; can be non-linear, i.e. they can work in a non-Bayesian way.  Then we can construct systems in which &lt;a href=&quot;https://en.wikipedia.org/wiki/Wave_interference#Quantum_interference&quot; rel=&quot;nofollow noreferrer&quot;&gt;qubits interfere&lt;/a&gt; in ways that favor desirable outcomes over undesirable outcomes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A good example might be &lt;a href=&quot;https://en.wikipedia.org/wiki/Shor%27s_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;Shor's algorithm&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Then ${\displaystyle \omega ^{ry}} \omega ^{ry}$ is a unit vector in the complex plane $( {\displaystyle \omega } \omega$  is a root of unity and $r$ and $y$ are integers), and the coefficient of ${\displaystyle Q^{-1}\left|y,z\right\rangle } Q^{-1}\left|y,z\right\rangle$  in the final state is$${\displaystyle \sum _{x:\,f(x)=z}\omega ^{xy}=\sum _{b}\omega ^{(x_{0}+rb)y}=\omega ^{x_{0}y}\sum _{b}\omega ^{rby}.}$$&#xA;  Each term in this sum represents a different path to the same result, and quantum &lt;a href=&quot;https://en.wikipedia.org/wiki/Interference_(wave_propagation)&quot; rel=&quot;nofollow noreferrer&quot;&gt;interference&lt;/a&gt; occurs – constructive when the unit vectors ${\displaystyle \omega ^{ryb}} \omega ^{ryb}$ point in nearly the same direction in the complex plane, which requires that ${\displaystyle \omega ^{ry}} \omega ^{ry}$ point along the &lt;a href=&quot;https://en.wikipedia.org/wiki/Positive_real_axis&quot; rel=&quot;nofollow noreferrer&quot;&gt;positive real axis&lt;/a&gt;.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;-&lt;a href=&quot;https://en.wikipedia.org/wiki/Shor%27s_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;Shor's algorithm&quot;&lt;/a&gt;, Wikipedia&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Then, the very next step after that starts with &lt;strong&gt;&quot;&lt;em&gt;Perform a measurement.&lt;/em&gt;&quot;&lt;/strong&gt;.  This is, they tweaked the odds in favor of the outcome that they wanted, now they're measuring it to see what that was.&lt;/p&gt;&#xA;" OwnerUserId="15" LastEditorUserId="15" LastEditDate="2018-03-21T01:54:32.123" LastActivityDate="2018-03-21T01:54:32.123" CommentCount="4" />
  <row Id="1228" PostTypeId="1" CreationDate="2018-03-21T02:15:23.523" Score="0" ViewCount="244" Body="&lt;p&gt;Seth Lloyd, a professor of mechanical engineering and physics at MIT, &lt;a href=&quot;https://arxiv.org/abs/1312.4455&quot; rel=&quot;nofollow noreferrer&quot;&gt;published a paper&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Programming_the_Universe&quot; rel=&quot;nofollow noreferrer&quot;&gt;a book&lt;/a&gt; in which he shows that the universe can be &#xA;regarded as a giant quantum computer. According to him, all observed phenomena are consistent with the model in which the universe is indistinguishable from a quantum computer, e.g., a quantum cellular automaton.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;He considers the following two statements to be true:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;The universe allows quantum computation.&lt;/li&gt;&#xA;&lt;li&gt;A quantum computer efficiently simulates the dynamics of the universe.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;To conclude with:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Finally, we can quantize question three: (Q3) ‘Is the universe a quantum&#xA;  cellular automaton?’ While we cannot unequivocally answer this question&#xA;  in the affirmative, we note that the proofs that show that a quantum computer&#xA;  can simulate any local quantum system efficiently immediately imply&#xA;  that any homogeneous, local quantum dynamics, such as that given by the&#xA;  standard model and (presumably) by quantum gravity, can be directly reproduced&#xA;  by a quantum cellular automaton. Indeed, lattice gauge theories,&#xA;  in Hamiltonian form, map directly onto quantum cellular automata. Accordingly,&#xA;  all current physical observations are consistent with the theory that&#xA;  the universe is indeed a quantum cellular automaton.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Does this theory hold up?&lt;/p&gt;&#xA;" OwnerUserId="395" LastEditorUserId="26" LastEditDate="2018-03-29T18:11:30.053" LastActivityDate="2018-03-29T18:11:30.053" Title="Is the universe indistinguishable from a giant quantum computer?" Tags="&lt;quantum-computer&gt;&lt;simulation&gt;" AnswerCount="2" CommentCount="3" FavoriteCount="1" ClosedDate="2018-03-26T15:26:50.937" />
  <row Id="1229" PostTypeId="2" ParentId="1228" CreationDate="2018-03-21T02:30:42.533" Score="10" Body="&lt;p&gt;I guess that he's right enough for the moment; quantum mechanics is part of our best theory of the universe, which by definition means that we think the universe works like that.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It's pretty circular though.  When we have some model of the universe, what that literally means is that we think that the universe is operating according to that model.  Currently that's a quantum model.  Still, who cares?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The paper attempts to address that question:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The immediate question is ‘So what?’ Does the fact that the universe is observationally indistinguishable from a giant quantum computer tell us anything new or interesting about its behavior? The answer to this question is a resounding ‘Yes!’ In particular, the quantum computational model of the universe answers a question that has plagued human beings ever since they first began to wonder about the origins of the universe, namely, Why is the universe so ordered and yet so complex [1]?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;So, I guess that he's saying that quantum mechanics helps us to model more about the universe than prior models.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Seems like a pretty trivial point.  It's weird that someone wrote a paper about it.&lt;/p&gt;&#xA;" OwnerUserId="15" LastActivityDate="2018-03-21T02:30:42.533" CommentCount="2" />
  <row Id="1230" PostTypeId="2" ParentId="1208" CreationDate="2018-03-21T05:06:59.597" Score="2" Body="&lt;p&gt;AI is a really broad field and so Im sure that there are quantum algorithms that fit under its umbrella.  However if you are a novice it may be hard to find them. There are ways to use to use QC to speed up current AI algorithms as well.  The 'new hotness' in AI (neural networks) is just a lot of tensor products.  This is something that Quantum computers can calculate really quickly, as there are ways to operate on every qbit at the same time while classical computers only can do one thing at a time.  &lt;/p&gt;&#xA;" OwnerUserId="407" LastEditorUserId="253" LastEditDate="2018-03-21T17:28:00.510" LastActivityDate="2018-03-21T17:28:00.510" CommentCount="3" />
  <row Id="1231" PostTypeId="2" ParentId="1222" CreationDate="2018-03-21T05:20:45.070" Score="3" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;What are the implications of Bremermann's limit for quantum computing? &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;From the Wikipedia page you referenced:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;A computer with the mass of the entire Earth operating at the Bremermann's limit could perform approximately $10^{75}$ mathematical computations per second.&quot;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Next you say:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The Wikipedia page says that the limit applies to any self-contained system, but in the last few lines they also claim ... statements seem contradictory.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The whole paragraph is:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;The limit&lt;/strong&gt; has been further analysed in later literature &lt;strong&gt;as the maximum rate at which a system&lt;/strong&gt; with energy spread $ \Delta E $ &lt;strong&gt;can evolve into an orthogonal and hence distinguishable state&lt;/strong&gt; to another, $ \Delta t = \pi \hbar / 2 \Delta E$. In particular, Margolus and Levitin has shown that a quantum system with average energy $E$ takes &lt;strong&gt;at least&lt;/strong&gt; time $ \Delta t = \pi \hbar / 2 E $ to &lt;strong&gt;evolve into an orthogonal state&lt;/strong&gt;. However, &lt;strong&gt;it has been shown&lt;/strong&gt; that &lt;strong&gt;access to quantum memory&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;enables&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;computational algorithms that require arbitrarily small amount of energy/time&lt;/strong&gt; per one elementary computation step.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The paper referenced, &quot;&lt;a href=&quot;http://%20https://arxiv.org/pdf/1701.05550.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Computing with a single qubit faster than the computation quantum speed limit&lt;/a&gt;&quot;, seems to explain it fairly clearly:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Page 1: &quot;Introduction. &lt;strong&gt;The quantum phase space of a qubit is a sphere (Fig. 1)&lt;/strong&gt;. One can discretize this space into any number of states and then apply field pulses to switch between the chosen states in an arbitrary order. In this sense, a qubit comprises the whole universe of choices for computation. For example, a qubit can work as finite automata when different unitary gates act on this qubit depending on arriving digital words. &lt;strong&gt;However, different states of a qubit are generally not distinguishable by measurements&lt;/strong&gt;. So, if the final quantum state encodes the result of computation, &lt;strong&gt;we cannot generally extract this information because we cannot distinguish this state by a measurement from other non-orthogonal possibilities reliably&lt;/strong&gt;. For such reasons, qubits &lt;strong&gt;are believed to&lt;/strong&gt; provide computational advantage over classical memory &lt;strong&gt;only when&lt;/strong&gt; they are used to create purely quantum correlations, i.e., entanglement or quantum discord.&quot;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;...&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&quot;Quantum mechanically, &lt;strong&gt;distinguishable states must be represented by orthogonal vectors that produce definitely different measurement outcomes&lt;/strong&gt;. However, &lt;strong&gt;the switching time between two orthogonal quantum states is restricted from&lt;/strong&gt; below by a fundamental computation speed limit T = h/(4∆E), where ∆E is characteristic energy of &lt;strong&gt;the control field coupling to the memory&lt;/strong&gt; that is needed to update one bit of information. So, &lt;strong&gt;restrictions on strength of control fields automatically restrict the speed of classical computation&lt;/strong&gt; that saves information in physically distinguishable states. While the existence of this &lt;em&gt;computation quantum speed limit&lt;/em&gt; is a mathematically proved fact, I will show an explicit elementary example that demonstrates possibility of solving a computational problem faster than the lowest time bound that is imposed by this limit on classical computation hardware. &lt;strong&gt;Access to the quantum memory makes this possible because it allows information processing using nonorthogonal quantum states.&lt;/strong&gt; So, there is &lt;strong&gt;no more direct linear relation&lt;/strong&gt; between the minimal time and the number of elementary logic operations required to implement an algorithm &lt;strong&gt;at given energy constraints&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/Y9idL.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/Y9idL.jpg&quot; alt=&quot;Qubit&amp;#39;s quantum phase space&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;FIG. 1. Up to overall phases that do not inuence measurement outcomes, states of a qubit correspond to points on the 2D sphere. This phase space can be discretized to create a register of states (green circles) for computation. However, &lt;strong&gt;only opposite points on this sphere&lt;/strong&gt;, such as the poles marked by |0and |1, &lt;strong&gt;are distinguishable by measurements&lt;/strong&gt;. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;[Note: You &lt;em&gt;might&lt;/em&gt; barely get by just skimming just the &lt;strong&gt;bold&lt;/strong&gt; text, I suggest you read the whole paper for a better understanding.]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Hopefully that is clear, if you have a comment I can make an edit.&lt;/p&gt;&#xA;" OwnerUserId="278" LastActivityDate="2018-03-21T05:20:45.070" CommentCount="0" />
  <row Id="1232" PostTypeId="2" ParentId="49" CreationDate="2018-03-21T06:21:15.117" Score="5" Body="&lt;p&gt;As far as I know the closest answer to your question for applications is given in the recent (still unpublished) work presented at the &lt;a href=&quot;http://meetings.aps.org/Meeting/MAR18/Session/S28.6&quot; rel=&quot;noreferrer&quot;&gt;March meeting&lt;/a&gt; by Bibek Pokharel, where he compares graph 3-coloring instances on D-Wave Two, D-Wave 2X and D-Wave 2000Q, all other things staying reasonably equal. &#xA;The short answer is that all the performance increase is essentially due to the possibility to run single anneals at shorter anneal-time. (e.g. 1$\mu$s instead of 5$\mu$s gives indeed about 5X of performance increase, in terms of time-to-solution (TTS) metric. With respect to 20$\mu$s of D-Wave Two the scaling is different).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I can also spoil that from D-Wave Two and D-Wave 2000Q on &lt;a href=&quot;https://journals.aps.org/prx/abstract/10.1103/PhysRevX.5.031040&quot; rel=&quot;noreferrer&quot;&gt;Sherrington-Kirkpatrick instances&lt;/a&gt; we observed no substantial improvement as well. Results will be published soon in collaborations with Stanford.&lt;/p&gt;&#xA;" OwnerUserId="410" LastActivityDate="2018-03-21T06:21:15.117" CommentCount="0" />
  <row Id="1233" PostTypeId="2" ParentId="75" CreationDate="2018-03-21T06:43:53.443" Score="6" Body="&lt;p&gt;As far as I’m aware, the surface code is still regarded as the best. With an assumption of all elements failing with equal probability (and doing so in a certain way) it has a &lt;a href=&quot;https://arxiv.org/abs/1208.0928&quot; rel=&quot;nofollow noreferrer&quot;&gt;threshold of around 1%&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that the paper you linked to doesn’t have a 3D surface code. It is the decoding problem that is 3D, due to tracking changes to the 2D lattice over time. As I think you suspected, this is the required procedure when try to keep the stored information coherent for as long as possible. Check out &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0110143&quot; rel=&quot;nofollow noreferrer&quot;&gt;this paper&lt;/a&gt; for an earlier reference in some of these things.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Exact threshold numbers mean you need a specific error model, as you know. And for that you need a decoder, which ideally adapts to the specifics of the error model while remaining fast enough to keep up. Your definition of what is fast enough for the task at hand will have a big effect on what the threshold is.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To get upper bounds for a specific code and specific noise model, we can sometimes map the model to one of statistical mechanics. The threshold then corresponds to the point of a phase transition. See &lt;a href=&quot;https://arxiv.org/abs/1406.5974&quot; rel=&quot;nofollow noreferrer&quot;&gt;this&lt;/a&gt; paper for an example of how to do this, and the references therein for others.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Other than the threshold, another important factor is how easy it is to do quantum computation on the stored information. The surface code is quite bad at this, which is a major reason that people still consider other codes, despite the great advantages of the surface codes. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The surface code can only do the X, Z and H gates very simply, but they aren’t enough. The Color code can also manage the S gate without too much trouble, but that still just restricts us to the Clifford gates. Expensive techniques like magic state distillation will still be needed for both cases to get additional operations, as required for universality.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Some codes don’t have this restriction. They can let you do a full universal gate set in a straightforward and fault-tolerant way. Unfortunately, they pay for this by being much less realistic to build. &lt;a href=&quot;http://www.physics.usyd.edu.au/quantum/Coogee2016/Presentations/Kubica.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;These slides&lt;/a&gt; might point you in the right directions for more resources on this matter.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It’s also worth noting that even within the family of surface codes there are variations to explore. The stabilizers can be changed to an &lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.90.016803&quot; rel=&quot;nofollow noreferrer&quot;&gt;alternating&lt;/a&gt; pattern, or a &lt;a href=&quot;https://arxiv.org/abs/1708.08474&quot; rel=&quot;nofollow noreferrer&quot;&gt;YYYY&lt;/a&gt; stabilizer can used, to better deal with certain noise types. More drastically, we could even make &lt;a href=&quot;https://arxiv.org/abs/1609.07774&quot; rel=&quot;nofollow noreferrer&quot;&gt;quite big changes to the nature of the stabilizers&lt;/a&gt;. There are also the boundary conditions, which are what distinguishes a planar code from a toric code, etc. These and other details give us lots to optimize over.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-03-21T19:04:41.577" LastActivityDate="2018-03-21T19:04:41.577" CommentCount="0" />
  <row Id="1234" PostTypeId="2" ParentId="1226" CreationDate="2018-03-21T08:45:51.630" Score="8" Body="&lt;p&gt;That is indeed the most important question at the moment!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/devices&quot; rel=&quot;noreferrer&quot;&gt;Superconducting qubits&lt;/a&gt; currently have the biggest devices. But will they continue to scale? Will short coherence times make it too hard for error correction to keep up?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://physicsworld.com/a/ion-trap-quantum-computer-is-programmable-and-reconfigurable/&quot; rel=&quot;noreferrer&quot;&gt;Trapped ions&lt;/a&gt; are not far behind. But they have their own &lt;a href=&quot;http://science.sciencemag.org/content/339/6124/1164&quot; rel=&quot;noreferrer&quot;&gt;scalability issues&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1204.5917&quot; rel=&quot;noreferrer&quot;&gt;Spin qubits&lt;/a&gt; should be great for scaling once they get going. They are still down in the &lt;a href=&quot;https://arxiv.org/abs/1708.04214&quot; rel=&quot;noreferrer&quot;&gt;few qubits&lt;/a&gt; at the moment, though.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Majoranas also are suspected to have some nice properties. But I’d have to see a single qubit before I declare them to be the leading edge.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Photonics are also a viable strategy. In fact, &lt;a href=&quot;http://cnotmz.appspot.com/&quot; rel=&quot;noreferrer&quot;&gt;the first cloud based quantum device&lt;/a&gt; was photonic. A few startups are also based around photonic based approaches, such as the one described &lt;a href=&quot;https://arxiv.org/abs/1607.08535&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-03-21T19:00:39.913" LastActivityDate="2018-03-21T19:00:39.913" CommentCount="4" />
  <row Id="1235" PostTypeId="1" AcceptedAnswerId="1241" CreationDate="2018-03-21T10:00:08.307" Score="17" ViewCount="289" Body="&lt;p&gt;As I understand it, the field of quantum mechanics was started in the early 20th century when Max Planck solved the black-body radiation problem. But I don't know when the idea of computers using quantum effects spread out.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What is the earliest source that proposes the idea of quantum computers using qubits?&lt;/p&gt;&#xA;" OwnerUserId="11" LastEditorUserId="26" LastEditDate="2018-03-29T18:10:48.373" LastActivityDate="2018-03-29T18:10:48.373" Title="Who invented quantum computing?" Tags="&lt;history&gt;" AnswerCount="2" CommentCount="5" FavoriteCount="2" />
  <row Id="1236" PostTypeId="1" AcceptedAnswerId="1240" CreationDate="2018-03-21T10:14:14.440" Score="5" ViewCount="144" Body="&lt;p&gt;Reading into &lt;a href=&quot;https://en.wikipedia.org/wiki/Controlled_NOT_gate#Constructing_the_Bell_State_&amp;#39;&amp;quot;%60UNIQ--postMath-00000039-QINU%60&amp;quot;&amp;#39;&quot; rel=&quot;nofollow noreferrer&quot;&gt;CNOT gate&lt;/a&gt; I understand that, mathematically, such a gate entangles the control qubit and the target. (the resulting state is $\frac{1}{\sqrt 2}(|00\rangle+|11\rangle)$)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, looking at the &lt;a href=&quot;https://en.wikipedia.org/wiki/Controlled_NOT_gate#Operation&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;truth table&quot;&lt;/a&gt; of the gate, it seems as though the result is not entangled: If I measure the target after passing the gate, the state of the control can still be either option. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Am I missing something, or did I misunderstand the truth table?&lt;/p&gt;&#xA;" OwnerUserId="13" LastEditorUserId="55" LastEditDate="2018-03-21T17:09:42.167" LastActivityDate="2018-03-21T18:02:38.053" Title="How does evolving a two-qubit state through a CNOT gate entangle them?" Tags="&lt;qubit&gt;&lt;quantum-gate&gt;&lt;quantum-entanglement&gt;" AnswerCount="2" CommentCount="4" />
  <row Id="1237" PostTypeId="2" ParentId="1235" CreationDate="2018-03-21T10:28:28.877" Score="8" Body="&lt;p&gt;Around 1960-1973 the idea was beginning to form, but the field really started spreading in the 1980s.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One of the biggest pioneers was Richard P. Feynman. &lt;strong&gt;He proposed a model of a quantum computer in his &lt;a href=&quot;https://en.wikipedia.org/wiki/There%27s_Plenty_of_Room_at_the_Bottom&quot; rel=&quot;noreferrer&quot;&gt;talk&lt;/a&gt;&lt;/strong&gt;. From that talk, many other scientists pushed the field further (Toffoli created one of the first quantum gates; Shor, at Bell Labs, created one of the first quantum algorithms etc.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The field has been changing and evolving rapidly throughout 1980-2000, and keeps evolving. But the initial &quot;spark&quot; was made by Richard Feynman. I don't know if he thought of qubits, but his main interest in quantum computing was for simulating quantum physics and systems.&lt;/p&gt;&#xA;" OwnerUserId="13" LastActivityDate="2018-03-21T10:28:28.877" CommentCount="0" />
  <row Id="1238" PostTypeId="5" CreationDate="2018-03-21T10:48:45.727" Score="0" Body="&lt;p&gt;History in the sense of quantum computing (or any scientific field) is a collection of milestones the field has made and contributions that have been made in the field.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In a quickly evolving field, and especially one involving quantum mechanics, understanding the history of the field is needed to fully comprehend how the field came to be as it is.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A timeline of quantum computing can be found &lt;a href=&quot;https://en.wikipedia.org/wiki/Timeline_of_quantum_computing&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;. &lt;/p&gt;&#xA;" OwnerUserId="13" LastEditorUserId="13" LastEditDate="2018-03-21T17:28:24.013" LastActivityDate="2018-03-21T17:28:24.013" CommentCount="0" />
  <row Id="1239" PostTypeId="4" CreationDate="2018-03-21T10:48:45.727" Score="0" Body="Questions related to the history of quantum computers and quantum computing. Use this tag to ask questions about they history of an aspect of quantum computing (such as some concept or paradigm)" OwnerUserId="13" LastEditorUserId="13" LastEditDate="2018-03-21T17:28:42.467" LastActivityDate="2018-03-21T17:28:42.467" CommentCount="0" />
  <row Id="1240" PostTypeId="2" ParentId="1236" CreationDate="2018-03-21T11:06:38.387" Score="10" Body="&lt;p&gt;You are correct that none of the states in the truth table are entangled. Not all states become entangled when acted on by the CNOT.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The entangled state in your question would result if the control qubit was in state $|+\rangle=\frac{1}{\sqrt 2}(|0\rangle+|1\rangle)$), and the target was in state $|0\rangle$. The two qubits would then be in a superposition of $|00\rangle$ and $|10\rangle$. Apply the truth table to each of these independently, and you should see that the CNOT produces the superposition of $|00\rangle$ and $|11\rangle$ that you gave.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that the truth table on that page is not the only one we could write. It favours a certain interpretation of the CNOT, which is that the CNOT performs an X (the quantum version of a NOT) on the target qubit when the control is in state $|1\rangle$. An equivalent interpretation is to say that the CNOT performs a Z on the control if the target is in state $|-\rangle$ (which shows that the &lt;em&gt;control&lt;/em&gt; and &lt;em&gt;target&lt;/em&gt; labels are quite arbitrary). We can also interpret the CNOT as an operation that swaps the expectation values of certain Pauli operators.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The CNOT is all of these things at once. To try and explain this (and other things), I made a &lt;a href=&quot;https://github.com/decodoku/Quantum_Programming_Tutorial/blob/master/README.md&quot; rel=&quot;noreferrer&quot;&gt;tutorial for quantum programming&lt;/a&gt;. Perhaps it will be of some use to you.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-03-21T12:16:33.483" LastActivityDate="2018-03-21T12:16:33.483" CommentCount="0" />
  <row Id="1241" PostTypeId="2" ParentId="1235" CreationDate="2018-03-21T11:32:54.517" Score="16" Body="&lt;p&gt;According to Wikipedia of &lt;a href=&quot;https://en.wikipedia.org/wiki/Timeline_of_quantum_computing&quot; rel=&quot;noreferrer&quot;&gt;Timeline of quantum computing&lt;/a&gt;, here are the main events:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1960&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Stephen_Wiesner&quot; rel=&quot;noreferrer&quot;&gt;Stephen Wiesner&lt;/a&gt; invents &lt;a href=&quot;https://en.wikipedia.org/wiki/Conjugate_coding&quot; rel=&quot;noreferrer&quot;&gt;conjugate coding&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;1968&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A quantum computer with spins as quantum bits was also formulated for use as a quantum spacetime in 1968.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;Finkelstein, David (1968). &quot;Space-Time Structure in High Energy Interactions&quot;. In Gudehus, T.; Kaiser, G. Fundamental Interactions at High Energy. New York: Gordon &amp;amp; Breach.&lt;/sup&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;1973 &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Alexander_Holevo&quot; rel=&quot;noreferrer&quot;&gt;Alexander Holevo&lt;/a&gt; publishes a paper showing that n qubits cannot carry more than n classical bits of information (see: &lt;a href=&quot;https://en.wikipedia.org/wiki/Holevo%27s_theorem&quot; rel=&quot;noreferrer&quot;&gt;&quot;Holevo's theorem&quot;&lt;/a&gt;/&quot;Holevo's bound&quot;).&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Charles_H._Bennett_(computer_scientist)&quot; rel=&quot;noreferrer&quot;&gt;Charles H. Bennett&lt;/a&gt; shows that computation can be done reversibly.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;1976&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Polish mathematical physicist &lt;a href=&quot;https://en.wikipedia.org/wiki/Roman_Stanis%C5%82aw_Ingarden&quot; rel=&quot;noreferrer&quot;&gt;Roman Stanisław Ingarden&lt;/a&gt; publishes a seminal paper entitled &quot;Quantum Information Theory&quot; in Reports on Mathematical Physics, vol. 10, 43–72, 1976.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;1980&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Paul Benioff described quantum mechanical Hamiltonian models of computers&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Yuri_I._Manin&quot; rel=&quot;noreferrer&quot;&gt;Yuri Manin&lt;/a&gt; proposed an idea of quantum computing&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;1981&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Richard Feynman in his talk [...], observed that it appeared to be impossible in general to simulate an evolution of a quantum system on a classical computer in an efficient way. He proposed a basic model for a quantum computer that would be capable of such simulations&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;1982&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Paul Benioff proposes the first recognisable theoretical framework for a quantum computer.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;So in general, the field of quantum computing was initiated by the work of &lt;a href=&quot;https://de.wikipedia.org/wiki/Paul_Benioff&quot; rel=&quot;noreferrer&quot;&gt;Paul Benioff&lt;/a&gt; &lt;sup&gt;&lt;a href=&quot;https://doi.org/10.1007%2FBF01011339&quot; rel=&quot;noreferrer&quot;&gt;study&lt;/a&gt;&lt;/sup&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Yuri_Manin&quot; rel=&quot;noreferrer&quot;&gt;Yuri Manin&lt;/a&gt; in 1980, &lt;a href=&quot;https://en.wikipedia.org/wiki/Richard_Feynman&quot; rel=&quot;noreferrer&quot;&gt;Richard Feynman&lt;/a&gt; in 1982 &lt;sup&gt;&lt;a href=&quot;https://doi.org/10.1007%2FBF02650179&quot; rel=&quot;noreferrer&quot;&gt;study&lt;/a&gt;&lt;/sup&gt;, and &lt;a href=&quot;https://en.wikipedia.org/wiki/David_Deutsch&quot; rel=&quot;noreferrer&quot;&gt;David Deutsch&lt;/a&gt; in 1985. Source: &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_computing&quot; rel=&quot;noreferrer&quot;&gt;Quantum computing at Wikipedia&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="99" LastEditorUserId="99" LastEditDate="2018-03-21T11:39:53.257" LastActivityDate="2018-03-21T11:39:53.257" CommentCount="0" />
  <row Id="1242" PostTypeId="2" ParentId="1196" CreationDate="2018-03-21T12:02:56.767" Score="5" Body="&lt;p&gt;In the context of scalable quantum computing, the polylog scaling needed for magic state distillation should not be a problem.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Indeed, it is not the only polylog scaling we need to contend with. Using the $S$ and $T$ gates to approximate a general single qubit rotation can have a similar cost when using the &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0505030&quot; rel=&quot;noreferrer&quot;&gt;Solvay-Kitaev algorithm&lt;/a&gt; (though this is no longer state-of-the-art). The cost of error correction is also similar to that of MSD. In fact, it has been shown &lt;a href=&quot;https://arxiv.org/abs/1605.07197&quot; rel=&quot;noreferrer&quot;&gt;&quot;that magic state factories have space-time costs that scale as a constant factor of surface code costs&quot;&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Within a scalable and fault-tolerant quantum computer, I see no reason to think that MSD will have a problematic overhead. We may find other methods that are better, such as ways to implement complex error correcting codes that allow transversal non-Clifford gates. But those will not be so great at error correction, and so have higher overheads for that. This could easily remove any benefits. &lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-03-21T12:02:56.767" CommentCount="0" />
  <row Id="1244" PostTypeId="1" CreationDate="2018-03-21T12:14:12.267" Score="9" ViewCount="180" Body="&lt;p&gt;While there are many interesting questions that a computer can solve with barely any data (such as factorization, which requires &quot;only&quot; a single integer), most real-world applications, such as &lt;a href=&quot;https://en.wikipedia.org/wiki/Machine_learning&quot; rel=&quot;nofollow noreferrer&quot;&gt;machine learning&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Artificial_intelligence&quot; rel=&quot;nofollow noreferrer&quot;&gt;AI&lt;/a&gt;, will require large amounts of data.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Can quantum computers handle this massive stream of data, in theory or in practice? Is it a good idea to store the data in a &quot;quantum memory&quot;, or is it better to store it in a &quot;classical memory&quot;? &lt;/p&gt;&#xA;" OwnerUserId="253" LastEditorUserId="26" LastEditDate="2018-04-02T16:35:58.487" LastActivityDate="2018-04-02T16:35:58.487" Title="Can quantum computers handle 'big' data?" Tags="&lt;quantum-computer&gt;&lt;quantum-memory&gt;&lt;memory-space&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="1" />
  <row Id="1245" PostTypeId="5" CreationDate="2018-03-21T12:59:17.557" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-21T12:59:17.557" LastActivityDate="2018-03-21T12:59:17.557" CommentCount="0" />
  <row Id="1246" PostTypeId="4" CreationDate="2018-03-21T12:59:17.557" Score="0" Body="For questions on theoretical models of quantum computations. Such models may be realistically 'build' in real machines, but not necessarily." OwnerUserId="253" LastEditorUserId="253" LastEditDate="2018-03-21T17:28:53.010" LastActivityDate="2018-03-21T17:28:53.010" CommentCount="0" />
  <row Id="1247" PostTypeId="1" CreationDate="2018-03-21T13:37:14.543" Score="8" ViewCount="170" Body="&lt;p&gt;I've got the following quantum code using &lt;a href=&quot;https://github.com/QISKit/qiskit-sdk-py&quot; rel=&quot;noreferrer&quot;&gt;QISKit&lt;/a&gt; (based on &lt;a href=&quot;https://github.com/QISKit/qiskit-sdk-py/blob/master/examples/python/hello_quantum.py&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;hello_quantum.py&lt;/code&gt;&lt;/a&gt;):&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import sys, os&#xA;from qiskit import QuantumProgram, QISKitError, RegisterSizeError&#xA;&#xA;# Create a QuantumProgram object instance.&#xA;Q_program = QuantumProgram()&#xA;try:&#xA;    import Qconfig&#xA;    Q_program.set_api(Qconfig.APItoken, Qconfig.config[&quot;url&quot;])&#xA;except:&#xA;    offline = True&#xA;    print(&quot;WARNING: There's no connection with IBMQuantumExperience servers.&quot;);&#xA;print(&quot;The backends available for use are: {}\n&quot;.format(&quot;,&quot;.join(Q_program.available_backends())))&#xA;backend = 'ibmqx5'&#xA;try:&#xA;    # Create a Quantum Register called &quot;qr&quot; with 2 qubits.&#xA;    qr = Q_program.create_quantum_register(&quot;qr&quot;, 2)&#xA;    # Create a Classical Register called &quot;cr&quot; with 2 bits.&#xA;    cr = Q_program.create_classical_register(&quot;cr&quot;, 2)&#xA;    # Create a Quantum Circuit called &quot;qc&quot;. involving the Quantum Register &quot;qr&quot;&#xA;    # and the Classical Register &quot;cr&quot;.&#xA;    qc = Q_program.create_circuit(&quot;bell&quot;, [qr], [cr])&#xA;&#xA;    # Add the H gate in the Qubit 0, putting this qubit in superposition.&#xA;    qc.h(qr[0])&#xA;    # Add the CX gate on control qubit 0 and target qubit 1, putting &#xA;    # the qubits in a Bell state&#xA;    qc.cx(qr[0], qr[1])&#xA;&#xA;    # Add a Measure gate to see the state.&#xA;    qc.measure(qr, cr)&#xA;&#xA;    # Compile and execute the Quantum Program.&#xA;    result = Q_program.execute([&quot;bell&quot;], backend=backend, shots=1024, seed=1)&#xA;&#xA;    # Show the results.&#xA;    print(result)&#xA;    print(result.get_data(&quot;bell&quot;))&#xA;&#xA;except QISKitError as ex:&#xA;    print('There was an error in the circuit!. Error = {}'.format(ex))&#xA;except RegisterSizeError as ex:&#xA;    print('Error in the number of registers!. Error = {}'.format(ex))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;I set my &lt;code&gt;APItoken&lt;/code&gt; in &lt;code&gt;Qconfig.py&lt;/code&gt; as:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;APItoken = 'XXX'&#xA;config = {&#xA;    'url': 'https://quantumexperience.ng.bluemix.net/api',&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;However, the code fails with the following error:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;The backends available for use are: ibmqx2,ibmqx5,ibmqx4,ibmqx_hpc_qasm_simulator,ibmqx_qasm_simulator,local_qasm_simulator,local_clifford_simulator,local_qiskit_simulator,local_unitary_simulator&#xA;&#xA;ERROR&#xA;There was an error in the circuit!. Error = 'QISkit Time Out'&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;I've tested both &lt;code&gt;ibmqx4&lt;/code&gt; and &lt;code&gt;ibmqx5&lt;/code&gt;, the same issue. I can see that they're active at &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/devices&quot; rel=&quot;noreferrer&quot;&gt;/qx/devices&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What does it mean? Does it mean the IBM Q server is down, or the program is too big to execute? Or there is something else going on? In other words, what should I do to run a simple Hello Quantum program on IBM quantum server?&lt;/p&gt;&#xA;" OwnerUserId="99" LastEditorUserId="26" LastEditDate="2018-03-24T06:09:28.160" LastActivityDate="2018-03-24T06:09:28.160" Title="There was an error in the circuit!. Error = 'QISkit Time Out'" Tags="&lt;ibm-q-experience&gt;&lt;qiskit&gt;" AnswerCount="2" CommentCount="4" />
  <row Id="1248" PostTypeId="5" CreationDate="2018-03-21T13:38:56.667" Score="0" Body="&lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum algorithm&lt;/a&gt; is a procedure or set of instructions that can be performed on a theoretical model of a &lt;a href=&quot;https://quantumcomputing.stackexchange.com/tags/quantum-computer/info&quot;&gt;quantum computer&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Generally, a quantum algorithm solves some problem and utilises the properties of quantum physics, such as entanglement, to do so. Often, a quantum algorithm will have a better time/query complexity than a classical algorithm solving the same problem.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;An algorithm can be written as a program in a quantum programming language, which can then be implemented on a large enough quantum computer.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Some famous algorithms include:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;Deutsch-Josza algorithm&lt;/a&gt;: The first algorithm to exponentially fast than the classical equivalent, showing the potential of quantum computing. Given an oracle that implements a function that takes an n-bit input and returns a single-bit output and is known to be either balanced (returning '1' as often as '0' over all inputs) or constant (the output is the same regardless of input), the Deutsch-Josza algorithm can deterministically find if the function is constant or balanced in a single step.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Simon%27s_problem&quot; rel=&quot;nofollow noreferrer&quot;&gt;Simon's algorithm&lt;/a&gt;: Given an oracle that implements a function (returning the same number of output bits as input bits) with the property that $f\left(x\right)=f\left(x\oplus s\right)\forall x\in\left\lbrace0, 1\right\rbrace^n$, for some unkown $s$, Simon's algorithm finds $s$ in $\mathcal O\left(n\right)$ queries, in comparison with the best possible algorithm requiring $\Omega\left(2^{n/2}\right)$ queries.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Shor%27s_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;Shor's algorithm&lt;/a&gt;: Solves the problem of integer factorisation sub-exponentially faster than the current best known classical algorithm (the general number field sieve). As current classical encryption methods rely on the computational difficulty in performing integer factorisation, a large enough fault tolerant universal quantum computer would break current encryption methods.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Grover%27s_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;Grover's algorithm&lt;/a&gt;: This finds the input value to an oracle returning a particular output for that input in a time quadratically faster than a classical computer.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;A list of all the currently discovered quantum algorithms can be found at the &lt;a href=&quot;https://math.nist.gov/quantum/zoo/&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum complexity zoo&lt;/a&gt;, which also contains links to several reviews on algorithms. Aside from Nielsen and Chuang's &lt;em&gt;Quantum Computation and Quantum Information&lt;/em&gt; textbook, these are lecture notes by:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;http://www.cs.umd.edu/~amchilds/qa/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Andrew Child&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;http://www.theory.caltech.edu/people/preskill/ph229/#lecture&quot; rel=&quot;nofollow noreferrer&quot;&gt;John Preskill&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;Michael Loceff's *A Course in Quantum Computing (for the Community College) - &lt;a href=&quot;https://www.fgamedia.org/faculty/loceff/cs_courses/cs_83a/Intro_to_QC_Vol_1_Loceff.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;pdf link&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;as well as review articles by:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/0808.0369&quot; rel=&quot;nofollow noreferrer&quot;&gt;Michele Mosca&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/0812.0380&quot; rel=&quot;nofollow noreferrer&quot;&gt;Andrew Childs and Wim van Dam&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1206.6126&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wim van Dam and Yoshitaka Sasaki&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://cacm.acm.org/magazines/2010/2/69352-recent-progress-in-quantum-algorithms/fulltext&quot; rel=&quot;nofollow noreferrer&quot;&gt;Dave Bacon and Wim van Dam&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1511.04206&quot; rel=&quot;nofollow noreferrer&quot;&gt;Ashley Montanaro&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="-1" LastEditorUserId="23" LastEditDate="2018-06-14T21:52:10.023" LastActivityDate="2018-06-14T21:52:10.023" CommentCount="0" />
  <row Id="1249" PostTypeId="4" CreationDate="2018-03-21T13:38:56.667" Score="0" Body="For questions on algorithms that could in theory be executed by quantum computers, usually the computers providing 'universal' quantum computation." OwnerUserId="253" LastEditorUserId="253" LastEditDate="2018-03-21T17:28:14.517" LastActivityDate="2018-03-21T17:28:14.517" CommentCount="0" />
  <row Id="1250" PostTypeId="2" ParentId="1247" CreationDate="2018-03-21T14:45:44.227" Score="3" Body="&lt;p&gt;As per &lt;a href=&quot;https://github.com/QISKit/qiskit-sdk-py/issues/354&quot; rel=&quot;nofollow noreferrer&quot;&gt;GitHub post&lt;/a&gt;, I had to increase the timeout for &lt;code&gt;Q_program.execute()&lt;/code&gt;, for example:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;result = Q_program.execute([&quot;bell&quot;], backend=backend, shots=1024, seed=1, timeout=600)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;The reason is probably, that the queues are busy, so we need to tell QISKit to wait up to 10 minutes. This instruction is basically blocking the rest of the script and wait till the job is executed on the actual backend server and the results are returned.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;To list details of the jobs which has been submitted, the following code can be used as proposed by &lt;a href=&quot;https://github.com/QISKit/qiskit-sdk-py/issues/354#issuecomment-374962526&quot; rel=&quot;nofollow noreferrer&quot;&gt;@ajavadia&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;from qiskit import QuantumProgram&#xA;import Qconfig&#xA;&#xA;qp = QuantumProgram()&#xA;qp.set_api(Qconfig.APItoken, Qconfig.config['url'])&#xA;&#xA;# Download details of all the jobs you've ever submitted (the default limit is 50).&#xA;my_jobs = qp.get_api().get_jobs(limit=999)&#xA;&#xA;# Filter down to get a list of completed jobs.&#xA;done_jobs = [j for j in my_jobs if j['status']=='COMPLETED']&#xA;&#xA;# Print the results for all of your completed jobs.&#xA;for j in done_jobs:&#xA;    for q in j['qasms']:&#xA;        print(q['qasm'])&#xA;        print(q['result'])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="99" LastEditorUserId="99" LastEditDate="2018-03-21T14:52:14.930" LastActivityDate="2018-03-21T14:52:14.930" CommentCount="3" />
  <row Id="1251" PostTypeId="2" ParentId="1247" CreationDate="2018-03-21T17:18:51.900" Score="6" Body="&lt;p&gt;Your job timed out, probably because of the queue being too long for the job to complete in the time allowed by default for &lt;code&gt;.execute()&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But you already know that, of course, because you have already written &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1251/409&quot;&gt;an excellent answer of your own&lt;/a&gt;. Nevertheless, I have some insights to add from battle hardened experience.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I usually use &lt;a href=&quot;https://github.com/decodoku/Misc_QISKit_Things/blob/master/Status.ipynb&quot; rel=&quot;nofollow noreferrer&quot;&gt;this notebook&lt;/a&gt; to check on how busy a device is, and if it is active. Then I typically run jobs in the following way.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    noResults = True&#xA;    while noResults:&#xA;        try: # try to run, and wait if it fails&#xA;            executedJob = engine.execute([&quot;script&quot;], backend=backend, shots=shots, max_credits = 5, wait=30, timeout=600)&#xA;            resultsVeryRaw = executedJob.get_counts(&quot;script&quot;)&#xA;            if ('status' not in resultsVeryRaw.keys()):&#xA;                noResults = False&#xA;            else:&#xA;                print(resultsVeryRaw)&#xA;                print(&quot;This is not data, so we'll wait and try again&quot;)&#xA;                time.sleep(300)&#xA;        except:&#xA;            print(&quot;Job failed. We'll wait and try again&quot;)&#xA;            time.sleep(600)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;This uses &lt;code&gt;try&lt;/code&gt; to manage any exceptions that might result. The program will just wait and try again rather than crash.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we get to the point of successfully using &lt;code&gt;.get_counts&lt;/code&gt;, the program then checks to see if it actually contains results. Or rather, it checks that the &lt;code&gt;'status'&lt;/code&gt; key is not present, for it is the harbinger of doom. If there is not proper results, the program again waits and tries again.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-03-21T18:14:06.007" LastActivityDate="2018-03-21T18:14:06.007" CommentCount="0" />
  <row Id="1252" PostTypeId="2" ParentId="1236" CreationDate="2018-03-21T18:02:38.053" Score="2" Body="&lt;p&gt;I'll try to give a slightly different perspective onto the same things covered by &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1240/55&quot;&gt;the other answer&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A &quot;table of truth&quot; characterises a gate by telling you how each basis state evolves through the gate.&#xA;Note that this requires choosing an input &lt;em&gt;and&lt;/em&gt; and output bases.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the prototypical example of the CNOT gate, one chooses the computational basis both for input and output states, and it turns out that all the elements of the computational basis evolve into other elements of the computational basis.&#xA;In other words, an element of the computational basis, passing through a CNOT gate, ends up in a specific output basis state (as opposed to a &lt;em&gt;superposition&lt;/em&gt; of basis states).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What might be confusing in this &quot;table of truth&quot; way to describe a gate, is that it can be used only with some choices of input and output bases.&#xA;For example, you cannot give a &quot;table of truth&quot; description of the CNOT gate using the $\{|L\rangle, |R\rangle\}$ basis, because, as you can check, $\text{CNOT}|L, L\rangle = \frac{1}{2}(|L, L\rangle + i |L, R\rangle + |R, L\rangle -i|R, R\rangle)$.&#xA;Indeed, the &quot;table of truth representation&quot; is only useful in some circumstances, for example when one wants to highlight that a gate might be a &quot;quantum generalisation&quot; of a specific classical gate, like it's the case for the CNOT gate.&lt;/p&gt;&#xA;" OwnerUserId="55" LastActivityDate="2018-03-21T18:02:38.053" CommentCount="0" />
  <row Id="1253" PostTypeId="5" CreationDate="2018-03-21T19:05:11.547" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-21T19:05:11.547" LastActivityDate="2018-03-21T19:05:11.547" CommentCount="0" />
  <row Id="1254" PostTypeId="4" CreationDate="2018-03-21T19:05:11.547" Score="0" Body="For questions about the principle and application of quantum entanglement, the phenomenon that the states of two qubits can only be described as the state of one system, to quantum computers." OwnerUserId="11" LastEditorUserId="1005" LastEditDate="2018-04-11T12:36:26.507" LastActivityDate="2018-04-11T12:36:26.507" CommentCount="0" />
  <row Id="1255" PostTypeId="1" AcceptedAnswerId="1260" CreationDate="2018-03-21T23:09:07.573" Score="14" ViewCount="217" Body="&lt;p&gt;In the last years, there has been a spur of demonstrations of devices able to perform proof of principle, small-scale, non-fault-tolerant quantum computation (or Noisy Intermediate-Scale Quantum technologies, how &lt;a href=&quot;https://arxiv.org/abs/1801.00862&quot; rel=&quot;noreferrer&quot;&gt;they have been referred to&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;With this I'm mostly referring to the superconducting and ion trap devices demonstrated by groups such as Google, Microsoft, Rigetti Computing, Blatt's group (and probably others that I'm forgetting now).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;These devices, as well as the ones that will follow them, are often radically different from each other (in terms of architecture, gates that are easier/harder to implement, number of qubit, connectivity between the qubits, coherence and gate times, generation and readout capabilities, gate fidelities, to name the most obvious factors).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;On the other hand, it is very common in press releases and non-technical news to just say &quot;the new X device has Y more qubits than the one before, therefore it is so much more powerful&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is the number of qubits really such an important factor to assess these devices? Or should we instead use different metrics? More generally, are there &quot;simple&quot; metrics that can be used to qualitatively, but meaningfully, compare different devices? &lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="26" LastEditDate="2018-03-26T00:01:20.233" LastActivityDate="2018-03-26T00:01:20.233" Title="How should different quantum computing devices be compared?" Tags="&lt;architecture&gt;&lt;technical-standards&gt;" AnswerCount="4" CommentCount="1" FavoriteCount="3" />
  <row Id="1256" PostTypeId="2" ParentId="1255" CreationDate="2018-03-21T23:51:03.770" Score="14" Body="&lt;p&gt;This is a greatly debated topic, and I'm not sure there is an answer to your question at the current time. However, the &lt;a href=&quot;https://www.ieee.org/index.html&quot; rel=&quot;noreferrer&quot;&gt;IEEE&lt;/a&gt; (Institute of Electrical and Electronics Engineers) has proposed PAR 7131 - &lt;a href=&quot;https://standards.ieee.org/develop/project/7131.html&quot; rel=&quot;noreferrer&quot;&gt;Standard for Quantum Computing Performance Metrics &amp;amp; Performance Benchmarking&lt;/a&gt;: &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The purpose of this project is to provide a standardized set of&#xA;  performance metrics and a standardized methodology of benchmarking the&#xA;  speed/performance of various types of quantum computing hardware and&#xA;  software as well as comparing these performance metrics to identical&#xA;  metrics in classical computers such that users of this document may&#xA;  determine the speed of a quantum computer for a specific application&#xA;  can easily, and reliably, compare computer performance.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Full disclosure I am the current Chair of the Quantum Computing Standards Workgroup and the reason this PAR was originally proposed was because of a lack of documentation/standards on testing the various quantum computing architectures against classical architectures and each other. The factors you sighted above &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;number of qubit, connectivity between the qubits, coherence and gate&#xA;  times, generation and readout capabilities, gate fidelities&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;are all included as are several other factors. As importantly we've also been working on a way to standardize solvers; an often overlooked component in benchmarking. Non-optimized solvers all too often benefit a quantum machine when comparing quantum architectures to classical architectures. That is, the solver running on the quantum architecture is always optimized where the solver running on the classical architecture is not. This creates an inherent bias in favor of the quantum architecture. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you're interested in participating in the development of this standard please let me know, the more people involved from both the quantum and classical sides of the argument the better imho. In the meantime the PAR will start work shortly, and will be coordinating their efforts with other standards organizations so that a single common standard with no bias can emerge to help address performance and benchmarking in the future. &lt;/p&gt;&#xA;" OwnerUserId="274" LastEditorUserId="52" LastEditDate="2018-03-22T16:44:43.943" LastActivityDate="2018-03-22T16:44:43.943" CommentCount="2" />
  <row Id="1257" PostTypeId="2" ParentId="1255" CreationDate="2018-03-22T00:05:45.893" Score="6" Body="&lt;p&gt;IBM is promoting their &lt;a href=&quot;https://www.research.ibm.com/ibm-q/resources/quantum-volume.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum volume&lt;/a&gt; (see also &lt;a href=&quot;https://pdfs.semanticscholar.org/650c/3fa2a231cd77cf3d882e1659ee14175c01d5.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;this&lt;/a&gt;) idea to quantify the power of a gate model machine with a single number. Before IBM, there was an attempt from Rigetti to define a &lt;a href=&quot;http://willzeng.com/shared/functional_architecture_final_ICRC.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;total quantum factor&lt;/a&gt;.&#xA;Unclear if it captures what we want in terms of usefulness of devices for applications. Things such as quantum volume are be designed with supremacy experiments in mind, it seems to me. I am leaning to think that a metric should be really application specific. For sampling, this work suggested to use &lt;a href=&quot;https://arxiv.org/abs/1801.07686&quot; rel=&quot;nofollow noreferrer&quot;&gt;the qBAS score&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For quantum annealing and similar analog approaches, it seems the community is agreeing on &lt;a href=&quot;https://arxiv.org/abs/1401.2910&quot; rel=&quot;nofollow noreferrer&quot;&gt;time-to-solution&lt;/a&gt; and variants; once again quite application specifics.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The community is working on defining metrics, and I expect in 2018 to see actual runs of the same problem on different devices (empirical comparison).&lt;/p&gt;&#xA;" OwnerUserId="410" LastEditorUserId="410" LastEditDate="2018-03-23T01:54:26.350" LastActivityDate="2018-03-23T01:54:26.350" CommentCount="0" />
  <row Id="1258" PostTypeId="2" ParentId="1255" CreationDate="2018-03-22T00:39:38.400" Score="8" Body="&lt;p&gt;While number of qubits should be &lt;em&gt;part of&lt;/em&gt; such a metric, as you say, it's far from everything.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, comparing two different completely different devices (e.g. superconducting and linear optics) is not the most straightforward task&lt;sup&gt;1&lt;/sup&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Factors&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Asking about coherence and gate times is equivalent to asking about fidelity and gate times&lt;sup&gt;1&lt;/sup&gt;. Gates being harder or easier to implement just affects the fidelity again.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Initialisation rate, qubit/entanglement generation and readout capabilities (etc.) are going to affect overall fidelities as well as something akin to 'how frequently (on average) can we perform a computation (while getting a high-enough fidelity result, for some idea of 'high-enough fidelity')'.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In terms of architecture, the more macro-architecture (e.g. qRAM) will have its own standards and benchmarks, such as readout time, 'is readout on demand?' and of course, fidelity.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The more microarchitecture can be described under the same notions of connectivity.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Another, often ignored, metric is the power/resources used.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Overall, this may have narrowed this list down &lt;em&gt;slightly&lt;/em&gt;, but it's still a list that involves a fair amount of comparison. Comparing different devices that use the same method isn't even that straightforward as (at current levels of technology), the processors with higher numbers of qubits often have lower fidelities&lt;sup&gt;2&lt;/sup&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Quantum volume&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Thankfully, a few people at IBM have taken the above (except for power used and the architecture) and defined something a bit more useful than 'number of qubits' and called it &lt;a href=&quot;https://www.semanticscholar.org/paper/Quantum-Volume-Bishop-Bravyi/650c3fa2a231cd77cf3d882e1659ee14175c01d5&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;&lt;em&gt;quantum volume&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;. In this, for a random pair of $2$ qubits, they first define an effective error rate, $\epsilon_{eff}$, by considering what gate errors would be required in an otherwise perfect system to give the same error as the device. This may require the use of SWAP for low connectivity and Solovay-Kitaev-esque methods for low numbers of implementable gates. This is countered by using teleportation if the system has &quot;fast measurements and feedback&quot; and any other appropriate method.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For a total number of qubits $n$ and maximising over the number of 'active qubits', $n'$, the quantum volume is $$V_Q = \max_{n'\leq n}\min\left[n', \frac{1}{\epsilon_{eff}\left(n'\right)}\right]^2.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Of course, we want to move beyond the point of science and into engineering. For that we need a standard&lt;sup&gt;3&lt;/sup&gt;. This is currently being planned, as detailed in &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1256/23&quot;&gt;Whurley's answer&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, as any comparison between such lists isn't going to be straightforward, there's always the more subjective way, such as &lt;a href=&quot;https://medium.com/@decodoku/how-good-are-todays-quantum-computers-really-896488e0b701&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;&lt;em&gt;Quantum Awesomeness&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;, where the enjoyment of the game depends on how good the processor is&lt;sup&gt;4&lt;/sup&gt;.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;1 In this particular case, one example is that as photons don't decohere, so this has to be adapted to asking about the length of time or number of gates before the realised state is no longer a good approximation to the ideal state, which is just asking for the fidelity, or fidelity and gate times&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;2 I've tried this much at least and even this isn't exactly the most fun task&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;3 The first, unlike in &lt;a href=&quot;https://xkcd.com/927/&quot; rel=&quot;noreferrer&quot;&gt;XKCD 927&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;4 The author's opinion is that, while an awesome idea and helpful for getting an idea of how good a processor is, saying that one processor is better than another at such a game is a bit &lt;em&gt;too&lt;/em&gt; subjective to tell if one processor is &lt;em&gt;actually&lt;/em&gt; better than another&lt;/sup&gt;&lt;/p&gt;&#xA;" OwnerUserId="23" LastEditorUserId="23" LastEditDate="2018-03-22T00:44:52.090" LastActivityDate="2018-03-22T00:44:52.090" CommentCount="1" />
  <row Id="1259" PostTypeId="2" ParentId="1244" CreationDate="2018-03-22T08:02:28.817" Score="3" Body="&lt;p&gt;It's not so much a matter of big data, but that of saving data. Quantum Storage is still (much like the rest of the field) in its infancy.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(Take what I write with a grain of salt. It's likely to change rapidly)&lt;br&gt;&#xA;There are a few theories on how quantum computers might be able to hold &quot;memory&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One of these is using nuclear spin. E.g. using long-lived nuclei in a quantum state. Converting an electron qubit (a qubit represented by an electron) to a nuclear qubit is &lt;a href=&quot;https://arxiv.org/pdf/0803.2021.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;possible&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Why nuclear qubit/spin?&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;A nucleus's coherence time - the time for which its phase is constant (when considering its wave function) - is longer than that of an electron. The &lt;a href=&quot;https://arxiv.org/pdf/0803.2021.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;linked article&lt;/a&gt; (same one as before) details how one can increase the coherence time of a nuclear spin (to some extent). The matter is being researched, but there is indication that nuclear qubits can be a form of quantum storage.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;What makes it difficult&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;The quantum state needs to remain, well, quantum. Additionally, if you entangle two of your &quot;storage&quot; qubits, you are likely to lose data. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Due to no-cloning, one cannot simply &quot;copy&quot; a qubit (who's state is unknown), which is one of the reasons quantum storage is difficult.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As for &quot;big&quot; data, it's just a matter of how much memory you have.&lt;/p&gt;&#xA;" OwnerUserId="13" LastActivityDate="2018-03-22T08:02:28.817" CommentCount="4" />
  <row Id="1260" PostTypeId="2" ParentId="1255" CreationDate="2018-03-22T10:09:08.527" Score="3" Body="&lt;p&gt;I think the answer depends on why you are comparing them. Things like the quantum volume, are perhaps better suited to defining progress in the development of devices rather than fully informing end users.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, you are buying a new laptop, you probably use more than just a single number when comparing them. The same should be true for quantum processors. There are many different aspects to a device: number of qubits, connectivity, all the different types of noise, time for measurement (and so whether feedback from measurement results is feasible), gate operation times, etc. All these need to be combined to tell you the one thing you actually need to know: can it run the program that you want to run? That is, I think, always going to be the most pertinent comparison. But it is also the trickiest.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-03-22T10:09:08.527" CommentCount="0" />
  <row Id="1262" PostTypeId="1" CreationDate="2018-03-22T11:54:59.120" Score="10" ViewCount="113" Body="&lt;p&gt;When expressing computations in terms of a quantum circuit, one makes use of &lt;em&gt;gates&lt;/em&gt;, that is, (typically) unitary evolutions.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In some sense, these are rather mysterious objects, in that they perform &quot;magic&quot; discrete operations on the states.&#xA;They are essentially black boxes, whose inner workings are not often dealt with while studying quantum algorithms.&#xA;However, that is not how quantum mechanics works: states evolve in a continuous fashion following Schrödinger's equation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In other words, when talking about quantum gates and operations, one neglects the &lt;em&gt;dynamic&lt;/em&gt; (that is, the Hamiltonian) realising said evolution, which is how the gates are actually implemented in experimental architectures.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One method is to decompose the gate in terms of elementary (in a given experimental architecture) ones. Is this the only way? What about such &quot;elementary&quot; gates? How are the dynamics implementing those typically found?&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-03-24T13:04:45.027" LastActivityDate="2018-03-24T13:04:45.027" Title="How are quantum gates realised, in terms of the dynamic?" Tags="&lt;quantum-gate&gt;&lt;architecture&gt;&lt;gate-synthesis&gt;" AnswerCount="1" CommentCount="10" />
  <row Id="1263" PostTypeId="1" AcceptedAnswerId="1264" CreationDate="2018-03-22T12:19:53.040" Score="3" ViewCount="188" Body="&lt;p&gt;The most down-voted question at the moment is about using entanglement for faster-than-light communication. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Much like how the word “laser” replaced “magic” in the vernacular not too long ago, what are some things that people outside the field think quantum computers, qubits, entanglement, tunneling, or superposition do that people might need to be educated about? Or what are some popular myths about these things should be dispelled?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One question I’m asked frequently is the reason for the difference in the number of qubits between the D Wave and IBM QX. D Wave has more so it must be better. So in this case, people need to be educated on the different implementations of quantum devices. &lt;/p&gt;&#xA;" OwnerUserId="54" LastActivityDate="2018-03-22T12:50:39.920" Title="What are some popular myths or common misconceptions about quantum computing?" Tags="&lt;quantum-computer&gt;&lt;qubit&gt;&lt;quantum-entanglement&gt;" AnswerCount="1" CommentCount="14" ClosedDate="2018-03-22T15:04:15.387" />
  <row Id="1264" PostTypeId="2" ParentId="1263" CreationDate="2018-03-22T12:50:39.920" Score="10" Body="&lt;p&gt;&lt;strong&gt;1. Quantum computers are powerful because they act in many universes at once&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is an oversimplification based on the MWI at best. I don't think it has any pedagogical value. It needs to stop being repeated. Every journalist I talk to asks whether it is a good thing to write. I always say no.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;2. Quantum computers/physics is weird and random&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Anyone not swept up in the parallel universes seems to think that quantum computers are just some weird random thing. As before, there is a kernel of truth, but it is not a good explanation. Quantum algorithms are all about managing the certainty in the system, moving it through the state space to turn a certain input into an (ideally) certain output. The randomness is there, but I don't think it should be the focus of an understanding of quantum computing.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There seems to be an idea that quantum physics is just a strange random thing. And so quantum computers are just computers with weird randomness going on. From what I've seen, anyone who doesn't get swept up in the whole 'computing in many&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;3. Quantum physics does not follow logic&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The popular talk of how strange and weird quantum physics is makes it seem quite illogical. This is pretty bad from the perspective of quantum computing, since computers are build on logic. How can a programmer be expected to make the move o quantum if they think that quantum programming is illogical? If the quantum world seems like a mystical realm understood only through arcane knowledge, it will be hard to engage people outside of the field.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Though quantum physics doesn't follow the logic of local hidden variables and non-contextuality, it of course has its own logic. The fun of quantum computing is learning how to embrace and use effects that are not possible in classical variables.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Summary&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I think we should be championing the message that quantum computers are full of logic and certainty, and that these are what we harness to do computation. Too much talk of random and strange effects should be avoided. As should the whole multiple universe thing.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-03-22T12:50:39.920" CommentCount="2" />
  <row Id="1265" PostTypeId="1" AcceptedAnswerId="1273" CreationDate="2018-03-22T14:26:11.617" Score="8" ViewCount="675" Body="&lt;p&gt;Recently, I've read about 'Quantum bogo sort' on some wiki. The basic idea is, that like bogo sort, we just shuffle our array and hope it gets sorted 'by accident' and retry on failure. &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The difference is that now, we have '&lt;em&gt;magic&lt;/em&gt; quantum', so we can simply try all permutations at once in 'parallel universes' and 'destroy all bad universes' where the sort is bad. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Now, obviously, this doesn't work. Quantum is physics, not magic. The main problems are &lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;'Parallel universes' is merely an &lt;em&gt;interpretation&lt;/em&gt; of quantum effects, not something that Quantum Computing exploits. I mean, we could use hard numbers here, interpretation will only confuse matters here, I think.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;'Destroying all bad universes' is a bit like qubit error correction, a very hard problem in Quantum Computing.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Bogo sort remains stupid. If we can speed-up sorting via quantum, why not base it on a &lt;em&gt;good sorting algorithm&lt;/em&gt;? (But we need randomness, my neighbour protests! Yes, but can't you think of &lt;a href=&quot;https://en.wikipedia.org/wiki/Quicksort&quot; rel=&quot;nofollow noreferrer&quot;&gt;a better classical algorithm that relies on randomness&lt;/a&gt;?)&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;While this algorithm is mostly a joke, it could be an 'educational joke', like the 'classical' bogo-sort as the difference between best case, worst case and average case complexity for randomized algorithms is easy and very clear here. (for the record, best case is $\Theta(n)$, we are very lucky but still must check that our answer is correct by scanning the array, expected time is simply &lt;em&gt;awful&lt;/em&gt; (IIRC, proportional to the number of permutations, so $O(n!)$) and worst case is we never finish)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, what can we learn from 'Quantum bogo sort'? In particular, are there real quantum algorithms that are similar or is this a theoretical or practical impossibility?&#xA;Furthermore, has there been research into 'quantum sorting algorithms'? If not, why?&lt;/p&gt;&#xA;" OwnerUserId="253" LastEditorUserId="26" LastEditDate="2018-03-29T18:10:12.643" LastActivityDate="2018-03-29T18:10:12.643" Title="What can we learn from 'Quantum Bogo sort'?" Tags="&lt;quantum-algorithms&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="1266" PostTypeId="5" CreationDate="2018-03-22T14:29:57.423" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-22T14:29:57.423" LastActivityDate="2018-03-22T14:29:57.423" CommentCount="0" />
  <row Id="1267" PostTypeId="4" CreationDate="2018-03-22T14:29:57.423" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-22T14:29:57.423" LastActivityDate="2018-03-22T14:29:57.423" CommentCount="0" />
  <row Id="1268" PostTypeId="2" ParentId="1208" CreationDate="2018-03-22T21:07:54.307" Score="10" Body="&lt;p&gt;I will only answer to the part of the question regarding how quantum mechanics can be useful for analysis of classical data via machine learning.&#xA;There are also works related to &quot;quantum AI&quot;, but that is a much more speculative (and less defined) kind of thing, which I do not want to go into.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, &lt;em&gt;can quantum computers be used to speed-up data analysis via machine learning algorithms&lt;/em&gt;? Quoting &lt;a href=&quot;https://www.scottaaronson.com/papers/qml.pdf&quot; rel=&quot;noreferrer&quot;&gt;Scott Aaronson's &lt;em&gt;Read the fine print&lt;/em&gt;&lt;/a&gt; paper, &lt;em&gt;that’s a simple question with a complicated answer&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It should first of all be noted that trying to answer this kind of question is a big part of what the research area of &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_machine_learning&quot; rel=&quot;noreferrer&quot;&gt;Quantum Machine Learning&lt;/a&gt; is about (more recently, the terms &lt;em&gt;quantum-enhanced machine learning&lt;/em&gt; or &lt;em&gt;quantum assisted machine learning&lt;/em&gt; seem to be preferred to refer to this merging of QM and ML, to distinguish it from the use of ML to help solve problems in QM).&#xA;As you can see from the Wikipedia page, there are many things going on in the field, and it would be pointless to try and give a comprehensive list of relevant papers here, as it would get outdated quickly.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quoting from &lt;a href=&quot;https://arxiv.org/abs/1409.3097&quot; rel=&quot;noreferrer&quot;&gt;Schuld et al. 2014&lt;/a&gt;, the idea behind &lt;em&gt;Quantum-Assisted Machine Learning&lt;/em&gt; (QAML) is the following:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Since the volume of globally stored data is growing by around 20%&#xA;  every year (currently ranging in the order of several hundred exabytes&#xA;  [1]), the pressure to find innovative approaches to machine learning&#xA;  is rising. A promising idea that is currently investigated by academia&#xA;  as well as in the research labs of leading IT companies exploits the&#xA;  potential of quantum computing in order to optimise classical machine&#xA;  learning algorithms.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Going back to your question, a first seemingly positive answer was provided by &lt;a href=&quot;https://arxiv.org/abs/0811.3171&quot; rel=&quot;noreferrer&quot;&gt;Harrow et al. 2009&lt;/a&gt;, which gave an efficient quantum algorithm to invert linear system of equations (under a number of conditions over the system), working when the data is stored in quantum states. Being this a fundamental linear algebra operation, the discovery led to many proposed quantum algorithms to solve machine learning problems by some of the same authors (&lt;a href=&quot;https://arxiv.org/abs/1307.0401&quot; rel=&quot;noreferrer&quot;&gt;1307.0401&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1307.0411&quot; rel=&quot;noreferrer&quot;&gt;1307.0411&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1307.0471&quot; rel=&quot;noreferrer&quot;&gt;1307.0471&lt;/a&gt;), as well as by many others.&#xA;There are now many reviews that you can have a look at to get more comprehensive lists of references, like &lt;a href=&quot;https://arxiv.org/abs/1409.3097&quot; rel=&quot;noreferrer&quot;&gt;1409.3097&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1512.02900&quot; rel=&quot;noreferrer&quot;&gt;1512.02900&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1611.09347&quot; rel=&quot;noreferrer&quot;&gt;1611.09347&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1707.08561&quot; rel=&quot;noreferrer&quot;&gt;1707.08561&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1708.09757&quot; rel=&quot;noreferrer&quot;&gt;1708.09757&lt;/a&gt;, &lt;a href=&quot;https://www.sciencedirect.com/science/book/9780128009536&quot; rel=&quot;noreferrer&quot;&gt;Peter Wittek's book&lt;/a&gt;, and likely more.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, it is far from established how this would work in practice. Some of the reasons are well explained in Aaronson's paper: &lt;a href=&quot;https://www.scottaaronson.com/papers/qml.pdf&quot; rel=&quot;noreferrer&quot;&gt;&lt;em&gt;Read the fine print&lt;/em&gt;&lt;/a&gt; (see also published version: &lt;a href=&quot;https://www.nature.com/articles/nphys3272&quot; rel=&quot;noreferrer&quot;&gt;nphys3272&lt;/a&gt;).&#xA;Very roughly speaking, the problem is that quantum algorithms generally handle &quot;data&quot; as stored in quantum states, often encoding vectors into the amplitudes of the state.&#xA;This is, for example, the case for the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_Fourier_transform&quot; rel=&quot;noreferrer&quot;&gt;QFT&lt;/a&gt;, and it is still the case for &lt;a href=&quot;https://arxiv.org/abs/0811.3171&quot; rel=&quot;noreferrer&quot;&gt;HHL09&lt;/a&gt; and derived works.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The big problem (or one of the big problems) with this is that it is far from obvious how you can efficiently load the &quot;big&quot; classical data into this quantum state for processing. The typical answer to this is &quot;we just have to use a &lt;a href=&quot;https://arxiv.org/abs/0708.1879&quot; rel=&quot;noreferrer&quot;&gt;qRAM&lt;/a&gt;&quot;, but that also comes with many caveats, as this process needs to be very fast to maintain the exponential speed-up that we now can be achieved once the data is in quantum form.&#xA;I again refer to &lt;a href=&quot;https://www.nature.com/articles/nphys3272&quot; rel=&quot;noreferrer&quot;&gt;Aaronson's paper&lt;/a&gt; for further details on the caveats.&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-04-01T08:14:11.497" LastActivityDate="2018-04-01T08:14:11.497" CommentCount="0" />
  <row Id="1269" PostTypeId="1" AcceptedAnswerId="1279" CreationDate="2018-03-22T21:35:42.920" Score="7" ViewCount="160" Body="&lt;p&gt;So, @AndrewO mentioned recently that he has had 'encounters' with people wondering why D-Wave has &lt;em&gt;a lot more qubits than IBM&lt;/em&gt;. Of course, this comparison is faulty, since the IBM and D-Wave's machine may both exploit quantum effects to a certain degree, IBM's machine matches the thing the TCS people call a 'Quantum computer' a bit more than D-Waves's alleged quantum annealer. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;How do you explain to a novice why IBM is still reaching important milesstones, even though the D-Wave has &lt;em&gt;a lot more 'qubits'&lt;/em&gt;. I understand that an easy answer is, 'well, you're comparing apples and pears', but that is merely relying on your possible authority and simply doesn't explain anything! &lt;/p&gt;&#xA;&#xA;&lt;p&gt;How can you explain that those devices are different, how can you dispell the myth that the number of qubits is not the only metric to judge quantum devices? (preferably to a layman, but assuming basic (undergrad?) Physics knowledge is ok, if needed)&lt;/p&gt;&#xA;" OwnerUserId="253" LastEditorUserId="26" LastEditDate="2018-03-25T06:50:43.397" LastActivityDate="2018-03-25T06:50:43.397" Title="How to explain in layman’s terms the significance of the difference of qubits of the D-Wave and IBM QX?" Tags="&lt;quantum-computer&gt;&lt;performance&gt;&lt;d-wave&gt;&lt;ibm-q-experience&gt;" AnswerCount="1" CommentCount="3" />
  <row Id="1270" PostTypeId="2" ParentId="12" CreationDate="2018-03-23T04:10:24.303" Score="3" Body="&lt;p&gt;Yes. If you build it yourself, find a 3rd party computer with the same specs as the BullSequana M9600 series, or come up with &lt;a href=&quot;http://www.computerweekly.com/news/450421977/Atos-targets-universities-and-research-centres-with-quantum-computing-simulator&quot; rel=&quot;nofollow noreferrer&quot;&gt;€100K+&lt;/a&gt; and buy a system from Atos.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Notice the similarity between the BullSequana M9600 series and the &lt;a href=&quot;https://atos.net/en/insights-and-innovation/atos-quantum&quot; rel=&quot;nofollow noreferrer&quot;&gt;Atos QLM&lt;/a&gt;.&#xA;&lt;a href=&quot;https://i.stack.imgur.com/S1qt6.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/S1qt6.png&quot; alt=&quot;Atis QLM vs. M9600&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Same box (and probably internal components) with different software (but you wanted to use your own, Q#). Atos claims: &quot;The highest-performing quantum simulator in the world&quot;. I'm not sure about that but the specs for the 30 qubit version are reachable, just two Intel CPUs and 1TB of memory. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://atos.net/wp-content/uploads/2017/07/atos-quantum-learning-machine.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Atos QLM .PDF Brochure&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Is there &lt;strong&gt;any way&lt;/strong&gt; to emulate a quantum computer in my &lt;strong&gt;normal&lt;/strong&gt; computer, so that I will be able to &lt;strong&gt;test&lt;/strong&gt; and &lt;strong&gt;try&lt;/strong&gt; quantum programming languages (such as Q#)?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;If you use only 256GB of memory and 1-24TB of Swap Drive it will be &lt;strong&gt;slow&lt;/strong&gt; but it &lt;em&gt;will&lt;/em&gt; work.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;I mean something that I can really test my hypothesis on and get &lt;strong&gt;the most accurate results&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Quote from the  Brochure:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;The Atos Quantum Learning Machine &lt;strong&gt;computes the exact execution&lt;/strong&gt; of a quantum program, with double digit precision. It &lt;strong&gt;simulates the laws of physics&lt;/strong&gt;, which are at the very heart of quantum computing. This is very different to existing quantum processors, which suffer from quantum noise, quantum decoherence, and manufacturing biases, as well as performance bottlenecks. Simulation on the Atos Quantum Learning Machine enables developers to focus on their applications and algorithms, without having to wait for quantum machines to be available&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;They claim high accuracy, since it's a simulator it's not subject to  noise - nor will it be as fast, or as expensive. In theory you could add some memory,  drives, and software to your computer ...&lt;/p&gt;&#xA;" OwnerUserId="278" LastActivityDate="2018-03-23T04:10:24.303" CommentCount="0" />
  <row Id="1271" PostTypeId="1" AcceptedAnswerId="1286" CreationDate="2018-03-23T04:54:39.233" Score="6" ViewCount="130" Body="&lt;p&gt;We've seen people use computers to design computers, AI to write computer programs, robots teach themselves, and even robots build themselves. I understand that conventional computers can be used to emulate quantum computers. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/1ZDzZ.gif&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/1ZDzZ.gif&quot; alt=&quot;Emika Robotic Arm builds it&amp;#39;s co-workers.&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Robotic arm builds more robotic arms.&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;My question is:&lt;/strong&gt; Will quantum computers be &lt;strong&gt;inherently able&lt;/strong&gt; to design &lt;strong&gt;better&lt;/strong&gt; quantum computers (which presumably robots could then build) or is that task better suited to Deep Learning / AI and conventional computers (with human intervention)?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Perhaps another way to ask the question, though I'm fairly certain that this won't make it clearer: &quot;Do conventional computers limit us to quantum  Darwinism while quantum computers might enable universal Darwinism &lt;strong&gt;with respect to&lt;/strong&gt; the evolution of quantum computer design?&quot;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Oversimplified (&lt;strong&gt;not&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;the&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;question&lt;/strong&gt;): Could they understand (design) themselves better than classical computers, Deep Learning / AI, or mankind - IE: they do not suffer from what Zurek calls “pointer states”.&lt;/p&gt;&#xA;" OwnerUserId="278" LastEditorUserId="278" LastEditDate="2018-03-25T15:00:40.070" LastActivityDate="2018-03-25T15:00:40.070" Title="Can quantum computers design quantum computers autonomously better than other methods?" Tags="&lt;quantum-computer&gt;&lt;architecture&gt;&lt;quantum-turing-machine&gt;" AnswerCount="3" CommentCount="0" FavoriteCount="1" />
  <row Id="1272" PostTypeId="2" ParentId="1262" CreationDate="2018-03-23T06:23:55.710" Score="4" Body="&lt;p&gt;Generally speaking, a realization of a quantum gate involves coherent manipulation of a two-level system (but this is nothing new to you, maybe). For example, you can use two long-lived electronic states in a trapped atom (neutral or ionized in vacuo) and use an applied electric field to implement single-qubit operations (see trapped ions or optical lattices, for example). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Alternatively, there are solid-state solutions like superconducting qubits or silicon-defect qubits which are addressed by radio-frequency electronics. You can use microwave-addressed nuclear spin sublevels, or nitrogen vacancy cells in diamond. The commonality is that the manipulation and coupling of the qubits is via applied light fields, and there are a range of methods you can use to tune the level spacing in these systems to enable single-spin addressing or manipulate lifetimes. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The translation from the implementation to Hamiltonian is obviously dependent on your choice of system, but eventually it all boils back down to Pauli matrices in the end. The light field provides off-diagonal elements in your single-qubit operations, whereas two-qubit operations are trickier and techniques are very implementation-dependent.&lt;/p&gt;&#xA;" OwnerUserId="484" LastActivityDate="2018-03-23T06:23:55.710" CommentCount="1" />
  <row Id="1273" PostTypeId="2" ParentId="1265" CreationDate="2018-03-23T09:05:19.030" Score="7" Body="&lt;h1&gt;DISCLAIMER: The quantum-bogosort is a joke-algorithm&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Let me just state the algorithm in brief:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Step 1: Using a quantum randomization algorithm, randomize the list/array, such that there is no way of knowing what order the list is in until it is observed. This will divide the universe into $O(N!)$ universes; however, the division has no cost, as it happens constantly anyway.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Step 2: Check if the list is sorted. If not, destroy the universe (neglecting the actual physical possibility).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Now, all remaining universes contain lists/arrays which are sorted.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Worst Case Complexity&lt;/strong&gt;: $O(N)$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(we only consider those universes which can observe that the list is sorted)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Average/Best Case Complexity&lt;/strong&gt;: $O(1)$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One of the major problems with this algorithm is the huge possibility magnification of errors as Nick Johnson mentions &lt;a href=&quot;https://stackoverflow.com/questions/2609857/are-there-any-worse-sorting-algorithms-than-bogosort-a-k-a-monkey-sort#comment9410415_2610433&quot;&gt;here&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;This algorithm has a much bigger problem, however. Assume that one in 10 billion times you will mistakenly conclude a list is sorted when it's not. There are 20! ways to sort a 20 element list. After the sort, the remaining universes will be the one in which the list was sorted correctly, and the 2.4 million universes in which the algorithm mistakenly concluded the list was sorted correctly. So what you have here is an algorithm for massively magnifying the error rate of a piece of machinery.&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;'Parallel universes' is a highly &lt;em&gt;simplified interpretation of quantum&#xA;  effects&lt;/em&gt;, not something that Quantum Computing exploits.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Not really sure what you mean by &quot;highly simplified interpretation of quantum effects&quot;. The sources (&lt;a href=&quot;http://wiki.c2.com/?QuantumBogoSort&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt; and &lt;a href=&quot;https://www.reddit.com/r/programming/comments/thtx/my_new_favorite_sorting_algorithm/ctkml/&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt;) I found on the internet regarding the quantum bogosort &lt;strong&gt;do not&lt;/strong&gt; explicitly mention that they're using the alternative interpretation of QM i.e. the &lt;a href=&quot;https://en.wikipedia.org/wiki/Many-worlds_interpretation&quot; rel=&quot;noreferrer&quot;&gt;Everett's interpretation&lt;/a&gt; which you might be thinking about. In fact I'm not even sure how to glue together the Everett's interpretation and quantum-bogosort (using post-selection, as some people commented). Anyhow, just as a note: in mainstream cosmology, it is widely believed that more than one universe exists and there are even classifications for them, called the &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiverse#Max_Tegmark&amp;#39;s_four_levels&quot; rel=&quot;noreferrer&quot;&gt;Max Tegmark's four levels&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiverse#Brian_Greene&amp;#39;s_nine_types&quot; rel=&quot;noreferrer&quot;&gt;Brian Greene's nine types&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiverse#Cyclic_theories&quot; rel=&quot;noreferrer&quot;&gt;Cyclic theories&lt;/a&gt;. Read the Wiki article on &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiverse&quot; rel=&quot;noreferrer&quot;&gt;Multiverse&lt;/a&gt; for more details.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;'Destroying all bad universes' is a bit like qubit error correction, a&#xA;  very hard problem in Quantum Computing.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Sure, it is in fact much harder, and we don't expect to &lt;em&gt;destroy&lt;/em&gt; universes literally. The quantum bogosort is just a theoretical concept, with no practical applications (which I know of).&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Bogo sort remains stupid. If we can speed-up sorting via quantum, why&#xA;  not base it on a good sorting algorithm? (But we need randomness, my&#xA;  neighbour protests! Yes, but can't you think of a better classical&#xA;  algorithm that relies on randomness?)&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Yes, it does remain &lt;em&gt;stupid&lt;/em&gt;. It does seem to have started out as an &quot;educational joke&quot; as you said. I did try to find the origin of this sort, or relevant academic papers, but couldn't find any. However, even the classical &lt;a href=&quot;https://en.wikipedia.org/wiki/Bogosort&quot; rel=&quot;noreferrer&quot;&gt;bogosort&lt;/a&gt; is stupid in the sense that is widely held as one of the most inefficient sorting algorithms. Still it has been researched on, purely out of educational interest.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;In particular, are there real quantum algorithms that are similar or&#xA;  is this a theoretical or practical impossibility?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;None that I know of. Such algorithms are indeed theoretical possibilities, but definitely not practical (at least, not yet).&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Furthermore, has there been research into 'quantum sorting&#xA;  algorithms'? If not, why?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There indeed has been research into &quot;quantum sorting&quot;. But the problem with such sorting algorithms is any comparison-based quantum sorting algorithm would take at least $\Omega (N\log N)$ steps, which is already achievable by classical algorithms. Thus, for this task, quantum computers are no better than classical ones. However, in space-bounded sorts, quantum algorithms outperform their classical counterparts. &lt;a href=&quot;https://dl.acm.org/citation.cfm?doid=780542.780553&quot; rel=&quot;noreferrer&quot;&gt;This&lt;/a&gt; and &lt;a href=&quot;https://link.springer.com/chapter/10.1007%2F3-540-48224-5_29&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt; are two relevant papers.&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-23T19:18:35.450" LastActivityDate="2018-03-23T19:18:35.450" CommentCount="14" />
  <row Id="1274" PostTypeId="2" ParentId="1271" CreationDate="2018-03-23T09:26:07.817" Score="4" Body="&lt;p&gt;We don't yet know if quantum computers are actually better than classical computers, as @heather mentions &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/168/26&quot;&gt;here&lt;/a&gt;. As for now there are just some theoretical algorithms which we know of, specifically for quantum-computers, which have much better time complexities than equivalent classical algorithms. For example - &lt;a href=&quot;https://en.wikipedia.org/wiki/Shor%27s_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;prime factorization&lt;/a&gt; and &lt;a href=&quot;http://ieeexplore.ieee.org/document/365700/&quot; rel=&quot;nofollow noreferrer&quot;&gt;discrete logarithms&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Wiki also says:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Besides factorization and discrete logarithms, quantum algorithms&#xA;  offering a more than polynomial speedup over the best known classical&#xA;  algorithm have been found for several problems, including the&#xA;  simulation of quantum physical processes from chemistry and solid&#xA;  state physics, the approximation of Jones polynomials, and solving&#xA;  Pell's equation. No mathematical proof has been found that shows that&#xA;  an equally fast classical algorithm cannot be discovered, although&#xA;  this is considered unlikely. For some problems, quantum computers&#xA;  offer a polynomial speedup. The most well-known example of this is&#xA;  quantum database search, which can be solved by Grover's algorithm&#xA;  using quadratically fewer queries to the database than are required by&#xA;  classical algorithms. In this case the advantage is provable. Several&#xA;  other examples of provable quantum speedups for query problems have&#xA;  subsequently been discovered, such as for finding collisions in&#xA;  two-to-one functions and evaluating NAND trees.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Whether you can use these speedups to &lt;em&gt;design&lt;/em&gt; better quantum computers, depends. I can imagine that you could of course simulate a quantum computer using another quantum computer, which could help in making new designs or rather testing-before-building. But I don't think polynomial speedups, faster prime factorizations, etc. will directly help in designing a quantum computer, unless you actually make use of it somehow. &lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;P.S: This is a very short and perhaps incomplete answer, I know. I just wanted to give the OP a basic idea. I'd request others to write alternate answers to this question. &lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-03-23T09:26:07.817" CommentCount="0" />
  <row Id="1276" PostTypeId="1" CreationDate="2018-03-23T10:28:15.810" Score="12" ViewCount="204" Body="&lt;p&gt;As a result from an excellent answer to my question on &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/1265/253&quot;&gt;Quantum bogo sort&lt;/a&gt;, I was wondering what is the current state of the art in quantum algorithms for sorting.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To be precise, &lt;em&gt;sorting&lt;/em&gt; is here defined as the following problem: &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Given an array $A$ of integers (feel free to choose your representation of $A$, but be clear about this, I think this already is non-trivial!) of size $n$, we wish to transform this array into the array $A_s$ such that the arrays 'are reshufflings of eachother' and $A_s$ is sorted, i.e. $A_s[i]\leq A_s[j]$ for all $i\leq j$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;What is known about this? Are there complexity bounds or conjectures for certain models? Are there &lt;em&gt;practical&lt;/em&gt; algorithms? Can we &lt;em&gt;beat&lt;/em&gt; classical sorting (even the &lt;em&gt;bucket&lt;/em&gt; or &lt;em&gt;radix&lt;/em&gt; sort &lt;em&gt;at their own game&lt;/em&gt;? (i.e. in the cases where they work well?))&lt;/p&gt;&#xA;" OwnerUserId="253" LastEditorUserId="26" LastEditDate="2018-03-29T18:09:50.177" LastActivityDate="2018-03-29T18:09:50.177" Title="What is the current state of the art in Quantum sorting algorithms?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-speedup&gt;&lt;performance&gt;" AnswerCount="2" CommentCount="1" FavoriteCount="1" />
  <row Id="1277" PostTypeId="5" CreationDate="2018-03-23T10:43:27.927" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-23T10:43:27.927" LastActivityDate="2018-03-23T10:43:27.927" CommentCount="0" />
  <row Id="1278" PostTypeId="4" CreationDate="2018-03-23T10:43:27.927" Score="0" Body="For questions on either 1) Using quantum computing to speed-up artificial intelligence and/or 2) Using artificial intelligence to solve problems in quantum computing. If your question is only on artificial intelligence, do not post here, but on another site on the network, either Computer Science or Artificial Intelligence or even Statistics (Cross Validated)" OwnerUserId="253" LastEditorUserId="253" LastEditDate="2018-03-23T16:56:21.923" LastActivityDate="2018-03-23T16:56:21.923" CommentCount="0" />
  <row Id="1279" PostTypeId="2" ParentId="1269" CreationDate="2018-03-23T10:59:53.233" Score="7" Body="&lt;p&gt;In the classical case, there is a pretty big difference between digital computers and analogue ones. The methodology and hardware is very much distinct (in all cases I know of, at least).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The divide is still there in the quantum case, but it doesn't run quite as deep. The hardware can be similar, but requirements on how it behaves and how to manipulate it are different. This means that both circuit model quantum computers and quantum annealers can both measure device size using the same metric, the number of qubits, but it is measuring very different and completely non-equivalent things.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Basically, it is like comparing the length of a slide rule to that of a smartphone, and using that to make statements about their computational power.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-03-23T10:59:53.233" CommentCount="1" />
  <row Id="1280" PostTypeId="1" AcceptedAnswerId="1281" CreationDate="2018-03-23T11:12:37.637" Score="7" ViewCount="157" Body="&lt;p&gt;Quantum gates seem to be like black boxes. Although we know what kind of operation they will perform, we don't know if it's actually possible to implement in reality (or, do we?). In classical computers, we use AND, NOT, OR, XOR, NAND, NOR, etc which are mostly implemented using semiconductor devices like diodes and transistors. Are there similar experimental implementations of quantum gates? Is there any &quot;universal gate&quot; in quantum computing (like the NAND gate is universal in classical computing)? &lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-03-23T11:12:37.637" Title="How are quantum gates implemented in reality?" Tags="&lt;quantum-gate&gt;" AnswerCount="1" CommentCount="0" ClosedDate="2018-03-23T16:30:53.787" />
  <row Id="1281" PostTypeId="2" ParentId="1280" CreationDate="2018-03-23T11:12:37.637" Score="9" Body="&lt;p&gt;One can replicate any quantum gate or at least get arbitrarily close using sufficient number of CNOT, H, X, Z and $\pi/8$ rotation gates. That is because they form a &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_logic_gate#Universal_quantum_gates&quot; rel=&quot;noreferrer&quot;&gt;universal set&lt;/a&gt; of quantum gates (refer to: &lt;em&gt;M. Nielsen and I. Chuang, Quantum Computation and Quantum Information, Cambridge University Press, 2016, page 189&lt;/em&gt;). Be careful here. Clearly, we cannot implement any arbitrary quantum gate $U$ with infinite precision. Instead, given $\epsilon&amp;gt;0$, we implement $U_{\epsilon}$, which is $\epsilon$-close to $U$ (refer to: &lt;a href=&quot;https://www.edx.org/course/quantum-mechanics-quantum-computation-uc-berkeleyx-cs-191x&quot; rel=&quot;noreferrer&quot;&gt;Quantum Mechanics and Quantum Computation MOOC offered by UC Berkely on EdX&lt;/a&gt;). This imperfection of quantum gates is one of the main reasons we need &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_error_correction&quot; rel=&quot;noreferrer&quot;&gt;error correction codes&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There have been attempts to implement those basic gates. I'm adding some of the recent research works related to these attempts:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;CNOT: &lt;a href=&quot;https://arxiv.org/abs/1803.04105&quot; rel=&quot;noreferrer&quot;&gt;Construction of controlled-NOT gate based on microwave-activated phase (MAP) gate in two transmon system&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/abs/1803.02844&quot; rel=&quot;noreferrer&quot;&gt;Rydberg atoms based mesoscopic $\text{CNOT}^{\text{N}}$ gate using STIRAP&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Hadamard (H): &lt;a href=&quot;http://ieeexplore.ieee.org/document/5612120/&quot; rel=&quot;noreferrer&quot;&gt;An approach to realize a quantum Hadamard gate through optical implementation&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Phase flip (Z): &lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.73.012323&quot; rel=&quot;noreferrer&quot;&gt;One-step implementation of a multiqubit controlled-phase-flip gate&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://arxiv.org/abs/0803.1017&quot; rel=&quot;noreferrer&quot;&gt;Realizing quantum controlled phase-flip gate through quantum dot in silicon slow-light photonic crystal waveguide&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Bit Flip (X): &lt;a href=&quot;http://naturalspublishing.com/Article.asp?ArtcID=13584&quot; rel=&quot;noreferrer&quot;&gt;Chiral Spin Flipping Gate Implemented in IBM Quantum Experience&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;$\pi/8$ rotation: &lt;a href=&quot;https://arxiv.org/abs/1206.1598&quot; rel=&quot;noreferrer&quot;&gt;Qudit versions of the qubit &quot;pi-over-eight&quot; gate&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;As Wiki mentions, another set of universal quantum gates consists of the Ising gate and the phase-shift gate. These are the set of gates natively available in some trapped-ion quantum computers (&lt;a href=&quot;https://www.nature.com/articles/nature18648&quot; rel=&quot;noreferrer&quot;&gt;Demonstration of a small programmable quantum computer with atomic qubits&lt;/a&gt;).&lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-03-23T11:12:37.637" CommentCount="0" />
  <row Id="1282" PostTypeId="5" CreationDate="2018-03-23T16:07:20.413" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-23T16:07:20.413" LastActivityDate="2018-03-23T16:07:20.413" CommentCount="0" />
  <row Id="1283" PostTypeId="4" CreationDate="2018-03-23T16:07:20.413" Score="0" Body="For questions about the theory and practical construction of dedicated quantum memory which is analogous to the memory in a normal computer, but consists of 'quantum state' (e.g. (partially) from qubits)" OwnerUserId="82" LastEditorUserId="253" LastEditDate="2018-03-24T23:44:31.380" LastActivityDate="2018-03-24T23:44:31.380" CommentCount="0" />
  <row Id="1284" PostTypeId="2" ParentId="97" CreationDate="2018-03-23T19:53:28.333" Score="3" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Why do you need error correction? My understanding is that error correction removes errors from noise, but noise should average itself out. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;If you built a house or a road and noise was a variance, a difference,  with respect to straightness, to direction, it's not solely / simply: &quot;How would it look&quot;, but &quot;How would it be?&quot; - a superposition of both  efficiency and correctness. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If two people calculated the circumference of a golf ball given a diameter each would get a similar answer, subject to the accuracy of their calculations; if each used &lt;em&gt;several&lt;/em&gt; places of decimal it would be 'good enough'.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If two people were provided with identical equipment and ingredients, and given the same recipe for a cake, should we expect identical results?&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;To make clear what I'm asking, why can't you, instead of involving error correction, simply run the operations, say, a hundred times, and pick the average/most common answer?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;You're spoiling the weighing, tapping your finger on the scale.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you're at a loud concert and try to communicate with the person next to you do they understand you the first time, everytime?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you tell a story or spread a rumor, (and some people communicate  verbatim, some add their own spin, and others forget parts), when it gets back to you does it average itself out and become essentially (but not identically) the same thing you said? - unlikely. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;It like crinkling up a piece of paper and then flattening it out.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;All those analogies were intended to offer simplicity over exactness, you can reread them a few times, average it out, and have the exact answer, or not. ;)&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;A more technical explanation of why quantum error correction is difficult but neccessary is explained on Wikipedia's weboage: &quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_error_correction&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Error Correction&lt;/a&gt;&quot;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;Quantum error correction (QEC) is used in quantum computing to protect quantum information from errors due to &lt;a href=&quot;https://en.wikipedia.org/wiki/Decoherence&quot; rel=&quot;nofollow noreferrer&quot;&gt;decoherence&lt;/a&gt; and other &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_noise&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum noise&lt;/a&gt;. Quantum error correction is essential if one is to achieve fault-tolerant quantum computation that can deal not only with noise on stored quantum information, but also with faulty quantum gates, faulty quantum preparation, and faulty measurements.&quot;.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&quot;Classical &lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction&quot; rel=&quot;nofollow noreferrer&quot;&gt;error correction&lt;/a&gt; employs &lt;a href=&quot;https://en.wikipedia.org/wiki/Redundancy_(information_theory)&quot; rel=&quot;nofollow noreferrer&quot;&gt;redundancy&lt;/a&gt;. &quot; ...&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&quot;Copying quantum information is not possible due to the &lt;a href=&quot;https://en.wikipedia.org/wiki/No-cloning_theorem&quot; rel=&quot;nofollow noreferrer&quot;&gt;no-cloning theorem&lt;/a&gt;. This theorem seems to present an obstacle to formulating a theory of quantum error correction. But it is possible to spread the information of one qubit onto a highly entangled state of several (physical) qubits. &lt;a href=&quot;https://en.wikipedia.org/wiki/Peter_Shor&quot; rel=&quot;nofollow noreferrer&quot;&gt;Peter Shor&lt;/a&gt; first discovered this method of formulating a quantum error correcting code by storing the information of one qubit onto a highly entangled state of nine qubits. A quantum error correcting code protects quantum information against errors of a limited form.&quot;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="278" LastEditorUserId="278" LastEditDate="2018-03-23T23:05:26.253" LastActivityDate="2018-03-23T23:05:26.253" CommentCount="3" />
  <row Id="1285" PostTypeId="1" AcceptedAnswerId="1287" CreationDate="2018-03-23T19:56:19.330" Score="13" ViewCount="235" Body="&lt;p&gt;In &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1281/26&quot;&gt;this&lt;/a&gt; answer I mentioned that the CNOT, H, X, Z and $\pi/8$ gates form a universal set of gates, which given in sufficient number of gates can get arbitrarily close to replicating any unitary quantum gate (I came to know about this fact from Professor Umesh Vazirani's EdX lectures). But, is there any mathematical justification for this? There should be! I tried searching for relevant papers but couldn't find much.&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="2293" LastEditDate="2018-05-08T19:54:27.807" LastActivityDate="2018-05-08T20:46:44.197" Title="What is the mathematical justification for the &quot;universality&quot; of the universal set of quantum gates (CNOT, H, Z, X and π/8)?" Tags="&lt;quantum-gate&gt;&lt;universal-gates&gt;&lt;gate-synthesis&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="1286" PostTypeId="2" ParentId="1271" CreationDate="2018-03-23T20:05:15.397" Score="5" Body="&lt;h2&gt;Sort of, quite possibly, if by degrees&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;This is a speculative, but plausible, answer&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;First of all, &lt;strong&gt;how do qubits interact and states evolve with time?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The description of how individual qubits evolve (i.e. a single qubit gate operation) is given by some Hamiltonian&lt;sup&gt;1&lt;/sup&gt;. Multiple, non-interacting qubits (that are exactly the same) therefore evolve using multiples of that same Hamiltonian. However, as soon as you include some form of interaction, simulating the exact evolution of a large number of interacting qubits quickly becomes intractable (which is exactly why quantum computers should be useful, in theory).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, &lt;strong&gt;how are quantum processors &lt;em&gt;designed?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Designing the microarchitecture of a processor (such as the connectivity, layout of the chip etc.) is one thing, but engineering sizes of qubits, waveguides etc. requires going on a computer and running detailed simulations a lot of the time. If there was a way to simulate large Hamiltonians for a long time, it's reasonable to assume that this would help improve knowledge of how the qubits interact with each other and the environment, such as in a more detailed version of &lt;a href=&quot;https://arxiv.org/abs/0804.2377v1&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt; and extensions thereof, as well as generally being able to look at how multiple qubits interact at once. This would in turn allow for improved design of the &lt;em&gt;details&lt;/em&gt; of chip, which would lead to effects such as reduction of decoherence.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Finally, &lt;strong&gt;what are quantum computers good at?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As mentioned above, quantum computers are potentially useful because of what makes them hard to simulate - a quantum computer &lt;em&gt;is&lt;/em&gt; a system that quickly becomes intractable it simulate with increasing numbers of qubits. However, something that quantum computers offer a speedup of is... &lt;a href=&quot;https://arxiv.org/abs/1005.1318v3&quot; rel=&quot;noreferrer&quot;&gt;&lt;em&gt;Hamiltonian simulation&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In other words, by iteratively running a quantum Hamiltonian simulation, using a classical computer to (tell the quantum computer to) vary certain parameters, it's not unreasonable to assume that a quantum computer could help for optimising certain aspects of the chip to e.g. reduce decoherence times, improve fidelities etc. In turn offering &lt;em&gt;better&lt;/em&gt; simulations and allowing for yet more qubits, which potentially offers better simulations and the continual improvement would (hopefully) begin.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As for whether it &lt;em&gt;does&lt;/em&gt;, or if classically simulating a few qubits and extrapolating from this would give a just-as-good design is something that only time will tell.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;1 Having said that, in linear optical quantum computers (at least), unitaries are implemented &lt;em&gt;directly&lt;/em&gt; using physical components such as beam splitters and phase shifters directly describing the unitary, as opposed to, say, superconducting, where applying microwaves is described in terms of a Hamiltonian, which is then used to &lt;em&gt;give&lt;/em&gt; a unitary. OK, all this is maybe simplifying a bit, but that gets the gist across. What &lt;em&gt;does&lt;/em&gt; matter is that, in linear optical quantum computers, &lt;em&gt;generating&lt;/em&gt; the photons on say, a ring resonator, is described by a Hamiltonian&lt;/sup&gt;&lt;/p&gt;&#xA;" OwnerUserId="23" LastActivityDate="2018-03-23T20:05:15.397" CommentCount="0" />
  <row Id="1287" PostTypeId="2" ParentId="1285" CreationDate="2018-03-23T22:45:46.993" Score="9" Body="&lt;p&gt;The answer you mention references Michael Nielsen and Isaac Chuang's book, &lt;em&gt;Quantum Computation and Quantum Information&lt;/em&gt; (Cambridge University Press), which does contain a proof of the universality of these gates.  (In my 2000 edition, this can be found on p. 194.)  The key insight is that the $T$ gate (or $\pi/8$ gate), together with the $H$ gate, generates two different rotations on the Bloch sphere with angles that are &lt;em&gt;irrational&lt;/em&gt; multiples of $2\pi$.  This allows combinations of $T$ and $H$ gates to densely fill the surface of the Bloch sphere and thereby approximate any one-qubit unitary operator.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;That this can be done &lt;em&gt;efficiently&lt;/em&gt; is shown by the &lt;em&gt;Solovay-Kitaev&lt;/em&gt; theorem.  Here, &quot;efficiently&quot; means polynomial in $\log(1/\epsilon)$, where $\epsilon$ is the desired accuracy.  This is also proven in Nielsen and Chuang's book (Appendix 3 in the 2000 edition).  An explicit construction can be found in &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0505030&quot; rel=&quot;noreferrer&quot;&gt;https://arxiv.org/abs/quant-ph/0505030&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Combining CNOT gates allows one to approximate arbitrary multi-qubit unitaries, as shown by Barenco &lt;em&gt;et al.&lt;/em&gt; in Phys. Rev. A &lt;strong&gt;52&lt;/strong&gt; 3457 (1995).  (A preprint of this paper can be found at &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9503016&quot; rel=&quot;noreferrer&quot;&gt;https://arxiv.org/abs/quant-ph/9503016&lt;/a&gt;.)  This is also discussed in Nielsen and Chuang (p. 191 in the 2000 edition).&lt;/p&gt;&#xA;" OwnerUserId="356" LastEditorUserId="124" LastEditDate="2018-03-25T20:16:47.497" LastActivityDate="2018-03-25T20:16:47.497" CommentCount="1" />
  <row Id="1288" PostTypeId="2" ParentId="1271" CreationDate="2018-03-23T22:54:52.633" Score="-1" Body="&lt;p&gt;I don't understand why we need a quantum computer, to be honest.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It has, as you claim, already been possible for a while to create computers semi-autonomously by a computer. (VSLI, a FGPA design language with an 'optimising compiler', exists)&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;We could do this in the 90's&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Also famous is the experiment where, using elementary Artificial Intelligence (first wave of AI, which was 90's at the latest), a circuit was automatically constructed to do some simple I/O task and optimized for cheap building cost.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, the AI refused to remove a component that wasn't connected to anything! This baffled the researcher, so he removed the component and the circuit failed, apparently this was needed! &lt;/p&gt;&#xA;&#xA;&lt;p&gt;What has happened without the researcher noticed is that the AI treated all components as a black box and hence could make the seemingly absurd choice to put a component on the grid without connecting it to anything! The reason this component was still needed is because while it did not logically influence the circuit, it did magnetically influence the circuit, yielding a rather unwieldy and unstable circuit, but cheap and working (under certain conditions).&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Are quantum computers harder to design, when we split them into components?&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;What can we learn from this tale? Apparently, &lt;em&gt;classical computers can design 'analog components' to optimise circuits&lt;/em&gt;. Not a far stretch would be to go beyond simply 'analog components' and use 'quantum components', but as long as you can treat them as black-box components, why would the task become more difficult? Of course, more components is harder, but QC are pretty small so far, so it isn't that hard to do something a bit harder than what we could in the 90's. Would you ask a quantum computer to design and optimise your children's playground? I'd ask a classical computer!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;While of course there is many potential for AI and QC, this is one point where the classical way is fine, and I don't see why you &lt;em&gt;need&lt;/em&gt; a quantum speedup, which makes them question &lt;em&gt;if&lt;/em&gt; you can do it pretty moot in my opinion.&lt;/p&gt;&#xA;" OwnerUserId="253" LastActivityDate="2018-03-23T22:54:52.633" CommentCount="0" />
  <row Id="1289" PostTypeId="1" AcceptedAnswerId="1324" CreationDate="2018-03-24T05:37:07.873" Score="21" ViewCount="1566" Body="&lt;p&gt;On reading &lt;a href=&quot;https://www.reddit.com/r/askscience/comments/1oqxfr/how_do_computers_do_math/&quot; rel=&quot;noreferrer&quot;&gt;this Reddit thread&lt;/a&gt; I realized that even after a couple months of learning about quantum computing I've absolutely no clue about how a quantum computer actually works. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;To make the question more precise, let's say we have a superconducting qubit based 5-qubit quantum computer (like the  5-qubit IBM Quantum Computer). I type in $2+3$ using a keyboard onto a monitor (say in a basic calculator app the quantum computer might have). After that it should return me $5$. But is going on at the hardware level? Are some sort of electrical signals corresponding to the inputs $2$,$3$ and $+$ going to the processing unit of the computer? Does that somehow &quot;initialize&quot; the Cooper pair electrons? What happens to the Cooper pair electron qubits after that (guess they'd be worked on by some &lt;em&gt;quantum-gates&lt;/em&gt;, which are in turn again &lt;em&gt;black boxes&lt;/em&gt;)? How does it finally return me the output $5$ ? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am surprised as to how little I could come up with about the &lt;em&gt;basic&lt;/em&gt; working of a quantum computer by searching on the net.&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-24T06:23:32.263" LastActivityDate="2018-04-10T18:03:32.747" Title="How does a quantum computer do basic math at the hardware level?" Tags="&lt;quantum-computer&gt;&lt;qubit&gt;&lt;architecture&gt;" AnswerCount="2" CommentCount="4" FavoriteCount="7" />
  <row Id="1291" PostTypeId="2" ParentId="1228" CreationDate="2018-03-24T18:22:05.333" Score="1" Body="&lt;p&gt;If by &quot;giant quantum computer&quot; you mean something that can be simulated very efficiently by a tensor product of sufficiently many qubits, then I think the answer is no. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;When we work with finite dimensional systems, it's very clear how to account for the joint description of two subsystems: we simply take the tensor product.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you want an infinite-dimensional space with continuously many degrees of freedom, then we have to do something more subtle. We'll call this the &quot;commuting operator&quot; model. To every open subset of space we attach an algebra observables corresponding to the local measurements on that part of space. Instead of requiring that the Hilbert space of the universe is the tensor product of all the local hilbert spaces, we just ask that if two regions of space don't intersect, then their algebras of observables commute. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;It's known that the commuting operator model gives rise to correlations between spacelike separated parties that do not arise in the tensor product model. See this paper by William Slofstra &lt;a href=&quot;https://arxiv.org/abs/1606.03140&quot; rel=&quot;nofollow noreferrer&quot;&gt;on the arXiv&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We don't know whether there is an experiment that could tell us that our universe is capable of generating correlations in the commuting operator model. See &lt;a href=&quot;https://www.scottaaronson.com/blog/?p=2820&quot; rel=&quot;nofollow noreferrer&quot;&gt;this blog post by Scott Aaronson&lt;/a&gt;, which describes Slofstra's result and some of its implications.&lt;/p&gt;&#xA;" OwnerUserId="483" LastEditorUserId="483" LastEditDate="2018-03-24T23:30:56.970" LastActivityDate="2018-03-24T23:30:56.970" CommentCount="8" />
  <row Id="1292" PostTypeId="1" AcceptedAnswerId="1316" CreationDate="2018-03-24T20:08:35.513" Score="9" ViewCount="111" Body="&lt;p&gt;In &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1235/who-invented-quantum-computing&quot;&gt;my previous question&lt;/a&gt; I asked who invented a quantum computer using qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As a follow-up to this question I want to ask who built the first quantum computer using at least two qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;During my research I have discovered that in 1998, Jonathan A. Jones and Michele Mosca &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9801027&quot; rel=&quot;noreferrer&quot;&gt;developed a quantum computer using two qubits&lt;/a&gt; specifically to solve &lt;a href=&quot;https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm&quot; rel=&quot;noreferrer&quot;&gt;Deutsch's problem&lt;/a&gt;. Have there been other working quantum computers before to solve other problems or general attempts not specifically bound to one problem?&lt;/p&gt;&#xA;" OwnerUserId="11" LastEditorUserId="26" LastEditDate="2018-03-26T16:00:31.197" LastActivityDate="2018-03-26T16:00:31.197" Title="Who built the first quantum computer using at least two qubits?" Tags="&lt;quantum-computer&gt;&lt;quantum-computing-models&gt;&lt;experimental-results&gt;&lt;history&gt;" AnswerCount="2" CommentCount="4" />
  <row Id="1293" PostTypeId="5" CreationDate="2018-03-24T22:39:59.963" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-24T22:39:59.963" LastActivityDate="2018-03-24T22:39:59.963" CommentCount="0" />
  <row Id="1294" PostTypeId="4" CreationDate="2018-03-24T22:39:59.963" Score="0" Body="Q# is an extension of the C# programming language and is used to program quantum algorithms. This tag should be used for questions related to creating/programming quantum algorithms using the 'Q#' language. If the question is not related to, or arising from some quantum aspect of Q#, it might be better to ask on StackOverflow." OwnerUserId="253" LastEditorUserId="23" LastEditDate="2018-03-26T16:42:16.800" LastActivityDate="2018-03-26T16:42:16.800" CommentCount="0" />
  <row Id="1295" PostTypeId="5" CreationDate="2018-03-24T22:50:42.300" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-24T22:50:42.300" LastActivityDate="2018-03-24T22:50:42.300" CommentCount="0" />
  <row Id="1296" PostTypeId="4" CreationDate="2018-03-24T22:50:42.300" Score="0" Body="The IBM Q Experience is an online platform that gives the general public access to a set of IBM’s prototype quantum processors. It is an example of cloud-based quantum computing (from Wikipedia). As of July 2018, there are five processors on the IBM Q Experience: two 5-qubit processors, one 16-qubit processor and two 20-qubit processors (only available to hubs, partners, and members of the IBM Q network)." OwnerUserId="253" LastEditorUserId="26" LastEditDate="2018-07-06T08:29:09.797" LastActivityDate="2018-07-06T08:29:09.797" CommentCount="0" />
  <row Id="1297" PostTypeId="5" CreationDate="2018-03-24T22:52:05.383" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-24T22:52:05.383" LastActivityDate="2018-03-24T22:52:05.383" CommentCount="0" />
  <row Id="1298" PostTypeId="4" CreationDate="2018-03-24T22:52:05.383" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-24T22:52:05.383" LastActivityDate="2018-03-24T22:52:05.383" CommentCount="0" />
  <row Id="1299" PostTypeId="5" CreationDate="2018-03-24T22:53:35.937" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-24T22:53:35.937" LastActivityDate="2018-03-24T22:53:35.937" CommentCount="0" />
  <row Id="1300" PostTypeId="4" CreationDate="2018-03-24T22:53:35.937" Score="0" Body="On memory as a resource for computation (similar to time). This can refer to performance in theoretical models, or the practical construction of such memory and related concerns. Use the appropriate tags to further specify if needed." OwnerUserId="253" LastEditorUserId="253" LastEditDate="2018-03-25T00:03:16.233" LastActivityDate="2018-03-25T00:03:16.233" CommentCount="0" />
  <row Id="1301" PostTypeId="2" ParentId="20" CreationDate="2018-03-24T23:16:16.757" Score="3" Body="&lt;p&gt;It seems that most ways of formalizing your question would lead to a problem that's QMA-hard, and therefore we shouldn't hope for an efficient quantum algorithm to solve it. (The relationship between BQP and QMA is similar to the relationship between P and NP: it would be very surprising if there were efficient quantum algorithms for QMA-complete problems.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The canonical &lt;a href=&quot;https://en.wikipedia.org/wiki/QMA&quot; rel=&quot;nofollow noreferrer&quot;&gt;QMA-complete&lt;/a&gt; problem is the &quot;local hamiltonian&quot; problem. Roughly speaking, the input to the problem is a description of the hamiltonian for a physical system acting on qubits, and the problem is to decide whether the ground state of the system has small energy. If your system of specifying constraints includes local hamiltonians as a special case, then your problem is intractable.&lt;/p&gt;&#xA;" OwnerUserId="483" LastEditorUserId="483" LastEditDate="2018-03-24T23:59:36.953" LastActivityDate="2018-03-24T23:59:36.953" CommentCount="2" />
  <row Id="1302" PostTypeId="1" AcceptedAnswerId="1306" CreationDate="2018-03-24T23:57:37.393" Score="14" ViewCount="153" Body="&lt;p&gt;In classical binary computers, real numbers are often represented using the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot; rel=&quot;noreferrer&quot;&gt;IEEE 754 standard&lt;/a&gt;. With quantum computers you can of course do this as well - and for measurements this (or a similar standard) will probably be necessary since the result of any measurement is binary. But could real numbers be modeled more easily and / or more precisely within the qubits using different methods before the measurement happens? If so, are there any use cases where this is actually useful, seeing that (I'm assuming) any additional precision will be lost when measurements are performed?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To be clear, I'm not (necessarily) looking for existing standards, just for ideas or suggestions on how to represent those numbers. If there's any research into it, that would be useful too of course.&lt;/p&gt;&#xA;" OwnerUserId="138" LastEditorUserId="26" LastEditDate="2018-07-16T15:03:46.870" LastActivityDate="2018-07-16T15:03:46.870" Title="Representation of real numbers in quantum computers" Tags="&lt;qubit&gt;&lt;qubit-state&gt;&lt;measurement&gt;&lt;technical-standards&gt;" AnswerCount="2" CommentCount="3" FavoriteCount="1" />
  <row Id="1303" PostTypeId="1" AcceptedAnswerId="1304" CreationDate="2018-03-25T01:02:30.473" Score="6" ViewCount="56" Body="&lt;p&gt;Quantum Computing (QC) pioneer Vazirani has graciously long provided some nice videos on an intro to QC. E.g. in &lt;a href=&quot;https://www.youtube.com/watch?v=xzG6c96PsLs&quot; rel=&quot;noreferrer&quot;&gt;&quot;2 qubit gates + tensor product&quot;&lt;/a&gt; (2014) he introduces the tensor product w.r.t. QC gates. I was generally able to follow this video but think there was one subtle point glossed over and I would like an expert to expand on it. We were discussing the tensor product in a QC meetup and the question came up if its commutative. As Wikipedia &lt;a href=&quot;https://en.wikipedia.org/wiki/Tensor_product&quot; rel=&quot;noreferrer&quot;&gt;states&lt;/a&gt;, the tensor product is not commutative. But when combining two qubits in a gate operation, Vazirani however does not mention whether order makes any difference. In his diagrams, there is total visual symmetry across the 2 qubits. Or maybe the tensor product is commutative over unitary matrices which QC is limited to? Can someone sort out/ unpack some of these ideas?&lt;/p&gt;&#xA;" OwnerUserId="377" LastEditorUserId="26" LastEditDate="2018-03-25T04:23:55.910" LastActivityDate="2018-03-25T13:22:36.253" Title="Symmetry of tensor product in QC wrt Vazirani 2-qubit video" Tags="&lt;quantum-gate&gt;&lt;qubit-state&gt;&lt;tensor-product&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="1304" PostTypeId="2" ParentId="1303" CreationDate="2018-03-25T03:44:04.247" Score="6" Body="&lt;p&gt;The tensor product is not commutative, i.e. in the computational basis, $$X\otimes Z=\left(&#xA;\begin{array}{cccc}&#xA; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; -1 \\&#xA; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; -1 &amp;amp; 0 &amp;amp; 0 \\&#xA;\end{array}&#xA;\right)$$ while $$Z\otimes X=\left(&#xA;\begin{array}{cccc}&#xA; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\&#xA; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; -1 \\&#xA; 0 &amp;amp; 0 &amp;amp; -1 &amp;amp; 0 \\&#xA;\end{array}&#xA;\right).$$&#xA;The two-qubit CNOT gate depicted in the video is not symmetric w.r.t. the two qubits (one is control, the other is target). However, the ordering of the subsystems (e.g. the qubits) is arbitrary and you can understand $X_A \otimes Z_B = Z_B \otimes X_A$, where the indices denote the subsystem. It happens quite frequently that people change the order of the subsystems to whatever order is convenient at that moment.&lt;/p&gt;&#xA;" OwnerUserId="104" LastEditorUserId="104" LastEditDate="2018-03-25T13:22:36.253" LastActivityDate="2018-03-25T13:22:36.253" CommentCount="0" />
  <row Id="1305" PostTypeId="2" ParentId="1303" CreationDate="2018-03-25T05:10:42.870" Score="4" Body="&lt;p&gt;I'll add a bit to the &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1304/26&quot;&gt;other answer&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;State of a two qubit system is written as $|\psi_1\rangle\otimes|\psi_2\rangle$ where $|\psi_1\rangle$ is the state vector of the &lt;strong&gt;first qubit&lt;/strong&gt;  and $|\psi_2\rangle$ is the state vector of the &lt;strong&gt;second qubit&lt;/strong&gt; (it is upto you to decide which one will be called &quot;first&quot; and which one will be called &quot;second&quot;). The order is important, as the first member of the product is always considered to be the state of the first qubit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$|\psi_{\text{state}}\rangle=|\psi_1\rangle\otimes|\psi_2\rangle=|\psi_1\psi_2\rangle\quad (\text{Tensor Product})$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, after choosing the initial convention of the order (i.e. &quot;first&quot; and &quot;second&quot; qubit) if you're changing ordering of the subsystems, as M.Stein says, you have to mention that explicitly. You can't just suddenly write it as $|\psi_2\rangle\otimes|\psi_1\rangle$. Also, another reason why you can't change order directly is because Tensor product is not-commutative, as M.Stein already mentioned with a nice example.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A tensor product of that form can be also written as $a|00\rangle + b|01\rangle + c|10\rangle + d|11\rangle$ (where $a,b,c,d\in \Bbb{C}$). Keep in mind that even here, the first entry $\alpha$ in $|\alpha\beta\rangle$ (where $\alpha,\beta\in\{0,1\}$) is the state of the first qubit. For example when you're measuring the first qubit in the $|0\rangle,|1\rangle$ basis you'll end up with either the state $\frac{a|00\rangle+b|01\rangle}{\sqrt{|a|^2+|b|^2}}$ or the state $\frac{c|10\rangle+d|11\rangle}{\sqrt{|c|^2+|d|^2}}$. Notice that, in these two possible results, the first result explicitly implies that the first qubit turns out to be $0$ in that case, while the second possible result implies that the first qubit turns out to be $1$ in that particular case. As you can see, maintaining that order of tensor product is important, to keep track of the actual changes to the qubit system during quantum computing.&lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-03-25T05:10:42.870" CommentCount="0" />
  <row Id="1306" PostTypeId="2" ParentId="1302" CreationDate="2018-03-25T05:41:21.520" Score="9" Body="&lt;p&gt;There have been efforts to implement construct &quot;floating point&quot; representation of &lt;strong&gt;small rotations&lt;/strong&gt; of qubit states, such as: &lt;a href=&quot;https://arxiv.org/abs/1305.5528&quot; rel=&quot;noreferrer&quot;&gt;Floating Point Representations in Quantum Circuit Synthesis&lt;/a&gt;. But there doesn't seem to be any international standard like the one you mentioned i.e. IEEE 754. &lt;a href=&quot;https://standards.ieee.org/develop/project/7130.html&quot; rel=&quot;noreferrer&quot;&gt;IEEE 7130 - Standard for Quantum Computing Definitions&lt;/a&gt; is an ongoing project. Anyhow, representation of floating point will automatically be dependent on the precision you want. If you want to follow the path in the first paper I linked (i.e. using qubit rotations) I can already imagine the possibility of errors during such rotation operations and you'd have to deal with them accordingly.&lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-03-25T05:41:21.520" CommentCount="1" />
  <row Id="1308" PostTypeId="2" ParentId="1302" CreationDate="2018-03-25T12:13:07.087" Score="0" Body="&lt;p&gt;I am afraid that while interesting work is being done here, it should be clear that the quantum computer architecture is very much non-standardised and hence this is all subject to change.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The IEEE 754 standard describes how to implement a feature that decades of engineering and research have shown to be useful and hence machines are to be expected to do this.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In contrast, scientists and engineers are still figuring out how to best create an 'universal' quantum computer. They have some ideas on how to do this, as Blue mentions. However, there is no 'one true idea' on which engineers can base standards. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Perhaps it would even turn out complex numbers are easier to represent on a quantum computer and we have a standard for complex number data-types, instead!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, while work is being done here, an IEEE standard seems very much in the far future.&lt;/p&gt;&#xA;" OwnerUserId="253" LastActivityDate="2018-03-25T12:13:07.087" CommentCount="2" />
  <row Id="1309" PostTypeId="5" CreationDate="2018-03-25T12:14:47.600" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-25T12:14:47.600" LastActivityDate="2018-03-25T12:14:47.600" CommentCount="0" />
  <row Id="1310" PostTypeId="4" CreationDate="2018-03-25T12:14:47.600" Score="0" Body="For questions on the manipulation and creation of 'qubits' and the state they represent. These actions may be either from theory or practice, use other tags to indicate this." OwnerUserId="253" LastEditorUserId="253" LastEditDate="2018-03-25T21:09:10.993" LastActivityDate="2018-03-25T21:09:10.993" CommentCount="0" />
  <row Id="1311" PostTypeId="5" CreationDate="2018-03-25T12:44:56.940" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-25T12:44:56.940" LastActivityDate="2018-03-25T12:44:56.940" CommentCount="0" />
  <row Id="1312" PostTypeId="4" CreationDate="2018-03-25T12:44:56.940" Score="0" Body="For questions about the practice and current state of standardization of quantum computers and their models. Do be sure these standards would be significantly different due to the nature of quantum computation before asking." OwnerUserId="253" LastEditorUserId="253" LastEditDate="2018-03-25T21:13:04.347" LastActivityDate="2018-03-25T21:13:04.347" CommentCount="0" />
  <row Id="1313" PostTypeId="5" CreationDate="2018-03-25T12:57:12.610" Score="0" Body="&lt;h2&gt;What are tensors?&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;A tensors is an $\left(n, m\right)$-order structure that generalizes scalars and vectors to higher orders and can be represented by a number, array, matrix, or higher order generalisations thereof. In physics, tensors with a 3- or 4- dimensions are common, but higher dimensions are sometimes used. For a formal definition, consult the standard sources, e.g. &lt;a href=&quot;https://en.wikipedia.org/wiki/Tensor&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wikipedia&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;What about their product?&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;An elementary tensor is defined as being non-zero and completely factorisable. Here, the rank of a tensor is the minimum number of elementary tensors that sum to that tensor, meaning that an elementary tensor is 'rank 1'. As such, impure tensors (having a rank greater than 1) are not factorisable, so are hard to represent and hence complicate matters. However, there is a lot of mathematics done on these structures that is ready for Physics to use.  A good resource is again &lt;a href=&quot;https://en.wikipedia.org/wiki/Tensor_product&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wikipedia&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Why do the quantum physicists care?&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Well, one common example of tensors in physics is the stress tensor. But tensors pop up in quantum computation in the definition of quantum gates and other places. As quantum states are vectors, they are tensors, so larger pure states are described using tensor products of the smaller states. When entangled, sums of these states are used, giving a rank greater than 1.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;I still don't understand what tensors are. Help?&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Personally, as someone with a mathematics background, I don't understand the physicists when they talk tensors. However, I can understand the mathematicians. So, perhaps you can try to get someone different to explain. That can help.&lt;/p&gt;&#xA;" OwnerUserId="253" LastEditorUserId="23" LastEditDate="2018-03-26T16:38:24.877" LastActivityDate="2018-03-26T16:38:24.877" CommentCount="0" />
  <row Id="1314" PostTypeId="4" CreationDate="2018-03-25T12:57:12.610" Score="0" Body="A tensor is an abstract object generalising a scalar or vector and can be represented by a number, a 1D array, 2D matrix or higher order generalisations thereof. A tensor product is a product defined on these tensors yielding other tensors or a method to define or represent tensors." OwnerUserId="253" LastEditorUserId="23" LastEditDate="2018-03-26T16:38:32.643" LastActivityDate="2018-03-26T16:38:32.643" CommentCount="0" />
  <row Id="1315" PostTypeId="2" ParentId="1276" CreationDate="2018-03-25T13:04:44.540" Score="7" Body="&lt;p&gt;For comparison-based sorting (and search) bounds seem to fit the ones of classical computers: $\Omega(N\log N)$ for sorting and $\Omega(\log N)$ for search, as shown by &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0102078&quot; rel=&quot;noreferrer&quot;&gt;Hoyer et al.&lt;/a&gt; A couple of quantum sorting algorithms are listed in 'Related work' section of &lt;a href=&quot;http://ieeexplore.ieee.org/document/7494107/&quot; rel=&quot;noreferrer&quot;&gt;&quot;Quantum sort algorithm based on entanglement qubits {00, 11}&quot;&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="505" LastActivityDate="2018-03-25T13:04:44.540" CommentCount="1" />
  <row Id="1316" PostTypeId="2" ParentId="1292" CreationDate="2018-03-25T13:24:04.950" Score="7" Body="&lt;p&gt;What is a qubit? And what is a quantum computer? Any claim about about which is first will depend on our definitions.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One suggestion might be the &lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.49.91&quot; rel=&quot;noreferrer&quot;&gt;1981 experiment by Aspect, Grangier and Roger&lt;/a&gt; to demonstrate a violation of Bell’s inequality.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My arguments for this are:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;It uses a physical degree of freedom (photon polarization) which has since been considered for qubits.&lt;/li&gt;&#xA;&lt;li&gt;It performs a task (Bell’s inequality violation) that has since been used in quantum information theoretic tasks (like cryptography).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;So though the authors would have had no concept of their setup being a two qubit quantum computer at the time, I’d say that it was.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For some other early two qubit systems, see references 7, 8 and 9 in &lt;a href=&quot;https://arxiv.org/pdf/quant-ph/9709025.pdf&quot; rel=&quot;noreferrer&quot;&gt;this paper&lt;/a&gt; (which has arguably the first 3 qubit system).&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-03-25T13:24:04.950" CommentCount="0" />
  <row Id="1317" PostTypeId="5" CreationDate="2018-03-25T14:38:49.657" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-25T14:38:49.657" LastActivityDate="2018-03-25T14:38:49.657" CommentCount="0" />
  <row Id="1318" PostTypeId="4" CreationDate="2018-03-25T14:38:49.657" Score="0" Body="For questions about using the circuit-model of quantum computing, versus, for example, the quantum annealing model or the measurement-based model. Questions which are using the circuit-model but are not specifically asking about it probably should not have this tag." OwnerUserId="91" LastEditorUserId="91" LastEditDate="2018-03-25T17:23:14.593" LastActivityDate="2018-03-25T17:23:14.593" CommentCount="0" />
  <row Id="1319" PostTypeId="5" CreationDate="2018-03-25T14:40:07.460" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-25T14:40:07.460" LastActivityDate="2018-03-25T14:40:07.460" CommentCount="0" />
  <row Id="1320" PostTypeId="4" CreationDate="2018-03-25T14:40:07.460" Score="0" Body="For questions about how quantum computing could improve or affect machine learning. Questions about classical machine learning belong on another site, such as Stack Overflow. " OwnerUserId="91" LastEditorUserId="91" LastEditDate="2018-03-25T17:22:27.240" LastActivityDate="2018-03-25T17:22:27.240" CommentCount="0" />
  <row Id="1321" PostTypeId="5" CreationDate="2018-03-25T14:43:36.400" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-25T14:43:36.400" LastActivityDate="2018-03-25T14:43:36.400" CommentCount="0" />
  <row Id="1322" PostTypeId="4" CreationDate="2018-03-25T14:43:36.400" Score="0" Body="For questions about the quantum complexity class referring to problems that can be solved by a quantum computer in polynomial time (the quantum equivalent of the classical complexity class P). You may also wish to tag with complexity-classes." OwnerUserId="91" LastEditorUserId="91" LastEditDate="2018-03-25T17:22:59.160" LastActivityDate="2018-03-25T17:22:59.160" CommentCount="0" />
  <row Id="1323" PostTypeId="1" AcceptedAnswerId="1572" CreationDate="2018-03-25T16:29:37.420" Score="17" ViewCount="195" Body="&lt;h2&gt;Background&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Recently I was reading the article &lt;em&gt;&lt;a href=&quot;https://arxiv.org/abs/1604.01383&quot; rel=&quot;noreferrer&quot;&gt;&quot;Quantum Bitcoin: An Anonymous and Distributed Currency Secured by the No-Cloning Theorem of Quantum Mechanics&quot;&lt;/a&gt;&lt;/em&gt; which demonstrates how a quantum bitcoin could function. The article's conclusion states that:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;quantum bitcoins are atomic and there is currently no way to subdivide quantum bitcoin into smaller denominations, or merge them into larger ones.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;As there is currently no way to subdivide or merge quantum bitcoins, you can not make change in a transaction. However, I could not understand why subdivision of a quantum bitcoin is not possible.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Question&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Why can you not subdivide a quantum bitcoin?&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Definitions&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;A quantum bitcoin - like a regular bitcoin - is a currency with no central authority. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The main idea behind the implementation of a quantum bitcoin is the no-cloning theorem. The no-cloning theorem demonstrates how it is impossible to copy the arbitrary quantum state $ \left| \varphi \right&amp;gt; $.&lt;/p&gt;&#xA;" OwnerUserId="82" LastEditorUserId="2927" LastEditDate="2018-08-25T05:11:57.550" LastActivityDate="2018-08-25T05:11:57.550" Title="Quantum Bitcoin Subdivision" Tags="&lt;quantum-algorithms&gt;&lt;cryptography&gt;&lt;cryptocurrency&gt;&lt;quantum-money&gt;" AnswerCount="1" CommentCount="5" FavoriteCount="1" />
  <row Id="1324" PostTypeId="2" ParentId="1289" CreationDate="2018-03-25T17:09:29.653" Score="21" Body="&lt;p&gt;Firstly, a &lt;em&gt;classical&lt;/em&gt; computer does basic maths at the hardware level in the arithmetic and logic unit (ALU). The logic gates take low and high input voltages and uses &lt;a href=&quot;https://en.wikipedia.org/wiki/CMOS&quot; rel=&quot;noreferrer&quot;&gt;CMOS&lt;/a&gt; to implement logic gates allowing for individual gates to be performed and built up to perform larger, more complicated operations. In this sense, typing on a keyboard is sending electrical signals, which eventually ends up in a command (in the form of more electrical signals) being sent to the ALU, the correct operations being performed and more signals sent back, which gets converted to display pixels in the shape of a number on your screen.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;What about a quantum computer?&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;There are two possible ways that quantum processors get used: by themselves, or in conjunction with a classical processor. However, most (including your example of superconducting) quantum processors don't actually use electrical signals, although this is still how your mouse, keyboard and monitor etc. transmit and receive information. So, there needs to be a way to convert the electric signal to whatever signal the quantum processor uses (which I'll get on to later), as well as some way of telling the processor what you want to do. Both these issues can be solved at once by classical pre- and post- processing, such as in IBM's &lt;a href=&quot;https://developer.ibm.com/code/open/projects/qiskit/&quot; rel=&quot;noreferrer&quot;&gt;QISKit&lt;/a&gt;. Microsoft is taking a bit more of a top-down approach in &lt;a href=&quot;https://docs.microsoft.com/en-us/quantum/quantum-qr-intro?view=qsharp-preview&quot; rel=&quot;noreferrer&quot;&gt;Q#&lt;/a&gt;, where programs for a quantum processor is written more like a 'classical' program, as opposed to a script, then compiled and potentially &lt;em&gt;optimised&lt;/em&gt; for the hardware. That is, if you've got a function, it can perform classical operations, as well as make calls to the quantum processor to perform any required quantum operations. This leads me to the first point:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;If you're going to ask a computer with access to a quantum processor to calculate something such as $2+3$, one very valid solution would be to just compute it on the classical processor as per usual.&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;OK, let's say that you're forcing the classical processor to use the quantum processor, which in this case is one of IBM's superconducting chips, using &lt;em&gt;transmon&lt;/em&gt; qubits, let's say, the &lt;a href=&quot;https://github.com/QISKit/ibmqx-backend-information/blob/master/backends/ibmqx4/README.md&quot; rel=&quot;noreferrer&quot;&gt;IBM QX4&lt;/a&gt;. This is too small to have error correction, so let's ignore that. There are three parts to using a circuit model processor: initialisation, unitary evolution and measurement, which are explained in more detail below. Before that, &lt;/p&gt;&#xA;&#xA;&lt;h2&gt;What is a transmon?&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Take a superconducting loop to allow for &lt;a href=&quot;https://en.wikipedia.org/wiki/Cooper_pair&quot; rel=&quot;noreferrer&quot;&gt;Cooper pairs&lt;/a&gt; and add one or two &lt;a href=&quot;https://en.wikipedia.org/wiki/Josephson_effect&quot; rel=&quot;noreferrer&quot;&gt;Josephson junctions&lt;/a&gt; to give a Cooper pair box island in the region between the two Josephson junctions with Josephson coupling energy $E_J = I_c\Phi_0/2\pi$, where the &lt;em&gt;magnetic flux quantum&lt;/em&gt; $\Phi_0 = h/2e$ and $I_c$ is the critical current of the junction. Applying a voltage $V_g$ to this box gives a 'gate capacitance' $C_g$ and makes this a &lt;em&gt;charge qubit&lt;/em&gt;. For the Coulomb energy of a single Cooper pair $E_C = \left(2e\right)^2/2C$, where $C$ is the sum of the total capacitance of the island. The Hamiltonian of such a system is given by $$H = E_C\left(n - n_g\right)^2 - E_J\cos\phi,$$ where $n$ is the number of Cooper pairs, $\phi$ is the phase change across the junction and $n_g = C_gV_g/2e$.  When performing unitary operations, only the two lowest states of the system are considered, $\left|n\right\rangle = \left|0\right\rangle$ and $\left|n\right\rangle = \left|1\right\rangle$ with respective energies $E_0 =\hbar\omega_0$ and $E_1 = \hbar\omega_1$ and qubit frequency $\omega = \omega_1-\omega_0$, describing the computational basis of a qubit. A typical charge qubit could have $E_C = 5E_J$. Adding a large shunting capacitance and increasing the gate capacitance switches this ratio, so that $E_J\gg E_C$ and we have a &lt;em&gt;transmon&lt;/em&gt;. This has the advantage of longer coherence times, at a cost of reduced anharmonicity (where energy levels beyond the first two are closer together, potentially causing leakage).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Finally&lt;/em&gt;, we get to the main question:&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;How do we initialise, evolve and measure a transmon?&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Single qubit unitary evolution:&lt;/strong&gt; Applying a microwave pulse $\mathcal E\left(t\right) = \mathcal E_x\left(t\right)\cos\left(\omega_dt\right) + \mathcal E_y\left(t\right)\sin\left(\omega_dt\right)$ for $0&amp;lt;t&amp;lt;t_g$ of frequency $\omega_d$ and making the &lt;a href=&quot;https://en.wikipedia.org/wiki/Rotating_wave_approximation&quot; rel=&quot;noreferrer&quot;&gt;rotating wave approximation&lt;/a&gt; gives the Hamiltonian of the qubit states (in the ideal case) as $$H =\hbar \begin{pmatrix}\omega_1-\omega_d &amp;amp;&amp;amp; \frac 12\mathcal E_x\left(t\right) - \frac i2\mathcal E_y\left(t\right)\\ \frac 12\mathcal E_x\left(t\right) + \frac i2\mathcal E_y\left(t\right) &amp;amp;&amp;amp; \omega_2-2\omega_d\end{pmatrix}$$ However, due to lower anharmonicity, the microwave pulses have to be shaped to reduce leakage to higher energy levels in a process known as &lt;a href=&quot;https://arxiv.org/abs/0901.0534v3&quot; rel=&quot;noreferrer&quot;&gt;&lt;em&gt;Derivative Removal by Adiabatic Gate (DRAG)&lt;/em&gt;&lt;/a&gt;. By varying the pulse, different Hamiltonians can be achieved, which, depending on the time of the pulse can be used to implement different unitary operations on a single qubit.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Measurement/readout:&lt;/strong&gt; A microwave resonator, with resonance frequency $\omega_r$, can be coupled to the transmon using a capacitor. This interaction causes (decaying) Rabi oscillations to occur in the transmon-resonator system. When the coupling strength of cavity and qubit, $g \ll \omega-\omega_r$, this is known as the &lt;em&gt;dispersive regime&lt;/em&gt;. In this regime, the transmittance spectrum of the cavity is shifted by $\pm g^2/\left(\omega-\omega_r\right)$ depending on the state of the qubit, so applying a microwave pulse and analysing the transmittance and reflectance (by computer) can then be used to measure the qubit.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Multiple qubit unitary evolution:&lt;/strong&gt; This idea of coupling a qubit to a microwave resonator can be extended by coupling the resonator to another qubit. As in the single qubit gate case, timings of the coupling as well as microwave pulses can be used allow the first qubit to couple to the cavity, which is then coupled to the second qubit and perform certain 2-qubit gates. Higher energy levels can also be used to make certain gates easier to implement due to interactions between higher levels caused by the cavity. One such example is shown &lt;a href=&quot;https://arxiv.org/abs/0903.2030v2&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;, where the cavity causes an interaction between the states of $\left|2\right&amp;gt;\left|0\right&amp;gt;$ and $\left|1\right&amp;gt;\left|1\right&amp;gt;$. An avoided crossing between these states means that a 2-qubit phase gate can be implemented, although in general 2-qubit gates are implemented less well (have a lower fidelity) than single qubit ones.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Initialisation:&lt;/strong&gt; Readout, potentially followed by a single qubit Pauli $X$ gate (on each qubit measured to be in state $\left|1\right\rangle$) to ensure that all qubits start in state $\left|0\right\rangle$.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Adding 2 and 3 is now a 'simple' matter of initialising the qubits, performing the gates equivalent to a classical reversible adder and measuring the result, all implemented automatically. The measurement result is then returned by a classical computer as per usual.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;As a bonus&lt;/strong&gt;, it seems a little pointless to go through all that in order to implement gates that could be done on a classical computer anyway, so it turns out that it's possible to approximately implement a &lt;a href=&quot;https://arxiv.org/abs/1611.07851&quot; rel=&quot;noreferrer&quot;&gt;quantum adder&lt;/a&gt;, which adds two quantum (as opposed to classical) states, with some error, on one of IBM's processors.&lt;/p&gt;&#xA;" OwnerUserId="23" LastEditorUserId="23" LastEditDate="2018-03-26T16:00:33.510" LastActivityDate="2018-03-26T16:00:33.510" CommentCount="1" />
  <row Id="1325" PostTypeId="5" CreationDate="2018-03-25T17:35:51.153" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-25T17:35:51.153" LastActivityDate="2018-03-25T17:35:51.153" CommentCount="0" />
  <row Id="1326" PostTypeId="4" CreationDate="2018-03-25T17:35:51.153" Score="0" Body="&quot;A cryptocurrency (or crypto currency) is a digital asset designed to work as a medium of exchange that uses cryptography to secure its transactions, to control the creation of additional units, and to verify the transfer of assets.&quot; (from Wikipedia) Please be sure that the system under consideration depends crucially on quantum computing." OwnerUserId="253" LastEditorUserId="253" LastEditDate="2018-03-25T18:07:27.127" LastActivityDate="2018-03-25T18:07:27.127" CommentCount="0" />
  <row Id="1327" PostTypeId="1" CreationDate="2018-03-25T17:45:24.167" Score="11" ViewCount="56" Body="&lt;p&gt;Consider a classical computer, one making, say, a calculation involving a large amount of data. Would quantum memory allow it to store that information (in the short term) more efficiently, or better handle that quantity of data?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My thought would be it isn't possible, due to the advantage of quantum information storage being in the superpositions, and the data from a classical computer being very much &lt;em&gt;not&lt;/em&gt; in a superposition, but I'd like to see if this is correct.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Either way, citations for further reading would be much appreciated.&lt;/p&gt;&#xA;" OwnerUserId="91" LastActivityDate="2018-03-25T18:23:26.927" Title="Quantum memory assisting classical memory" Tags="&lt;quantum-memory&gt;&lt;classical-computing&gt;" AnswerCount="1" CommentCount="5" />
  <row Id="1328" PostTypeId="1" CreationDate="2018-03-25T17:49:50.387" Score="7" ViewCount="80" Body="&lt;p&gt;As mentioned in an earlier question of mine, I am interested in using type one spontaneous down conversion (SPDC) in optical quantum computing. However, SPDC is a somewhat low probability occurrence - most of the photons pass straight through the crystals unentangled. What methods, if any, are there to improve the probability of down conversion occurring, and therefore entanglement between photons?&lt;/p&gt;&#xA;" OwnerUserId="91" LastEditorUserId="26" LastEditDate="2018-03-27T09:59:41.300" LastActivityDate="2018-04-04T18:26:40.737" Title="Improving probability of spontaneous parametric down conversion" Tags="&lt;optical-quantum-computing&gt;&lt;experimental-results&gt;&lt;spdc&gt;" AnswerCount="2" CommentCount="3" />
  <row Id="1329" PostTypeId="2" ParentId="1328" CreationDate="2018-03-25T17:58:40.973" Score="2" Body="&lt;p&gt;Here's some relevant work in &lt;a href=&quot;https://arxiv.org/abs/1001.4182&quot; rel=&quot;nofollow noreferrer&quot;&gt;Optimizing type-I polarization-entangled photons-Radhika Rangarajan, Michael Goggin, Paul Kwiat&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Optical quantum information processing needs ultra-bright sources of&#xA;  entangled photons, especially from synchronizable femtosecond lasers&#xA;  and low-cost cw-diode lasers. Decoherence due to timing information&#xA;  and spatial mode-dependent phase has traditionally limited the&#xA;  brightness of such sources. We report on a variety of methods to&#xA;  optimize type-I polarization-entangled sources - the combined use of&#xA;  different compensation techniques to engineer high-fidelity pulsed and&#xA;  cw-diode laser-pumped sources, as well as the first production of&#xA;  polarization-entanglement directly from the highly nonlinear biaxial&#xA;  crystal BiB3O6 (BiBO). Using spatial compensation, we show more than a&#xA;  400-fold improvement in the phase flatness, which otherwise limits&#xA;  efficient collection of entangled photons from BiBO, and report the&#xA;  highest fidelity to date (99%) of any ultrafast&#xA;  polarization-entanglement source. Our numerical code, available on our&#xA;  website, can design optimal compensation crystals and simulate&#xA;  entanglement from a variety of type-I phasematched nonlinear crystals.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Apart from that I'd like to mention another interesting development in methods to entangle photons efficiently: An alternative to spontaneous parametric down conversion (SPDC) is&#xA;two-photon emission from electrically driven semiconductors. According to &lt;a href=&quot;https://en.wikipedia.org/wiki/Spontaneous_parametric_down-conversion#Alternatives&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wikipedia&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The newly observed effect of two-photon emission from electrically&#xA;  driven semiconductors has been proposed as a basis for more efficient&#xA;  sources of entangled photon pairs. Other than SPDC-generated&#xA;  photon pairs, the photons of a semiconductor-emitted pair usually are&#xA;  not identical but have different energies. Until recently, within&#xA;  the constraints of quantum uncertainty, the pair of emitted photons&#xA;  were assumed to be co-located: they are born from the same location.&#xA;  However, a new nonlocalized mechanism for the production of correlated&#xA;  photon pairs in SPDC has highlighted that occasionally the individual&#xA;  photons that constitute the pair can be emitted from spatially&#xA;  separated points.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Relevant paper: &lt;a href=&quot;https://www.nature.com/articles/nphoton.2008.28&quot; rel=&quot;nofollow noreferrer&quot;&gt;Observation of two-photon emission from semiconductors - Alex Hayat, Pavel Ginzburg &amp;amp; Meir Orenstein&lt;/a&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;According to the abstract it is &quot;&lt;em&gt;three orders of magnitude more efficient than the existing down-conversion schemes&lt;/em&gt;&quot;.&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-25T18:47:11.223" LastActivityDate="2018-03-25T18:47:11.223" CommentCount="0" />
  <row Id="1330" PostTypeId="2" ParentId="1327" CreationDate="2018-03-25T18:23:26.927" Score="10" Body="&lt;h2&gt;In summary, no.&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;If you think about it, this makes sense. When measuring a quantum system with $n$ qubits, you get $n$ bits of information. the $2^n$ figure exists only when the system is in superposition, which a classical computer cannot access.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The specific theorem in question here is &lt;a href=&quot;https://en.wikipedia.org/wiki/Holevo%27s_theorem&quot; rel=&quot;noreferrer&quot;&gt;Holevo's theorem&lt;/a&gt;. To quote Wikipedia:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;In essence, the Holevo bound proves that given $n$ qubits, although they can &quot;carry&quot; a larger amount of (classical) information (thanks to quantum superposition), the amount of classical information that can be retrieved, i.e. accessed, can be only up to $n$ classical (non-quantum encoded) bits.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;See &lt;a href=&quot;https://physics.stackexchange.com/questions/358628/will-quantum-computing-provide-any-advantage-for-storing-large-amounts-of-data&quot;&gt;this physics question and answer(s)&lt;/a&gt; as well. (Thanks to glS for linking to this in the comments.)&lt;/p&gt;&#xA;" OwnerUserId="91" LastActivityDate="2018-03-25T18:23:26.927" CommentCount="1" />
  <row Id="1331" PostTypeId="2" ParentId="1225" CreationDate="2018-03-25T19:12:10.960" Score="4" Body="&lt;p&gt;From a computer science perspective, the calculation of quantum-state amplitudes can be related to group-by aggregation queries in relational database systems, and the techniques we developed to reorganize calculations can be related to algebraic manipulations that are performed by database query optimizers. The general “design pattern” is thus analogous: convert quantum circuits into graph-based algebraic representations that can be readily manipulated and then use those representations to generate optimized execution plans for their simulation. A complexity analysis could then be approached from this perspective.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I included a simple example in a reply to a question posted on the IBM Q Experience Forum: &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/community/question?questionId=625bb74685836730de3e36a61f78277f&quot; rel=&quot;nofollow noreferrer&quot;&gt;Equations for Bristle Brush Example&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="522" LastActivityDate="2018-03-25T19:12:10.960" CommentCount="1" />
  <row Id="1332" PostTypeId="5" CreationDate="2018-03-25T23:09:54.967" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-25T23:09:54.967" LastActivityDate="2018-03-25T23:09:54.967" CommentCount="0" />
  <row Id="1333" PostTypeId="4" CreationDate="2018-03-25T23:09:54.967" Score="0" Body="For questions about the quantum analogue of the universal Turing machine; i.e., for questions about the theoretical construct that is the universal quantum computer. This tag is not for questions about the normal Turing machine; these would fit better on Computer Science. " OwnerUserId="91" LastEditorUserId="91" LastEditDate="2018-03-25T23:48:57.297" LastActivityDate="2018-03-25T23:48:57.297" CommentCount="0" />
  <row Id="1334" PostTypeId="5" CreationDate="2018-03-25T23:11:37.393" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-25T23:11:37.393" LastActivityDate="2018-03-25T23:11:37.393" CommentCount="0" />
  <row Id="1335" PostTypeId="4" CreationDate="2018-03-25T23:11:37.393" Score="0" Body="For questions about the set of quantum gates that form a set of gates from which another gate can be produced; this set is analogous the classical set of universal gates (either a NOR gate or a NAND gate can produce any other gate). This tag, however, is not to be used for the classical set of universal gates; those questions are probably more appropriate on Computer Science." OwnerUserId="91" LastEditorUserId="91" LastEditDate="2018-03-25T23:49:58.177" LastActivityDate="2018-03-25T23:49:58.177" CommentCount="0" />
  <row Id="1336" PostTypeId="2" ParentId="1292" CreationDate="2018-03-25T23:25:33.680" Score="5" Body="&lt;p&gt;It's difficult to define the point where an experimental setup is a quantum computer. But the crucial feature of a quantum computer is that it's able to perform a quantum computation. The first experimental realization of an algorithm was indeed &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9801027&quot; rel=&quot;noreferrer&quot;&gt;Jones' and Mosca's implementation&lt;/a&gt; of the Deutsch algorithm in 1998 using an NMR setup. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Of course previous experiments showed components that could be used in a quantum computer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, it is quite reasonable to demand that a quantum computer is able to perform arbitrary arithmetics, whether programmable or by minor adjustments to the setup. By this definition we don't have a quantum computer, yet. This is related to the &lt;a href=&quot;https://en.wikipedia.org/wiki/DiVincenzo%27s_criteria&quot; rel=&quot;noreferrer&quot;&gt;DiVincenzo Criteria&lt;/a&gt; for Quantum Computers.&lt;/p&gt;&#xA;" OwnerUserId="104" LastEditorUserId="104" LastEditDate="2018-03-25T23:50:47.003" LastActivityDate="2018-03-25T23:50:47.003" CommentCount="0" />
  <row Id="1337" PostTypeId="2" ParentId="1276" CreationDate="2018-03-26T01:08:53.800" Score="5" Body="&lt;p&gt;There is a newer result from Robert Beals, Stephen Brierley, Oliver Gray, Aram Harrow, Samuel Kutin, Noah Linden, Dan Shepherd, Mark Stather. They present on Table 2 of &lt;a href=&quot;https://arxiv.org/abs/1207.2307&quot; rel=&quot;nofollow noreferrer&quot;&gt;Efficient Distributed Quantum Computing&lt;/a&gt; the results for bubble sort and insertion sort, it is mainly for &quot;network sorting&quot; but they gave more references about sorting. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;A quick and very briefly description of the paper can be:&#xA;We can say that the paper show how to solve several problems such as access the quantum memory without the loss of superposition (and they give the cost for it). Also, the paper presents the problem of sorting a network doing it quantumly (one of the problems is the reversibility of operations). I like the paper because it raises several problems and the authors gave the solution for some of the problems. I think that it is hard to try to summarize, I really recommend to read.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I hope that I have helped.&lt;/p&gt;&#xA;" OwnerUserId="534" LastEditorUserId="534" LastEditDate="2018-03-26T11:01:59.027" LastActivityDate="2018-03-26T11:01:59.027" CommentCount="2" />
  <row Id="1338" PostTypeId="2" ParentId="12" CreationDate="2018-03-26T01:13:54.233" Score="3" Body="&lt;p&gt;I think a nice &quot;overview&quot; about the subject can be found at: &lt;a href=&quot;https://www.quantiki.org/wiki/list-qc-simulators&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantiki&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;They have a list of quantum computer simulators in several languages, some of the simulators have been cited here before. However, they keep a list that they update to inform (or try to inform) of the project's status. There are some &quot;libraries&quot; such as:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Haskell&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://hackage.haskell.org/package/qchas&quot; rel=&quot;nofollow noreferrer&quot;&gt;qchas&lt;/a&gt; (qchas: A library for implementing Quantum Algorithms) - A library useful for implementing Quantum Algorithms. It contains definitions of Quantum Gates, Qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Python&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://github.com/artiste-qb-net/qubiter&quot; rel=&quot;nofollow noreferrer&quot;&gt;qubiter&lt;/a&gt; : The Qubiter project aims to provide eventually a full suite of tools, written mostly in Python, for designing and simulating quantum circuits on classical computers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Javascript&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://github.com/garrison/jsqis&quot; rel=&quot;nofollow noreferrer&quot;&gt;jsqis&lt;/a&gt; : &#xA;jsqis, at its core, is a quantum computer simulator written in Javascript. It allows initialization of quantum registers and their manipulation by means of quantum gates.&lt;/p&gt;&#xA;" OwnerUserId="534" LastEditorUserId="82" LastEditDate="2018-03-26T02:55:21.647" LastActivityDate="2018-03-26T02:55:21.647" CommentCount="1" />
  <row Id="1339" PostTypeId="1" AcceptedAnswerId="1643" CreationDate="2018-03-26T02:22:40.907" Score="7" ViewCount="76" Body="&lt;p&gt;Q1: I've tried to find out if &lt;a href=&quot;https://en.wikipedia.org/wiki/Barkhausen_effect#Barkhausen_noise&quot; rel=&quot;nofollow noreferrer&quot;&gt;Barkhausen noise&lt;/a&gt; affects the &lt;a href=&quot;https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics&quot; rel=&quot;nofollow noreferrer&quot;&gt;measurement&lt;/a&gt; of spin-wave excitations in magnetic particle material based qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I prefer implementations such as those described in &quot;&lt;a href=&quot;https://arxiv.org/abs/cond-mat/0009432&quot; rel=&quot;nofollow noreferrer&quot;&gt;Magnetic qubits as hardware for quantum computers&lt;/a&gt;&quot;, rather than a true hybrid system such as described in &quot;&lt;a href=&quot;http://science.sciencemag.org/content/349/6246/405&quot; rel=&quot;nofollow noreferrer&quot;&gt;Coherent coupling between a ferromagnetic magnon and a superconducting qubit&lt;/a&gt;&quot; &lt;strong&gt;or&lt;/strong&gt; &quot;&lt;a href=&quot;http://advances.sciencemag.org/content/3/7/e1603150.full&quot; rel=&quot;nofollow noreferrer&quot;&gt;Resolving quanta of collective spin excitations in a millimeter-sized ferromagnet&lt;/a&gt;&quot;; which relies on the coherent coupling between a single-magnon excitation in a millimeter-sized ferromagnetic sphere and a superconducting qubit. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I'm asking about the situation where the magnetic particle is the qubit and not simply part of a magnon-qubit coupling scheme.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Q2: Is Barkhausen noise a factor that is not considered relevant?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;After several hours of research the closest search I could find, for a paper of quantum computing hardware, Mesoscale and Nanoscale Physics, and Barkhausen noise, was this paper: &quot;&lt;a href=&quot;https://arxiv.org/abs/1603.06858v2&quot; rel=&quot;nofollow noreferrer&quot;&gt;The Theory of Spin Noise Spectroscopy: A Review&lt;/a&gt;&quot;.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;&lt;strong&gt;Barkhausen noise&lt;/strong&gt;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Studies of fluctuations in magnetic systems take roots in the work of Heinrich Barkhausen who proved already in 1919 that the magnetic hysteresis curve is not continuous, but is made up of small random steps caused when the magnetic domains move under an applied magnetic field. This noise can be characterized by placing a coil of a conducting wire near the sample. The motion of ferromagnetic domain walls produces changes in the magnetization that induces noisy electrical signals in the coil. Studies of Barkhausen noise have been used in practice as a nondemolition tool to characterize the distribution of elastic stresses and the microstructure of magnetic samples&quot;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;It would seem that Barkhausen noise can affect even very small magnetic particles subjected to an external magnetizing field, as might be encountered during measurement, but nowhere (it would seem) is there research on it's effect on quantum noise of the system.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It appears to be a difficult or unanswered question.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;An answer was offered stating:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The Barkhausen effect has to do with domain wall motion. The magnetic qubit discussed in the first reference is based on &lt;a href=&quot;https://en.wikipedia.org/wiki/Nanometre&quot; rel=&quot;nofollow noreferrer&quot;&gt;nm&lt;/a&gt; sized magnetic particle, which we can assume to be &lt;a href=&quot;https://en.wikipedia.org/wiki/Single_domain_(magnetic)&quot; rel=&quot;nofollow noreferrer&quot;&gt;single domain&lt;/a&gt;, and therefore would not exhibit Barkhausen noise. This &lt;a href=&quot;https://dspace.mit.edu/bitstream/handle/1721.1/5030/RLE-TR-016-14261877.pdf?sequence=1&amp;amp;origin=publicationDetail&quot; rel=&quot;nofollow noreferrer&quot;&gt;paper by Kittel&lt;/a&gt; [Theory of the Structure of Ferromagnetic Domains - 1946] discusses domains in magnetic particles. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There are different limits stated as to &lt;a href=&quot;https://en.wikipedia.org/wiki/Single_domain_(magnetic)#Limits_on_the_single-domain_size&quot; rel=&quot;nofollow noreferrer&quot;&gt;what constitutes a single-domain magnetic particle&lt;/a&gt;, I've found upper limits ranging from 30-100 nm, with lower limits somewhat more consistent around 10 nm.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;While it's not precisely stated what the exact size of the particles are in that paper, and we might assume others using similar methods could utilize particles of a different size, let's assume for the sake of &lt;strong&gt;that one answer only&lt;/strong&gt; that the particles in question are single domain.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are five main mechanisms due to which magnetic Barkhausen emissions occur [Jiles (1988)]: &lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Discontinuous, irreversible domain wall motion &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Discontinuous rotation of magnetic moments within a domain&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Appearance and disappearance of domain walls (Bloch or Neel). Domain&#xA;walls are narrow transition regions between magnetic domains. They&#xA;only differ in the plane of rotation of magnetization. For Bloch&#xA;walls the magnetization rotates through the plane of the domain wall&#xA;whereas for Neel walls the magnetization rotates within the plane of&#xA;the domain wall. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Inversion of magnetization in single-domain particles&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Displacement of Bloch or Neel lines in two 180$°$ walls with&#xA;oppositely directed magnetizations&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;There are a number of papers on the measurement of Barkhausen noise in single-domain magnetic particles:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&quot;&lt;a href=&quot;https://www.researchgate.net/publication/224070409_Detection_of_the_magnetization_reversal_of_individual_interacting_single-domain_particles_within_Co-Cr_columnar_thin-films&quot; rel=&quot;nofollow noreferrer&quot;&gt;Detection of the magnetization reversal of individual interacting single-domain particles within Co-Cr columnar thin-films&lt;/a&gt;&quot; - 1988&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;The fundamental Barkhausen noise generated by the magnetization reversal of individual particles within a particulate magnetic medium has been observed using the anomalous Hall effect (AHE) as a sensitive magnetization probe. This is the first time the reversal of individual interacting single or nearly single domain particles has been detected. The jumps correspond to magnetic switching volumes of ~3×10$^{-15}$ cm$^3$ with moments around 10$^{-12}$ emu.&quot;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&quot;&lt;a href=&quot;https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/JB088iB08p06505&quot; rel=&quot;nofollow noreferrer&quot;&gt;The dependence of magnetic domain structure upon magnetization state with emphasis upon nucleation as a mechanism for pseudo‐single‐domain behavior&lt;/a&gt;&quot; - 1983&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;These observations thereby demonstrate that nucleation becomes increasingly more dominant as the particles become smaller, a manifestation of the random distribution of active nucleation sites. Nucleation may therefore account for much of the magnitude and grain size dependence of hysteresis parameters in the PSD range as well as resulting in a gradual transition between multidomain and PSD behavior. Fine particles completely controlled by nucleation during hysteresis behave in a strikingly parallel manner to classical single domains and are therefore quite appropriately described as being pseudo‐single‐domain.&quot;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&quot;&lt;a href=&quot;https://arxiv.org/abs/1401.4326v1&quot; rel=&quot;nofollow noreferrer&quot;&gt;Statistical Physics of Pure Barkhausen Noise&lt;/a&gt;&quot; - 2014&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;That paper goes as far as to state:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;We will show that here Barkhausen Noise has nothing to do with the movement of domain walls nor with Self Organized Criticality nor with fractal domains nor with thermodynamic criteria.&quot;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="278" LastEditorUserId="278" LastEditDate="2018-03-27T05:39:07.650" LastActivityDate="2018-04-08T21:12:58.903" Title="Does Barkhausen noise affect the measurement of magnetic particle based qubits?" Tags="&lt;qubit&gt;&lt;architecture&gt;&lt;noise&gt;&lt;measurement&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="1340" PostTypeId="2" ParentId="1339" CreationDate="2018-03-26T05:59:50.943" Score="1" Body="&lt;p&gt;The Barkhausen effect has to do with domain wall motion. The magnetic qubit discussed in the first reference is based on nm sized magnetic particle, which we can assume to be single domain, and therefore would not exhibit Barkhausen noise. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This &lt;a href=&quot;https://dspace.mit.edu/bitstream/handle/1721.1/5030/RLE-TR-016-14261877.pdf?sequence=1&amp;amp;origin=publicationDetail&quot; rel=&quot;nofollow noreferrer&quot;&gt;paper&lt;/a&gt; by Kittel discusses domains in magnetic particles. &lt;/p&gt;&#xA;" OwnerUserId="127" LastEditorUserId="127" LastEditDate="2018-03-26T16:43:35.787" LastActivityDate="2018-03-26T16:43:35.787" CommentCount="4" />
  <row Id="1341" PostTypeId="1" CreationDate="2018-03-26T10:49:31.487" Score="4" ViewCount="140" Body="&lt;p&gt;What does one mean by saying that classical bits perform operations at the scale of $2n$ and quantum computers perform operations at the scale of $2^n$? In both cases, $n$ = Number of bits/qubits. &lt;/p&gt;&#xA;" OwnerUserId="543" LastEditorUserId="253" LastEditDate="2018-03-26T16:53:03.833" LastActivityDate="2018-03-28T19:28:00.683" Title="Why do classical bits perform calculations at a scale that expands linearly and qubits at exponential scale in the number of (qu)bits?" Tags="&lt;quantum-computer&gt;&lt;qubit&gt;&lt;quantum-speedup&gt;" AnswerCount="3" CommentCount="2" />
  <row Id="1342" PostTypeId="2" ParentId="1341" CreationDate="2018-03-26T11:16:19.733" Score="2" Body="&lt;p&gt;The reason is because of the superposition. It allows you to perform operations and won the speed up. For example, if you have a just one qubit you will have the following because of the superposition:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\alpha_0\lvert0\rangle + \alpha_1\lvert1\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can see that you have already $2$ basis for one qubit. If you have two qubits you will have $4$ basis for your system and go on. I will put the $2$ qubit but as a combination of tensor product of the previous basis and we will have:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\lvert0\rangle ⊗ \lvert0\rangle, \lvert0\rangle ⊗ \lvert1\rangle, \lvert1\rangle ⊗ \lvert0\rangle, \lvert1\rangle ⊗ \lvert1\rangle$$ &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you apply the tensor product of it, you will end up with a $4$ basis system for $2$ qubits ($2^2$). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you are looking for a introduction material I think that the &lt;a href=&quot;https://homepages.cwi.nl/~rdewolf/qcnotes.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Lecture Notes&lt;/a&gt; from Ronald de Wolf is a good start. It is possible to get directly from his website and it is for free. He gave a better explanation about this on section 1.3. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I hope that I have helped you. &lt;/p&gt;&#xA;" OwnerUserId="534" LastEditorUserId="26" LastEditDate="2018-03-26T14:45:19.363" LastActivityDate="2018-03-26T14:45:19.363" CommentCount="0" />
  <row Id="1343" PostTypeId="2" ParentId="1341" CreationDate="2018-03-26T12:33:09.170" Score="7" Body="&lt;p&gt;I'm not sure it really is true to make such a claim, even though it is one that is often seen. Even so, this statement is common because it does point towards a difference between classical computers and quantum ones.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Classical computation is essentially a process that takes a single input bit string and keeps transforming it until you get a single output bit string. You can think of the whole process as only ever having one bit string in the computer at once.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The same is true for quantum computers, except that you need to replace 'bit string' with 'state of many qubits'. So how do bit strings compare with multi qubit states? To find out, we can look at how classical computers can simulate quantum ones.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One way to represent states of $n$ qubits in a classical computer is to think of them as superpositions of all possible $n$-bit strings. Then you can have a big array, which stores the corresponding amplitude for every $n$-bit string. Since there are $2^n$ $n$-bit strings, this will take an exponentially large amount of memory. This is often not the most efficient method of representing quantum states, but there are cases when it is no worse than any other.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So if we need to simulate any possible process for $n$ qubits with bits, we know that it will incur this kind of overhead. If we use this to draw a comparison between qubits and bits, we could say that an exponentially large number of qubits are required to match the power of $n$ bits. But the same would not be true for all possible computational tasks.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-03-26T12:33:09.170" CommentCount="3" />
  <row Id="1344" PostTypeId="1" AcceptedAnswerId="1354" CreationDate="2018-03-26T15:37:09.230" Score="11" ViewCount="166" Body="&lt;p&gt;Suppose we have a circuit decomposition of a unitary $U$ using some universal gate set (for example CNOT-gates and single qubit unitaries). Is there a direct way to write down the circuit of the corresponding controlled unitary $C_U$ using the same universal gate set?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example take $U=i Y = H X H X$, as a circuit:&lt;br&gt;&#xA;&lt;a href=&quot;https://i.stack.imgur.com/xGUVS.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/xGUVS.png&quot; alt=&quot;circuit for U&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We can replace the $X$ gates by $C_X$ (CNOT) gates to obtain $C_U$:&lt;br&gt;&#xA;&lt;a href=&quot;https://i.stack.imgur.com/UPq7u.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/UPq7u.png&quot; alt=&quot;circuit for CU&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This works because if the control qubit is in state $|0\rangle$ the action on the target is $H^2=\mathbb{I}$, while for $|1\rangle$ it applies the circuit for $U$. For different $U$, in particular if it acts on several qubits, coming up with such a circuit might be cumbersome. Is there a recipe to obtain the circuit of $C_U$ given that you know how to build $U$?&lt;/p&gt;&#xA;" OwnerUserId="104" LastEditorUserId="104" LastEditDate="2018-03-27T12:53:42.597" LastActivityDate="2018-03-27T12:53:42.597" Title="Circuit of controlled-Unitary gate" Tags="&lt;quantum-gate&gt;&lt;circuit-model&gt;&lt;universal-gates&gt;&lt;gate-synthesis&gt;" AnswerCount="2" CommentCount="3" />
  <row Id="1345" PostTypeId="5" CreationDate="2018-03-26T15:47:12.237" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-26T15:47:12.237" LastActivityDate="2018-03-26T15:47:12.237" CommentCount="0" />
  <row Id="1346" PostTypeId="4" CreationDate="2018-03-26T15:47:12.237" Score="0" Body="On questions related to experiments with actual quantum computing devices and how to interpret their results. Also appropriate if the question can only be reasonable answered with an experiment (or experiment design)" OwnerUserId="253" LastEditorUserId="253" LastEditDate="2018-03-26T17:29:04.793" LastActivityDate="2018-03-26T17:29:04.793" CommentCount="0" />
  <row Id="1347" PostTypeId="2" ParentId="74" CreationDate="2018-03-26T15:50:23.407" Score="8" Body="&lt;h3&gt;Measurement-based quantum computation (MBQC)&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;This is a way to perform quantum computation, using intermediary measurements as a way of &lt;em&gt;driving&lt;/em&gt; the computation rather than just extracting the answers. It is a special case of &quot;quantum circuits with intermediary measurements&quot;, and so is no more powerful. However, when it was introduced, it up-ended many people's intuitions of the role of unitary transformations in quantum computation. In this model one has constraints such as the following:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;One prepares, or is given, a very large entangled state &amp;mdash; one which can be described (or prepared) by having some set of qubits all initially prepared in the state $\lvert + \rangle$, and then some sequence of controlled-Z operations $\mathrm{CZ} = \mathrm{diag}(+1,+1,+1,-1)$, performed on pairs of qubits according to the edge-relations of a graph (commonly, a rectangular grid or hexagonal lattice).&lt;/li&gt;&#xA;&lt;li&gt;Perform a sequence of measurements on these qubits &amp;mdash; some perhaps in the standard basis, but the majority not in the standard basis, but instead measuring observables such as $M_{\mathrm{XY}}(\theta) = \cos(\theta) X - \sin(\theta) Y$ for various angles $\theta$. Each measurement yields an outcome $+1$ or $-1$ (often labelled '0' or '1' respectively), and the choice of angle is allowed to depend in a simple way on the outcomes of previous measurements (in a way computed by a classical control system).&lt;/li&gt;&#xA;&lt;li&gt;The answer to the computation may be computed from the classical outcomes $\pm 1$ of the measurements.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;As with the unitary circuit model, there are variations one can consider for this model. However, the core concept is adaptive single-qubit measurements performed on a large entangled state, or a state which has been subjected to a sequence of commuting and possibly entangling operations which are either performed all at once or in stages.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This model of computation is usually considered as being useful primarily as a way to simulate unitary circuits. Because it is often seen as a means to simulate a better-liked and simpler model of computation, it is not considered theoretically very interesting anymore to most people. However:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;It is important among other things as a motivating concept behind the class &lt;strong&gt;IQP&lt;/strong&gt;, which is one means of demonstrating that a quantum computer is difficult to simulate, and Blind Quantum Computing, which is one way to try to solve problems in secure computation using quantum resources.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;There is no reason why measurement-based computations should be essentially limited to simulating unitary quantum circuits: it seems to me (and a handful of other theorists in the minority) that MQBC could provide a way of describing interesting computational primitives. While MBQC is just a special case of circuits with intermediary measurements, and can therefore be simulated by unitary circuits with only polynomial overhead, this is not to say that unitary circuits would necessarily be a very &lt;em&gt;fruitful&lt;/em&gt; way of describing anything that one could do in principle in a measurement-based computation (just as there exists imperative and functional programming languages in classical computation which sit a little ill-at-ease with one another).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;The question remains whether MBQC will suggest any way of thinking about building algorithms which is not as easily presented in terms of unitary circuits &amp;mdash; but there can be no question of a computational advantage or disadvantage over unitary circuits, except one of specific resources and suitability for some architecture.&lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="253" LastEditDate="2018-03-29T11:01:42.117" LastActivityDate="2018-03-29T11:01:42.117" CommentCount="0" />
  <row Id="1348" PostTypeId="2" ParentId="74" CreationDate="2018-03-26T15:51:25.113" Score="6" Body="&lt;h3&gt;The Unitary Circuit Model&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;This is the best well-known model of quantum computation. In this model one has constraints such as the following:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;a set of qubits initialised to a pure state, which we denote $\lvert 0 \rangle$;&lt;/li&gt;&#xA;&lt;li&gt;a sequence of unitary transformations which one performs on them, which may depend on a classical bit-string $x\in \{0,1\}^n$;&lt;/li&gt;&#xA;&lt;li&gt;one or more measurements in the standard basis performed at the very end of the computation, yielding a classical output string $y \in \{0,1\}^k$. (We do not require $k = n$: for instance, for YES / NO problems, one often takes $k = 1$ no matter the size of $n$.)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Minor details may change (for instance, the set of unitaries one may perform; whether one allows preparation in other pure states such as $\lvert 1 \rangle$, $\lvert +\rangle$, $\lvert -\rangle$; whether measurements must be in the standard basis or can also be in some other basis), but these do not make any essential difference.&lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="253" LastEditDate="2018-03-29T11:03:04.987" LastActivityDate="2018-03-29T11:03:04.987" CommentCount="0" />
  <row Id="1349" PostTypeId="2" ParentId="74" CreationDate="2018-03-26T15:54:40.103" Score="10" Body="&lt;h3&gt;The adiabatic model&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;This model of quantum computation is motivated by ideas in quantum many-body theory, and differs substantially both from the circuit model (in that it is a continuous-time model) and from continuous-time quantum walks (in that it has a time-dependent evolution).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Adiabatic computation usually takes the following form.&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Start with some set of qubits, all in some simple state such as $\lvert + \rangle$. Call the initial global state $\lvert \psi_0 \rangle$.&lt;/li&gt;&#xA;&lt;li&gt;Subject these qubits to an interaction Hamiltonian $H_0$ for which $\lvert \psi_0 \rangle$ is the unique ground state (the state with the lowest energy). For instance, given $\lvert \psi_0 \rangle = \lvert + \rangle^{\otimes n}$, we may choose $H_0 = - \sum_{k} \sigma^{(x)}_k$.&lt;/li&gt;&#xA;&lt;li&gt;Choose a final Hamiltonian $H_1$, which has a unique ground state which encodes the answer to a problem you are interested in. For instance, if you want to solve a constraint satisfaction problem, you could define a Hamiltonian $H_1 = \sum_{c} h_c$, where the sum is taken over the constraints $c$ of the classical problem, and where each $h_c$ is an operator which imposes an energy penalty (a positive energy contribution) to any standard basis state representing a classical assignment which does not satisfy the constraint $c$.&lt;/li&gt;&#xA;&lt;li&gt;Define a time interval $T \geqslant 0$ and a time-varying Hamiltonian $H(t)$ such that $H(0) = H_0$ and $H(T) = H_1$. A common but not necessary choice is to simply take a linear interpolation $H(t) = \tfrac{t}{T} H_1 + (1 - \tfrac{t}{T})H_0$.&lt;/li&gt;&#xA;&lt;li&gt;For times $t = 0$ up to $t = T$, allow the system to evolve under the continuously varying Hamiltonian $H(t)$, and measure the qubits at the output to obtain an outcome $y \in \{0,1\}^n$.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;The basis of the adiabatic model is the &lt;em&gt;adiabatic theorem&lt;/em&gt;, of which there are several versions. The version by Ambainis and Regev [&amp;thinsp;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0411152&quot; rel=&quot;noreferrer&quot;&gt;arXiv:quant-ph/0411152&lt;/a&gt;&amp;thinsp;] (a more rigorous example) implies that if there is always an &quot;energy gap&quot; of at least $\lambda &amp;gt; 0$ between the ground state of $H(t)$ and its first excited state for all $0 \leqslant t \leqslant T$, and the operator-norms of the first and second derivatives of $H$ are small enough (that is, $H(t)$ does not vary too quickly or abruptly), then you can make the probability of getting the output you want as large as you like just by running the computation slowly enough. Furthermore, you can reduce the probability of error by any constant factor just by slowing down the whole computation by a polynomially-related factor.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Despite being very different in presentation from the unitary circuit model, it has been shown that this model is polynomial-time equivalent to the unitary circuit model [&amp;thinsp;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0405098&quot; rel=&quot;noreferrer&quot;&gt;arXiv:quant-ph/0405098&lt;/a&gt;&amp;thinsp;]. The advantage of the adiabatic algorithm is that it provides a different approach to constructing quantum algorithms which is more amenable to optimisation problems. One disadvantage is that it is not clear how to protect it against noise, or to tell how its performance degrades under imperfect control. Another problem is that, even without any imperfections in the system, determining how slowly to run the algorithm to get a reliable answer is a difficult problem &amp;mdash; it depends on the energy gap, and it isn't easy in general to tell what the energy gap is for a static Hamiltonian $H$, let alone a time-varying one $H(t)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Still, this is a model of both theoretical and practical interest, and has the distinction of being the most different from the unitary circuit model of essentially any that exists.&lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="253" LastEditDate="2018-03-29T11:01:57.110" LastActivityDate="2018-03-29T11:01:57.110" CommentCount="0" />
  <row Id="1350" PostTypeId="2" ParentId="74" CreationDate="2018-03-26T15:56:31.213" Score="5" Body="&lt;h3&gt;Discrete-time quantum walk&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;A &quot;discrete-time quantum walk&quot; is a quantum variation on a random walk, in which there is a 'walker' (or multiple 'walkers') which takes small steps in a graph (e.g. a chain of nodes, or a rectangular grid). The difference is that where a random walker takes a step in a randomly determined direction, a quantum walker takes a step in a direction determined by a quantum &quot;coin&quot; register, which at each step is &quot;flipped&quot; by a unitary transformation rather than changed by re-sampling a random variable. See &#xA;[&amp;thinsp;&lt;a href=&quot;http://arxiv.org/abs/quant-ph/0012090&quot; rel=&quot;nofollow noreferrer&quot; title=&quot;Quantum Walks On Graphs. Dorit Aharonov, Andris Ambainis, Julia Kempe, Umesh Vazirani.&quot;&gt;arXiv:quant-ph/0012090&lt;/a&gt;&amp;thinsp;] for an early reference.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For the sake of simplicity, I will describe a quantum walk on a cycle of size $2^n$; though one must change some of the details to consider quantum walks on more general graphs. In this model of computation, one typically does the following.&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Prepare a &quot;position&quot; register on $n$ qubits in some state such as $\lvert 00\cdots 0\rangle$, and a &quot;coin&quot; register (with standard basis states which we denote by $\lvert +1 \rangle$ and $\lvert -1 \rangle$) in some initial state which may be a superposition of the two standard basis states.&lt;/li&gt;&#xA;&lt;li&gt;Perform a coherent controlled-unitary transformation, which adds 1 to the value of the position register (modulo $2^n$) if the coin is in the state $\lvert +1 \rangle$, and subtracts 1 to the value of the position register (modulo $2^n$) if the coin is in the state $\lvert -1 \rangle$.&lt;/li&gt;&#xA;&lt;li&gt;Perform a fixed unitary transformation $C$ to the coin register. This plays the role of a &quot;coin flip&quot; to determine the direction of the next step. We then return to step 2.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;The main difference between this and a random walk is that the different possible &quot;trajectories&quot; of the walker are being performed coherently in superposition, so that they can destructively interfere. This leads to a walker behaviour which is more like ballistic motion than diffusion. Indeed, an early presentation of a model such as this was made by Feynmann, as a way to simulate the Dirac equation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This model also often is described in terms of looking for or locating 'marked' elements in the graph, in which case one performs another step (to compute whether the node the walker is at is marked, and then to measure the outcome of that computation) before returning to Step&amp;nbsp;2. Other variations of this sort are reasonable.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To perform a quantum walk on a more general graph, one must replace the &quot;position&quot; register with one which can express all of the nodes of the graph, and the &quot;coin&quot; register with one which can express the edges incident to a vertex. The &quot;coin operator&quot; then must also be replaced with one which allows the walker to perform an interesting superposition of different trajectories. (What counts as 'interesting' depends on what your motivation is: physicists often consider ways in which changing the coin operator changes the evolution of the probability density, not for computational purposes but as a way of probing at basic physics using quantum walks as a reasonable toy model of particle movement.) A good framework for generalising quantum walks to more general graphs is the Szegedy formulation [&amp;thinsp;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0401053&quot; rel=&quot;nofollow noreferrer&quot; title=&quot;Spectra of Quantized Walks and a √(δε) rule. Mario Szegedy.&quot;&gt;arXiv:quant-ph/0401053&lt;/a&gt;&amp;thinsp;] of discrete-time quantum walks.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This model of computation is strictly speaking a special case of the unitary circuit model, but is motivated with very specific physical intuitions, which has led to some algorithmic insights (see e.g.&amp;nbsp;[&amp;thinsp;&lt;a href=&quot;https://arxiv.org/abs/1302.3143&quot; rel=&quot;nofollow noreferrer&quot; title=&quot;Quantum Walks and Electric Networks. Aleksandr&amp;#39;s Belovs.&quot;&gt;arXiv:1302.3143&lt;/a&gt;&amp;thinsp;]) for polynomial-time speedups in bounded-error quantum algorithms. This model is also a close relative of the continuous-time quantum walk as a model of computation. &lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="253" LastEditDate="2018-03-29T11:03:47.783" LastActivityDate="2018-03-29T11:03:47.783" CommentCount="2" />
  <row Id="1351" PostTypeId="2" ParentId="74" CreationDate="2018-03-26T15:59:37.053" Score="5" Body="&lt;h3&gt;Quantum circuits with intermediary measurements&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;This is a slight variation on &quot;unitary circuits&quot;, in which one allows measurements in the &lt;em&gt;middle&lt;/em&gt; of the algorithm as well as the end, and where one also allows future operations to depend on the outcomes of those measurements. It represents a realistic picture of a quantum processor which interacts with a classical control device, which among other things is the interface between the quantum processor and a human user.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Intermediary measurement is practically necessary to perform error correction, and so this is in principle a more realistic picture of quantum computation than the unitary circuit model. but it is not uncommon for theorists of a certain type to strongly prefer measurements to be left until the end (using the principle of deferred measurement to simulate any 'intermediary' measurements). So, this may be a significant distinction to make when &lt;em&gt;talking&lt;/em&gt; about quantum algorithms &amp;mdash; but this does not lead to a theoretical increase in the computational power of a quantum algorithm.&lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="253" LastEditDate="2018-03-29T11:02:50.717" LastActivityDate="2018-03-29T11:02:50.717" CommentCount="2" />
  <row Id="1352" PostTypeId="2" ParentId="1344" CreationDate="2018-03-26T16:37:02.747" Score="3" Body="&lt;p&gt;Although this might not answer your question completely, I think it might provide some direction of thinking. Here are two important facts:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Any unitary $2^{n}\times 2^{n}$ matrix $M$, can be realized on a quantum computer with $n$-quantum bits by a &lt;strong&gt;finite&lt;/strong&gt; sequence of controlled-not and single qubit gates&lt;sup&gt;1&lt;/sup&gt;. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Suppose $U$ is a unitary $2\times 2$ matrix satisfying $\text{tr } U \neq 0$, $\text{tr} (UX) \neq 0$, and $\text{det } U \neq 1$. Then &lt;strong&gt;six&lt;/strong&gt; elementary gates are necessary and sufficient to implement a controlled $U$-gate&lt;sup&gt;2&lt;/sup&gt;.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;It should be possible to extend the second case to the general $n\times n$ case, given the first point, although I haven't found any paper which does that explicitly.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;1 &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9503016&quot; rel=&quot;nofollow noreferrer&quot;&gt;Elementary gates for quantum computation-A. Barenco (Oxford), C. H. Bennett (IBM), R. Cleve (Calgary), D. P. DiVincenzo (IBM), N. Margolus (MIT), P. Shor (AT&amp;amp;T), T. Sleator (NYU), J. Smolin (UCLA), H. Weinfurter (Innsbruck)&#xA;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2 &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0207157&quot; rel=&quot;nofollow noreferrer&quot;&gt;Optimal Realizations of Controlled Unitary Gates - Guang Song, Andreas Klappenecker (Texas A&amp;amp;M University)&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-03-26T16:37:02.747" CommentCount="0" />
  <row Id="1353" PostTypeId="1" AcceptedAnswerId="1611" CreationDate="2018-03-26T16:41:12.750" Score="6" ViewCount="220" Body="&lt;p&gt;I'm wondering whether even if we cannot create a fast quantum computer, simulating quantum algorithms can be a reasonable method for classical algorithms.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In particular, I'd like to see any results of classical algorithms that have been sped up by using a quantum simulation as a subroutine. Second, the next logical step would be to 'cut out the middleman' and see if we can remove the simulator. Perhaps this can even be done semi-automatically!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, is there any result or research on this? Suggestions are welcome.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;To be clear, I'm asking whether there exists any problem such that running a simulation of a quantum computer, on a classical computer, can offer any improvement (time or memory) over (trying to) solve the same problem on a classical computer without running any sort of simulation of a quantum computer. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Second, I am wondering how one then would attempt to adapt this algorithm such that all 'useless' parts of the quantum algorithm and the simulation are removed, hopefully improving the method even further.&lt;/p&gt;&#xA;" OwnerUserId="253" LastEditorUserId="253" LastEditDate="2018-04-05T13:06:30.927" LastActivityDate="2018-04-05T14:00:28.597" Title="Can classical algorithms be improved by using quantum simulation as an intermediary step?" Tags="&lt;quantum-speedup&gt;&lt;quantum-algorithms&gt;&lt;performance&gt;&lt;classical-computing&gt;" AnswerCount="2" CommentCount="19" FavoriteCount="1" />
  <row Id="1354" PostTypeId="2" ParentId="1344" CreationDate="2018-03-26T19:20:56.803" Score="9" Body="&lt;p&gt;The question may not be entirely well-defined, in the sense that to ask for a way to compute $C(U)$ from a decomposition of $U$ you need to specify the set of gates that you are willing to use.&#xA;Indeed, it is a known result that any $n$-qubit gate can be exactly decomposed using $\text{CNOT}$ and single-qubit operations, so that a naive answer to the question would be: just decompose $C(U)$ using single-qubit and $\text{CNOT}$s.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A different interpretation of the question is the following: given $U$, can I compute $C(U)$ using a set of single-qubit operations and $\text{CNOT}$s &lt;em&gt;not on the control qubit&lt;/em&gt;, and $\text{CNOT}$s with the control being the first qubit?&#xA;This can be done generalising a result found in chapter four of &lt;a href=&quot;https://dl.acm.org/citation.cfm?id=1972505&quot; rel=&quot;noreferrer&quot;&gt;Nielsen &amp;amp; Chuang&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let $U$ be a single-qubit gate.&#xA;It can then be proved that $U$ can always be written as $U = e^{i\alpha} AXBXC$, where $X$ is the Pauli X gate, and $A, B$ and $C$ are single-qubit operations such that $ABC=I$ (see N&amp;amp;C for a proof).&#xA;It follows that&#xA;$$C(U)=\Phi_1(\alpha)A_2C(X)B_2C(X) C_2,$$&#xA;where $\Phi_1(\alpha)\equiv\begin{pmatrix}1&amp;amp;0\\0&amp;amp;e^{i\alpha}\end{pmatrix}\otimes I$ is a phase gate applied to the first qubit, and $A_2, B_2, C_2$ are $A, B, C$ applied to the second qubit.&#xA;This is immediate once you realise that, if that first qubit is $|0\rangle$, then $C(X)$ becomes an identity, and on the second qubit you have the operations $ABC$, which give the identity. On the other hand, if the first qubit is $|1\rangle$, then on the second rail you have $AXBXC$, which (together with the phase) equals $U$ by definition.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The above decomposition can be used to find a naive way to compute $C(U)$ for a general $n$-qubit unitary gate.&#xA;The main observation is that if $U=A_1 A_2\cdots A_m$ for any set of gates $\{A_1,..,A_m\}$, then&#xA;$$C(U)=C(A_1)C(A_2)\cdots C(A_m).$$&#xA;But we also know that any $n$-qubit $U$ can be decomposed in terms of CNOTs and single-qubit operations.&#xA;It follows that $C(U)$ is a sequence of CCNOT and $C(V)$ operations, where CCNOT is here an $X$ gate applied to some qubit conditioned to two other qubits being $|1\rangle$, and $V$ is a single-qubit operation on some qubit.&#xA;But again, any CCNOT operation (also called &lt;a href=&quot;https://en.wikipedia.org/wiki/Toffoli_gate&quot; rel=&quot;noreferrer&quot;&gt;Toffoli&lt;/a&gt;), can be decomposed as shown in Figure 4.9 in N&amp;amp;C, and the $C(V)$ are decomposed as shown in the first part of the answer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This method allows decomposing a general $n$-qubit unitary gate $U$ using only $\text{CNOT}$ and single-qubit gates.&#xA;You may then go further and generalise this to find a decomposition for the case of multiple control qubits.&#xA;For this you only now need a way to decompose the Toffoli gates, which is again found in Figure 4.9 of N&amp;amp;C.&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-03-26T19:34:03.297" LastActivityDate="2018-03-26T19:34:03.297" CommentCount="2" />
  <row Id="1355" PostTypeId="2" ParentId="1353" CreationDate="2018-03-27T01:42:02.197" Score="1" Body="&lt;p&gt;The question here seems to be: &quot;can a classical computer be more efficient by simulating a quantum computer?&quot; and &quot;what research has been done on this?&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I think it's important, first, to point out that no one is 100% sure that a quantum computer is even actually better than a classical computer, whether or not we have the fastest possible algorithms for a classical or quantum computer for really any particular problem, and so forth.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I found an &lt;a href=&quot;https://spectrum.ieee.org/tech-talk/computing/hardware/ibms-quantum-leap-simulates-56qubit-machine&quot; rel=&quot;nofollow noreferrer&quot;&gt;article&lt;/a&gt; from October 2017 that details an experiment IBM did simulating a 56 qubit quantum computer on a supercomputer. Here's what the study author said:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;For instance, whereas a perfect 56-qubit quantum computer can perform the experiments &quot;in 100 microseconds or less, we took two days, so a factor of a billion times slower&quot;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;(See &lt;a href=&quot;http://lanl.arxiv.org/pdf/1710.05867v1&quot; rel=&quot;nofollow noreferrer&quot;&gt;their paper on arXiv&lt;/a&gt; for more information.) I also found a paper submitted to arXiv in February of 2018 which simulates a 64 qubit quantum computer, building on the work of IBM. They also estimate a 72 qubit circuit could be simulated.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What seems to be prevalent in all of this, though, is that these simulations are for help in comparison to quantum computing results and times, and none of them claim to show quantum computing &quot;useless&quot; or &quot;replicable&quot;. So, my final answer would be &lt;strong&gt;no&lt;/strong&gt;, this is not a thing. &lt;/p&gt;&#xA;" OwnerUserId="91" LastActivityDate="2018-03-27T01:42:02.197" CommentCount="6" />
  <row Id="1356" PostTypeId="1" CreationDate="2018-03-27T17:09:15.597" Score="15" ViewCount="223" Body="&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_error_correction&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum error correction&lt;/a&gt; is a fundamental aspect of quantum computation, without which large-scale quantum computations are practically unfeasible.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One aspect of fault-tolerant quantum computing that is often mentioned is that each error-correction protocol has associated an &lt;em&gt;error rate threshold&lt;/em&gt;.&#xA;Basically, for a given computation to be protectable against errors via a given protocol, the error rate of the gates must be below a certain threshold.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In other words, if the error rates of single gates are not low enough, then it is not possible to apply error-correction protocols to make the computation more reliable.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Why is this? Why is it not possible to reduce error rates that are not already very low to begin with?&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-05-24T13:47:34.957" LastActivityDate="2018-05-26T04:26:46.040" Title="Why do error correction protocols only work when the error rates are already significantly low to begin with?" Tags="&lt;quantum-gate&gt;&lt;quantum-error-correction&gt;&lt;fault-tolerance&gt;" AnswerCount="5" CommentCount="2" FavoriteCount="2" />
  <row Id="1358" PostTypeId="2" ParentId="1356" CreationDate="2018-03-27T18:35:20.277" Score="2" Body="&lt;p&gt;To me there seem to be two parts of this question (one more related to the title, one more related to the question itself):  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;1) To which amount of noise are error correction codes effective?&lt;br&gt;&#xA; 2) With which amount of imperfection in gates can we implement fault-tolerant quantum computations?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let me firs stress the difference: quantum error correction codes can be used in many different scenarios, for example to correct for losses in transmissions. Here the amount of noise mostly depends on the length of the optical fibre and not on the imperfection of the gates. However if we want to implement fault-tolerant quantum computation, the gates are the main source of noise.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;On 1)&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Error correction works for large error rates (smaller than $1/2$). Take for example the simple 3 qubit repetition code. The logical error rate is just the probability for the majority vote to be wrong (the orange line is $f(p)=p$ for comparison):  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/PfHyd.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/PfHyd.png&quot; alt=&quot;plot physical vs logical error rate&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So whenever the physical error rate $p$ is below $1/2$, the logical error rate is smaller than $p$. Note however, that is particularly effective for small $p$, because the code changes the rate from $\mathcal{O}(p)$ to a $\mathcal{O}(p^2)$ behaviour.  &lt;/p&gt;&#xA;&#xA;&lt;h3&gt;On 2)&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;We want to perfrom arbitrarily long quantum computations with a quantum computer. However, the quantum gates are not perfect. In order to cope with the errors introduced by the gates, we use quantum error correction codes. This means that one logical qubit is encoded into many physical qubits. This redundancy allows to correct for a certain amount of errors on the physical qubits, such that the information stored in the logical qubit remains intact. &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9605011&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bigger codes allow for longer calculations to still be accurate&lt;/a&gt;. However, larger codes involve more gates (for example more syndrome measurements) and these gates introduce noise. You see there is some trade-off here, and which code is optimal is not obvious.&lt;br&gt;&#xA;If the noise introduced by each gate is below some threshold (the fault-tolerance or accuracy threshold), then it is possible to increase the code size to allow for arbitrarily long calculations. This threshold depends on the code we started with (usually it is iteratively concatenated with itself). There are several ways to estimate this value. Often it is done by numerical simulation: Introduce random errors and check whether the calculation still worked. This method typically gives threshold values which are too high. There are also some analytical proofs in the literature, for example &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0610063&quot; rel=&quot;nofollow noreferrer&quot;&gt;this one by Aliferis and Cross&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="104" LastEditorUserId="104" LastEditDate="2018-03-28T23:25:23.883" LastActivityDate="2018-03-28T23:25:23.883" CommentCount="5" />
  <row Id="1359" PostTypeId="1" AcceptedAnswerId="1361" CreationDate="2018-03-27T20:34:12.867" Score="23" ViewCount="418" Body="&lt;p&gt;The standard popular-news account of quantum computing is that a quantum computer (QC) would work by splitting into exponentially many noninteracting parallel copies of itself in different universes and having each one attempt to verify a different certificate, then at the end of the calculation, the single copy that found a valid certificate &quot;announces&quot; its solution and the other branches magically vanish.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;People who know anything about theoretical quantum computation know that this story is absolute nonsense, and that the rough idea described above more closely corresponds to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-deterministic_Turing_machine&quot; rel=&quot;noreferrer&quot;&gt;nondeterministic Turing machine&lt;/a&gt; (NTM) than to a quantum computer. Moreover, the compexity class of problems efficiently solvable by NTMs is &lt;strong&gt;NP&lt;/strong&gt; and by QCs is &lt;strong&gt;BQP&lt;/strong&gt;, and these classes are not believed to be equal.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;People trying to correct the popular presentation rightfully point out that the simplistic &quot;many-worlds&quot; narrative greatly overstates the power of QCs, which are not believed to be able to solve (say) &lt;strong&gt;NP&lt;/strong&gt;-complete problems. They focus on the misrepresentation of the measurement process: in quantum mechanics, which outcome you measure is determined by the Born rule, and in most situations the probability of measuring an incorrect answer completely swamps the probability of measuring the right one. (And in some cases, such as black-box search, we can &lt;em&gt;prove&lt;/em&gt; that no clever quantum circuit can beat the Born rule and deliver an exponential speedup.) If we &lt;em&gt;could&lt;/em&gt; magically &quot;decide what to measure&quot;, then we would be able to efficiently solve all problems in the complexity class &lt;strong&gt;PostBQP&lt;/strong&gt;, which is believed to be much large than &lt;strong&gt;BQP&lt;/strong&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But I've never seen anyone explicitly point out that there is &lt;em&gt;another&lt;/em&gt; way in which the popular characterization is wrong, which goes in the other direction. &lt;strong&gt;BQP&lt;/strong&gt; is believed to be not a strict subset of &lt;strong&gt;NP&lt;/strong&gt;, but instead incomparable to it. There exist problems like &lt;a href=&quot;https://www.scottaaronson.com/papers/bqpph.pdf&quot; rel=&quot;noreferrer&quot;&gt;Fourier checking&lt;/a&gt; which are believed to not only lie outside of &lt;strong&gt;NP&lt;/strong&gt;, but in fact outside of the entire polynomial hierarchy &lt;strong&gt;PH&lt;/strong&gt;. So with respect to problems like these, the popular narrative actually &lt;em&gt;under&lt;/em&gt;states rather than overstates the power of QCs.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My naive intuition is that if we &lt;em&gt;could&lt;/em&gt; &quot;choose what to measure&quot;, then the popular narrative would be more or less correct, which would imply that these super-quantum-computers would be able to efficiently solve exactly the class &lt;strong&gt;NP&lt;/strong&gt;. But we believe that this is wrong; in fact &lt;a href=&quot;https://www.scottaaronson.com/papers/pp.pdf&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;PostBQP=PP&lt;/strong&gt;&lt;/a&gt;, which we believe to be a strict superset of &lt;strong&gt;NP&lt;/strong&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is there any intuition for what's going on behind the scenes that allows a quantum computer to be (in some respects) more powerful than a nondeterministic Turing machine? Presumably this &quot;inherently quantum&quot; power, when combined with postselection (which &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-deterministic_Turing_machine#Resolution_of_multiple_rules&quot; rel=&quot;noreferrer&quot;&gt;in a sense&lt;/a&gt; NTMs already have) is what makes a super-QC so much more powerful than a NTM. (Note that I'm looking for some intuition that directly contrasts NTMs and QCs with postselection, without &quot;passing through&quot; the classical complexity class &lt;strong&gt;PP&lt;/strong&gt;.)&lt;/p&gt;&#xA;" OwnerUserId="551" LastEditorUserId="1847" LastEditDate="2018-04-27T16:51:08.520" LastActivityDate="2018-04-27T16:51:08.520" Title="Why is a quantum computer in some ways more powerful than a nondeterministic Turing machine?" Tags="&lt;quantum-speedup&gt;&lt;complexity-theory&gt;&lt;bqp&gt;" AnswerCount="2" CommentCount="9" FavoriteCount="1" />
  <row Id="1360" PostTypeId="1" AcceptedAnswerId="1382" CreationDate="2018-03-27T21:49:18.280" Score="3" ViewCount="72" Body="&lt;p&gt;There are different theoretical models for quantum computing like the circuit model or the model of adiabatic quantum computers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Between which of these models exist polynomial-time reductions?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that this question does not aim to cover physical implementations of quantum computers which are already discussed &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1255/how-should-different-quantum-computing-devices-be-compared&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="673" LastEditorUserId="104" LastEditDate="2018-03-28T12:25:17.290" LastActivityDate="2018-03-28T12:25:17.290" Title="Which theoretical models for quantum computing are polynomial-time equivalent?" Tags="&lt;quantum-computing-models&gt;" AnswerCount="1" CommentCount="5" ClosedDate="2018-04-02T08:55:43.670" />
  <row Id="1361" PostTypeId="2" ParentId="1359" CreationDate="2018-03-27T21:51:55.380" Score="10" Body="&lt;p&gt;From a pseudo-foundational standpoint, the reason why &lt;strong&gt;BQP&lt;/strong&gt; is a &lt;em&gt;differently powerful&lt;/em&gt; (to coin a phrase) class than &lt;strong&gt;NP&lt;/strong&gt;, is that quantum computers can be considered as making use of destructive interference.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Many different complexity classes can be described in terms of (more or less complicated properties of) the number of accepting branches of an NTM. Given an NTM in 'normal form', meaning that the set of computational branches are a complete binary tree  (or something similar to it) of some polynomial depth, we may consider classes of languages defined by making the following distinctions:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Is the number of accepting branches zero, or non-zero? (A characterisation of &lt;strong&gt;NP&lt;/strong&gt;.)&lt;/li&gt;&#xA;&lt;li&gt;Is the number of accepting branches less than the maximum, or exactly equal to the maximum? (A characterisation of &lt;strong&gt;coNP&lt;/strong&gt;.)&lt;/li&gt;&#xA;&lt;li&gt;Is the number of accepting branches at most one-third, or at least two-thirds, of the total? (A characterisation of &lt;strong&gt;BPP&lt;/strong&gt;.)&lt;/li&gt;&#xA;&lt;li&gt;Is the number of accepting branches less than one-half, or at least one-half, of the total? (A characterisation of &lt;strong&gt;PP&lt;/strong&gt;.)&lt;/li&gt;&#xA;&lt;li&gt;Is the number of accepting branches different from exactly half, or equal to exactly half, of the total? (A characterisation of a class called &lt;strong&gt;C&lt;sub&gt;=&lt;/sub&gt;P&lt;/strong&gt;.)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;These are called &lt;em&gt;counting classes&lt;/em&gt;, because in effect they are defined in terms of the count of accepting branches.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Interpreting the branches of an NTM as randomly generated, they are questions about the probability of acceptance (even if these properties are not efficiently testable with any statistical confidence). A different approach to describing complexity classes is to consider instead the &lt;em&gt;gap&lt;/em&gt; between the number of accepting branches and the number of rejecting branches of an NTM. If counting the cumulation of NTM computational branches corresponds to probabilities, one could suggest that canceling accepting branches against rejecting branches models the cancellation of computational 'paths' (as in sum-over-paths) in quantum computation &amp;mdash; that is, as modeling destructive interference.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The best known upper bounds for &lt;strong&gt;BQP&lt;/strong&gt;, namely &lt;strong&gt;AWPP&lt;/strong&gt; and &lt;strong&gt;PP&lt;/strong&gt;, are readily definable in terms of 'acceptance gaps' in this way. The class &lt;strong&gt;NP&lt;/strong&gt;, however, does not have such an obvious characterisation. Furthermore, many of the classes which one obtains from definitions in terms of acceptance gaps appear to be more powerful than &lt;strong&gt;NP&lt;/strong&gt;. One could take this to indicate that 'nondeterministic destructive interference' is a potentially more powerful computational resource than mere nondeterminism; so that even if quantum computers do not take full advantage of this computational resource, it may nevertheless resist easy containment in classes such as &lt;strong&gt;NP&lt;/strong&gt;.&lt;/p&gt;&#xA;" OwnerUserId="124" LastActivityDate="2018-03-27T21:51:55.380" CommentCount="5" />
  <row Id="1363" PostTypeId="2" ParentId="1359" CreationDate="2018-03-28T05:45:33.183" Score="-1" Body="&lt;p&gt;&lt;em&gt;This answer was 'migrated' from when this question was asked on &lt;a href=&quot;https://cs.stackexchange.com&quot;&gt;Computer Science&lt;/a&gt; (Author remains the same)&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Well, one main reason is that there aren't any quantum algorithms that solve NP-hard problems in polynomial time. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Another is that adiabetic quantum annealing (as in the Dwave) can only barely beat the classical quantum annealing.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Also, most researchers think P$\neq$NP. A lot believe P$=$BQP. However, P$\neq$PostBQP. Is PostBQP$\neq$NP now contradictionay? No. We only know that P$=$NP is a weaker statement than (not nessecarily implying more!) PostBQP$=$P! So, why all the fuss about a question harder than P vs. NP!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As for why to believe P$=$BQP, some believe any improvement will not be asymptotic or merely a constant, as in differing implementation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, there are some reasons to believe PostBQP$\neq$NP. But this is all speculation and likely remains speculation for a while. You can believe whatever you want, for now, at least.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;There exist problems like Fourier checking which are believed to not only lie outside of NP, but in fact outside of the entire polynomial hierarchy. So with respect to problems like these, the popular narrative actually understates rather than overstates the power of QCs.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;As for this, I haven't seen a result that states a quantum computer can solve this &lt;em&gt;efficiently&lt;/em&gt;! Also, that the machine can solve weird problems fast (simulating itself in $O(n)$, for example) isn't more surprising that a waterfall simulating itself in $O(n)$ (n being the number of simulation steps)&lt;/p&gt;&#xA;" OwnerUserId="253" LastActivityDate="2018-03-28T05:45:33.183" CommentCount="0" />
  <row Id="1364" PostTypeId="1" CreationDate="2018-03-28T05:59:41.467" Score="4" ViewCount="73" Body="&lt;p&gt;The main reason to start with Post Quantum Crypto (PQC) &lt;em&gt;right now&lt;/em&gt; is because creating strong crypto, good implementation and accepted standards takes very long. Right now, most PQC is in the 'crypto' stage or starting to enter 'implementation' stage.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I'm wondering whether, given recent advances in constructing quantum computers, the PQC initiative will be 'fast enough'.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In particular, I'd like to know if PQC resistant against breaking factoring is widely deployed in practice before...:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Government agencies can efficiently factor using Shor's algorithm&lt;/li&gt;&#xA;&lt;li&gt;Serious hackers and medium sized companies can factor using Shor.&lt;/li&gt;&#xA;&lt;li&gt;Script kiddies can run Shor's algorithm&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;To clarify, I am looking for literature or analyses based on history about deployment speed of cryptographical defenses and compare this with current analysis on the predicted power of quantum computers. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;For instance, when will a good lattice based cryptosystem have a 'mainstream' implementation? &lt;/p&gt;&#xA;" OwnerUserId="253" LastEditorUserId="253" LastEditDate="2018-03-28T09:41:58.860" LastActivityDate="2018-03-28T09:41:58.860" Title="Will post quantum crypto come soon enough?" Tags="&lt;cryptography&gt;&lt;post-quantum-crypto&gt;" AnswerCount="0" CommentCount="2" ClosedDate="2018-03-28T08:49:08.427" />
  <row Id="1365" PostTypeId="1" AcceptedAnswerId="1373" CreationDate="2018-03-28T06:05:23.490" Score="6" ViewCount="275" Body="&lt;p&gt;As per my limited understanding, a &lt;em&gt;pure&lt;/em&gt; state is the quantum state where we have &lt;strong&gt;exact information&lt;/strong&gt; about the quantum system. And the &lt;em&gt;mixed&lt;/em&gt; state is the &lt;strong&gt;combination of probabilities of the information&lt;/strong&gt; about the quantum state of the quantum system. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, it is mentioned that different distributions of &lt;em&gt;pure&lt;/em&gt; states can generate equivalent &lt;em&gt;mixed&lt;/em&gt; states. So how a &lt;strong&gt;combination of exact information&lt;/strong&gt; can result in the &lt;strong&gt;combination of probabilities&lt;/strong&gt;?&lt;/p&gt;&#xA;" OwnerUserId="769" LastEditorUserId="26" LastEditDate="2018-03-29T18:07:33.753" LastActivityDate="2018-03-29T18:07:33.753" Title="What's the difference between a pure and mixed quantum state?" Tags="&lt;qubit-state&gt;&lt;quantum-state&gt;" AnswerCount="3" CommentCount="4" />
  <row Id="1366" PostTypeId="1" AcceptedAnswerId="1370" CreationDate="2018-03-28T06:19:29.607" Score="11" ViewCount="331" Body="&lt;p&gt;We have been reading about Quantum Computers being developed and tested in labs.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And also, we have quantum simulator programs that use limited virtual qubits (&lt;em&gt;up to 30-40 qubits if cloud-based&lt;/em&gt;).&#xA;And we have also started learning new Quantum Computing languages like &lt;strong&gt;Q#&lt;/strong&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But do we really have actual commercial Quantum Computers ready with physical qubits?&lt;/p&gt;&#xA;" OwnerUserId="769" LastEditorUserId="609" LastEditDate="2018-03-28T06:29:13.460" LastActivityDate="2018-07-05T09:04:26.997" Title="Do real commercial Quantum Computers exist?" Tags="&lt;quantum-computer&gt;&lt;simulation&gt;&lt;q#&gt;" AnswerCount="4" CommentCount="3" FavoriteCount="1" />
  <row Id="1367" PostTypeId="1" AcceptedAnswerId="1372" CreationDate="2018-03-28T06:32:28.333" Score="33" ViewCount="821" Body="&lt;p&gt;I come from a non-physics background and I am very much interested in pursuing Quantum Computing - especially how to program them. Any guidance on how to get started will be very helpful.&lt;/p&gt;&#xA;" OwnerUserId="769" LastEditorUserId="1847" LastEditDate="2018-04-25T15:22:37.393" LastActivityDate="2018-04-25T15:22:37.393" Title="Programming quantum computers for non-physics majors" Tags="&lt;quantum-computer&gt;&lt;resource-request&gt;&lt;quantum-programming&gt;" AnswerCount="6" CommentCount="3" FavoriteCount="12" />
  <row Id="1368" PostTypeId="2" ParentId="1366" CreationDate="2018-03-28T06:33:19.677" Score="4" Body="&lt;p&gt;Ready for useful large scale applications? No.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However there do exist machines such as IBM's Quantum Experience with real physical qubits on a chip as well as Google announcing this month a new machine with 72 qubits. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;D-Wave likes to tag itself as the first commercially available quantum computer however determining if it is indeed quantum seems to have been left as an exercise to the user. The D-Wave is available for commercial applications for a hefty price if you'd like to purchase a machine.&lt;/p&gt;&#xA;" OwnerUserId="54" LastActivityDate="2018-03-28T06:33:19.677" CommentCount="1" />
  <row Id="1369" PostTypeId="2" ParentId="1366" CreationDate="2018-03-28T06:33:36.743" Score="-1" Body="&lt;p&gt;From an &lt;a href=&quot;https://techcrunch.com/2017/11/10/ibm-passes-major-milestone-with-20-and-50-qubit-quantum-computers-as-a-service/&quot; rel=&quot;nofollow noreferrer&quot;&gt;article&lt;/a&gt; I read a while ago, it seems like IBM has a 20-qbit quantum computing as a service (QCAAS as I'd like to call it).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;They officially call it IBM Q: &lt;a href=&quot;https://www.research.ibm.com/ibm-q/&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://www.research.ibm.com/ibm-q/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here's an excerpt from the linked article (Nov 10, 2017):&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;IBM makes 20 qubit quantum computing machine available as a cloud service&lt;/strong&gt;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;IBM has been offering quantum computing as a cloud service&#xA;  since last year when it came out with a 5 qubit version of the&#xA;  advanced computers.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Today, the company announced that it’s releasing&#xA;  20-qubit quantum computers, quite a leap in just 18 months.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="780" LastEditorUserId="780" LastEditDate="2018-03-29T01:50:12.767" LastActivityDate="2018-03-29T01:50:12.767" CommentCount="6" />
  <row Id="1370" PostTypeId="2" ParentId="1366" CreationDate="2018-03-28T06:34:10.983" Score="10" Body="&lt;p&gt;That depends on your definitions of &quot;commercial&quot; and of &quot;quantum computer&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The company &lt;a href=&quot;https://www.dwavesys.com/home&quot; rel=&quot;nofollow noreferrer&quot;&gt;D-Wave Systems&lt;/a&gt; has been offering what they call quantum computers commercially since 2011. Many things seem to point towards those being adiabatic quantum computers (though people disagree on this). That doesn't quite fit the kind of quantum computers that are becoming popular right now though. You can check &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/171/is-there-proof-that-the-d-wave-one-is-a-quantum-computer-and-is-effective&quot;&gt;this question&lt;/a&gt; and its answers for more information on that discussion.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Companies such as IBM in the other hand are offering access to circuit model quantum computers (with physical qubits). IBM specifically does this in the &lt;a href=&quot;https://www.research.ibm.com/ibm-q/&quot; rel=&quot;nofollow noreferrer&quot;&gt;IBM Q&lt;/a&gt; project via their website and a &lt;a href=&quot;https://github.com/QISKit/qiskit-sdk-py&quot; rel=&quot;nofollow noreferrer&quot;&gt;programming interface&lt;/a&gt;. They cooperate with commercial companies to explore possibilities in the quantum computing field. (A similar offer is available from Rigetti Computing via their &lt;a href=&quot;https://rigetti.com/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rigetti Forrest&lt;/a&gt; project.) That's not what most people would call &quot;commercial quantum computers&quot; though.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So the answer truly is: It depends.&lt;/p&gt;&#xA;" OwnerUserId="138" LastEditorUserId="138" LastEditDate="2018-07-05T09:04:26.997" LastActivityDate="2018-07-05T09:04:26.997" CommentCount="2" />
  <row Id="1372" PostTypeId="2" ParentId="1367" CreationDate="2018-03-28T06:49:06.140" Score="17" Body="&lt;p&gt;You could start with an introduction to quantum computers such as &lt;a href=&quot;https://youtu.be/Y8cU5-55wvc&quot; rel=&quot;noreferrer&quot;&gt;this one from Voxxed Days Vienna 2018&lt;/a&gt; - it's intended for people with a programming background but little to no prior knowledge in quantum mechanics. After that you can check out the guides in the &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/experience&quot; rel=&quot;noreferrer&quot;&gt;IBM Quantum Experience&lt;/a&gt; or those for the &lt;a href=&quot;https://www.microsoft.com/en-us/quantum/development-kit&quot; rel=&quot;noreferrer&quot;&gt;Microsoft Quantum Development Kit&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In addition to that, there are loads of videos on YouTube, for example, that can help you understand the topic more deeply.&lt;/p&gt;&#xA;" OwnerUserId="138" LastActivityDate="2018-03-28T06:49:06.140" CommentCount="0" />
  <row Id="1373" PostTypeId="2" ParentId="1365" CreationDate="2018-03-28T06:58:41.283" Score="5" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;A pure state is the quantum state where we have exact information about the quantum system. And the mixed state is the combination of probabilities of the information about the quantum state ... different distributions of pure states can generate equivalent mixed states. I did not understand how a combination of exact information can result in the combination of probabilities.&quot;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;On a Bloch sphere, pure states are represented by a point on the surface of the sphere, whereas mixed states are represented by an interior point. The completely mixed state of a single qubit ${{\frac {1}{2}}I_{2}\,}$ is represented by the center of the sphere, by symmetry. The purity of a state can be visualized as the degree in which it is close to the surface of the sphere.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In quantum mechanics, the state of a quantum system is represented by a state vector (or ket) $| \psi \rangle$. A quantum system with a state vector $| \psi \rangle$ is called a pure state. However, it is also possible for a system to be in a statistical ensemble of different state vectors: For example, there may be a 50% probability that the state vector is $| \psi_1 \rangle$ and a 50% chance that the state vector is $| \psi_2 \rangle$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This system would be in a mixed state. The &lt;a href=&quot;https://en.wikipedia.org/wiki/Density_matrix&quot; rel=&quot;nofollow noreferrer&quot;&gt;density matrix&lt;/a&gt; is especially useful for mixed states, because any state, pure or mixed, can be characterized by a single density matrix.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Density_matrix#Mathematical_description&quot; rel=&quot;nofollow noreferrer&quot;&gt;Mathematical description&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The state vector $|\psi \rangle$ of a pure state completely determines the statistical behavior of a measurement. For concreteness, take an observable quantity, and let A be the associated observable operator that has a representation on the Hilbert space ${\mathcal {H}}$ of the quantum system. For any real-valued, analytical function $F$ defined on the real numbers, suppose that $F(A)$ is the result of applying $F$ to the outcome of a measurement. The expectation value of $F(A)$ is&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\langle \psi | F(A) | \psi \rangle\, .$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now consider a mixed state prepared by statistically combining two different pure states $| \psi \rangle$ and $| \phi\rangle$, with the associated probabilities $p$ and $1 − p$, respectively. The associated probabilities mean that the preparation process for the quantum system ends in the state $|\psi \rangle$ with probability $p$ and in the state $|\phi\rangle$ with probability $1 − p$.&lt;/p&gt;&#xA;" OwnerUserId="278" LastEditorUserId="26" LastEditDate="2018-03-28T10:17:30.493" LastActivityDate="2018-03-28T10:17:30.493" CommentCount="0" />
  <row Id="1374" PostTypeId="1" AcceptedAnswerId="1381" CreationDate="2018-03-28T07:30:39.697" Score="6" ViewCount="127" Body="&lt;p&gt;I've stumbled myself upon &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_decoherence&quot; rel=&quot;noreferrer&quot;&gt;this article&lt;/a&gt; on Wikipedia, which says:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Decoherence can be viewed as the &lt;strong&gt;loss of information from a system into the environment&lt;/strong&gt; (often modeled as a heat bath), since every system is loosely coupled with the energetic state of its surroundings.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;em&gt;&amp;lt;...&gt;&lt;/em&gt;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Decoherence represents a challenge for the practical realization of quantum computers, since such machines are expected to rely heavily on the undisturbed evolution of quantum coherences. Simply put, they require that coherent states be preserved and that &lt;strong&gt;decoherence is managed&lt;/strong&gt;, in order to actually perform quantum computation.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;&lt;em&gt;(emphasis mine)&lt;/em&gt;&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So I am wondering how can this &lt;code&gt;loss of information&lt;/code&gt; be managed? Does this mean that it should be prevented completely, or is it necessary for quantum computing to actually allow some information loss in order to compute?&lt;/p&gt;&#xA;" OwnerUserId="609" LastActivityDate="2018-03-28T11:19:22.200" Title="How can quantum decoherence be managed?" Tags="&lt;quantum-information&gt;&lt;quantum-decoherence&gt;" AnswerCount="2" CommentCount="1" FavoriteCount="1" />
  <row Id="1375" PostTypeId="2" ParentId="1367" CreationDate="2018-03-28T07:33:46.463" Score="12" Body="&lt;p&gt;I think that quantum programmers won’t necessarily need to know about quantum physics and linear algebra. These are certainly things that will help broaden a quantum programmers knowledge, but they should not be regarded as prerequisites.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Even so, most resources to help a budding quantum programmer start with an assumption of linear algebra. The ones that don’t mostly focus on QISKit, the SDK for IBM’s quantum device (and some of them were written by me).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The simplest program you can come up with is a “Hello World”. How do you do that for quantum computers? My proposal is a &lt;a href=&quot;https://medium.com/qiskitters/making-a-quantum-computer-smile-cee86a6fc1de&quot; rel=&quot;noreferrer&quot;&gt;superposition of emoticons&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Once you’ve moved beyond “Hello World” in quantum programming, you’ll want to do something more complex. Often people make simple games. So let’s do that with a quantum computer. I made &lt;a href=&quot;https://medium.com/qiskitters/how-to-program-a-quantum-computer-982a9329ed02&quot; rel=&quot;noreferrer&quot;&gt;Battleships&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You will find these and many more examples of quantum programming at the &lt;a href=&quot;https://github.com/QISKit/qiskit-tutorial&quot; rel=&quot;noreferrer&quot;&gt;QISKit tutorial&lt;/a&gt;. I think that is probably the best place for new quantum programmers to see what can be done, and how to do it.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-03-28T09:36:03.610" LastActivityDate="2018-03-28T09:36:03.610" CommentCount="1" />
  <row Id="1376" PostTypeId="1" CreationDate="2018-03-28T08:15:48.983" Score="7" ViewCount="217" Body="&lt;p&gt;Reading &lt;a href=&quot;https://hackernoon.com/how-i-cornered-the-bitcoin-mining-market-using-a-quantum-computer-9e5dceba9f92&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt; entertaining piece of a QC enthusiast mining bitcoins with a Quantum Computer (although efficiently mining bitcoins with the current state of QCs is far-fetched, it is quite possible to be done in the next few years), I wonder how exactly will technologies already using Blockchain adapt to the change?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Are they currently being worked upon? &lt;strong&gt;How would post-quantum cryptography integrate with existing tech secured using today's cryptography algorithms?&lt;/strong&gt;&lt;/p&gt;&#xA;" OwnerUserId="747" LastEditorUserId="26" LastEditDate="2018-03-28T09:39:02.270" LastActivityDate="2018-03-28T15:35:52.467" Title="How would Blockchain technologies change to survive a post-quantum world?" Tags="&lt;cryptography&gt;&lt;post-quantum-crypto&gt;&lt;cryptocurrency&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="2" ClosedDate="2018-03-28T15:31:39.580" />
  <row Id="1377" PostTypeId="2" ParentId="1374" CreationDate="2018-03-28T08:19:01.273" Score="0" Body="&lt;p&gt;Yes, currently the loss of information is being managed by means of &lt;em&gt;quantum error correction&lt;/em&gt; protocols. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Ideally, &lt;em&gt;quantum decoherence&lt;/em&gt; and eventual loss of information &lt;em&gt;should be prevented&lt;/em&gt;. However, in real-world scenarios, it is hard to completely isolate quantum systems from their environment.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;s&gt;Technically, &lt;em&gt;quantum decoherence&lt;/em&gt; is something &lt;em&gt;necessary&lt;/em&gt; for the overall operation of the quantum computing system, in order to bring the quantum computing system to equilibrium state to initiate or perform another computing operation. Having said that loss of information due to quantum decoherence during an computing operation is not an ideal thing.&lt;/s&gt;&lt;/p&gt;&#xA;" OwnerUserId="812" LastEditorUserId="812" LastEditDate="2018-03-28T10:46:38.560" LastActivityDate="2018-03-28T10:46:38.560" CommentCount="4" />
  <row Id="1379" PostTypeId="2" ParentId="1365" CreationDate="2018-03-28T10:11:26.650" Score="1" Body="&lt;p&gt;&lt;strong&gt;Pure state:&lt;/strong&gt; Systems whose state is unequivocally defined by A state vector in other words, &lt;em&gt;single state vector&lt;/em&gt;. &lt;s&gt;And this has the complete information about the system.&lt;/s&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Mixed state:&lt;/strong&gt; System whose state cannot be defined unequivocally by &lt;em&gt;single state vector&lt;/em&gt;. It only has limited or no knowledge about the state of the system.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In reality, we often deal with ensemble of systems and we repeat the experiment. In such, cases it might be difficult to prepare the system exactly the same way to any particular initial state. Under such scenario, mixed state come in handy.  &lt;/p&gt;&#xA;" OwnerUserId="812" LastEditorUserId="812" LastEditDate="2018-03-28T16:33:05.323" LastActivityDate="2018-03-28T16:33:05.323" CommentCount="2" />
  <row Id="1380" PostTypeId="2" ParentId="1366" CreationDate="2018-03-28T10:46:11.190" Score="0" Body="&lt;p&gt;Commercially, no. But it is something that companies such as Intel have been working on. In-fact, Intel recently announced its new &lt;a href=&quot;https://www.youtube.com/watch?v=nE819PPCA5o&quot; rel=&quot;nofollow noreferrer&quot;&gt;49-qubit quantum chip &amp;amp; neuromorphic chip&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="872" LastActivityDate="2018-03-28T10:46:11.190" CommentCount="1" />
  <row Id="1381" PostTypeId="2" ParentId="1374" CreationDate="2018-03-28T11:19:22.200" Score="4" Body="&lt;p&gt;The quantum circuit model describes a quantum computer as a closed quantum system and assumes that there is a system which executes the circuit but is completely isolated from the rest of the universe. In the real world, however, there are no known mechanisms for truly isolating a quantum system from its environment. Real quantum systems are open quantum systems. Open quantum systems couple to their environment and destroy the quantum information in the system through &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_decoherence&quot; rel=&quot;nofollow noreferrer&quot;&gt;decoherence&lt;/a&gt;. When examining the simple evolution of a single quantum system this system-environment coupling appears to cause errors on the quantum system’s evolution (which wouldn't be &lt;em&gt;unitary&lt;/em&gt; in this case). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;A coin has two states, and makes a good bit but a poor qubit because it cannot remain in superposition of &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt; for very long as it is a classical object. A single nuclear spin can be a very good qubit, because superposition of being aligned with or against an external magnetic field can last for a long time, even days. But it can be difficult to build a quantum computer from nuclear spins because their coupling is so small that it is hard to measure the orientation of a single nuclei. The observation that the constraints are opposing in general: a quantum computer has to be well isolated in order to retain its quantum properties, but at the same time its qubits have to be accessible so that they can be manipulated to perform computation and read out the results. A realistic implementation must strike a balance between these constraints.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The first step towards solving the decoherence problem was taken in 1995 when&#xA;Shor and Steane independently discovered a quantum analogue of classical&#xA;error correcting codes. Shor discovered that by encoding quantum information,&#xA;this information could become more resistant to interaction with its environment. Following this discovery a rigorous theory of quantum error correction was developed. Many different &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_error_correction&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum error correcting codes&lt;/a&gt; were discovered and this further led to a theory of fault-tolerant quantum computation. Fully fault-tolerant quantum computation describes methods for dealing with system-environment coupling as well as dealing with faulty control of the quantum computer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Of particular significance was the discovery of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_threshold_theorem&quot; rel=&quot;nofollow noreferrer&quot;&gt;threshold theorem&lt;/a&gt; for fault-tolerant quantum computation. The threshold theorem states that if the decoherence interactions are of a certain form and are weaker than the controlling interactions by a certain ratio, quantum computation to any desired precision can be achieved. The threshold theorem for fault-tolerance thus declares a final solution to the question of whether there are theoretical limits to the construction of robust quantum computers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Reference: &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0305025&quot; rel=&quot;nofollow noreferrer&quot;&gt;Decoherence, Control, and Symmetry in Quantum Computers - D. Bacon&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-03-28T11:19:22.200" CommentCount="0" />
  <row Id="1382" PostTypeId="2" ParentId="1360" CreationDate="2018-03-28T11:36:25.067" Score="2" Body="&lt;p&gt;A non-exhaustive list of theoretical models of quantum computation are provided as answers to another question: &quot;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/74/what-are-the-methods-of-quantum-computation&quot;&gt;What are the methods of quantum computation?&lt;/a&gt;&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As to which models are polynomial-time equivalent &amp;mdash; the following is an incomplete list of models which are provably universal for polynomial-time quantum computation, assuming perfect control:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;The unitary circuit model is polynomial-time equivalent to adiabatic quantum computation [&lt;a href=&quot;http://arXiv.org/abs/quant-ph/0405098&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv:quant-ph/0405098&lt;/a&gt;];&lt;/li&gt;&#xA;&lt;li&gt;The unitary circuit model is polynomial-time equivalent to quantum circuits with intermediate measurements (by the principle of deferred measurement);&lt;/li&gt;&#xA;&lt;li&gt;The one-way measurement-based model is polynomial-time equivalent to unitary circuits.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="124" LastActivityDate="2018-03-28T11:36:25.067" CommentCount="0" />
  <row Id="1383" PostTypeId="1" AcceptedAnswerId="1406" CreationDate="2018-03-28T11:49:43.077" Score="16" ViewCount="435" Body="&lt;p&gt;One of the common claims about quantum computers is their ability to &quot;break&quot; conventional cryptography. This is because conventional cryptography is based on prime factors, something which is computationally expensive for conventional computers to calculate, but which is a supposedly trivial problem for a quantum computer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;What property of quantum computers makes them so capable of this task&lt;/strong&gt; where conventional computers fail and &lt;strong&gt;how are qubits applied to the problem of calculating prime factors?&lt;/strong&gt;&lt;/p&gt;&#xA;" OwnerUserId="842" LastEditorUserId="842" LastEditDate="2018-03-28T15:13:20.460" LastActivityDate="2018-04-05T14:04:52.387" Title="What makes quantum computers so good at computing prime factors?" Tags="&lt;quantum-computer&gt;&lt;qubit&gt;" AnswerCount="4" CommentCount="8" FavoriteCount="2" />
  <row Id="1385" PostTypeId="1" AcceptedAnswerId="1386" CreationDate="2018-03-28T12:22:51.887" Score="19" ViewCount="442" Body="&lt;p&gt;This &lt;a href=&quot;https://www.scottaaronson.com/blog/?p=208&quot; rel=&quot;noreferrer&quot;&gt;blogpost by Scott Aaronson&lt;/a&gt; is a very useful and simple explanation of &lt;a href=&quot;https://en.wikipedia.org/wiki/Shor%27s_algorithm&quot; rel=&quot;noreferrer&quot;&gt;Shor's algorithm&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I'm wondering if there is such an explanation for the second most famous quantum algorithm: &lt;a href=&quot;https://en.wikipedia.org/wiki/Grover%27s_algorithm&quot; rel=&quot;noreferrer&quot;&gt;Grover's algorithm&lt;/a&gt; to search an &lt;em&gt;unordered&lt;/em&gt; database of size $O(n)$ in $O(\sqrt{n})$ time. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In particular, I'd like to see some understandable intuition for the initially surprising result of the running time!&lt;/p&gt;&#xA;" OwnerUserId="253" LastEditorUserId="609" LastEditDate="2018-03-28T13:05:05.933" LastActivityDate="2018-07-13T08:53:19.913" Title="Is there a layman's explanation for why Grover's algorithm works?" Tags="&lt;quantum-algorithms&gt;&lt;complexity-theory&gt;&lt;grovers-algorithm&gt;" AnswerCount="3" CommentCount="0" FavoriteCount="6" />
  <row Id="1386" PostTypeId="2" ParentId="1385" CreationDate="2018-03-28T13:22:25.650" Score="15" Body="&lt;p&gt;There is a good explanation by Craig Gidney &lt;a href=&quot;http://twistedoakstudios.com/blog/Post2644_grovers-quantum-search-algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt; (he also has other great content, including a circuit simulator, on &lt;a href=&quot;http://algassert.com/&quot; rel=&quot;nofollow noreferrer&quot;&gt;his blog&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Essentially, Grover's algorithm applies when you have a function which returns &lt;code&gt;True&lt;/code&gt; for one of its possible inputs, and &lt;code&gt;False&lt;/code&gt; for all the others. The job of the algorithm is to find the one that returns &lt;code&gt;True&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To do this we express the inputs as bit strings, and encode these using the $|0\rangle$ and $|1\rangle$ states of a string of qubits. So the bit string &lt;code&gt;0011&lt;/code&gt; would be encoded in the four qubit state $|0011\rangle$, for example.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We also need to be able to implement the function using quantum gates Specifcially, we need to find a sequence of gates that will implement a unitary $U$ such that&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$U | a \rangle = - | a \rangle, \,\,\,\,\,\,\,\,\,\,\,\,\, U | b \rangle = -| b \rangle $&lt;/p&gt;&#xA;&#xA;&lt;p&gt;where $a$ is the bit string for which the function would return &lt;code&gt;True&lt;/code&gt; and $b$ is any for which it would return &lt;code&gt;False&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we start with a superposition of all possible bit strings, which is pretty easy to do by just Hadamarding everything, all inputs start off with the same amplitude of $\frac{1}{\sqrt{2^n}}$ (where $n$ is the length of the bit strings we are searching over, and therefore the number of qubits we are using). But if we then apply the oracle, the amplitude of the state we are looking for will change to $-\frac{1}{\sqrt{2^n}}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is not any easily observable difference, so we need to amplify it. To do this we use the &lt;em&gt;Grover Diffusion Operator&lt;/em&gt;, $D$. The effect of this operator is essentially to look at how each amplitude is different from the mean amplitude, and then invert this difference. So if a certain amplitude was a certain amount larger than the mean amplitude, it will become that same amount less than the mean, and vice-versa.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Specifically, if you have a superposition of bit strings $b_j$, the diffusion operator has the effect&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$D: \,\,\,\, \sum_j \alpha_j \, | b_j \rangle \,\,\,\,\,\, \rightarrow \,\,\,\,\,\, \sum_j (2\mu \, - \,  \alpha_j) \, | b_j \rangle$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;where $\mu = \sum_j \alpha_j$ is the mean amplitude. So any amplitude $\mu + \delta$ gets turned into $\mu - \delta$. To see why it has this effect, and how to implement it, see &lt;a href=&quot;https://people.eecs.berkeley.edu/~vazirani/f04quantum/notes/lec10/lec11.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;these lecture notes&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Most of the amplitudes will be a tiny bit larger than the mean (due to the effect of the single $-\frac{1}{\sqrt{2^n}}$), so they will become a tiny bit less than the mean through this operation. Not a big change.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The state we are looking for will be affected more strongly. Its amplitude is a lot less than the mean, and so will become a lot greater the mean after the diffusion operator is applied. The end effect of the diffusion operator is therefore to cause an interference effect on the states which skims an amplitude of $\frac{1}{\sqrt{2^n}}$ from all the wrong answers and adds it to the right one. By repeating this process, we can quickly get to the point where our solution stands out from the crowd so much that we can identify it.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Of course, this all goes to show that all the work is done by the diffusion operator. Searching is just an application that we can connect to it.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;See the answers to other questions for details on how the &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/175/how-is-the-oracle-in-grovers-search-algorithm-implemented&quot;&gt;functions&lt;/a&gt; and &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1613/how-does-the-grover-diffusion-operator-work-and-why-is-it-optimal&quot;&gt;diffusion operator&lt;/a&gt; are implemented.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-05-23T18:22:44.207" LastActivityDate="2018-05-23T18:22:44.207" CommentCount="6" />
  <row Id="1387" PostTypeId="2" ParentId="1367" CreationDate="2018-03-28T14:19:27.073" Score="3" Body="&lt;p&gt;It's not necessary to fully understand Quantum Mechanics to understand  the theory behind QC. I'm a math BSc/programmer and I read about the topic and also did the &lt;a href=&quot;https://www.edx.org/course/quantum-mechanics-quantum-computation-uc-berkeleyx-cs-191x&quot; rel=&quot;nofollow noreferrer&quot;&gt;old edX QC course&lt;/a&gt; (unfortunately it's not available, but there are others). I think I can say that I understand the gist of QC, but I know next to nothing about Quantum Mechanics.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The key part is that Quantum Computing uses mostly linear algebra, which is based on math that is commonly taught at engineering/computer science undergraduate studies. Contrast this to &lt;em&gt;real&lt;/em&gt; Quantum Mechanics that uses infinite-dimensional spaces (or functional analysis, if you'd like). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you feel comfortable with these undergraduate math topics you can check out Susskind's &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/0465062903&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Mechanics:Theoretical Minimum&lt;/a&gt; - it isn't actually about 'real' quantum mechanics, it's mostly stuff that is useful for QC. BTW the whole Theoretical Minimum book series is aimed at people who know some math (like computer scientists, or engineering majors), and would like to know more about physics. There are also lots of courses online, for example there are new courses on edX, but I didn't do any of them, so I can't recommend one.&lt;/p&gt;&#xA;" OwnerUserId="949" LastActivityDate="2018-03-28T14:19:27.073" CommentCount="1" />
  <row Id="1388" PostTypeId="2" ParentId="135" CreationDate="2018-03-28T14:31:35.300" Score="2" Body="&lt;p&gt;The complexity class of decision problems efficiently solvable on a classical computer is called &lt;strong&gt;BPP&lt;/strong&gt; (or &lt;strong&gt;P&lt;/strong&gt;, if you don't allow randomness, but these are suspected to be equal anyway). The class of problems efficiently solvable on a classical computer is called &lt;strong&gt;BQP&lt;/strong&gt;. If a problem exists for which a quantum computer provides an exponential speedup, then this would imply that &lt;strong&gt;BPP&lt;/strong&gt; $\neq$ &lt;strong&gt;BQP&lt;/strong&gt;. However, the &lt;strong&gt;BQP&lt;/strong&gt; versus &lt;strong&gt;BPP&lt;/strong&gt; question is a major open question in theoretical computer science, so no such problem has been proven to exist (and if you find one, you'll definitely win all kinds of awards).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;On the other hand, as the other answer mentions, there are black-box (&quot;oracle&quot;) problems relative to which we know that $\textbf{BPP}^O \neq \textbf{BQP}^O$, like &lt;a href=&quot;https://en.wikipedia.org/wiki/Simon&amp;#39;s_problem&quot; rel=&quot;nofollow noreferrer&quot;&gt;Simon's algorithm&lt;/a&gt;. This provides evidence, though not a proof, that &lt;strong&gt;BPP&lt;/strong&gt; $\neq$ &lt;strong&gt;BQP&lt;/strong&gt; in the real world.&lt;/p&gt;&#xA;" OwnerUserId="551" LastActivityDate="2018-03-28T14:31:35.300" CommentCount="1" />
  <row Id="1389" PostTypeId="2" ParentId="3" CreationDate="2018-03-28T14:40:16.780" Score="4" Body="&lt;p&gt;To follow up on Ella Rose's answer: most practical encryption schemes used today (e.g. Diffie-Hellman, RSA, elliptic curve, lattice-based) are centered around the difficulty of solving the &lt;a href=&quot;https://en.wikipedia.org/wiki/Hidden_subgroup_problem&quot; rel=&quot;nofollow noreferrer&quot;&gt;hidden subgroup problem&lt;/a&gt; (HSP). However, the first three are centered around the HSP for &lt;em&gt;abelian&lt;/em&gt; groups. The HSP for abelian groups can be efficiently solved by the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_Fourier_transform&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum Fourier transform&lt;/a&gt;, which is implemented e.g. by Shor's algorithm. They are therefore vulnerable to attack by a quantum computer. Most lattice-based methods, on the other hand, revolve around the HSP for &lt;em&gt;dihedral&lt;/em&gt; groups, which are nonabelian. Quantum computers are not believed to be able to efficiently solve the nonabelian HSP, so these algorithms should be able to implement post-quantum cryptography.&lt;/p&gt;&#xA;" OwnerUserId="551" LastEditorUserId="551" LastEditDate="2018-03-28T22:10:07.490" LastActivityDate="2018-03-28T22:10:07.490" CommentCount="0" />
  <row Id="1390" PostTypeId="1" AcceptedAnswerId="1395" CreationDate="2018-03-28T14:50:42.507" Score="8" ViewCount="383" Body="&lt;p&gt;In regular computers, bits may be physically represented using a wide variety of two-state devices, such as polarity of magnetization of a certain area of a ferromagnetic film or two levels of electric charge in a capacitor.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But qubits have a property that they can be in a superposition of both states at the same time. I've seen &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/1182/&quot;&gt;this question&lt;/a&gt;'s answers, which explain how can a qubit be represented, or modeled using a regular computer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So I want to know what can be used (and is used by companies like D-Wave) to represent a qubit in a real physical quantum computer?&lt;/p&gt;&#xA;" OwnerUserId="609" LastActivityDate="2018-04-08T14:20:05.467" Title="What is the physical representation of a qubit?" Tags="&lt;quantum-computer&gt;&lt;qubit&gt;&lt;architecture&gt;" AnswerCount="1" CommentCount="1" />
  <row Id="1391" PostTypeId="2" ParentId="1376" CreationDate="2018-03-28T15:10:13.583" Score="5" Body="&lt;p&gt;Bitcoin uses elliptic-curve cryptography to sign transactions, which can easily be broken by Shor's algorithm.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I didn't actually read the article because it looked kind of dumb, but I gathered that the author proposed using Grover's algorithm to speed up the mining process by looking for hashes more efficiently. If you had a functioning quantum computer, then I think it would be more efficient to forget about mining and instead just transfer people's bitcoins directly into your own account. A useful quantum computer would completely destroy the entire Bitcoin fundamental model.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I believe that other cryptocurrencies, like Cardano, are already designed to be secure against quantum attacks, to prevent this issue.&lt;/p&gt;&#xA;" OwnerUserId="551" LastEditorUserId="551" LastEditDate="2018-03-28T15:35:52.467" LastActivityDate="2018-03-28T15:35:52.467" CommentCount="5" />
  <row Id="1392" PostTypeId="2" ParentId="1383" CreationDate="2018-03-28T15:28:01.007" Score="1" Body="&lt;p&gt;First of all, factoring can be done on a quantum computer (with usage of 'unitary' quantum gates) by means of &lt;a href=&quot;https://en.wikipedia.org/wiki/Shor%27s_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;Shor's algorithm&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;An explanation that doesn't require advanced mathematics nor any advanced knowledge of physics is this &lt;a href=&quot;https://www.scottaaronson.com/blog/?p=208&quot; rel=&quot;nofollow noreferrer&quot;&gt;blog post by Scott Aaronson&lt;/a&gt;, titled &quot;Shor, I'll do it.&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A brief summary of his ideas is the following:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;First, we represent our quantum gates/qubits with clocks (using the 'complex numbers as arrows (i.e. elements of $\mathbb{R}^2$ with weird multiplication), representation') &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then, we note that a CS researcher has very irregular sleeping periods. To find this strange period, we use the clocks. Then, we note that this period finding can be used to factor integers (using a similar construction as in the randomized Pollard -$\rho$ algorithm)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Hence, our strange quantum clocks can help us factor efficiently!&lt;/p&gt;&#xA;" OwnerUserId="253" LastActivityDate="2018-03-28T15:28:01.007" CommentCount="0" />
  <row Id="1393" PostTypeId="5" CreationDate="2018-03-28T15:37:24.750" Score="0" Body="&lt;h2&gt;What is the goal of post quantum crypto?&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;In short, post quantum crypto is the research initiative to get new cryptographic primitives to replace all implementations for such primitives to are expected to be broken by attacks based on efficient quantum algorithms. First, we'd like to know what needs to be replaced.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Which methods are likely compromised?&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;At least all methods that are based on the hardness of &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Factoring (e.g. RSA); or&lt;/li&gt;&#xA;&lt;li&gt;Discrete logarithm (e.g. some forms of Diffie-Helmann); or&lt;/li&gt;&#xA;&lt;li&gt;Problems on Elliptic curves (elliptic curve cryptography).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;All problems above are expected to be hard for classical computers, but can be solved efficiently by a practical implementation of Shor's algorithm. Unfortunately, all these problems already cover most of the mainstream crypto.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Although Grover's algorithm for unordered search also has implications for security, the only change useful and nessecary is to double the bit size of the keys (i.e, we square the actual size of the key-space, as Grover can search a space of size $n$ in $O(\sqrt{n})$). As this has no further implications, this isn't the focus of post quantum crypto.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Which methods might survive the quantum age?&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Currently, among the methods that might be &quot;quantum-resistant&quot; are the following:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Hash-based methods (usually for signatures)&lt;/li&gt;&#xA;&lt;li&gt;Code-based methods: A very broad field based on results from coding theory. Has many different cryptographic applications&lt;/li&gt;&#xA;&lt;li&gt;Lattice-based methods: These again have broad applications and are based on problems on discrete lattices, such as lattice base reduction.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;See &lt;a href=&quot;https://pqcrypto.org/&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://pqcrypto.org/&lt;/a&gt; to learn more about the current state of post quantum crypto&lt;/p&gt;&#xA;" OwnerUserId="253" LastEditorUserId="253" LastEditDate="2018-04-05T14:07:08.947" LastActivityDate="2018-04-05T14:07:08.947" CommentCount="0" />
  <row Id="1394" PostTypeId="4" CreationDate="2018-03-28T15:37:24.750" Score="0" Body="For questions about encryption methods that are hard/impossible to crack even when using quantum computers. Be certain that your question concerns quantum computation as an essential component! Otherwise, it would be better to ask on either Cryptography or Information Security" OwnerUserId="11" LastEditorUserId="11" LastEditDate="2018-03-28T16:01:19.220" LastActivityDate="2018-03-28T16:01:19.220" CommentCount="0" />
  <row Id="1395" PostTypeId="2" ParentId="1390" CreationDate="2018-03-28T15:38:41.493" Score="10" Body="&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_computing#Developments&quot; rel=&quot;nofollow noreferrer&quot;&gt;This section&lt;/a&gt; on Wikipedia collects the most important ongoing attempts to physically implement qubits.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;For physically implementing a quantum computer, many different&#xA;  candidates are being pursued, among them (distinguished by the&#xA;  physical system used to realize the qubits):&lt;/p&gt;&#xA;  &#xA;  &lt;ul&gt;&#xA;  &lt;li&gt;&lt;p&gt;Superconducting quantum computing (qubit implemented by the state of small superconducting circuits (Josephson junctions))&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Trapped ion quantum computer (qubit implemented by the internal state of trapped ions)&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Optical lattices (qubit implemented by internal states of neutral atoms trapped in an optical lattice)&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Quantum dot computer, spin-based (e.g. the Loss-DiVincenzo quantum computer) (qubit given by the spin states of trapped electrons)&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Quantum dot computer, spatial-based (qubit given by electron position in double quantum dot)&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Nuclear magnetic resonance on molecules in solution (liquid-state NMR) (qubit provided by nuclear spins within the dissolved molecule)&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Solid-state NMR Kane quantum computers (qubit realized by the nuclear spin state of phosphorus donors in silicon)&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Electrons-on-helium quantum computers (qubit is the electron spin)&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Cavity quantum electrodynamics (CQED) (qubit provided by the internal state of  trapped atoms coupled to high-finesse cavities)&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Molecular magnet (qubit given by spin states)&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Fullerene-based ESR quantum computer (qubit based on the electronic spin of atoms or molecules encased in fullerenes)&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Linear optical quantum computer (qubits realized by processing states of different modes of light through linear elements e.g.&#xA;  mirrors, beam splitters and phase shifters)&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Diamond-based quantum computer (qubit realized by electronic or nuclear spin of nitrogen-vacancy centers in diamond)&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Bose–Einstein condensate-based quantum computer&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Transistor-based quantum computer – string quantum computers with entrainment of positive holes using an electrostatic trap&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Rare-earth-metal-ion-doped inorganic crystal based quantum computers (qubit realized by the internal electronic state of dopants in optical&#xA;  fibers)&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Metallic-like carbon nanospheres based quantum computers&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;/ul&gt;&#xA;  &#xA;  &lt;p&gt;The large number of candidates demonstrates that the topic, in spite&#xA;  of rapid progress, is still in its infancy. There is also a vast&#xA;  amount of flexibility.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-08T14:20:05.467" LastActivityDate="2018-04-08T14:20:05.467" CommentCount="2" />
  <row Id="1397" PostTypeId="2" ParentId="1383" CreationDate="2018-03-28T16:43:57.407" Score="-1" Body="&lt;p&gt;There are two main algorithms available for quantum computing, and they solve different problems. &lt;strong&gt;Grover's algorithm&lt;/strong&gt; is good at sorting phone books and other sort related math problems. (Traveling Salesman, Wedding Seat planner, NP-complete problems, etc.) &lt;strong&gt;Shor's algorithm&lt;/strong&gt; uses a different property of physics, and solves NP-incomplete problems such as factoring and discrete logarithms, which is the foundation of current public-private cryptography. Knowing these are two different problem sets that can be solved by two different kinds of hardware is important.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quantum Computing often discusses quantum state, entanglement and superposition, and other tricks to function. These things are necessary components to the engineering of quantum computers, but the core realization in my mind is understanding what is different between traditional silicon computing and quantum computing.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Silicon computing has only two instructions: addition and comparison of two numbers. Subtraction is performed by taking a two's complement, followed by addition. Quantum computing is fundamentally different, because &lt;strong&gt;physics itself solves the question loaded into the machine.&lt;/strong&gt; There are caveats: the entire question must be loaded into the machine, the question needs to be encoded, solved and read before heat interferes with the entanglement, the reading of the resulting quantum state is error prone and difficult, the answer could be randomly incorrect. Instead of addition and comparison, quantum computers uses physics to auto-magically solve the math question. I refer to it as the &quot;magic 8 ball&quot; of computing because it is random, error prone, and something of a black box for calculation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The actual math problem involved for factoring numbers and solving discrete logs is the &lt;strong&gt;&quot;Quantum Fourier Transform&quot;&lt;/strong&gt; one of &lt;a href=&quot;https://math.nist.gov/quantum/zoo/&quot; rel=&quot;nofollow noreferrer&quot;&gt;many quantum algorithms.&lt;/a&gt; &lt;/p&gt;&#xA;" OwnerUserId="1008" LastEditorUserId="1008" LastEditDate="2018-04-04T17:22:35.083" LastActivityDate="2018-04-04T17:22:35.083" CommentCount="11" />
  <row Id="1399" PostTypeId="5" CreationDate="2018-03-28T16:55:59.620" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-28T16:55:59.620" LastActivityDate="2018-03-28T16:55:59.620" CommentCount="0" />
  <row Id="1400" PostTypeId="4" CreationDate="2018-03-28T16:55:59.620" Score="0" Body="Use this tag to mark questions that involve a request for resources to learn about Quantum Computing or anything related to that." OwnerUserId="1005" LastEditorUserId="1005" LastEditDate="2018-03-28T18:21:06.100" LastActivityDate="2018-03-28T18:21:06.100" CommentCount="0" />
  <row Id="1402" PostTypeId="2" ParentId="1383" CreationDate="2018-03-28T18:41:39.327" Score="2" Body="&lt;p&gt;What makes quantum computers good at factoring large numbers is their ability to solve the period finding problem (and a mathematical fact that relates finding prime factors to period finding). That's basically Shor's algorithm in a nutshell. Yet it only begs the question what makes quantum computers good at period finding.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;At the core of period finding is the ability to calculate a function's value over its entire domain (that is, for every conceivable input). This is called quantum parallelism. This in itself is not good enough, but together with interference (the ability to combine results from quantum parallelism in a certain way), it is.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I suppose this answer might be a bit of a cliff hanger: How does one use these abilities to actually factor? Find the answer to that at &lt;a href=&quot;https://en.wikipedia.org/wiki/Shor%27s_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;wikipedia on Shor's algorithm&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastEditorUserId="1039" LastEditDate="2018-03-28T19:33:39.923" LastActivityDate="2018-03-28T19:33:39.923" CommentCount="0" />
  <row Id="1403" PostTypeId="2" ParentId="1385" CreationDate="2018-03-28T18:45:10.373" Score="1" Body="&lt;p&gt;The simple explanation for how (and hence why) Grover's algorithm works is that a quantum gate can only reshuffle (or otherwise distribute) probability amplitudes. Using an initial state with equal probability amplitudes for all states of the computational basis, one starts with an amplitude of $1/\sqrt{N}$. This much can be &quot;added&quot; to the desired (solution) state in each iteration, such that after $\sqrt{N}$ iterations one arrives at a probability amplitude of $1$ meaning the desired state has been distilled.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-03-28T18:45:10.373" CommentCount="1" />
  <row Id="1404" PostTypeId="1" AcceptedAnswerId="1407" CreationDate="2018-03-28T19:04:30.763" Score="9" ViewCount="437" Body="&lt;p&gt;Deep Learning (multiple layers of artificial neural networks used in supervised and unsupervised machine learning tasks) is an incredibly powerful tool for many of the most difficult machine learning tasks: image recognition, video recognition, speech recognition, etc.  Given that it is currently one of the most powerful machine learning algorithms, and Quantum Computing is generally regarded as a game changer for certain very difficult computation tasks, I'm wondering if there has been any movement on combining the two.  &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Could a deep learning algorithm run on a quantum computer?  &lt;/li&gt;&#xA;&lt;li&gt;Does it make sense to try?   &lt;/li&gt;&#xA;&lt;li&gt;Are there other quantum algorithms that would make deep learning irrelevant?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="1044" LastEditorUserId="55" LastEditDate="2018-03-29T18:36:46.643" LastActivityDate="2018-04-18T16:53:03.317" Title="Will deep learning neural networks run on quantum computers?" Tags="&lt;quantum-algorithms&gt;&lt;machine-learning&gt;&lt;neural-network&gt;&lt;deep-learning&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="1405" PostTypeId="2" ParentId="1367" CreationDate="2018-03-28T19:10:42.050" Score="2" Body="&lt;p&gt;Quantum computers are programmed by (evolving programming languages representing) so-called quantum circuits. These are a sequence of quantum gates plus the information on which quantum bits (qubits) they act.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The only thing you really need to know about quantum gates is that they represent rotations (in a higher dimensional space, so-called Hilbert space). Hence they are reversible: Quantum computers are programmed with reversible logic.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What do quantum gates rotate? It is the hyperspheres on whose surface qubit states live. Each state of the computational basis ($\left|00\right&amp;gt;$, $\left|01\right&amp;gt;$, $\left|10\right&amp;gt;$, $\left|11\right&amp;gt;$ for a 2-qubit system in the usual Dirac notation) gets a complex number as a coefficient or as a so-called probability amplitude. The basis vectors are orthogonal and span the state's Hilbert space, the probability amplitudes can be seen as coordinates in it. This is the picture in which quantum gates effect rotations. You will find that physicists often use a different picture, the Bloch sphere, for single qubit systems, in which quantum gates also cause rotations (but sometimes by a larger angle or by one that is omitted in that picture altogether).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;All conventional logic can be implemented by a quantum computer by first expressing it in reversible logic (which may require ancilla bits). The classical NOT gate corresponds to the X quantum gate, but unlike the classical case where the only 1-bit reversible gates are the identity and the NOT gate, a quantum computer has four corresponding gates (X, Y, Z according to rotations on the Bloch sphere, plus the identity). Further, you can have rotations that rotate only by a fraction of how far these gates rotate; a few particular interesting ones have special names and abbreviations such as the Hadamard gate or H gate that creates the equal superposition of all states.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Unfortunately, early quantum software engineers will probably have to know a bit about the quantum computer hardware they will be using: Due to the arbitrarily and continuously chooseable angle of a quantum gate's effective rotation, there is a sort-of analogue element to quantum computers that necessarily creates errors (and physical quantum computers have even more error sources than just that). There's a way to deal with it, quantum error correction that discretizes errors and corrects the most likely discretizations of them to achieve (ideally) arbitrarily complex computations with bound errors. But optimization will likely mean that one quantum computer with one choice of quantum error correction will be more apt at certain quantum gate or even algorithms than others, in ways that are a bit more subtle than just looking up a speed factor.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-03-28T19:10:42.050" CommentCount="0" />
  <row Id="1406" PostTypeId="2" ParentId="1383" CreationDate="2018-03-28T19:11:26.583" Score="9" Body="&lt;h2&gt;The short answer&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;$\newcommand{\modN}[1]{#1\,\operatorname{mod}\,N}\newcommand{\on}[1]{\operatorname{#1}}$Quantum Computers are able to run subroutines of an algorithm for factoring, exponentially faster than any known classical counterpart. This doesn't mean classical computers CAN'T do it fast too, we just don't know as of today a way for classical algorithms to run as efficient as quantum algorithms&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;The long answer&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Quantum Computers are good at Discrete Fourier Transforms.&#xA;There's a lot at play here that isn't captured by just &quot;&lt;em&gt;it's parallel&lt;/em&gt;&quot; or &quot;&lt;em&gt;it's quick&lt;/em&gt;&quot;, so let's get into the blood of the beast.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &lt;em&gt;factoring problem&lt;/em&gt; is the following: Given a number $N = pq$ where $p,q$ are primes, how do you recover $p$ and $q$? One approach is to note the following: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If I look at a number $\modN{x}$, then either $x$ shares a common factor with $N$, or it doesn't. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If $x$ shares a common factor, and isn't a multiple of $N$ itself, then we can easily ask for what the common factors of $x$ and $N$ are (through the Euclidean algorithm for greatest common factors). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now a not so obvious fact: the set of all $x$ that don't share a common factor with $N$ forms a multiplicative group $\on{mod} N$. What does that mean? You can look at the definition of a group in Wikipedia &lt;a href=&quot;https://en.wikipedia.org/wiki/Group_(mathematics)&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;. Let the group operation be multiplication to fill in the details, but all we really care about here is the following consequence of that theory which is: the sequence&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ \modN{x^0}, \quad\modN{x^1}, \quad\modN{x^2}, ... $$ &lt;/p&gt;&#xA;&#xA;&lt;p&gt;is periodic, when $x,N$ don't share common factors (try $x = 2$, $N = 5$) to see it first hand as:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\newcommand{\mod}[1]{#1\,\operatorname{mod}\,5}&#xA;\mod1 = 1,\quad&#xA;\mod4 = 4,\quad&#xA;\mod8 = 3,\quad&#xA;\mod{16} = 1.&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now how many natural numbers $x$ less than $N$ don't share any common factors with $N$? That is answered by &lt;a href=&quot;https://en.wikipedia.org/wiki/Euler%27s_totient_function&quot; rel=&quot;nofollow noreferrer&quot;&gt;Euler's totient function&lt;/a&gt;, it's $(p-1)(q-1)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Lastly, tapping on the subject of group theory, the length of the repeating chains &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ \modN{x^0}, \quad\modN{x^1}, \quad\modN{x^2}, ... $$ &lt;/p&gt;&#xA;&#xA;&lt;p&gt;divides that number $(p-1)(q-1)$. So if you know the period of sequences of powers of $x \mod N$ then you can start to put together a guess for what $(p-1)(q-1)$ is. Moreover, If you know what $(p-1)(q-1)$ is, and what $pq$ is (that's N don't forget!), then you have 2 equations with 2 unknowns, which can be solved through elementary algebra to separate $p,q$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Where do quantum computers come in? The period finding. There's an operation called a Fourier transform, which takes a function $g$ written as a sum of periodic functions $a_1 e_1 + a_2 e_2 ... $ where $a_i$ are numbers, $e_i$ are periodic functions with period $p_i$ and maps it to a new function $\hat{f}$ such that $ \hat{f}(p_i) = a_i$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Computing the &lt;a href=&quot;https://en.wikipedia.org/wiki/Fourier_transform&quot; rel=&quot;nofollow noreferrer&quot;&gt;Fourier transform&lt;/a&gt; is usually introduced as an integral, but when you want to just apply it to an array of data (the I&lt;sup&gt;th&lt;/sup&gt; element of the array is $f(I)$) you can use this tool called a &lt;a href=&quot;https://en.wikipedia.org/wiki/Discrete_Fourier_transform#The_unitary_DFT&quot; rel=&quot;nofollow noreferrer&quot;&gt;Discrete Fourier Transform&lt;/a&gt; which amounts to multiplying your &quot;array&quot; as if it were a vector, by a very big unitary matrix.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Emphasis on the word unitary: it's a really arbitrary property described &lt;a href=&quot;https://en.wikipedia.org/wiki/Unitary_matrix&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;. But the key takeaway is the following: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the world of physics, all operators obey the same general mathematical principle: &lt;a href=&quot;https://en.wikipedia.org/wiki/Unitarity_(physics)&quot; rel=&quot;nofollow noreferrer&quot;&gt;unitarity&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So that means it's not unreasonable to replicate that DFT matrix operation as a quantum operator. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now here is where it gets deep an $n$ Qubit Array can represent $2^n$ possible array elements (consult anywhere online for an explanation of that or drop a comment). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;And similarly an $n$ Qubit quantum operator can act on that entire $2^n$ quantum space, and produce an answer that we can interpret.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;See &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_Fourier_transform&quot; rel=&quot;nofollow noreferrer&quot;&gt;this Wikipedia article&lt;/a&gt; for more detail. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we can do this Fourier transform on an exponentially large data set, using only $n$ Qubits, then we can find the period very quickly.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we can find the period very quickly we can rapidly assemble an estimate for $(p-1)(q-1)$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we can do that fast then given our knowledge of $N=pq$ we can take a stab at checking $p,q$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;That's whats going on here, at a very high level.&lt;/p&gt;&#xA;" OwnerUserId="1034" LastEditorUserId="45" LastEditDate="2018-04-05T14:04:52.387" LastActivityDate="2018-04-05T14:04:52.387" CommentCount="5" />
  <row Id="1407" PostTypeId="2" ParentId="1404" CreationDate="2018-03-28T19:21:42.297" Score="6" Body="&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Yes, all classical algorithms can be run on quantum computers, moreover any classical algorithm involving searching can get a $\sqrt{\text{original time}}$ boost by the use of grovers algorithm. An example that comes to mind is treating the fine tuning of neural network parameters as a &quot;search for coefficients&quot; problem.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;For the fact there are clear computational gains in some processes: yes. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Not that I know of. But someone with more expertise can chime in here if they want. The one thing that comes to mind: often we may use Deep Learning and other forms of Artificial Intelligence to study problems of chemistry, and physics because simulation is expensive or impractical. In this domain, Quantum Computers will likely slaughter their classical ancestors given their ability to natively simulate quantum systems (like those in Nuclear Chemistry) in effectively real time or faster. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Last I spoke with him, Mario Szegedy was interested in precisely this, there are probably a lot of other researchers too working on it right now.&lt;/p&gt;&#xA;" OwnerUserId="1034" LastEditorUserId="1034" LastEditDate="2018-03-28T19:30:44.737" LastActivityDate="2018-03-28T19:30:44.737" CommentCount="5" />
  <row Id="1408" PostTypeId="2" ParentId="1356" CreationDate="2018-03-28T19:22:07.573" Score="2" Body="&lt;p&gt;You need a surprisingly large number of quantum gates to implement a quantum error correcting code in a fault-tolerant manner. One part of the reason is that there are many errors to detect since a code that can correct all single qubit errors already requires 5 qubits and each error can be of three kinds (corresponding to unintentional X, Y, Z gates). Hence to even just correct any single qubit error, you already need logic to distinguish between these 15 errors plus the no-error situation: $XIIII$, $YIIII$, $ZIIII$, $IXIII$, $IYIII$, $IZIII$, $IIXII$, $IIYII$, $IIZII$, $IIIXI$, $IIIYI$, $IIIZI$, $IIIIX$, $IIIIY$, $IIIIZ$, $IIIII$ where $X$, $Y$, $Z$ are the possible single qubit errors and $I$ (identity) denotes the no-error-for-this-qubit situation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The main part of the reason is, however, that you cannot use straight-forward error detection circuitry: Every CNOT (or every other nontrivial 2 or more qubit gate) forwards errors in one qubit to another qubit which would be disastrous for the most trivial case of a single qubit error correcting code and still very bad for more sophisticated codes. Hence a fault-tolerant (useful) implementation of needs even more effort than one might naively think.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;With many gates per error correcting step, you can only permit a very low error rate per step. Here yet another problem arises: Since you may have coherent errors, you must be ready for the worst case that an error $\epsilon$ propagates not as $N \epsilon$ after N single qubit gates but as $N^2 \epsilon$. This value must remain sufficiently low such that you overall gain after correcting some (but not all) errors, for example single qubit errors only.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;An example for a coherent error is an implementation of a gate $G$ that does, to first order, not simply $G$ but $G + \sqrt{\epsilon} X$ which you might call an error of $\epsilon$ because that is the probability corresponding to the probability amplitude $\sqrt{\epsilon}$ and hence the probability that a measurement directly after the gate reveals that it acted as the error $X$. After $N$ applications of this gate, again to first order, you have actually applied $G^N + N \sqrt{\epsilon} G^N X$ (if G and X commute, otherwise a more complicated construct that has $N$ distinct terms proportional to $\sqrt{\epsilon}$). Hence you would, if measuring then, find an error probability of $N^2 \epsilon$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Incoherent errors are more benign. Yet if one must give a single value as an error threshold, then one cannot choose to only assume benign errors!&lt;/p&gt;&#xA;" OwnerUserId="1039" LastEditorUserId="1039" LastEditDate="2018-03-29T09:16:53.693" LastActivityDate="2018-03-29T09:16:53.693" CommentCount="3" />
  <row Id="1409" PostTypeId="2" ParentId="1341" CreationDate="2018-03-28T19:28:00.683" Score="0" Body="&lt;p&gt;By saying that a quantum computer using $n$ qubits does (up to) $2^n$ computations in parallel, one tries to explain quantum parallelism: If you represent the state of the $n$ qubits using probability amplitudes for each state in the computational basis, there are $2^n$ such probability amplitudes that a classical computer would have to update per quantum gate it is to simulate, whilst a quantum computer does this automatically (but with potentially less benefit since not all these numbers can be independently measured).&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-03-28T19:28:00.683" CommentCount="0" />
  <row Id="1410" PostTypeId="1" AcceptedAnswerId="1418" CreationDate="2018-03-28T19:32:31.093" Score="3" ViewCount="259" Body="&lt;p&gt;What is the computational basis of a quantum computer or for a quantum algorithm? Is it special?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note: I think this question is well-formed and complete, but apparently it lacks length in the view of automatic quality assurance.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-03-29T03:35:47.207" Title="What is the Computational Basis?" Tags="&lt;qubit-state&gt;" AnswerCount="4" CommentCount="2" />
  <row Id="1411" PostTypeId="2" ParentId="1410" CreationDate="2018-03-28T19:32:31.093" Score="0" Body="&lt;p&gt;A quantum state is a vector in a high-dimensional vector space (the Hilbert space). There is one basis that comes natural to any quantum algorithm (or quantum computer) that is based on qubits: The states that correspond to the binary numbers are special, they are the so-called computational basis states.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-03-28T19:32:31.093" CommentCount="0" />
  <row Id="1412" PostTypeId="2" ParentId="136" CreationDate="2018-03-28T19:38:37.110" Score="1" Body="&lt;p&gt;Measurements are unitary operations, too, you just don't see it: A measurement is equivalent to some complicated (quantum) operation that acts not just on the system but also on its environment. If one were to model everything as a quantum system (including the environment), one would have unitary operations all the way.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, usually there is little point in this because we usually don't know the exact action on the environment and typically don't care. If we consider only the system, then the result is the well-known collapse of the wave function, which is indeed a non-unitary operation.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-03-28T19:38:37.110" CommentCount="0" />
  <row Id="1413" PostTypeId="1" AcceptedAnswerId="1431" CreationDate="2018-03-28T19:39:49.517" Score="4" ViewCount="147" Body="&lt;p&gt;I would like to play with a quantum circuit &lt;code&gt;local_qasm_simulator&lt;/code&gt; in QISKit, but I do not want to implement a separate quantum circuit that would prepare an initial state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The way I do it now is by falling back to NumPy. Specifically, first, I extract matrix &lt;code&gt;u&lt;/code&gt; from a quantum program &lt;code&gt;qp&lt;/code&gt;:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cname = 'circuit name'&#xA;results = qp.execute(cname, backend='local_unitary_simulator', shots=1)&#xA;data = results.get_data(cname)&#xA;u = data['unitary']&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Then, I explicitly create the state I need (e.g., $|\psi\rangle = \frac{1}{2}(|00\rangle + |01\rangle + |10\rangle - |11\rangle)$):&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;num_qubits = 2&#xA;psi = np.ones(2**num_qubits) / 2.0&#xA;psi[3] = -psi[3]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Finally, I apply &lt;code&gt;u&lt;/code&gt; to &lt;code&gt;psi&lt;/code&gt; with NumPy:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;u @ psi&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;The advantage of this approach is that I can explicitly obtain the state $U |\psi\rangle$. However, I cannot use &lt;code&gt;local_qasm_simulator&lt;/code&gt; and the &lt;code&gt;measure()&lt;/code&gt; function.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, how could I prepare an arbitrary state, and supply it to a circuit, and run a &lt;code&gt;local_qasm_simulator&lt;/code&gt;?&lt;/p&gt;&#xA;" OwnerUserId="528" LastActivityDate="2018-03-29T08:03:10.940" Title="How to create an arbitrary state in QISKit for a local_qasm_simulator?" Tags="&lt;qiskit&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="2" />
  <row Id="1414" PostTypeId="2" ParentId="1365" CreationDate="2018-03-28T19:46:50.480" Score="3" Body="&lt;p&gt;A pure state is what one would naturally call a state of a system. Now imagine you have a qubit in a certain state, say the equal superposition of both its computational basis states, which is $\frac{\sqrt{2}}{2} \left( \left|0\right&amp;gt; + \left|1\right&amp;gt; \right)$. Then measure it in the computational basis. What state do you get as a result?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you read the measurement result, you know which state you have. But if you discard that result, then you don't know which state the system is in (either it is in $\left|0\right&amp;gt;$ or in $\left|1\right&amp;gt;$). This is different from the superposition you had before (which was a pure state): It is a mixed state.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-03-28T19:46:50.480" CommentCount="0" />
  <row Id="1415" PostTypeId="2" ParentId="1356" CreationDate="2018-03-28T19:57:29.923" Score="4" Body="&lt;p&gt;We want to compare an output state with some ideal state, so normally, fidelity, $F\left(\left|\psi\right&amp;gt;, \rho\right)$ is used as this is a good way to tell how well the possible measurement outcomes of $\rho$ compare with the possible measurement outcomes of $\left|\psi\right&amp;gt;$, where $\left|\psi\right&amp;gt;$ is the ideal output state and $\rho$ is the achieved (potentially mixed) state after some noise process. As we're comparing states, this is $$F\left(\left|\psi\right&amp;gt;, \rho\right) = \sqrt{\left&amp;lt;\psi\right|\rho\left|\psi\right&amp;gt;}.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Describing both the noise and error correction processes using Kraus operators, where $\mathcal N$ is the noise channel with Kraus operators $N_i$ and $\mathcal E$ is the error correction channel with Kraus operators $E_j$, the state after noise is $$\rho' = \mathcal N\left(\left|\psi\rangle\langle\psi\right|\right) = \sum_iN_i\left|\psi\rangle\langle\psi\right|N_i^\dagger$$ and the state after both noise and error correction is $$\rho = \mathcal E\circ\mathcal N\left(\left|\psi\rangle\langle\psi\right|\right) = \sum_{i, j}E_jN_i\left|\psi\rangle\langle\psi\right|N_i^\dagger E_j^\dagger.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The fidelity of this is given by \begin{align}F\left(\left|\psi\right&amp;gt;, \rho\right) &amp;amp;= \sqrt{\left&amp;lt;\psi\right|\rho\left|\psi\right&amp;gt;} \\ &amp;amp;= \sqrt{\sum_{i, j}\left&amp;lt;\psi\right|E_jN_i\left|\psi\rangle\langle\psi\right|N_i^\dagger E_j^\dagger\left|\psi\right&amp;gt;} \\&amp;amp;= \sqrt{\sum_{i, j}\left&amp;lt;\psi\right|E_jN_i\left|\psi\rangle\langle\psi\right|E_jN_i\left|\psi\right&amp;gt;^*} \\ &amp;amp;= \sqrt{\sum_{i, j}\lvert\left&amp;lt;\psi\right|E_jN_i\left|\psi\right\rangle\rvert^2}.\end{align}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For the error correction protocol to be of any use, we want the fidelity after error correction to be larger than the fidelity after noise, but before error correction, so that the error corrected state is less distinguishable from the non-corrected state. That is, we want $$F\left(\left|\psi\right&amp;gt;, \rho\right) &amp;gt; F\left(\left|\psi\right&amp;gt;, \rho'\right).$$ This gives $$\sqrt{\sum_{i, j}\lvert\left&amp;lt;\psi\right|E_jN_i\left|\psi\right\rangle\rvert^2} &amp;gt; \sqrt{\sum_i\lvert\left&amp;lt;\psi\right|N_i\left|\psi\right\rangle\rvert^2}.$$ As fidelity is positive, this can be rewritten as $$\sum_{i, j}\lvert\left&amp;lt;\psi\right|E_jN_i\left|\psi\right\rangle\rvert^2 &amp;gt; \sum_i\lvert\left&amp;lt;\psi\right|N_i\left|\psi\right\rangle\rvert^2.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Splitting $\mathcal N$ into the correctable part,$\mathcal N_c$ , for which $\mathcal E\circ\mathcal N_c\left(\left|\psi\rangle\langle\psi\right|\right) = \left|\psi\rangle\langle\psi\right|$ and the non-correctable part, $\mathcal N_{nc}$, for which $\mathcal E\circ\mathcal N_{nc}\left(\left|\psi\rangle\langle\psi\right|\right) = \sigma$. Denoting the probability of the error being correctable as $\mathbb P_c$ and non-correctable (i.e. too many errors have occurred to reconstruct the ideal state) as $\mathbb P_{nc}$ gives $$\sum_{i, j}\lvert\left&amp;lt;\psi\right|E_jN_i\left|\psi\right\rangle\rvert^2 = \mathbb P_c + \mathbb P_{nc}\left&amp;lt;\psi\vert\sigma\vert\psi\right&amp;gt; \geq \mathbb P_c,$$ where equality will be assumed by assuming $\left&amp;lt;\psi\vert\sigma\vert\psi\right&amp;gt; = 0$. That is a false 'correction' will project onto an orthogonal outcome to the correct one.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For $n$ qubits, with an (equal) probability of error on each qubit as $p$ (&lt;strong&gt;note&lt;/strong&gt;: this is &lt;em&gt;not&lt;/em&gt; the same as the noise parameter, which would have to be used to calculate the probability of an error), the probability of having a correctable error (assuming that the $n$ qubits have been used to encode $k$ qubits, allowing for errors on up to $t$ qubits, determined by the Singleton bound $n-k\geq 4t$) is \begin{align} \mathbb P_c &amp;amp;=\sum_j^t {n\choose j}p^j\left(1-p\right)^{n-j}\\ &amp;amp;= \left(1-p\right)^n + np\left(1-p\right)^{n-1} + \frac 12n\left(n-1\right)p^2\left(1-p\right)^{n-2} + \mathcal O\left(p^3\right) \\ &amp;amp;= 1 - {n\choose{t+1}}p^{t+1} +  \mathcal O\left(p^{t + 2}\right)\end{align}.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Noise channels can also be written as $N_i = \sum_j\alpha_{i, j}P_j$ for a basis $P_j$, which can be used to define a &lt;em&gt;process matrix&lt;/em&gt; $\chi_{j, k} = \sum_i\alpha_{i, j}\alpha^*_{i, k}$. This gives $$\sum_i\lvert\left&amp;lt;\psi\right|N_i\left|\psi\right\rangle\rvert^2 = \sum_{j, k}\chi_{j, k}\left&amp;lt;\psi\right|P_j\left|\psi\right\rangle\left&amp;lt;\psi\right|P_k\left|\psi\right\rangle\geq\chi_{0, ,0},$$ where $\chi_{0, 0} = \left(1-p\right)^n$ is the probability of &lt;em&gt;no&lt;/em&gt; error occurring.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This gives that the error correction has been successfully in mitigating (at least some of) the noise when $$1 - {n\choose{t+1}}p^{t+1} \gtrapprox\left(1-p\right)^n.$$ While this is only valid for $\rho \ll 1$ and as a weaker bound has been used, potentially giving inaccurate results of when the error correction has been successful, this displays that error correction is good for small error probabilities as $p$ grows faster than $p^{t+1}$ when $p$ is small.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, as $p$ gets slightly larger, $p^{t+1}$ grows faster than $p$ and, depending on prefactors, which depends on the size of the code and number of qubits to correct, will cause the error correction to &lt;em&gt;incorrectly&lt;/em&gt; 'correct' the errors that have occurred and it starts failing as an error correction code. In the case of $n=5$, giving $t=1$, this happens at $p\approx 0.29$, although this is very much just an estimate.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Edit from comments:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As $\mathbb P_c + \mathbb P_{nc} = 1$, this gives $$\sum_{i, j}\lvert\left&amp;lt;\psi\right|E_jN_i\left|\psi\right\rangle\rvert^2 = \left&amp;lt;\psi\vert\sigma\vert\psi\right&amp;gt; + \mathbb P_c\left(1-\left&amp;lt;\psi\vert\sigma\vert\psi\right&amp;gt;\right).$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Plugging this in as above further gives $$1-\left(1-\left&amp;lt;\psi\vert\sigma\vert\psi\right&amp;gt;\right){n\choose{t+1}}p^{t+1} \gtrapprox\left(1-p\right)^n,$$ which is the same behaviour as before, only with a different constant.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This also shows that, although error correction can increase the fidelity, it can't increase the fidelity to $1$, especially as there will be errors (e.g. gate errors from not being able to perfectly implement any gate in reality) arising from implementing the error correction. As any reasonably deep circuit requires, by definition, a reasonable number of gates, the fidelity after each gate is going to be less than the fidelity of the previous gate (on average) and the error correction protocol is going to be less effective. There will then be a cut-off number of gates at which point the error correction protocol will &lt;em&gt;decrease&lt;/em&gt; the fidelity and the errors will continually compound.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This shows, to a rough approximation, that error correction, or merely reducing the error rates, &lt;strong&gt;is not enough for fault tolerant computation&lt;/strong&gt;, unless errors are extremely low, depending on the circuit depth.&lt;/p&gt;&#xA;" OwnerUserId="23" LastEditorUserId="23" LastEditDate="2018-03-31T19:27:38.967" LastActivityDate="2018-03-31T19:27:38.967" CommentCount="4" />
  <row Id="1416" PostTypeId="1" AcceptedAnswerId="1421" CreationDate="2018-03-28T20:12:03.880" Score="8" ViewCount="146" Body="&lt;p&gt;On the Wikipedia page for Shor's algorithm, it is stated that Shor's algorithm is not currently feasible to use to factor RSA-sized numbers, because a quantum computer has not been built with enough qubits due to things such as quantum noise. How do modern quantum computers prevent interference with computations from this noise? Can they prevent it at all?&lt;/p&gt;&#xA;" OwnerUserId="983" LastEditorUserId="26" LastEditDate="2018-03-28T20:26:54.413" LastActivityDate="2018-03-29T08:37:04.787" Title="How do quantum computers prevent &quot;quantum noise&quot;?" Tags="&lt;quantum-computer&gt;&lt;quantum-algorithms&gt;&lt;noise&gt;&lt;shors-algorithm&gt;" AnswerCount="2" CommentCount="1" />
  <row Id="1417" PostTypeId="2" ParentId="1416" CreationDate="2018-03-28T20:50:17.257" Score="7" Body="&lt;p&gt;The answer to noise (and any source of error, really) in quantum computations is &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_error_correction&quot; rel=&quot;noreferrer&quot;&gt;quantum error correction&lt;/a&gt;: You choose an encoding such that discretized errors correspond not only to invalid encodings but also uniquely determine what kind of error must have occured. This is not possible for all errors but with reasonable error models (such as single qubit errors are much more likely than two qubit errors which are much more likely than three qubit errors, etc.) it can be shown that, if your noise and other error sources are below a certain threshold, you can enable arbitrarily large and long computations.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-03-28T20:50:17.257" CommentCount="0" />
  <row Id="1418" PostTypeId="2" ParentId="1410" CreationDate="2018-03-28T21:12:32.017" Score="3" Body="&lt;p&gt;When we have just one qubit, there's nothing particularly special about the computational basis; it's just nice to have a canonical basis. In practice you could think that first you implement a gate $Z$ with $Z^2 = I$ and $Z\neq I$, and then you say that the computational basis is the eigenbasis of this gate.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, when we talk about multi-qubit systems, the computational basis &lt;em&gt;is&lt;/em&gt; meaningful. It comes from picking a basis for each qubit, and then taking the basis which is the tensor product of all these bases. Picking the same basis for each qubit is nice just to keep everything uniform, and calling them $0$ and $1$ is a nice notational choice. What's really important is that our basis states are product states across our qubits: the computational basis states can be prepared by initializing our qubits separately and then bringing them together. This isn't true for arbitrary states! For example, the cat state $\frac1{\sqrt2}\left(|0^n\rangle + |1^n\rangle\right)$ requires a log-depth circuit in order to prepare it from a product state.&lt;/p&gt;&#xA;" OwnerUserId="483" LastActivityDate="2018-03-28T21:12:32.017" CommentCount="0" />
  <row Id="1419" PostTypeId="1" AcceptedAnswerId="1430" CreationDate="2018-03-28T21:19:07.080" Score="5" ViewCount="200" Body="&lt;p&gt;Grover's algorithm is often described as a way to &lt;em&gt;search a database&lt;/em&gt; in $O(\sqrt{N})$ time. For using it we need an oracle gate that represents some function $f$ such that $f^{-1}(1)$ is the answer. But how do you actually make such a “&lt;em&gt;database oracle&lt;/em&gt;”?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Suppose I have an array of numbers $a$ that contains $w$ exactly once and I need to find $w$'s index. On a classical computer, I would load the array into memory and iterate through it until I find $w$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, if $a = [3, 2, 0, 1, 2, 3]$ and $w = 0$, I expect to get 2 as the answer (or 3 in 1-indexing).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;How do I represent this array in a quantum computer and make a gate that returns $a_x$ for some $x$? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In particular, do you need to have the entirety of the “database” within quantum memory (assuming there are some ways to access classical registers from quantum gates)?&lt;/p&gt;&#xA;" OwnerUserId="580" LastEditorUserId="55" LastEditDate="2018-03-28T23:19:28.960" LastActivityDate="2018-04-26T17:53:45.153" Title="Does the oracle in Grover's algorithm need to contain information about the entirety of the database?" Tags="&lt;quantum-algorithms&gt;&lt;grovers-algorithm&gt;" AnswerCount="2" CommentCount="5" />
  <row Id="1420" PostTypeId="2" ParentId="1419" CreationDate="2018-03-28T21:22:59.710" Score="1" Body="&lt;p&gt;You would build a function $f$ such that $f(x)$ first accesses the $x$-th item of your array and then compares it to $w$. An actual implementation might access the array encoded in extra (parameter) input qubits as if they were bits.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-03-28T21:22:59.710" CommentCount="2" />
  <row Id="1421" PostTypeId="2" ParentId="1416" CreationDate="2018-03-28T21:26:18.617" Score="5" Body="&lt;p&gt;&lt;strong&gt;How do we prevent quantum noise in a quantum computer?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Well, technically the answer is (at least for most systems): we use ridiculously low temperatures (much colder than space), we shield everything (or at least as much as possible) out, that might introduce any noise (radio waves, such as phone signals or light, magnetic fields, ...), we do everything to remove particles on our chips, that might interact with our system and we are super careful, that the connections (i.e. cables, optical fibres and such) to the environment (control and readout lines) carry as little noise as possible.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But that will not be enough to run a relevant Shor. To understand what else we can do, let's understand:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;What is Quantum noise?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Noise is present in all systems - so also your classical computer. In classical computers however this can manifest in only one way: a bit that should be in one state (say 1) turns out to be in the other (say 0) instead. This is pretty easy to correct for: we just run the computation in parallel a few times and check every now and again if one of them is off and correct the error (assuming the majority to be right)*. So we, of course try to prevent noise, but more importantly, we correct for it!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quantum noise turns out to be much more complicated. How so? Well generally the state of a quantum bit (qubit) can be described as a point on a sphere (commonly called bloch sphere). Noise can now move this point somewhere along the sphere (or in fact make the sphere smaller). But we can still apply the same error correcting we used for the classical computer right? No! The tricky part about quantum computing is, that we only get to chose to points on the sphere and get to know to which one it was closer to*. Also we &lt;em&gt;project&lt;/em&gt; the state of the qubit into that value - so the value actually becomes the value we measured, no matter what it was before. Crazy, right? Well that's &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_mechanics&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum mechanics&lt;/a&gt; for ya. So we cannot simply compare the computations while running it as before, because that would destroy our computation!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Quantum error correction to the rescue?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Well, it turns out &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_error_correction&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum error correction&lt;/a&gt; is actually possible through a few tricks (which are kind of hard to explain here - so just for feelings sake: we measure in a slightly different way instead, allowing us to just measure weather two qubits are the same in some respect or not. Again, if we do measure that they are the same we have &lt;em&gt;projected&lt;/em&gt; them into being the same, if not we can correct. The important phrase being &lt;em&gt;in some respect&lt;/em&gt;, so we have to do this for several types of errors that can happen and afterwards try to puzzle out what actually happened to the qubit). For it to work however, we need a quantum computer that already has very little noise to begin with (see also &quot;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1356/why-do-error-correction-protocols-only-work-when-the-error-rates-are-already-sig&quot;&gt;Why do error correction protocols only work when the error rates are already significantly low to begin with?&lt;/a&gt;&quot;), can &lt;em&gt;talk&lt;/em&gt; (are coupled) to each other and we generally have sufficient control over. Right now, nobody is close to fulfilling all these requirements sufficiently at once (separately on different system they have all been achieved).&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;*Well that's not exactly how it works, but roughly.&lt;/p&gt;&#xA;" OwnerUserId="689" LastEditorUserId="689" LastEditDate="2018-03-29T08:37:04.787" LastActivityDate="2018-03-29T08:37:04.787" CommentCount="0" />
  <row Id="1422" PostTypeId="5" CreationDate="2018-03-28T21:29:12.323" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-28T21:29:12.323" LastActivityDate="2018-03-28T21:29:12.323" CommentCount="0" />
  <row Id="1423" PostTypeId="4" CreationDate="2018-03-28T21:29:12.323" Score="0" Body="Grover's search algorithm is an algorithm that can perform a search in the order of square root of the input size. This is a provable speed up over the best classical algorithm, which requires a time of order N to perform a search" OwnerUserId="23" LastEditorUserId="23" LastEditDate="2018-03-29T08:49:22.603" LastActivityDate="2018-03-29T08:49:22.603" CommentCount="0" />
  <row Id="1424" PostTypeId="2" ParentId="1356" CreationDate="2018-03-28T21:41:34.270" Score="4" Body="&lt;p&gt;There is a good mathematical answer already, so I'll try and provide an easy-to-understand one.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quantum error correction (QEC) is a (group of) rather complex algorithm(s), that requires a lot of actions (gates) on and between qubits. In QEC, you pretty much connect two qubits to a third helper-qubit (ancilla) and transfer the information if the other two are equal (in some specific regard) into that third qubit. Then you read that information out of the ancialla. If it tells you, that they are not equal, you act on that information (apply a correction). So how can that go wrong if our qubits and gates are not perfect?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;QEC can make the information stored in your qubits decay.&lt;/strong&gt; Each of these gates can decay the information stored in them, if they are not executed perfectly. So if just executing the QEC destroys more information than it recovers on average, it's useless.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;You think you found an error, but you didn't.&lt;/strong&gt; If the comparison (execution of gates) or the readout of the information (ancilla) is imperfect, you might obtain wrong information and thus apply &quot;wrong corrections&quot; (read: introduce errors). Also if the information in the ancillas decays (or is changed by noise) before you can read it out, you will also get wrong readout.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The goal of every QEC is obviously to introduce less errors than it corrects for, so you need to minimize the aforementioned effects. If you do all the math, you find pretty strict requirements on your qubits, gates and readouts (depending on the exact QEC algorithm you chose).&lt;/p&gt;&#xA;" OwnerUserId="689" LastEditorUserId="689" LastEditDate="2018-05-25T14:17:09.730" LastActivityDate="2018-05-25T14:17:09.730" CommentCount="1" />
  <row Id="1425" PostTypeId="2" ParentId="1410" CreationDate="2018-03-28T21:46:16.700" Score="0" Body="&lt;p&gt;No, the computational basis &lt;em&gt;does not&lt;/em&gt; have any special meaning, it is just the basis that is &quot;most natural&quot; in a given context, and is conventionally denoted with $|0\rangle$ and $|1\rangle$ in the case of qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To give a few examples:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;If the qubits are encoded into the polarization of single photons, the computational basis is typically the basis formed by the horizontal and vertical polarization states of the photon.&lt;/li&gt;&#xA;&lt;li&gt;If the qubits are encoded into the spins of something like ions, atoms or electrons, then the &quot;computational basis&quot; is typically assumed to be the basis of the eigenstates of the $S_z$, that is, the spin angular momentum the vertical direction (of course, what &quot;vertical&quot; means also depends on the context).&lt;/li&gt;&#xA;&lt;li&gt;If a qubit is encoded into the presence or absence of a photon in a given mode, then the &quot;computational basis&quot; is, well, the occupational state of that mode.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;I could go on.&#xA;One also often speaks of &quot;computational basis&quot; for higher-dimensional states (qudits), in which case the same applies: a basis is called &quot;computational&quot; when it's the most &quot;natural&quot; in a given context.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;From a purely theoretical point of view, the &quot;computational basis&quot; is nothing but &lt;em&gt;some basis&lt;/em&gt; that is usually denoted with $\{|0\rangle, |1\rangle,...\}$, to distinguish it from some other basis having some relation with it.&#xA;It is fundamental to understand that from a purely theoretical point of view, all bases are equivalent to each other, and they only acquire meaning when one decides that a given basis represents a specific set of states of some physical system.&lt;/p&gt;&#xA;" OwnerUserId="55" LastActivityDate="2018-03-28T21:46:16.700" CommentCount="0" />
  <row Id="1426" PostTypeId="1" CreationDate="2018-03-28T22:32:44.897" Score="11" ViewCount="136" Body="&lt;p&gt;My understanding is that the magnetic fields needed to hold the ions in place in ion trap quantum computers are very complex, and for that reason, currently, only 1-D computers are possible, therefore reducing the ease of communication between qubits. There does seem to be a proposition for a 2-d system using a Paul trap &lt;a href=&quot;https://arxiv.org/pdf/1408.6659.pdf&quot; rel=&quot;noreferrer&quot;&gt;in this preprint&lt;/a&gt; but I can't seem to find if this has actually been tested.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Does the scalability of ion trap quantum computers depend upon this alone (whether or not the ions can be arranged in configurations other than a straight line) or are other factors entailed? If the former, what progress has been made? If the latter, what are the other factors?&lt;/p&gt;&#xA;" OwnerUserId="91" LastEditorUserId="1847" LastEditDate="2018-04-19T06:20:43.913" LastActivityDate="2018-04-19T06:20:43.913" Title="Scalability of ion trap quantum computers" Tags="&lt;quantum-computer&gt;&lt;architecture&gt;&lt;experimental-results&gt;&lt;ion-trap-quantum-computing&gt;&lt;scalability&gt;" AnswerCount="3" CommentCount="0" FavoriteCount="1" />
  <row Id="1428" PostTypeId="1" CreationDate="2018-03-28T23:25:26.580" Score="12" ViewCount="315" Body="&lt;p&gt;Google recently announced the &lt;em&gt;Bristlecone&lt;/em&gt; 72 qubit quantum computer.&#xA;However, D-Wave already announced quantum computers featuring more than $2000$ qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Why is Google's new device newsworthy then? Is it better than D-Wave's machine in some respects? If so, how?&lt;/p&gt;&#xA;" OwnerUserId="1086" LastEditorUserId="26" LastEditDate="2018-03-29T04:44:13.713" LastActivityDate="2018-04-05T05:47:08.257" Title="Is Google's 72 qubit device better than D-Wave's machines, which feature more than 2000 qubits?" Tags="&lt;quantum-computer&gt;&lt;qubit&gt;&lt;performance&gt;&lt;d-wave&gt;" AnswerCount="2" CommentCount="3" FavoriteCount="1" ClosedDate="2018-03-31T11:53:29.730" />
  <row Id="1429" PostTypeId="1" AcceptedAnswerId="1480" CreationDate="2018-03-28T23:26:41.120" Score="14" ViewCount="224" Body="&lt;p&gt;I've heard the term &lt;a href=&quot;https://en.wikipedia.org/wiki/Topological_quantum_computer&quot; rel=&quot;noreferrer&quot;&gt;Topological Quantum Computer&lt;/a&gt; a few times now and know that it is equivalent to quantum computers using circuits with respect to some polynomial-time reduction.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, it is totally unclear to me how such a quantum computer differs from others, how it works, and what its strengths are.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In short: how is a &lt;em&gt;topological quantum computer&lt;/em&gt; different than other models, such as gate-based quantum computers and what are the specific use cases for that it is better suited than other models?&lt;/p&gt;&#xA;" OwnerUserId="673" LastEditorUserId="673" LastEditDate="2018-03-29T13:55:52.453" LastActivityDate="2018-04-15T04:12:00.540" Title="How do Topological Quantum Computers differ from others models of quantum computation?" Tags="&lt;quantum-computer&gt;&lt;quantum-computing-models&gt;&lt;topological-quantum-computing&gt;" AnswerCount="2" CommentCount="6" FavoriteCount="1" />
  <row Id="1430" PostTypeId="2" ParentId="1419" CreationDate="2018-03-28T23:43:48.213" Score="5" Body="&lt;p&gt;$\newcommand{\xtarget}{\boldsymbol{x}_{\operatorname{target}}}\newcommand{\bs}[1]{{\boldsymbol #1}}\newcommand{\on}[1]{{\operatorname{#1}}}$No, it does not.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &quot;&lt;em&gt;oracle&lt;/em&gt;&quot; in Grover's algorithm is a function that, given any element $\boldsymbol x_k$, checks whether $\boldsymbol x_k$ is the element we are looking for, say $\xtarget$.&#xA;To do this, &lt;em&gt;the oracle does not need any knowledge of all the other elements $x_j$ that are in the database&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It may help to consider a more concrete example.&#xA;Say you have a database of $20000$ four-digit phone numbers, with $\boldsymbol x_k$ denoting the $k$-th element in this database.&#xA;You are interested in knowing what position in the database corresponds to the element $1234$.&#xA;Let us assume that the element 10000 of the database is the only such element, that is, $\bs x_{10000}=1234$ and $\bs x_k\neq 1234$ for all $k\neq10000$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the classical case, being the database unsorted, there is no better way than going through every single element in the database, checking each one against the target $1234$.&#xA;To do this, you only require to have an algorithm that, given $\bs x_k$, returns $\on{yes}$ if $\bs x_k=1234$ and $\on{no}$ otherwise.&#xA;An equivalent way to state this problem is to say that we want an algorithm which, given a list of pairs $\{(k,\bs x_k)\}_{k=1}^{20000}$, returns the pair such that $\bs x_k$ is what we want.&#xA;Thus, in our case, we want an algorithm which given $\{(k,\bs x_k)\}_{k=1}^{20000}$ returns $(10000,\bs x_{10000}=1234)$.&#xA;Note that this means that the function checking each pair &lt;em&gt;only checks for features of a part of the state&lt;/em&gt;, namely, the $\bs x_k$ part.&#xA;Indeed, if this was not the case, the whole thing would be pointless because we wouldn't be recovering any information.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This last framing of the problem is the one that one should keep in mind while thinking about Grover's algorithm.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the quantum case, &lt;em&gt;the pairs&lt;/em&gt; $(k, \bs x_k)$ become the quantum states $|\psi_k\rangle$ (or just $|k\rangle$ how they are usually denoted), and the oracular function &lt;em&gt;only checks that part of the information stored in $|\psi_k\rangle$ matches the target&lt;/em&gt;.&#xA;The output of the procedure is the state $|\psi_{10000}\rangle$.&#xA;Now, &lt;em&gt;part of this state we already know&lt;/em&gt;, because it was hardcoded in the oracle: we know that the second part of the information encoded in $|\psi_{10000}\rangle$ is $1234$, because that is what we were looking for in the first place, and is the information that was encoded into the oracle itself.&#xA;&lt;em&gt;However&lt;/em&gt;, the state $|\psi_{10000}\rangle$ &lt;em&gt;also carries additional information&lt;/em&gt;, namely the position in the database: $10000$.&#xA;&lt;strong&gt;&lt;em&gt;This information was not used to build the oracle&lt;/em&gt;&lt;/strong&gt;, and is the information that we gain by running the algorithm.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Finally, note that the oracle knows nothing about the content of the full database. It only implements coherently a function that checks &lt;em&gt;a single state&lt;/em&gt; $|\psi_k\rangle$ against its target.&#xA;However, the fact that this gate works coherently means that one can input to this &lt;em&gt;checker&lt;/em&gt; function a superposition of many (possibly all of the) elements of the database, and obtain an output which contains some &lt;em&gt;global information&lt;/em&gt; about all the elements in the database.&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-04-26T17:53:45.153" LastActivityDate="2018-04-26T17:53:45.153" CommentCount="0" />
  <row Id="1431" PostTypeId="2" ParentId="1413" CreationDate="2018-03-29T00:44:39.327" Score="6" Body="&lt;p&gt;I think you can use the &lt;code&gt;initialize&lt;/code&gt; function as detailed at the section &quot;Arbitrary Initialization&quot; at &lt;a href=&quot;https://github.com/QISKit/qiskit-tutorial/blob/master/1_introduction/quantum_gates_and_linear_algebra.ipynb&quot; rel=&quot;noreferrer&quot;&gt;this tutorial&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As an example, this tutorial explicitly shows how to initialize the three qubit state&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ \frac{i}{\sqrt{16}} | 000 \rangle + \frac{1}{\sqrt{8}} | 001 \rangle +  \frac{1+i}{\sqrt{16}} | 010 \rangle + \frac{1+2i}{\sqrt{8}} | 101 \rangle + \frac{1}{\sqrt{16}} | 110 \rangle .$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Which is done using the following lines of QISKit code.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import math&#xA;desired_vector = [&#xA;    1 / math.sqrt(16) * complex(0, 1),&#xA;    1 / math.sqrt(8) * complex(1, 0),&#xA;    1 / math.sqrt(16) * complex(1, 1),&#xA;    0,&#xA;    0,&#xA;    1 / math.sqrt(8) * complex(1, 2),&#xA;    1 / math.sqrt(16) * complex(1, 0),&#xA;    0]&#xA;initialize_circuit_3q = Q_program.create_circuit('initialize_circuit_3q', [qr], [cr])&#xA;initialize_circuit_3q.initialize(&quot;init&quot;, desired_vector, [qr[0],qr[1],qr[2]])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="1092" LastEditorUserId="409" LastEditDate="2018-03-29T08:03:10.940" LastActivityDate="2018-03-29T08:03:10.940" CommentCount="3" />
  <row Id="1432" PostTypeId="2" ParentId="1428" CreationDate="2018-03-29T00:52:56.110" Score="9" Body="&lt;p&gt;&lt;strong&gt;Short explanation:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;D-Wave implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_annealing&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum annealing&lt;/a&gt;, while Google has &lt;a href=&quot;https://arxiv.org/abs/1511.03316&quot; rel=&quot;nofollow noreferrer&quot;&gt;digitized adiabatic quantum computation&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Lengthy Explanation:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;D-Wave advertises their line of quantum computers as having thousands of qubits, though these systems are designed specifically for quadratic unconstrained binary optimization. More information &lt;a href=&quot;https://www.dwavesys.com/tutorials/background-reading-series/introduction-d-wave-quantum-hardware#h2-3&quot; rel=&quot;nofollow noreferrer&quot;&gt;about D-Wave's manufacturing&lt;/a&gt; process. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is &lt;a href=&quot;https://www.dwavesys.com/quantum-computing&quot; rel=&quot;nofollow noreferrer&quot;&gt;D-Wave's claim&lt;/a&gt; that: &quot;It is best suited to tackling complex optimization problems that exist across many domains such as&quot;:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Optimization &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Machine learning &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Sampling / Monte Carlo&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Pattern recognition and anomaly detection &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Cyber security &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Image analysis &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Financial analysis &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Software / hardware verification and validation &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Bioinformatics / cancer research&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;D-Wave's &lt;a href=&quot;https://www.dwavesys.com/tutorials/background-reading-series/introduction-d-wave-quantum-hardware#h2-4&quot; rel=&quot;nofollow noreferrer&quot;&gt;QPU&lt;/a&gt; uses &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_annealing&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum annealing&lt;/a&gt; (QA), a metaheuristic for finding the global minimum of a given objective function over a given set of candidate solutions (candidate states), by a process using quantum fluctuations. Quantum annealing is used mainly for problems where the search space is discrete (combinatorial optimization problems) with many local minima; such as finding the ground state of a spin glass.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_annealing#Implementations&quot; rel=&quot;nofollow noreferrer&quot;&gt;D-Wave's architecture differs from traditional quantum computers&lt;/a&gt;. It is not known to be polynomially equivalent to a universal quantum computer and, in particular, cannot execute Shor's algorithm because Shor's Algorithm is not a hillclimbing process. Shor's Algorithm requires a universal quantum computer. D-wave claims only to do quantum annealing.[citation needed]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Papers:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://www.nature.com/articles/srep11168&quot; rel=&quot;nofollow noreferrer&quot;&gt;Experimental quantum annealing: case study involving the graph isomorphism problem&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://www.nature.com/articles/s41598-018-22763-2&quot; rel=&quot;nofollow noreferrer&quot;&gt;Defects in Quantum Computers&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://research.googleblog.com/2018/03/a-preview-of-bristlecone-googles-new.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Google's claim is&lt;/a&gt;: &quot;The goal of the Google Quantum AI lab is to build a quantum computer that can be used to solve real-world problems. Our strategy is to explore near-term applications using systems that are forward compatible to a large-scale universal error-corrected quantum computer using linear array technology&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Papers:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;a href=&quot;https://www.nature.com/articles/nature14270&quot; rel=&quot;nofollow noreferrer&quot;&gt;State preservation by repetitive error detection in a superconducting quantum circuit&lt;/a&gt;&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;a href=&quot;https://www.nature.com/articles/nature17658&quot; rel=&quot;nofollow noreferrer&quot;&gt;Digitized adiabatic quantum computing with a superconducting circuit&lt;/a&gt;&quot;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Inaccurate layperson' explanation:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A Graphic Card has more Cores than a CPU.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;GPUs are optimized for taking huge batches of data and performing the same operation over and over very quickly, unlike PC microprocessors, which tend to skip all over the place.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Architecturally, the CPU is composed of just few cores with lots of cache memory that can handle a few software threads at a time. In contrast, a GPU is composed of hundreds of cores that can handle thousands of threads simultaneously. &lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Technical, but not overly complicated, layperson's explanation:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Why is Google's new device newsworthy then? Is it better than D-Wave's machine in some respects? If so, how?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There are &quot;Annealing QPUs&quot; and &quot;Universal QPUs&quot; as explained above, an incomplete list is offered on Wikipedia's page: &quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_quantum_processors&quot; rel=&quot;nofollow noreferrer&quot;&gt;List of Quantum Processors&lt;/a&gt;&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_annealing&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum annealing&lt;/a&gt;, the strength of transverse field determines the quantum-mechanical probability to change the amplitudes of all states in parallel.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the case of annealing a purely mathematical objective function, one may consider the variables in the problem to be classical degrees of freedom, and the cost functions to be the potential energy function (classical Hamiltonian). Moreover, it may be able to do this without the tight error controls needed to harness the quantum entanglement used in more traditional quantum algorithms.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;That makes it easier to provide more qubits, but the kinds of problems they are able to solve is more limited than the qubits provided in a universal QPU.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In general the ground state of a Hamiltonian can be used to encode a wider variety of problems than NP (know QMA-complete problems), and so decision to focus on NP optimization problems has led to restrictions which prevent the device from being used for general purpose quantum computing (even if noise was not an issue). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;There is an interesting subtlety as regards noise: If you add noise to the adiabatic algorithm, it degrades gracefully into one of the best classical algorithms for the same problem.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The adiabatic model can encode universal quantum computation, however the limitations of DWave's implementation means that specific machine cannot.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://research.googleblog.com/2018/03/a-preview-of-bristlecone-googles-new.html?m=1&quot; rel=&quot;nofollow noreferrer&quot;&gt;Google's universal QPU&lt;/a&gt; can solve a wider range of problems than D-Wave's QPU (in it's current implementation) if they can solve their decoherence problem.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the case of Google's Bristlecone caution is warranted. Bristlecone is a scaled up version of a 9-qubit Google design that has failed to yield acceptable error rates for a commercially viable quantum system. In real-world settings, quantum processors must have a two-qubit error rate of less than 0.5 percent. According to Google, its best result has been a 0.6 percent error rate using its much smaller 9-qubit hardware.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The commercial success of quantum computing will require more than high qubit numbers. It will depend on quality qubits with low error rates and long-lasting circuit connectivity in a system with the ability to outperform classic computers in complex problem solving, i.e., “quantum supremacy”. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Google will use it's record number of more useful qubits to correct the error rate of those error prone qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;More qubits are needed to solve bigger problems and longer living (coherent) qubits to are needed to hold the information long enough for the quantum algorithm to run. IBM describes the problem as: &quot;Quantum Volume: preferring fewer errors per qubit over more qubits&quot;, see also: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1226/what-is-the-leading-edge-technology-for-creating-a-quantum-computer-with-the-few&quot;&gt;What is the leading edge technology for creating a quantum computer with the fewest errors?&lt;/a&gt; .&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Google plans to use &lt;a href=&quot;https://en.wikipedia.org/wiki/Toric_code&quot; rel=&quot;nofollow noreferrer&quot;&gt;Surface Codes&lt;/a&gt; to resolve this problem, for more info and a comparison to spin glass models see: &quot;&lt;a href=&quot;https://arxiv.org/abs/1504.01444&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Computation with Topological Codes: from qubit to topological fault-tolerance&lt;/a&gt;&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;IBM has a video titled: &quot;&lt;a href=&quot;https://www.youtube.com/watch?v=S52rxZG-zi0&quot; rel=&quot;nofollow noreferrer&quot;&gt;A Beginner’s Guide to Quantum Computing&lt;/a&gt;&quot; which explains quantum computing for laypersons in under 20 minutes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://www.microsoft.com/en-us/research/group/microsoft-quantum-santa-barbara-station-q/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Microsoft&lt;/a&gt; intends to take the wind from everyone's sails with the integration of Q# (Q sharp) into Visual Studio and some information about their Majorana fermion based qubits, and a great reduction in the error rate, in the months to come. See: &quot;&lt;a href=&quot;https://arxiv.org/abs/1712.02353&quot; rel=&quot;nofollow noreferrer&quot;&gt;Majorana-based fermionic quantum computation&lt;/a&gt;&quot;. The will enable a system that uses less than 25% as many better qubits to accomplish the same amount of work as Google's qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The website &quot;The Next Platform&quot; describes the current situation as: &quot;&lt;a href=&quot;https://www.nextplatform.com/2018/01/10/quantum-computing-enters-2018-like-1968/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Computing Enters 2018 Like it's 1968&lt;/a&gt;&quot;.&lt;/p&gt;&#xA;" OwnerUserId="278" LastEditorUserId="278" LastEditDate="2018-04-05T05:47:08.257" LastActivityDate="2018-04-05T05:47:08.257" CommentCount="8" />
  <row Id="1435" PostTypeId="2" ParentId="1428" CreationDate="2018-03-29T02:46:41.343" Score="8" Body="&lt;p&gt;There are two points I'd make here.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;D-Wave's computer and Google's computer are fundamentally different.&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;D-Wave's computer is a quantum annealer. Imagine a landscape with some grassy hills. If you put a ball at the top of the hill, it will roll to a local minima, or even the minimum - in this case, a valley. Similarly, a quantum annealer has the qubits as the ball and a polynomial as the landscape. It has the advantage that effects like quantum tunneling help make the process more efficient. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;On the other hand, Google's computer is gate based. Much like a digital classical computer, it has qubits and gates that are then applied to those qubits. This means that they are optimized, in some senses, for different types of problems. It's like comparing apples and oranges - not totally equivalent.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Just because you have a lot of qubits doesn't mean they are good qubits.&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;A lot of the controversy surrounding D-Wave has been because it has been called into question whether or not D-Wave's qubits actually exhibit quantum effects. (It hasn't really helped that D-Wave has...overhyped their successes a bit along the way.) You can have a ton of qubits, but if they aren't actually coherent for a long enough length of time, it's not really useful.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Google's qubits are definitely coherent for a reasonable period of time. We don't 100% know about D-Wave's. &lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Tl;dr: both are different in how they work and in their problems.&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Both are notable in their own ways.&lt;/p&gt;&#xA;" OwnerUserId="91" LastActivityDate="2018-03-29T02:46:41.343" CommentCount="0" />
  <row Id="1436" PostTypeId="2" ParentId="1410" CreationDate="2018-03-29T03:35:47.207" Score="7" Body="&lt;p&gt;Quantum computing deals (mostly) with finite-dimensional quantum systems called &lt;a href=&quot;https://en.wikipedia.org/wiki/Qubit&quot; rel=&quot;noreferrer&quot;&gt;qubits&lt;/a&gt;. If you know basic quantum mechanics then you know that the Hilbert space of a qubit is $\mathbb{C}^2$, i.e., the two-dimensional complex Hilbert space over $\mathbb{C}$ (for the more technical people, the Hilbert space is actually $\mathbb{C}P^1$). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Therefore, to describe the vectors (or physically, the quantum state of the qubit) in this two-dimensional Hilbert space  we need at least two basis elements. If you think of the state of the qubit as a column vector, &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$${{\bigl [}{\begin{smallmatrix}a\\b\end{smallmatrix}}{\bigr ]}},$$ then you would need to specify what $a,b$ are to specify the state of the qubit. Note that what $a,b$ are depends on what the basis of the system is $-$ there can be two different looking column vectors (in different bases) that represent the same state $|\psi\rangle$ of the qubit. In any case, we need some basis to work with and this is where the &quot;computational basis&quot; comes into play. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The computational basis is simply the two basis states composed by (any of) the two &lt;em&gt;distinct&lt;/em&gt; quantum states that the qubit can be in physically. However, just like in linear algebra, which two (&lt;em&gt;linearly independent&lt;/em&gt;) states you choose is kinda arbitrary (I say kinda because in some physical situations there is a natural choice of the basis; see &lt;a href=&quot;https://en.wikipedia.org/wiki/Einselection&quot; rel=&quot;noreferrer&quot; title=&quot;einselection&quot;&gt;Einselection&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, if you have an electron in a magnetic field (pointing in the z-axis say), then the states of the spin pointing upwards and downwards in the z-axis are a typical choice for the computational basis $-$ this is clearly not the only choice, since the z-axis can point in any arbitrary direction. These two states, the $|\uparrow\rangle$ and $|\downarrow\rangle$ pointing states of the spin of the electron are the eigenstates of the $\sigma_z$ (Pauli-z) operator and are usually called the &quot;computational basis&quot;.&lt;/p&gt;&#xA;" OwnerUserId="1108" LastActivityDate="2018-03-29T03:35:47.207" CommentCount="1" />
  <row Id="1437" PostTypeId="1" AcceptedAnswerId="1443" CreationDate="2018-03-29T04:49:20.043" Score="11" ViewCount="145" Body="&lt;p&gt;I've been browsing &lt;a href=&quot;https://www.dwavesys.com/d-wave-two-system&quot; rel=&quot;noreferrer&quot;&gt;The D-Wave 2000Q site&lt;/a&gt; when I bumped into this aspect of their quantum computers:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;A Unique Processor Environment&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Shielded to 50,000× less than Earth’s magnetic field&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Why is that relevant? What would happen if it would be much less than 50.000x?&lt;/p&gt;&#xA;" OwnerUserId="1115" LastEditorUserId="26" LastEditDate="2018-03-29T04:51:25.160" LastActivityDate="2018-04-02T15:18:53.230" Title="Is it important for a quantum computer to be shielded by the magnetic field?" Tags="&lt;quantum-computer&gt;&lt;d-wave&gt;" AnswerCount="3" CommentCount="0" />
  <row Id="1438" PostTypeId="2" ParentId="1437" CreationDate="2018-03-29T05:00:46.437" Score="3" Body="&lt;p&gt;It is relevant to reduce the quantum noise in the system. If the shield strength is more than 50,000x, better the quantum computing system is shielded from the earth's magnetic field and thus better quantum noise reduction.&lt;s&gt;, at least, theoretically.&lt;/s&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;EDIT:&lt;/strong&gt;&#xA;&lt;em&gt;Superposition&lt;/em&gt; is the heart of quantum computing. Superposition state is susceptible to fluctuating external magnetic fields, thermal fluctuations, radiowave etc., The quantum processor should be in an space where the magnetic field is uniform and stable to avoid quantum noise introduced by the above mentioned factors. Thus, isolating the quantum computing system from its disturbing environment is mandatory. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Achieving a ideal quantum noise free environment is still a daunting task. However, progress made thus far has brought us to experimental realizations of quantum computers. Shielding more than 50,000x earth's magnetic field would reduce the quantum noise induced by earth's magnetic field.&lt;/p&gt;&#xA;" OwnerUserId="812" LastEditorUserId="812" LastEditDate="2018-03-29T05:33:37.027" LastActivityDate="2018-03-29T05:33:37.027" CommentCount="2" />
  <row Id="1439" PostTypeId="1" AcceptedAnswerId="1456" CreationDate="2018-03-29T05:32:43.053" Score="5" ViewCount="114" Body="&lt;p&gt;Quantum computers have shown a new way to compute old problems. D-Wave  has a quantum annealer, and &lt;a href=&quot;https://en.wikipedia.org/wiki/D-Wave_Two&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wikipedia&lt;/a&gt; describes the D-Wave quantum computer and its use of quantum annealing properties. Hardware wise, how does D-Wave achieve quantum annealing? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;There may be many ways to achieve quantum annealing. D-Wave, being first on the market with quantum annealing hardware, therefore is open to more scrutiny (is their hardware open to such scrutiny?) Does D-Wave use a specific type of annealing at the atomic level (there could be one of many ways to achieve quantum annealing), or (in other words) are there many ways to achieve quantum annealing? &lt;/p&gt;&#xA;" OwnerUserId="429" LastEditorUserId="26" LastEditDate="2018-03-29T18:09:20.863" LastActivityDate="2018-03-29T18:09:20.863" Title="Hardware wise, how does D-Wave achieve quantum annealing?" Tags="&lt;d-wave&gt;&lt;quantum-annealing&gt;" AnswerCount="1" CommentCount="8" />
  <row Id="1440" PostTypeId="1" AcceptedAnswerId="1442" CreationDate="2018-03-29T06:51:03.897" Score="13" ViewCount="440" Body="&lt;p&gt;After reading the &quot;&lt;a href=&quot;http://www.bris.ac.uk/news/2011/8109.html&quot; rel=&quot;noreferrer&quot;&gt;first programmable quantum photonic chip&lt;/a&gt;&quot;. I was wondering just what software for a computer that uses quantum entanglement would be like.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is there any example of code for specific quantum programming? Like pseudocode or high-level language? Specifically, what's the shortest program that can be used to create a Bell state $$\left|\psi\right&amp;gt; = \frac{1}{\sqrt 2} \left(\left|00\right&amp;gt; + \left|11\right&amp;gt; \right)$$ starting from a state initialised to $\left|\psi_0\right&amp;gt; = \left|00\right&amp;gt;$ using both a simulation and one of IBM's &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/experience&quot; rel=&quot;noreferrer&quot;&gt;Quantum Experience&lt;/a&gt; processors, such as the &lt;a href=&quot;https://github.com/QISKit/ibmqx-backend-information/blob/master/backends/ibmqx4/README.md&quot; rel=&quot;noreferrer&quot;&gt;ibmqx4&lt;/a&gt;?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Making the conceptual jump from traditional programming to entanglement isn't that easy.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;I've found C's &lt;a href=&quot;http://www.libquantum.de/&quot; rel=&quot;noreferrer&quot;&gt;libquantum&lt;/a&gt; too.&lt;/p&gt;&#xA;" OwnerUserId="58" LastEditorUserId="23" LastEditDate="2018-03-29T09:02:04.127" LastActivityDate="2018-03-29T09:08:34.100" Title="What would a very simple quantum program look like?" Tags="&lt;simulation&gt;&lt;ibm-q-experience&gt;&lt;quantum-programming&gt;" AnswerCount="3" CommentCount="4" FavoriteCount="5" />
  <row Id="1441" PostTypeId="1" AcceptedAnswerId="1591" CreationDate="2018-03-29T07:16:45.100" Score="11" ViewCount="170" Body="&lt;p&gt;In his celebrated paper &quot;&lt;a href=&quot;https://www.researchgate.net/publication/234782642_Conjugate_Coding&quot; rel=&quot;noreferrer&quot;&gt;Conjugate Coding&lt;/a&gt;&quot; (written around 1970), Stephen Wiesner proposed a scheme for quantum money that is unconditionally impossible to counterfeit, assuming that the issuing bank has access to a giant table of random numbers and that banknotes can be brought back to the bank for verification. In Wiesner's scheme, each banknote consists of a classical &quot;serial number&quot; $s$, together with a quantum money state $|\psi_s\rangle$ consisting of $n$ unentangled qubits, each one either&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$|0\rangle,\ |1\rangle,\ |+\rangle=(|0\rangle+|1\rangle)/\sqrt{2},\ \text{or}\ |-\rangle=(|0\rangle-|1\rangle)/\sqrt{2}.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The bank remembers a classical description of $|\psi_s\rangle$ for every $s$.  And therefore, when $|\psi_s\rangle$ is brought back to the bank for verification, the bank can measure each qubit of $|\psi_s\rangle$ in the correct basis (either $\{|0\rangle,|1\rangle\}$ or $\{|+\rangle,|-\rangle\}$), and check that it gets the correct outcomes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;On the other hand, because of the uncertainty relation (or alternatively, the No-Cloning Theorem), it's &quot;intuitively obvious&quot; that, if a counterfeiter who &lt;i&gt;doesn't&lt;/i&gt; know the correct bases tries to copy $|\psi_s\rangle$, then the probability that &lt;i&gt;both&lt;/i&gt; of the counterfeiter's output states pass the bank's verification test can be at most $c^n$, for some constant $c&amp;lt;1$.  Furthermore, this should be true regardless of what strategy the counterfeiter uses, consistent with quantum mechanics (e.g., even if the counterfeiter uses fancy entangled measurements on $|\psi_s\rangle$).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, while writing a paper about other quantum money schemes, my coauthor and I realized that we'd never seen a rigorous proof of the above claim anywhere or an explicit upper bound on $c$: neither in Wiesner's original paper nor in any later one.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, &lt;i&gt;has&lt;/i&gt; such a proof (with an upper bound on $c$) been published?  If not, then can one derive such a proof in a more-or-less straightforward way from (say) approximate versions of the No-Cloning Theorem, or results about the security of the BB84 quantum key distribution scheme?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I should maybe clarify that I'm looking for more than just a reduction from the security of BB84.  Rather, I'm looking for an &lt;i&gt;explicit upper bound&lt;/i&gt; on the probability of successful counterfeiting (i.e., on $c$)---and ideally, also some understanding of what the optimal counterfeiting strategy looks like.  I.e., does the optimal strategy simply measure each qubit of $|\psi_s\rangle$ independently, say on the basis&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\{ \cos(\pi/8)|0\rangle+\sin(\pi/8)|1\rangle, \sin(\pi/8)|0\rangle-\cos(\pi/8)|1\rangle \}?$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Or is there an entangled counterfeiting strategy that does better?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Right now, the best counterfeiting strategies that I know are (a) the strategy above, and (b) the strategy that simply measures each qubit in the $\{|0\rangle,|1\rangle\}$ basis and &quot;hopes for the best.&quot;  Interestingly, &lt;i&gt;both&lt;/i&gt; of these strategies turn out to achieve a success probability of $(5/8)$&lt;sup&gt;$n$&lt;/sup&gt;.  So, my conjecture of the moment is that $(5/8)$&lt;sup&gt;$n$&lt;/sup&gt; might be the right answer.  In any case, the fact that $5/8$ is a &lt;i&gt;lower&lt;/i&gt; bound on c rules out any security argument for Wiesner's scheme that's &quot;too&quot; simple (for example, any argument to the effect that there's nothing nontrivial that a counterfeiter can do, and therefore the right answer is $c=1/2$).&lt;/p&gt;&#xA;" OwnerUserId="58" LastEditorUserId="2927" LastEditDate="2018-08-14T05:53:30.703" LastActivityDate="2018-08-14T05:53:30.703" Title="Rigorous security proof for Wiesner's quantum money" Tags="&lt;quantum-algorithms&gt;&lt;cryptocurrency&gt;&lt;quantum-cryptography&gt;&lt;quantum-money&gt;" AnswerCount="2" CommentCount="1" FavoriteCount="1" />
  <row Id="1442" PostTypeId="2" ParentId="1440" CreationDate="2018-03-29T07:27:41.910" Score="10" Body="&lt;p&gt;Assuming you are considering a gate-based quantum computer, the most easy way to produce an entagled state is to produce one of the Bell states. The following circuit shows the Bell state $\left| \Phi^+ \right&amp;gt;$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/GQxa8.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/GQxa8.png&quot; alt=&quot;Bellstate&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;By examining $\left| \psi_0 \right&amp;gt;$, $\left| \psi_1 \right&amp;gt;$ and $\left| \psi_2 \right&amp;gt;$ we can determine the entagled state after application of all gates:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;1. $\left| \psi_0 \right&amp;gt;$:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Not much happens here since no gates were applied at this point. The state of the whole system is therefore just the tensorproduct of the single states which we write like this:&#xA;$$&#xA;\left| \psi_0 \right&amp;gt; = \left | 0 0 \right &amp;gt; &#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;2. $\left| \psi_1 \right&amp;gt;$:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Hadamard-Gate applies on the first qubit which results in the following:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;\left| \psi_1 \right&amp;gt; =(H \otimes I)\left | 0 0 \right &amp;gt; = H\left | 0  \right &amp;gt; \otimes \left | 0 \right &amp;gt; = \frac{1}{\sqrt 2}  \left (\left | 0  \right &amp;gt; + \left | 1 \right &amp;gt; \right ) \left | 0 \right &amp;gt; = \frac{1}{\sqrt 2} \left (\left | 0 0 \right &amp;gt;  + \left | 1 0 \right &amp;gt;  \right )&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;3. $\left| \psi_2 \right&amp;gt;$:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now a CNOT gate is applied and flips the second qubit but only where the first one has the value 1. The result is&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;\left| \psi_2 \right&amp;gt; = \frac{1}{\sqrt 2} \left (\left | 0 0 \right &amp;gt;  + \left | 1 1 \right &amp;gt;  \right )&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This last state $\left| \psi_2 \right&amp;gt;$ is an entagled state and usually the most natural way to come up with such a situation. Bell states occure in a lot of interesting quantum algorithms such as super dense coding or teleportation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Although the approach above might not seem like programming to you in a usual sense, applying gates to states is basically how programming a gate-based quantum computer works. There exists abstraction layers that allow you to perform high-level programming but translate the commands to the application of gates. The &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/qasm&quot; rel=&quot;noreferrer&quot;&gt;IBM Quantum Experience&lt;/a&gt; interface provides such features.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In a language like Microsoft's Q# the above example could look similar to this:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;operation BellTest () : ()&#xA;{&#xA;    body&#xA;    {&#xA;        // Use two qubits&#xA;        using (qubits = Qubit[2])&#xA;        {&#xA;            Set (One, qubits[0]);&#xA;            Set (Zero, qubits[1]);&#xA;&#xA;            // Apply Hadamard gate to the first qubit&#xA;            H(qubits[0]);&#xA;&#xA;            // Apply CNOT gate&#xA;            CNOT(qubits[0],qubits[1]);&#xA;         }&#xA;     }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;A more detailed version (including measurement) can be found here: &lt;a href=&quot;https://docs.microsoft.com/en-us/quantum/quantum-WriteAQuantumProgram?view=qsharp-preview&amp;amp;tabs=tabid-vs2017&quot; rel=&quot;noreferrer&quot;&gt;Microsoft: Writing a Quantum Program&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="673" LastEditorUserId="673" LastEditDate="2018-03-29T07:42:07.423" LastActivityDate="2018-03-29T07:42:07.423" CommentCount="0" />
  <row Id="1443" PostTypeId="2" ParentId="1437" CreationDate="2018-03-29T07:36:25.467" Score="7" Body="&lt;p&gt;The DWave machine relies heavily on single-flux-quantum &lt;a href=&quot;https://arxiv.org/pdf/0907.3757.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;digital control&lt;/a&gt; for setting up qubit and coupler operating points, and for carrying out the annealing protocol. Any stray magnetic flux, if present while the chip is cooled through its superconducting transition, will be &lt;a href=&quot;https://arxiv.org/pdf/1701.03837.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;trapped&lt;/a&gt; inside the circuit and can cause it to fail. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can calculate how much shielding you need by requiring the magnetic field inside the shield to be smaller than a &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Magnetic_flux_quantum&quot; rel=&quot;nofollow noreferrer&quot;&gt;flux quantum&lt;/a&gt; over the area of the chip. $B = \frac{\Phi_0}{A}$, where $\Phi_0 \sim 2 \cdot 10^{-15} ~ \text{Wb}$ is the flux quantum and $A$ is the area. If the area of the DWave chip is $(2 ~ \text{cm})^2$ (guessing) then $B \sim 5 ~ \text{pT}$. Earth’s field is about $0.25 ~ \mu \text{T}$ so you really want $\times 5 \cdot 10^6$ attenuation of the field. Shielding of 50,000 means that you will have on average about 100 flux quanta that can trap in the chip. Typically people add &lt;a href=&quot;https://www.researchgate.net/profile/Vladimir_Talanov/publication/282639553_Reproducible_Operating_Margins_on_a_72800-Device_Digital_Superconducting_Chip/links/57ae08c908ae0101f1727750.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;trapping sites&lt;/a&gt; on the chip to sequester the remaining flux in safe areas. &lt;/p&gt;&#xA;" OwnerUserId="127" LastEditorUserId="580" LastEditDate="2018-03-29T20:18:07.207" LastActivityDate="2018-03-29T20:18:07.207" CommentCount="1" />
  <row Id="1444" PostTypeId="2" ParentId="1440" CreationDate="2018-03-29T07:48:02.680" Score="14" Body="&lt;p&gt;One way of writing quantum programs is with QISKit. This can be used to run the programs on IBM's devices. The &lt;a href=&quot;https://www.qiskit.org/&quot; rel=&quot;noreferrer&quot;&gt;QISKit website&lt;/a&gt; suggests the following code snippet to get you going, which is an entangled circuit as you want. It is also the same process as in the answer by datell. I'll comment on it line-by-line.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# import and initialize the method used to store quantum programs&#xA;from qiskit import QuantumProgram&#xA;qp = QuantumProgram()&#xA;# initialize a quantum register of two qubits&#xA;qr = qp.create_quantum_register('qr',2) &#xA;# and a classical register of two bits&#xA;cr = qp.create_classical_register('cr',2) &#xA;# create a circuit with them which we call 'Bell'&#xA;qc = qp.create_circuit('Bell',[qr],[cr]) &#xA;# apply a Hadamard to the first qubit&#xA;qc.h(qr[0]) &#xA;# apply a controlled not with the first qubit as control&#xA;qc.cx(qr[0], qr[1]) &#xA;# measure the first qubit and store its result on the first bit&#xA;qc.measure(qr[0], cr[0]) &#xA;# the same for the second qubit and bit&#xA;qc.measure(qr[1], cr[1]) &#xA;# run the circuit&#xA;result = qp.execute('Bell') &#xA;# extract the results&#xA;print(result.get_counts('Bell')) &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Note that the 'execute' command here only specifies the program to run. All other settings, such as the device you want to use, the number of times you want to repeat it to get statistics, etc are set to their default values. To run on &lt;em&gt;ibmqx4&lt;/em&gt; for 1024 shots, you can instead use&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;results = qp.execute(['Bell'], backend='ibmqx4', shots=1024)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-03-29T09:08:34.100" LastActivityDate="2018-03-29T09:08:34.100" CommentCount="1" />
  <row Id="1445" PostTypeId="2" ParentId="1426" CreationDate="2018-03-29T08:00:35.337" Score="4" Body="&lt;p&gt;Ion trap quantum computers hold ions in empty space using electric not magnetic fields. That is impossible using static fields (&lt;a href=&quot;https://en.wikipedia.org/wiki/Earnshaw%27s_theorem&quot; rel=&quot;nofollow noreferrer&quot;&gt;Earnshaw's theorem&lt;/a&gt;) so an alternating field is used. The effect is that charged particles such as ions seek a field minimum; this type of ion trap is also called a quadrupole trap because the simplest (lowest order) field having a minimum in space is a quadrupole field. It is simple to arrange fields that confine ions either to a point or to a line and ion trap quantumcomputers use the latter. Yet this does not scale because computations involve motional modes of the ions which become harder to distinguish when there are more ions.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are two approaches to make this approach scalable: Couple strings of ions either using light (photons) or by shuttling ions from one to another such linear ion trap section. Using photons is particularly difficult and far from currently workable for a quantum computer that meets an error correction threshold, so let's focus on shuttling ions.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Mathematically true quadrupole traps cannot be built to have intersections but that hasn't stopped physicists from making them anyways. The trick is that, although one cannot arrange to have a quadrupole field at the center of the intersection, one can still have confinement. And by slightly driving ions into the confining (alternating) field using a static field, one can get sufficiently strong confinement. It has even been shown that such shuttling across an intersection is possible without significantly heating the ion (changing its motional state).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;With such intersections, ion traps are scalable.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-03-29T08:00:35.337" CommentCount="2" />
  <row Id="1446" PostTypeId="2" ParentId="175" CreationDate="2018-03-29T08:19:37.717" Score="2" Body="&lt;p&gt;Well, Grover's original paper, &quot;Quantum mechanics helps in searching for a needle in a haystack&quot; clearly states, it &lt;strong&gt;assumes&lt;/strong&gt; that C(S) can be evaluated in a constant time. Grover's search is not concerned about the implementability, but the polynomial reduction in what's called a query complexity (how many times you consult the oracle, like a classical database)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In fact, the concept of &lt;em&gt;oracle&lt;/em&gt; in computing was proposed by &lt;a href=&quot;https://en.wikipedia.org/wiki/Alan_Turing&quot; rel=&quot;nofollow noreferrer&quot;&gt;Alan Turing&lt;/a&gt; to describe constructs for which a description on a UTM might not be realizable (Wikipedia). It &lt;strong&gt;is&lt;/strong&gt; in some sense magical.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But of course, coming back to your question, how do we then actually make the circuit for Grover search (or any oracular) algorithm? Do we need to know the answer in advance to search the result? Well, in some sense you need to. That is exactly what clever improvements on Grover search tries to work on, such that, we need not know the exact answer in advance, but some properties of it. Let me illustrate with an example.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For the pattern recognition problem using Grover's search, if I have 4 patterns on 2 qubits (00, 01, 10, 11) and I want to mark and amplify 11, the diagonal of my oracle unitary should be like (1,1,1,-1) to take care of the pi phase shift for the solution. So, for this simple implementation, for construction the unitary, you need to know the full answer in advance.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A clever improvement of pattern completion if given in the paper &quot;Quantum pattern matching&quot; by Mateas and Omar. In essence, it constructs as many fixed oracles as there are alphabets in the set. So for our binary string, there will be an oracle which marks out all 1s, and another that marks out all 0s. The oracles are invoked conditionally based on what I want to search. If I want to search 11, I call oracle 1 on the LSqubit, and oracle 1 again on the MSqubit. By the first oracle, I would amplify the states (01, 11), i.e. states with LSQ as 1, and in the 2nd call, it would amplify (10, 11). So as you see, 11 is the only state that gets amplified twice, ending in a higher measurement probability. Though the compiled quantum circuit would change based on what my input search pattern is, a high-level description of the quantum algorithm remains the same. You can think of the oracles as function calls based on a switch case of the alphabet set invoked for each character in the search string.&lt;/p&gt;&#xA;" OwnerUserId="1153" LastEditorUserId="55" LastEditDate="2018-03-29T11:38:57.710" LastActivityDate="2018-03-29T11:38:57.710" CommentCount="0" />
  <row Id="1447" PostTypeId="2" ParentId="1440" CreationDate="2018-03-29T08:59:30.063" Score="1" Body="&lt;p&gt;The simplest quantum program I can think of is a (1 bit) true random number generator. As a quantum circuit, it looks like this:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;|0&gt; ----|H|---- (measure)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You first prepare a qubit in state $\left| 0 \right&amp;gt;$, then apply a Hadamard gate to produce the superposition $\frac{\sqrt{2}}{2} \Big( \left| 0 \right&amp;gt; + \left| 1 \right&amp;gt; \Big)$ which you then measure in the computational basis. The measurement's result is 0 or 1, each with a probability of 50%.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-03-29T08:59:30.063" CommentCount="0" />
  <row Id="1448" PostTypeId="1" CreationDate="2018-03-29T09:27:19.713" Score="2" ViewCount="38" Body="&lt;p&gt;Consider an implementation of the Born-Jordan quantization or an arbitrary Cohen class time-frequency analysis algorithm.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Are there any numerical differences between classical and quantum solutions? Would our visualizations of the data output change in any way? (Or perhaps, would we have to change the way we visualize the data?)&lt;/p&gt;&#xA;" OwnerUserId="1165" LastEditorUserId="55" LastEditDate="2018-03-29T12:25:39.417" LastActivityDate="2018-03-29T12:25:39.417" Title="Are there numerical differences between classical and quantum solutions of problems such as the Born-Jordan quantization?" Tags="&lt;quantum-algorithms&gt;" AnswerCount="0" CommentCount="3" ClosedDate="2018-03-29T19:14:54.537" />
  <row Id="1449" PostTypeId="2" ParentId="20" CreationDate="2018-03-29T09:35:52.860" Score="4" Body="&lt;p&gt;Excellent question! You are asking if we can, given a property we want in a quantum system (for example superconductivity in a chemical compound), efficiently find one example of such a compound.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;First of all, it is perhaps not yet a completely settled question if we can calculate such properties in the forward direction efficiently: Given a compound, does it superconduct? It is efficiently possible to simulate the temporal evolution from a given initial state and also to calculate its energy. There are several ideas that suggest it is also efficiently possible to calculate the interesting states (either the ground state or thermal states) and I believe this is possible but I want to emphasize that some details of these are still debated or not yet investigated academically.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Assuming we can efficiently calculate if a given compound fulfills your desires, one could start an exhaustive search over a number $N$ of compounds. Such a search can be accelerated by Grover's algorithm; even for the less straight-forward case that we have here, that an unknown number of solutions exist, this is possible in a number of compound-property calculations that scales with $\sqrt{N}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Hence you have a quantum speedup, likely exponential in the calculation of the desired properties of one chemical compound, and subexponential in the search among compounds.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastEditorUserId="1039" LastEditDate="2018-03-29T10:58:16.330" LastActivityDate="2018-03-29T10:58:16.330" CommentCount="0" />
  <row Id="1451" PostTypeId="1" AcceptedAnswerId="1483" CreationDate="2018-03-29T10:43:05.193" Score="19" ViewCount="629" Body="&lt;p&gt;I would like to know how a job for a D-Wave device is written in code and submitted to the device.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the answer it would be best to see a specific example of this for a simple problem. I guess that the &quot;Hello World&quot; of a &lt;a href=&quot;https://en.wikipedia.org/wiki/D-Wave_Systems&quot; rel=&quot;noreferrer&quot;&gt;D-Wave device&lt;/a&gt; would be something like finding the ground states of a &lt;a href=&quot;https://www.triplespark.net/sim/isingmag/&quot; rel=&quot;noreferrer&quot;&gt;simple 2D Ising model&lt;/a&gt;, since this is the kind of problem directly realized by the hardware. So perhaps this would be a nice example to see. But if those with expertise thing an alternative example would be suitable, I'd be happy to see an alternative.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-03-29T12:43:39.983" LastActivityDate="2018-05-19T10:35:07.823" Title="How do you write a simple program for a D-Wave device?" Tags="&lt;d-wave&gt;&lt;quantum-programming&gt;" AnswerCount="3" CommentCount="3" FavoriteCount="7" />
  <row Id="1452" PostTypeId="2" ParentId="4" CreationDate="2018-03-29T10:43:33.000" Score="4" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;How does the quantum gate &lt;em&gt;affect&lt;/em&gt; (not necessarily change it) the&#xA;  result of measuring the state of the qubits (as the measurement result&#xA;  is affected greatly by the probabilities of each possible state)? More&#xA;  specifically, is it possible to know, in advance, how the&#xA;  probabilities of each state change due to the quantum gate?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Let's try to approach this with an example and some geometry. Consider a single qubit, whose Hilbert space is $\mathbb{C}^2$, i.e., the two-dimensional complex Hilbert space over $\mathbb{C}$ (for the more technical people, the Hilbert space is actually $\mathbb{C}P^1$). It turns out that $\mathbb{C}P^1 \cong S^2$, the unit sphere, also known as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bloch_sphere&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bloch sphere&lt;/a&gt;. This translates into the fact that all states of a qubit can be represented (&lt;em&gt;uniquely&lt;/em&gt;) on the Bloch sphere.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/cPken.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/cPken.png&quot; alt=&quot;Quantum states on the Bloch sphere&quot;&gt;&lt;/a&gt;&#xA;Source: Wikipedia&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The state of a qubit can be represented on the Bloch sphere as ${\displaystyle |\psi \rangle =\cos \left({\frac {\theta }{2}}\right)|0\rangle \,+\,e^{i\phi }\sin \left({\frac {\theta }{2}}\right)|1\rangle}$, where $0 \leq \theta \leq \pi$ and $0 \leq \phi &amp;lt; 2 \pi$. Here, $|0\rangle = {{\bigl [}{\begin{smallmatrix}1\\0\end{smallmatrix}}{\bigr ]}}$ and $|1\rangle = {{\bigl [}{\begin{smallmatrix}0\\1\end{smallmatrix}}{\bigr ]}}$ are the two basis states (represented in the figure at the north and south pole respectively). So the states of the qubit are nothing but column vectors, which are identified with (unique) points on the sphere.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;What are quantum gates?&#xA;These are unitary operators, $U$ s.t., $U U^\dagger = U^\dagger U = \mathbb{I}$. Gates on a single qubit are elements of $SU(2)$. Consider a simple gate like $Y$ (which stands for the Pauli matrix $\sigma_y :=  Y = \begin{bmatrix} 0 &amp;amp; -i \\ i &amp;amp; 0 \end{bmatrix}$). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;How does this gate act on a qubit and &lt;em&gt;affect&lt;/em&gt; the measurement outcomes?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Say you begin with a qubit in the state $|0\rangle$, i.e., at the north pole on the Bloch sphere. You apply a unitary of the form $U = e^{-i \gamma Y}$ where $\gamma \in \mathbb{R}$. Using properties of the Pauli matrix, we get $U = e^{-i \gamma Y} = cos(\gamma) \mathbb{I} -i sin(\gamma) Y$. The action of this operator is to rotate the state by an angle $2 \gamma$ along the y-axis and therefore if we choose $\gamma = \pi/2$, the qubit $|0\rangle \rightarrow U|0\rangle = |1\rangle$. That is to say, given we know what unitary we are applying to our state, we completely know the way in which our initial state will transform and hence we know how the measurement probabilities would change.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, if we were to make a measurement in the $\{|0\rangle, |1\rangle\}$ basis, initially, one would get the state $|0\rangle$ with probability 1; after applying the unitary, one would get the state $|1\rangle$ with probability 1.&lt;/p&gt;&#xA;" OwnerUserId="1108" LastActivityDate="2018-03-29T10:43:33.000" CommentCount="0" />
  <row Id="1453" PostTypeId="2" ParentId="135" CreationDate="2018-03-29T12:28:00.970" Score="0" Body="&lt;p&gt;Whilst I cannot supply a formal proof, the simulation of (the temporal evolution) of a quantum system is believed to be such a case: There is no known better way to do this on a classical computer than in exponential time but a quantum computer can trivially do it in polynomial time.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The idea of such a quantum simulator (see also &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_simulator&quot; rel=&quot;nofollow noreferrer&quot;&gt;wikipedia article&lt;/a&gt;) is in fact how quantum computers got first proposed.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastEditorUserId="1039" LastEditDate="2018-03-29T12:36:24.870" LastActivityDate="2018-03-29T12:36:24.870" CommentCount="1" />
  <row Id="1454" PostTypeId="2" ParentId="1451" CreationDate="2018-03-29T12:33:44.610" Score="9" Body="&lt;p&gt;The title and question body seem to ask two different questions. In the title you ask &quot;How do you write a simple program for a D-Wave device?&quot;, while in the question body you ask how to find the ground states of a simple 2D Ising model using the underlying hardware of the D-Wave device, and what the corresponding code would be (which is a more specific question).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I will answer the former, since it is the more general question.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;According to the &lt;a href=&quot;https://www.dwavesys.com/software&quot; rel=&quot;noreferrer&quot;&gt;D-Wave Software page&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The D-Wave 2000Q system provides a standard Internet API (based on&#xA;  RESTful services), with client libraries available for C/C++, Python,&#xA;  and MATLAB. This interface allows users to access the system either as&#xA;  a cloud resource over a network, or integrated into their&#xA;  high-performance computing (HPC) environments and data centers. Access&#xA;  is also available through D-Wave’s hosted cloud service. Using D-Wave’s development tools and client libraries, developers can create&#xA;  algorithms and applications within their existing environments using&#xA;  industry-standard tools. &lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;While users can submit problems to the system in a number of different&#xA;  ways, ultimately a problem represents a set of values that correspond&#xA;  to the weights of the qubits and the strength of the couplers. The&#xA;  system takes these values along with other user-specified parameters&#xA;  and sends a single quantum machine instruction (QMI) to the QPU.&#xA;  Problem solutions correspond to the optimal configuration of qubits&#xA;  found; that is, the lowest points in the energy landscape. These&#xA;  values are returned to the user program over the network.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Because quantum computers are probabilistic rather than deterministic,&#xA;  multiple values can be returned, providing not only the best solution&#xA;  found, but also other very good alternatives from which to choose.&#xA;  Users can specify the number of solutions they want the system to&#xA;  return.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;strong&gt;Users can submit problems to the D-Wave quantum computer in several ways:&lt;/strong&gt;&lt;/p&gt;&#xA;  &#xA;  &lt;ol&gt;&#xA;  &lt;li&gt;Using a program in C, C++, Python, or MATLAB to create and execute QMIs&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Using a D-Wave tool such as:&lt;/p&gt;&#xA;  &#xA;  &lt;ul&gt;&#xA;  &lt;li&gt;&lt;p&gt;&lt;strong&gt;QSage&lt;/strong&gt;, a translator designed for optimization problems&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;&lt;strong&gt;ToQ&lt;/strong&gt;, a high level language translator used for constraint &#xA;  satisfaction &#xA;  problems and designed to let users “speak” in the language of their &#xA;  problem domain&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;&lt;strong&gt;qbsolv&lt;/strong&gt;, an open-source, hybrid partitioning optimization solver for &#xA;  problems that are larger than will fit natively on the QPU. Qbsolv can&lt;br&gt;&#xA;  be downloaded &lt;a href=&quot;https://github.com/dwavesystems/qbsolv&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;. &lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;&lt;strong&gt;dw&lt;/strong&gt;, which executes QMIs created via a text editor&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;/ul&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;By directly programming the system via QMIs&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;/ol&gt;&#xA;  &#xA;  &lt;p&gt;&lt;a href=&quot;https://www.dwavesys.com/sites/default/files/Map%20Coloring%20WP2.pdf&quot; rel=&quot;noreferrer&quot;&gt;Download this white paper&lt;/a&gt; to learn more about the programming model for a D-Wave system&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-03-29T12:33:44.610" CommentCount="0" />
  <row Id="1455" PostTypeId="2" ParentId="1451" CreationDate="2018-03-29T12:56:10.520" Score="4" Body="&lt;p&gt;The inputs to the D-Wave are a list of interactions and more recently the annealing time of the qubits. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;As you mentioned the Ising problem is one of the the easiest with $J_{ij} = 1$ in the problem Hamiltonian however it's not very interesting.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I recommend the appendices in this paper for a concise description of how the D-Wave hardware operates. (Full disclosure: I'm a coauthor.)&#xA;&lt;a href=&quot;https://arxiv.org/pdf/1505.01545.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/pdf/1505.01545.pdf&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="54" LastActivityDate="2018-03-29T12:56:10.520" CommentCount="1" />
  <row Id="1456" PostTypeId="2" ParentId="1439" CreationDate="2018-03-29T13:10:48.397" Score="2" Body="&lt;p&gt;Quantum annealing as defined by Chakrabarti 1981 and later implemented by Kadowaki and Nishimori 1998 uses a varying transverse magnetic field to facilitate tunneling through the energy landscape of an optimization problem.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The system is prepared in the ground state of a Hamiltonian and then the transverse field is applied and slowly reduced (adiabatically) while the problem Hamiltonian is simultaneously 'turned on'. If this is done correctly, the system will remain in the ground state throughout the process and you'll have turned off the initial Hamiltonian and turned on the problem Hamiltonian with the system in the ground state (solution). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The temperature of the machine does not change (which is a common misconception), only the transverse magnetic field does. &lt;/p&gt;&#xA;" OwnerUserId="54" LastActivityDate="2018-03-29T13:10:48.397" CommentCount="0" />
  <row Id="1457" PostTypeId="1" CreationDate="2018-03-29T13:53:17.543" Score="9" ViewCount="85" Body="&lt;p&gt;Trapped ion quantum computers are among the most promising approaches to achieve large-scale quantum computation.&#xA;The general idea is to encode the qubits into the electronic states of each ion, and then control the ions via electromagnetic forces.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In this context, I often see that experimental realisation of trapped ion systems use ${}^{40}\!\operatorname{Ca}^+$ ions (see e.g. &lt;a href=&quot;https://arxiv.org/abs/1803.10238&quot; rel=&quot;noreferrer&quot;&gt;1803.10238&lt;/a&gt;).&#xA;Is this always the case? If not, what other kinds of ions are or can be used to build these kinds of trapped ion systems?&#xA;What are the main characteristics that the ions must have to be conveniently used to build trapped ion devices?&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="26" LastEditDate="2018-03-29T18:08:41.953" LastActivityDate="2018-03-30T14:22:42.520" Title="What kinds of ions do trapped ion quantum computers use?" Tags="&lt;quantum-computer&gt;&lt;architecture&gt;&lt;experimental-results&gt;&lt;ion-trap-quantum-computing&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="2" />
  <row Id="1458" PostTypeId="2" ParentId="1457" CreationDate="2018-03-29T14:42:01.807" Score="7" Body="&lt;p&gt;$\require{\mhchem}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are almost too many ion species to list that have been used in ion trap based quantum computing or related experiments. The usual choice is one that is, when singly ionized, hydrogen-like which has convenient consequences for their laser spectroscopy: Then a strong, typically $20$ MHz wide transition lies in the UV or blue end of the laser-accessible spectrum (rather than in the vacuum-UV as it would for ions that need higher than single ionization to become hydrogen-like). Also, the spectrum remains relatively simple (if it is hydrogen-like) meaning there are a limited number of other states that may need their own laser as a repumper laser. It can be advantageous to have one optical meta-stable state that needs a repumper laser because that can be used in measurements and state preparations (or, atypically, to represent one qubit state).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Finally, you typically (but not always) want an ion that has a hyperfine structure because that allows you to use hyperfine states with only a few $\mathrm{GHz}$ energy spacing as qubit states. These states are advantageous because they have century-long decay times, meaning you have practically no decoherence simply from their spontaneous decay (but you do have decoherence from magnetic fields, to which well-chosen states have, however, no linear and only a quadratic dependence).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is also convenient to have a low mass ion because that allows you to build an ion trap with higher motional frequencies (the ion is more strongly confined if its charge-to-mass ratio is high). High motional frequencies imply less (anomalous) heating inside the ion trap and the possibility of faster $2$-qubit gate speeds.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One of the most popular ion species is $\ce{^{171}Yb^+}$ because you have all required lasers in a spectral region (IR and visible) where you can build them with relative simplicity and there is a convenient meta-stable state of about $1\ \mathrm{Hz}$ width (and one with about $1\ \mathrm{nHz}$ width that is irrelevant), and it has a particularly simple hyperfine structure due to its nuclear spin of $1/2$. $\ce{Ca^+}$ is almost as good: If you can live without having a hyperfine structure, $\ce{^{40}Ca^+}$ has equally simple laser requirements and a relatively low mass whilst by tuning your lasers for $\ce{^{43}Ca^+}$ you gain a hyperfine structure at the expense of it being a fairly complicated one due to the nuclear spin of $7/2$. Some groups pursue $\ce{^9Be^+}$ which is cool for being so light and for only needing lasers at essentially the same wavelength, albeit a difficult one ($313\ \mathrm{nm}$). Many other ions have been used experimentally, including $\ce{Sr^+}$, $\require{\mhchem}\ce{Hg^+}$ and a good depiction of the important properties can be found at &lt;a href=&quot;http://iontrap.umd.edu/resources-2/periodic-table/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Chris Monroe's &quot;Ion Periodic Table&quot;&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastEditorUserId="1039" LastEditDate="2018-03-30T14:22:42.520" LastActivityDate="2018-03-30T14:22:42.520" CommentCount="0" />
  <row Id="1459" PostTypeId="2" ParentId="1185" CreationDate="2018-03-29T14:59:26.797" Score="2" Body="&lt;p&gt;If you want to use a quantum circuit as a subroutine (such as an oracle) to a quantum algorithm that makes use of interference, you must allow interference by a process known as uncomputing your ancillary (or, in your words, garbage) qubits. Uncomputing is always possible: Since your gates are reversible, you can just apply their inverse. That is, after the step you mentioned, $\left|x\right&amp;gt;\left|0\right&amp;gt;\left|0\right&amp;gt;\mapsto\left|x\right&amp;gt;\left|f(x)\right&amp;gt;\left|g\right&amp;gt;$, you perform another computation (or uncomputation) that leads to $\left|x\right&amp;gt;\left|f(x)\right&amp;gt;\left|0\right&amp;gt;$.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-03-29T14:59:26.797" CommentCount="0" />
  <row Id="1460" PostTypeId="2" ParentId="136" CreationDate="2018-03-29T16:44:14.823" Score="5" Body="&lt;p&gt;There are several misconceptions here, most of them originate from exposure to only the &lt;em&gt;pure&lt;/em&gt; state formalism of quantum mechanics, so let's address them one by one:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;blockquote&gt;&#xA;  &lt;p&gt;All quantum operations must be unitary to allow reversibility, but&#xA;  what about measurement?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;This is false. In general, the states of a quantum system are not just vectors in a Hilbert space $\mathcal{H}$ but &lt;a href=&quot;https://en.wikipedia.org/wiki/Density_matrix&quot; rel=&quot;nofollow noreferrer&quot;&gt;density matrices&lt;/a&gt; $-$ unit-trace, positive semidefinite operators acting on the Hilbert space $\mathcal{H}$ i.e., $\rho: \mathcal{H} \rightarrow \mathcal{H}$, $Tr(\rho) = 1$, and $\rho \geq 0$ (Note that the pure state vectors are not vectors in the Hilbert space but &lt;strong&gt;rays in a complex projective space&lt;/strong&gt;; for a qubit this amounts to the Hilbert space being $\mathbb{C}P^1$ and not $\mathbb{C}^2$). Density matrices are used to describe a statistical ensemble of quantum states. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The density matrix is called &lt;strong&gt;pure&lt;/strong&gt; if $\rho^2 = \rho$ and &lt;strong&gt;mixed&lt;/strong&gt; if $\rho^2 &amp;lt; \rho$. Once we are dealing with a pure state density matrix (that is, there's no statistical uncertainty involved), since $\rho^2 = \rho$, the density matrix is actually a &lt;a href=&quot;https://en.wikipedia.org/wiki/Projection_(linear_algebra)&quot; rel=&quot;nofollow noreferrer&quot;&gt;projection operator&lt;/a&gt; and one can find a $|\psi\rangle \in \mathcal{H}$ such that $\rho = |\psi\rangle \langle\psi|$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The most general quantum operation is a CP-map (completely positive map), i.e., $\Phi: L(\mathcal{H}) \rightarrow L(\mathcal{H})$ such that $$\Phi(\rho) = \sum_i K_i \rho K_i^\dagger; \sum_i K_i^\dagger K_i \leq \mathbb{I}$$ (if $\sum_i K_i^\dagger K_i = \mathbb{I}$ then these are called CPTP (completely positive and &lt;strong&gt;trace-preserving&lt;/strong&gt;) map or a &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_channel&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum channel&lt;/a&gt;) where the $\{K_i\}$ are called &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_operation#Kraus_operators&quot; rel=&quot;nofollow noreferrer&quot;&gt;Kraus operators&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Now, coming to the OP's claim that all quantum operations are unitary to allow reversibility -- this is just not true. The unitarity of time evolution operator ($e^{-iHt/\hbar}$) in quantum mechanics (for closed system quantum evolution) is simply a consequence of the Schrödinger equation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, when we consider density matrices, the most general evolution is a CP-map (or CPTP for a closed system to preserve the trace and hence the probability).&lt;/p&gt;&#xA;&#xA;&lt;ol start=&quot;2&quot;&gt;&#xA;&lt;li&gt;&lt;blockquote&gt;&#xA;  &lt;p&gt;Are there any situations where non-unitary gates might be allowed?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Yes. An important example that comes to mind is open quantum systems where Kraus operators (which are not unitary) are the &quot;gates&quot; with which the system evolves.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that if there is only a single Kraus operator then, $\sum_i K_i^\dagger K_i = \mathbb{I}$. But there's only one $i$, therefore, we have, $K^\dagger K = \mathbb{I}$ or, $K$ is unitary. So the system evolves as $\rho \rightarrow U \rho U^\dagger$ (which is the standard evolution that you may have seen before). However, in general, there are several Kraus operators and therefore the evolution is non-unitary.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Coming to the final point:&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;ol start=&quot;3&quot;&gt;&#xA;&lt;li&gt;&lt;blockquote&gt;&#xA;  &lt;p&gt;Measurement can be represented as a matrix, and that matrix is applied to qubits, so that seems equivalent to the operation of a quantum gate. That's definitively not reversible.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;In standard quantum mechanics (with wavefunctions etc.), the system's evolution is composed of two parts $-$ a &lt;em&gt;smooth&lt;/em&gt; unitary evolution under the system's Hamiltonian and then a &lt;em&gt;sudden&lt;/em&gt; quantum jump when a measurement is made $-$ also known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Wave_function_collapse&quot; rel=&quot;nofollow noreferrer&quot;&gt;wavefunction collapse&lt;/a&gt;. Wavefunction collapses are described as some projection operator say $|\phi\rangle \langle\phi|$ acting on the quantum state $|\psi\rangle$ and the $|\langle\phi|\psi\rangle|^2$ gives us the probability of finding the system in the state $|\phi\rangle$ after the measurement. Since the measurement operator is after all a projector (or as the OP suggests, a matrix), shouldn't it be linear and physically similar to the unitary evolution (also happening via a matrix). This is an interesting question and in my opinion, difficult to answer physically. However, I can shed some light on this mathematically.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we are working in the modern formalism, then measurements are given by &lt;a href=&quot;https://en.wikipedia.org/wiki/POVM&quot; rel=&quot;nofollow noreferrer&quot;&gt;POVM elements&lt;/a&gt;; Hermitian positive semidefinite operators, $\{M_{i}\}$ on a Hilbert space $\mathcal{H}$ that sum to the identity operator (on the Hilbert space) $\sum _{{i=1}}^{n}M_{i}=\mathbb{I}$. Therefore, a measurement takes the form $$ \rho \rightarrow \frac{E_i \rho E_i^\dagger}{\text{Tr}(E_i \rho E_i^\dagger)}, \text{ where } M_i = E_i^\dagger E_i.$$ &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The $\text{Tr}(E_i \rho E_i^\dagger) =: p_i$ is the probability of the measurement outcome being $M_i$ and is used to &lt;em&gt;renormalize&lt;/em&gt; the state to unit trace. Note that the numerator, $\rho \rightarrow E_i \rho E_i^\dagger$ is a linear operation, but the probabilistic dependence on $p_i$ is what brings in the &lt;em&gt;non-linearity&lt;/em&gt; or &lt;em&gt;irreversibility&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Edit 1: You might also be interested &lt;a href=&quot;https://en.wikipedia.org/wiki/Stinespring_factorization_theorem&quot; rel=&quot;nofollow noreferrer&quot;&gt;Stinespring dilation theorem&lt;/a&gt; which gives you an isomorphism between a CPTP map and a unitary operation on a larger Hilbert space followed by partial tracing the (tensored) Hilbert space (see &lt;a href=&quot;https://www.quantiki.org/wiki/church-larger-hilbert-space#Stinespring&amp;#39;s_dilation_theorem&quot; rel=&quot;nofollow noreferrer&quot;&gt;1&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1110.6815&quot; rel=&quot;nofollow noreferrer&quot;&gt;2&lt;/a&gt;).&lt;/p&gt;&#xA;" OwnerUserId="1108" LastEditorUserId="1108" LastEditDate="2018-03-30T21:31:32.220" LastActivityDate="2018-03-30T21:31:32.220" CommentCount="0" />
  <row Id="1461" PostTypeId="1" AcceptedAnswerId="1476" CreationDate="2018-03-29T16:54:30.243" Score="8" ViewCount="144" Body="&lt;p&gt;My understanding so far is: a pure state is a basic state of a system, and a mixed state represents uncertainty about the system, i.e. the system is in one of a set of states with some (classical) probability. However, superpositions seem to be a kind of mix of states as well, so how do they fit into this picture?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, consider a fair coin flip. You can represent it as a mixed state of “heads” $\left|0\right&amp;gt;$ and “tails” $\left|1\right&amp;gt;$: $$ \rho_1 = \sum_j \frac{1}{2} \left|\psi_j\right&amp;gt; \left&amp;lt;\psi_j\right| = \frac{1}{2} \begin{pmatrix} 1 &amp;amp; 0 \\ 0 &amp;amp; 1 \end{pmatrix} $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, we can also use the superposition of “heads” and “tails”: specific state $\psi = \frac{1}{\sqrt{2}}\left( \left|0\right&amp;gt; + \left|1\right&amp;gt; \right)$ with density&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ \rho_2 = \left|\psi\right&amp;gt; \left&amp;lt;\psi\right| = \frac{1}{2} \begin{pmatrix} 1 &amp;amp; 1 \\ 1 &amp;amp; 1 \end{pmatrix} $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we measure in the computational basis, we will get the same result. What is the difference between a superposed and a mixed state?&lt;/p&gt;&#xA;" OwnerUserId="580" LastEditorUserId="580" LastEditDate="2018-03-29T22:16:51.247" LastActivityDate="2018-03-29T22:16:51.247" Title="What is the difference between superpositions and mixed states?" Tags="&lt;superposition&gt;&lt;quantum-state&gt;" AnswerCount="2" CommentCount="5" FavoriteCount="1" />
  <row Id="1462" PostTypeId="1" AcceptedAnswerId="1501" CreationDate="2018-03-29T16:59:39.067" Score="4" ViewCount="139" Body="&lt;p&gt;A string of $n$ qutrits  has a state-space spanned by the $3^n$ different states $\lvert x \rangle $ for strings $x \in \{0,1,2\}^n$ (or $x \in  \{-1,0,+1\}^n$, equivalently), while $n $ qubits can only represent $2^n$ computational basis states.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;According to   &lt;a href=&quot;https://en.wikipedia.org/wiki/Qutrit&quot; rel=&quot;nofollow noreferrer&quot;&gt;the Wikipedia article on qutrits&lt;/a&gt;, &quot;qutrits ... are more robust to decoherence under certain environmental interactions&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Does the increase of possible simultaneous states represented, result in robustness to decoherence?&lt;/p&gt;&#xA;" OwnerUserId="609" LastEditorUserId="26" LastEditDate="2018-05-07T13:39:05.200" LastActivityDate="2018-05-07T13:39:05.200" Title="Are qutrits more robust to decoherence?" Tags="&lt;quantum-decoherence&gt;&lt;qudit&gt;&lt;qutrit&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="1464" PostTypeId="2" ParentId="1461" CreationDate="2018-03-29T17:20:20.283" Score="4" Body="&lt;p&gt;The short answer is that there is more to quantum information than &quot;uncertainty&quot;. This is because there is more than one way to measure a state; and &lt;em&gt;that&lt;/em&gt; is because there is more than one basis in which, in principle, you can store and retrieve information. Superpositions allow you to express information in a different basis than the computational basis &amp;mdash; but &lt;strong&gt;mixtures&lt;/strong&gt; describe the presence of a probabilistic element, no matter which basis you use to look at the state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The longer answer is as follows &amp;mdash;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Measurement as you have described it is specifically measurement in the computational basis. This is often described just as &quot;measurement&quot; for the sake of brevity, and large subsets of the community think in terms of this being the primary way to measure things. But in many physical systems, it is possible to &lt;em&gt;choose a measurement basis&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A vector space over $\mathbb C$ has more than one basis (even more than one orthonormal basis), and on a mathematical level there isn't much that makes one basis more special than another, aside from what is convenient for the mathematician to think about. The same is true in quantum mechanics: unless you specify some specific dynamics, there is no basis which is more special than the others. That means that the computational basis&#xA;$$ \lvert 0 \rangle = \begin{bmatrix} 1 \\ 0 \end{bmatrix}, \qquad \lvert 1 \rangle = \begin{bmatrix} 0 \\ 1 \end{bmatrix}$$&#xA;is not fundamentally different physically from another basis such as&#xA;$$ \lvert + \rangle = \tfrac{1}{\sqrt 2}\begin{bmatrix} 1 \\ 1 \end{bmatrix}, \qquad \lvert - \rangle = \tfrac{1}{\sqrt 2}\begin{bmatrix} 1 \\ -1 \end{bmatrix},$$&#xA;which is also an orthonormal basis. That means that there should be a way to &quot;measure&quot; a state $\lvert \psi \rangle \in \mathbb C^2$ in such a way that the probabilities of the outcomes depend on projections onto these states $\lvert + \rangle$ and $\lvert - \rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In some physical systems, the way one performs this measurement is to literally take the same apparatus and tilt it so that it is aligned with the X axis instead of the Z axis. Mathematically, the way we do this is to consider the projectors&#xA;$$ \Pi_+ = \lvert + \rangle\!\langle + \rvert = \tfrac{1}{2}\begin{bmatrix} 1 &amp;amp; 1 \\ 1 &amp;amp; 1 \end{bmatrix}, \qquad \Pi_- =  \lvert - \rangle\!\langle - \rvert = \tfrac{1}{2}\begin{bmatrix} 1 &amp;amp; -1 \\ -1 &amp;amp; 1 \end{bmatrix}$$&#xA;and then to ask what the projections $\lvert \varphi_+ \rangle := \Pi_+ \lvert \psi \rangle$ and $\lvert \varphi_- \rangle := \Pi_- \lvert \psi \rangle$. The norm-squared of $\lvert \varphi_\pm \rangle$ determines the probability of &quot;measuring $\lvert + \rangle$&quot; and of &quot;measuring $\lvert - \rangle$&quot;; and normalising $\lvert \varphi_+ \rangle$ or $\lvert \varphi_- \rangle$ to have a norm of 1 yields the post-measurement state. (For a state on a single qubit, this will just be $\lvert + \rangle$ or $\lvert - \rangle$. More interesting post-measurement states may result if we consider multi-qubit states, and consider the projector $\Pi_+$ or $\Pi_-$ acting on one of many qubits.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For density operators, one takes the state $\rho$ which you want to perform a measurement on, and consider $\rho_+ := \Pi_+ \rho \Pi_+$ and $\rho_- := \Pi_- \rho \Pi_-$. These operators may be sub-normalised in the same way that the states $\lvert \varphi_\pm \rangle$ might be, in the sense that they may have trace less than 1. The value of the trace of $\rho_\pm$ is the probability of obtaining the outcome $\lvert + \rangle$ or $\lvert - \rangle$ of the measurement; to renormalise, simply scale the projected operator to have trace 1.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Consider your state $\rho_2$ above. If you measure it with respect to the $\lvert \pm \rangle$ basis, what you will find is that $\rho_2 = \rho_{2,+} := \Pi_+ \rho_2 \Pi_+$. This means that projecting the operator with $\Pi_+$ does change the state, and that the probability of obtaining the outcome $\lvert + \rangle$ to the measurement is 1. If you do this instead with $\rho_1$, you will find a 50/50 chance of obtaining either $\lvert + \rangle$ or $\lvert - \rangle$. So the state $\rho_1$ is a mixed state, while $\rho_2 $ is not --- the difference being that $\rho_2$ has a definite outcome in a &lt;em&gt;different&lt;/em&gt; measurement basis than the standard basis. You might say that $\rho_2$ stores a &lt;em&gt;definite&lt;/em&gt; piece of information, albeit in a different basis than the computational basis.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;More generally, a mixed state is one whose largest eigenvalue is less than 1, meaning that there is no basis in which you can measure it to get a definite outcome. Superpositions allow you to express information in a different basis than the computational basis; mixtures represent a degree of randomness about the state of the system you're considering, regardless of how you measure that system.&lt;/p&gt;&#xA;" OwnerUserId="124" LastActivityDate="2018-03-29T17:20:20.283" CommentCount="0" />
  <row Id="1467" PostTypeId="2" ParentId="1404" CreationDate="2018-03-29T18:27:14.720" Score="9" Body="&lt;p&gt;This is very much an open question, but yes, there is a considerable amount of work that is being done on this front.&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;Some clarifications&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;It is, first of all, to be noted that there are two major ways to merge machine learning (and deep learning in particular) with quantum mechanics/quantum computing:&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;1) ML $\to$ QM&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Apply classical machine learning techniques to tackle problems arising in the context of quantum mechanics/quantum information/quantum computation&lt;/em&gt;&lt;/strong&gt;.&#xA;This area is growing too fast for me to even attempt a decent list of references, so I will just link to a couple of the most recent works in this direction: in &lt;a href=&quot;https://arxiv.org/abs/1803.04114&quot; rel=&quot;nofollow noreferrer&quot;&gt;1803.04114&lt;/a&gt; the authors used a machine learning approach to find circuits to compute the overlap between two states (there are a number of other works in this same direction), and in &lt;a href=&quot;https://arxiv.org/abs/1803.05193&quot; rel=&quot;nofollow noreferrer&quot;&gt;1803.05193&lt;/a&gt; the authors studied how deep neural networks can be used to find quantum control correction schemes.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;2) QM $\to$ ML&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Study of quantum algorithms to analyze big data&lt;/em&gt;&lt;/strong&gt;, which often amounts to look for &quot;&lt;em&gt;quantum generalizations&lt;/em&gt;&quot; of classical machine learning algorithms. You can have a look at &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1268/55&quot;&gt;this other answer of mine&lt;/a&gt; to get some basic references about this topic.&#xA;More specifically for the case of &lt;em&gt;deep learning&lt;/em&gt;, in &lt;a href=&quot;https://arxiv.org/abs/1412.3489&quot; rel=&quot;nofollow noreferrer&quot;&gt;1412.3489&lt;/a&gt; (aptly named &lt;em&gt;Quantum Deep Learning&lt;/em&gt;) the authors propose a method (effectively, a quantum algorithm) to generally speed-up the training of deep, &lt;a href=&quot;https://en.wikipedia.org/wiki/Restricted_Boltzmann_machine&quot; rel=&quot;nofollow noreferrer&quot;&gt;restricted Boltzmann machines&lt;/a&gt;.&#xA;Another relevant reference here is &lt;a href=&quot;https://arxiv.org/abs/1712.05304&quot; rel=&quot;nofollow noreferrer&quot;&gt;1712.05304&lt;/a&gt;, in which the authors develop a low-depth quantum algorithm to train quantum Boltzmann machines.&#xA;See &lt;a href=&quot;https://arxiv.org/abs/1708.09757&quot; rel=&quot;nofollow noreferrer&quot;&gt;1708.09757&lt;/a&gt;, as well as the references in the linked answer, to find many more works on this. Note that the speed-up that is claimed in these works can vary wildly, from exponential speed-ups to polynomial ones.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Sometimes the speed-up comes from the use of quantum algorithms to solve particular linear algebraic problems (see e.g. Table 1 in (&lt;a href=&quot;https://arxiv.org/pdf/1707.08561&quot; rel=&quot;nofollow noreferrer&quot;&gt;1707.08561&lt;/a&gt;), sometimes it comes from what basically amounts to the use of (variations of) Grover's search, and sometimes from other things (but mostly these two).&#xA;Quoting from Dunjko and Briegel &lt;a href=&quot;https://arxiv.org/abs/1709.02779&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The ideas for quantum-enhancements for ML can roughly be classified&#xA;  into two groups: a) approaches which rely on Grover’s search and&#xA;  amplitude amplification to obtain up-to-quadratic speed-ups, and, b)&#xA;  approaches which encode relevant information into quantum amplitudes,&#xA;  and which have a potential for even exponential improvements. The&#xA;  second group of approaches forms perhaps the most developed research&#xA;  line in quantum ML, and collects a plethora quantum tools – most&#xA;  notably quantum linear algebra, utilized in quantum ML proposals.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h1&gt;More direct answer to the three questions&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Having said the above, let me more directly answer the three points you raised:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;em&gt;Could a deep learning algorithm run on a quantum computer?&lt;/em&gt; Most definitely yes: if you can run something on a classical computer you can do it on quantum computers. However, the question one should be asking is rather &lt;em&gt;can a quantum (deep) machine learning algorithm be more efficient than the classical counterparts&lt;/em&gt;? The answer to &lt;em&gt;this&lt;/em&gt; question is trickier. &lt;em&gt;Possibly yes&lt;/em&gt;, there are many proposals in this direction, but it still too soon to be sure what will or will not work.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;em&gt;Does it make sense to try?&lt;/em&gt; Yes!&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;em&gt;Are there other quantum algorithms that would make deep learning irrelevant?&lt;/em&gt; This strongly depends on what you mean by &quot;&lt;em&gt;irrelevant&lt;/em&gt;&quot;. I mean, for what is known at the moment, there may very well be &lt;em&gt;classical&lt;/em&gt; algorithms that will make deep learning &quot;irrelevant&quot;.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-04-18T16:53:03.317" LastActivityDate="2018-04-18T16:53:03.317" CommentCount="2" />
  <row Id="1468" PostTypeId="1" AcceptedAnswerId="1469" CreationDate="2018-03-29T18:38:00.123" Score="2" ViewCount="205" Body="&lt;p&gt;From &lt;a href=&quot;https://en.wikipedia.org/wiki/Qubit&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wikipedia&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;A qubit is a two-state quantum system [...] &lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;There are two possible&#xA;  outcomes for the measurement of a qubit — usually $0$ and $1$, like a bit.&#xA;  The difference is that whereas the state of a bit is either $0$ or $1$,&#xA;  the state of a qubit can also be a superposition of both.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Is it true that quantum computing must be based on qubits, limiting it to only a two-state quantum system? Is it physically possible to build a $n$-state quantum-system (where $n&amp;gt;2$)?&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;sub&gt;This is 'repost' of a (&quot;legitimate&quot;) question was deleted by the OP, &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1465/why-does-quantum-computing-is-limited-to-a-superposition-of-only-two-states&quot;&gt;here&lt;/a&gt;. I decided to repost it along with the answer which I started writing.&lt;/sub&gt;&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="253" LastEditDate="2018-03-29T19:05:45.680" LastActivityDate="2018-03-30T16:26:44.220" Title="Is quantum computing limited to a superposition of only two states?" Tags="&lt;qubit&gt;&lt;qudit&gt;" AnswerCount="2" CommentCount="7" />
  <row Id="1469" PostTypeId="2" ParentId="1468" CreationDate="2018-03-29T18:38:00.123" Score="3" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Is quantum computing limited to a superposition of only two&#xA;  states?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;In theory it is not. Keep in mind that a qubit is a quantum analogue of the classical &quot;bit&quot; which has only two states $0$ and $1$. In principle, there is no limit to the dimension of the state space of a quantum system. There could even be a &quot;infinite&quot; dimensional separable Hilbert space (in short, separable means denumerable/countable with a one-one onto mapping to the natural numbers). &lt;a href=&quot;https://physics.stackexchange.com/questions/60608/nonseparable-hilbert-space&quot;&gt;For non-separable Hilbert spaces there are some complications involved.&lt;/a&gt;&#xA;In the context of quantum information systems with state space dimension greater than $2$ are called &quot;&lt;a href=&quot;https://spectrum.ieee.org/tech-talk/computing/hardware/qudits-the-real-future-of-quantum-computing&quot; rel=&quot;nofollow noreferrer&quot;&gt;qudits&lt;/a&gt;&quot;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;And yes, there has been ongoing work to make physical implementations of higher dimensional quantum systems, like qutrits (with trapped ions), as mentioned by &lt;a href=&quot;https://quantumcomputing.stackexchange.com/users/54/andrew-o&quot;&gt;@Andrew O&lt;/a&gt;, &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1466/26&quot;&gt;on their currently deleted answer&lt;/a&gt; (only users having the priviledge to view deleted posts can see it at present).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Relevant paper: &lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.67.062313&quot; rel=&quot;nofollow noreferrer&quot;&gt;Qutrit quantum computer with trapped ions-A. B. Klimov, R. Guzmán, J. C. Retamal, and C. Saavedra&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;@glS mentions &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1468/is-quantum-computing-limited-to-a-superposition-of-only-two-states?noredirect=1#comment994_1469&quot;&gt;here&lt;/a&gt; that in some cases making higher dimensional quantum systems can in fact be easier, which is an interesting fact I did not know earlier. &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;In the context of photonics for example, it is relatively easy to&#xA;  generate states in high-dimensional Hilbert spaces, for example&#xA;  exploiting the orbital angular momentum of single photons. See for&#xA;  example &lt;a href=&quot;https://arxiv.org/abs/1607.05114&quot; rel=&quot;nofollow noreferrer&quot;&gt;1607.05114&lt;/a&gt; and the many&#xA;  references therein, or &lt;a href=&quot;https://arxiv.org/abs/1207.2376&quot; rel=&quot;nofollow noreferrer&quot;&gt;Fickler&#xA;  2012&lt;/a&gt;, in which they experimentally&#xA;  demonstrate entanglement of states living in 600-dimensional Hilbert&#xA;  spaces.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;@glS also mentions in the &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1468/is-quantum-computing-limited-to-a-superposition-of-only-two-states?noredirect=1#comment999_1469&quot;&gt;following comment&lt;/a&gt; that &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;It is also to be noted that the matter of non-separability is&#xA;  absolutely a non-issue for practical implementation of whatever&#xA;  protocol, and also that &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous-variable_quantum_information&quot; rel=&quot;nofollow noreferrer&quot;&gt;continuous variable quantum computation&lt;/a&gt; is a&#xA;  big subject in quantum computing &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-03-30T16:26:44.220" LastActivityDate="2018-03-30T16:26:44.220" CommentCount="6" />
  <row Id="1471" PostTypeId="1" AcceptedAnswerId="1482" CreationDate="2018-03-29T19:15:12.063" Score="7" ViewCount="141" Body="&lt;p&gt;This recent press release claiming that &lt;a href=&quot;https://www.tue.nl/en/university/news-and-press/news/01-01-1970-improved-measurements-bring-final-proof-of-majorana-particles-closer-than-ever/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Improved measurements bring final proof of Majorana particles closer than ever&lt;/a&gt;, which summarizes the results of a recent paper in Nature simply entitled &quot;&lt;a href=&quot;https://www.nature.com/articles/nature26142&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantized Majorana conductance&lt;/a&gt;&quot; claims that &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Thanks to their unique physical characteristics, Majorana particles are much more stable than most other qubits.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Why would this be the case (in theory, at least). Is the approach to qubits with Majorana particles considered to be valid, or are they surrounded by skepticism?&lt;/p&gt;&#xA;" OwnerUserId="253" LastEditorUserId="26" LastEditDate="2018-05-07T13:19:50.577" LastActivityDate="2018-05-07T13:19:50.577" Title="How could Majorana particles be used to improve quantum computers?" Tags="&lt;qubit&gt;&lt;quantum-error-correction&gt;&lt;majorana-particle&gt;" AnswerCount="2" CommentCount="2" />
  <row Id="1472" PostTypeId="1" AcceptedAnswerId="1475" CreationDate="2018-03-29T19:22:49.070" Score="9" ViewCount="551" Body="&lt;p&gt;The terms &lt;a href=&quot;http://www.mcclatchydc.com/news/nation-world/national/national-security/article179971861.html&quot; rel=&quot;noreferrer&quot;&gt;Quantum Computing Race&lt;/a&gt; and &lt;a href=&quot;https://www.wsj.com/podcasts/the-global-race-for-quantum-computing-supremacy/B32A35C3-751D-4079-98CF-703E2E9BAB35.html&quot; rel=&quot;noreferrer&quot;&gt;Global Quantum Computing Race&lt;/a&gt; have been used in the press and research communities lately in an effort to describe countries making investments into a &quot;battle&quot; to create the first universal quantum computer. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;What countries are leading this &quot;Global Quantum Computing Race&quot;?&lt;/p&gt;&#xA;" OwnerUserId="1280" LastEditorUserId="274" LastEditDate="2018-03-29T20:47:59.697" LastActivityDate="2018-08-30T14:54:19.240" Title="What countries are leading this &quot;Global Quantum Computing Race&quot;?" Tags="&lt;quantum-computer&gt;&lt;quantum-supremacy&gt;" AnswerCount="2" CommentCount="11" FavoriteCount="1" />
  <row Id="1473" PostTypeId="2" ParentId="1471" CreationDate="2018-03-29T19:27:28.393" Score="4" Body="&lt;p&gt;I heard an interesting analogy that shed some light on the situation for me, so I'll share it here. Majorana fermions are topologically based; let's look at what topology sort of &quot;means&quot;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Topology looks at the bigger picture. If you have a balloon, no matter how much you blow it up, take air out, or tie it up in knots (if you're a balloon artist), it still doesn't have holes in it. To have holes would make it fundamentally different. You can stretch and shrink and twist a sphere all you want, but it's never going to turn into a donut. If you take a donut, though, you can twist that into all sorts of things with holes - but you can never make something without holes, like a sphere, or with two or more holes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Another example of topology looking at the bigger picture. Take a balloon (again) and zoom in on its surface. Even though the balloon is curved when you zoom out, when you're zoomed in, it looks like a 2-d Euclidean plane. If you zoom in on a circle, it looks like a 1-d Euclidean plane. The little twists and turns don't matter in topology.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's bring this back towards Majorana fermions. Let's picture a system where we're registering if the electron goes all the way around a tree or not. It doesn't matter whether the electron has a really squiggly nutty path or a just a simple circular path - it still goes around. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The noise introduced in these systems might make the electron's path squiggly or it might not, but it doesn't actually &lt;em&gt;matter&lt;/em&gt;. It still goes around. That's where the advantage in Majorana fermions lies - the noise doesn't affect it.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Obviously this isn't rigorous; I'll try to add more that sheds light on that as I have time.&lt;/p&gt;&#xA;" OwnerUserId="91" LastActivityDate="2018-03-29T19:27:28.393" CommentCount="4" />
  <row Id="1474" PostTypeId="1" AcceptedAnswerId="1524" CreationDate="2018-03-29T19:39:56.853" Score="38" ViewCount="1978" Body="&lt;p&gt;From this question, I gathered that the main quantum computing programming languages are &lt;a href=&quot;https://www.microsoft.com/en-us/quantum/development-kit&quot; rel=&quot;noreferrer&quot;&gt;Q#&lt;/a&gt; and &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/experience&quot; rel=&quot;noreferrer&quot;&gt;QISKit&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What other programming languages are available for programming quantum computers? Are there certain benefits to choosing particular ones?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;EDIT: I am looking for programming languages, not emulators. Emulators simulate things. Programming languages are a method of writing instructions (either for real objects or for emulators). There may be a single language that works for multiple emulators and vice versa.&lt;/p&gt;&#xA;" OwnerUserId="1289" LastEditorUserId="26" LastEditDate="2018-03-29T21:46:14.157" LastActivityDate="2018-08-07T21:06:07.660" Title="What programming languages are available for quantum computers?" Tags="&lt;quantum-programming&gt;" AnswerCount="4" CommentCount="3" FavoriteCount="17" />
  <row Id="1475" PostTypeId="2" ParentId="1472" CreationDate="2018-03-29T19:56:15.037" Score="12" Body="&lt;p&gt;There are several countries that are actively participating in the &quot;Quantum Race&quot;, most of which are making significant investments. The estimated annual spending on non-classified quantum-technology research in 2015 broke down like this: &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;United States (360 €m)&lt;/li&gt;&#xA;&lt;li&gt;China (220 €m)&lt;/li&gt;&#xA;&lt;li&gt;Germany (120 €m)&lt;/li&gt;&#xA;&lt;li&gt;Britain (105 €m)&lt;/li&gt;&#xA;&lt;li&gt;Canada (100 €m)&lt;/li&gt;&#xA;&lt;li&gt;Australia (75 €m)&lt;/li&gt;&#xA;&lt;li&gt;Switzerland (67 €m)&lt;/li&gt;&#xA;&lt;li&gt;Japan (63€m)&lt;/li&gt;&#xA;&lt;li&gt;France (52 €m)&lt;/li&gt;&#xA;&lt;li&gt;Singapore (44 €m)&lt;/li&gt;&#xA;&lt;li&gt;Italy (36 €m)&lt;/li&gt;&#xA;&lt;li&gt;Austria (35 €m)&lt;/li&gt;&#xA;&lt;li&gt;Russia (30 €m)&lt;/li&gt;&#xA;&lt;li&gt;Netherlands (27 €m)&lt;/li&gt;&#xA;&lt;li&gt;Spain (25 €m)&lt;/li&gt;&#xA;&lt;li&gt;Denmark (22 €m)&lt;/li&gt;&#xA;&lt;li&gt;Sweden (15 €m)&lt;/li&gt;&#xA;&lt;li&gt;South Korea (13 €m)&lt;/li&gt;&#xA;&lt;li&gt;Finland (12 €m)&lt;/li&gt;&#xA;&lt;li&gt;Poland (12 €m)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;If you chart that out, it looks something like this: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/lzKJY.jpg&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/lzKJY.jpg&quot; alt=&quot;Global Quantum Spending in 2015&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As you can see the European Union invested a combined 550 €m. It's also interesting to see how this investment correlates to patent applications from each of these countries: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/RX6z7.jpg&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/RX6z7.jpg&quot; alt=&quot;Patent Applications Per Country (2015)&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Since 2015 the interest from countries in quantum computing has grown significantly. The worldwide investment has now broken 2,000 €m. The biggest increase has been seen in China's spending which encompasses quantum computing but includes quantum information systems as well. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are several examples of countries investing in quantum computing in the past year that might be of particular interest. These include:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;China&lt;/strong&gt; - In 2017 China announced that it was set to open a National Laboratory for Quantum Information Sciences by 2020. This included a 92-Acre, $10 Billion quantum research center.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Japan&lt;/strong&gt; - In 2017 in a joint, state-sponsored research project with Japan’s National Institute of Informatics and the University of Tokyo produced the machine, Nippon Telegraph and Telephone (NTT) shared a prototype quantum computer for public use over the internet. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Sweden&lt;/strong&gt; - In 2017 Sweden invested 1 billion Swedish Krona (roughly $118 million or 100m €) into a research initiative with the goal of developing a &quot;robust quantum computer&quot;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that the United States has been seen as not investing enough into quantum computing and over the summer academia and industry testified before the U.S. House Subcommittees on Research &amp;amp; Technology and Energy in an effort to spur investment into this space. Most notably Dr. Christopher Monroe was quoted as saying that &lt;em&gt;&quot;U.S. leadership in quantum technology will be critical to our national security, and will open new doors for private industry and academia while ensuring America’s role as a global technology leader in the 21st century.”&lt;/em&gt;  &lt;/p&gt;&#xA;" OwnerUserId="274" LastEditorUserId="274" LastEditDate="2018-03-29T20:33:30.183" LastActivityDate="2018-03-29T20:33:30.183" CommentCount="10" />
  <row Id="1476" PostTypeId="2" ParentId="1461" CreationDate="2018-03-29T20:03:59.833" Score="5" Body="&lt;p&gt;&lt;strong&gt;&lt;em&gt;No&lt;/em&gt;&lt;/strong&gt;, a &lt;em&gt;superposition&lt;/em&gt; of two different states is a completely different beast than a &lt;em&gt;mixture&lt;/em&gt; of the same states.&#xA;While it may appear from your example that $\rho_1$ and $\rho_2$ produce the same measurement outcomes (and that is indeed the case), &lt;a href=&quot;https://physics.stackexchange.com/a/376384/58382&quot;&gt;as soon as you measure in a different basis they will give measurably different results&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A &quot;superposition&quot; like $\newcommand{\up}{|\!\!\uparrow\rangle}\newcommand{\down}{|\!\!\downarrow\rangle}|\psi\rangle=\frac{1}{\sqrt2}(\up+\down)$ is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_state#Pure_states&quot; rel=&quot;noreferrer&quot;&gt;pure state&lt;/a&gt;. This means that it is a completely characterised state.&#xA;In other words, there is no amount of information that, added to its description, could make it &quot;less undetermined&quot;.&#xA;Note that &lt;em&gt;every pure state&lt;/em&gt; can be written as superposition of other pure states.&#xA;Writing a given state $|\psi\rangle$ as a superposition of other states is literally the same thing as writing a vector $\boldsymbol v$ in terms of some basis: you can always change the basis and find a different representation of $\boldsymbol v$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is in direct contrast to a &lt;em&gt;mixed state&lt;/em&gt; like $\rho_1$ in your question.&#xA;In the case of $\rho_1$, the probabilistic nature of the outcomes &lt;em&gt;depends on our ignorance about the state itself&lt;/em&gt;. This means that, in principle, it is possible to acquire some additional information that will tell us whether $\rho_2$ is indeed in the state $\up$ or in the state $\down$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A mixed state cannot, in general, be written as a pure state.&#xA;This should be clear from the above physical intuition: mixed states represent &lt;em&gt;our ignorance&lt;/em&gt; about a physical state, while &lt;em&gt;pure states&lt;/em&gt; are completely defined states, which just so happen to still give probabilistic outcomes due to the way quantum mechanics work.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Indeed, there is a simple criterion to tell whether a given (generally mixed) state $\rho$ can be written as $|\psi\rangle\langle\psi|$ for some (pure) state $|\psi\rangle$: computing its &lt;a href=&quot;https://en.wikipedia.org/wiki/Purity_(quantum_mechanics)&quot; rel=&quot;noreferrer&quot;&gt;&lt;em&gt;purity&lt;/em&gt;&lt;/a&gt;.&#xA;The purity of a state $\rho$ is defined as $\operatorname{Tr} \,(\rho^2)$, and it is a standard result that the purity of state is $1$ &lt;em&gt;if and only if&lt;/em&gt; the state is pure (and lesser than $1$ otherwise).&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-03-29T21:02:15.857" LastActivityDate="2018-03-29T21:02:15.857" CommentCount="6" />
  <row Id="1477" PostTypeId="2" ParentId="1462" CreationDate="2018-03-29T20:22:14.157" Score="4" Body="&lt;p&gt;The statement in Wikipedia is very generic, and only cites &lt;a href=&quot;https://journals.aps.org/prb/abstract/10.1103/PhysRevB.70.014435&quot; rel=&quot;nofollow noreferrer&quot;&gt;this paper&lt;/a&gt; as a reference.&#xA;Quoting from the abstract of the paper:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;We demonstrate that decoherence of many-spin systems can drastically&#xA;  differ from decoherence of single spin systems. The difference&#xA;  originates at the most basic level, being determined by parity of the&#xA;  central system, i.e., by whether the system comprises even or odd&#xA;  number of spin-1/2 entities. Therefore, it is very likely that similar&#xA;  distinction between the central spin systems of even and odd parity is&#xA;  important in many other situations. Our consideration clarifies the&#xA;  physical origin of the unusual two-step decoherence found previously&#xA;  in the two-spin systems&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;As can be understood from the above excerpt, the paper is referring to a very specific situation, and it is by no means substantiating a broad claim such as &quot;qutrits are more robust to decoherence&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Moreover, to say &quot;system X is more robust to decoherence under certain environmental interactions&quot; is generic enough to be always true, as one can always find a kind of &quot;environmental interaction&quot; in which the system X is more stable than the system Y.&lt;/p&gt;&#xA;" OwnerUserId="55" LastActivityDate="2018-03-29T20:22:14.157" CommentCount="0" />
  <row Id="1478" PostTypeId="1" AcceptedAnswerId="1479" CreationDate="2018-03-29T20:26:16.033" Score="10" ViewCount="76" Body="&lt;p&gt;I was wondering if there is a source (online or review article) which tabulates recent algorithms, and their complexities, used in simulating various physical systems. Something along the lines of:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Physical System 1&lt;/strong&gt;: Quantum Field Theory (scattering)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Complexity&lt;/strong&gt;: Polynomial in number of particles, energy, and precision&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Source&lt;/strong&gt;: &lt;a href=&quot;https://arxiv.org/abs/1111.3633&quot; rel=&quot;noreferrer&quot;&gt;https://arxiv.org/abs/1111.3633&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Physical System 2&lt;/strong&gt;: Atomic Energy levels ...&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And so on.&lt;/p&gt;&#xA;" OwnerUserId="1287" LastEditorUserId="26" LastEditDate="2018-03-29T20:29:09.490" LastActivityDate="2018-04-19T06:20:25.307" Title="Is there any source which tabulates quantum computing algorithms for simulating physical systems?" Tags="&lt;quantum-algorithms&gt;&lt;simulation&gt;&lt;resource-request&gt;" AnswerCount="1" CommentCount="3" />
  <row Id="1479" PostTypeId="2" ParentId="1478" CreationDate="2018-03-29T20:27:26.160" Score="9" Body="&lt;p&gt;I believe what you're after is &lt;a href=&quot;https://math.nist.gov/quantum/zoo/&quot; rel=&quot;nofollow noreferrer&quot;&gt;NIST's Quantum Zoo&lt;/a&gt;, a comprehensive catalog of quantum algorithms maintained by Stephen Jordan. Its sections include:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Algebraic and Number Theoretic Algorithms (14 items)&lt;/li&gt;&#xA;&lt;li&gt;Oracular Algorithms (34 items)&lt;/li&gt;&#xA;&lt;li&gt;Approximation and Simulation Algorithms (12 items)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;and for each algorithm it includes its speedup, a description and relevant references. The third category would be the answer to the present question.&lt;/p&gt;&#xA;" OwnerUserId="54" LastEditorUserId="1847" LastEditDate="2018-04-19T06:20:25.307" LastActivityDate="2018-04-19T06:20:25.307" CommentCount="1" />
  <row Id="1480" PostTypeId="2" ParentId="1429" CreationDate="2018-03-29T20:36:42.060" Score="10" Body="&lt;p&gt;The idea of topological quantum computing was introduced by Kitaev in &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9707021&quot; rel=&quot;noreferrer&quot;&gt;this paper&lt;/a&gt;. The basic idea is to build a quantum computer using the properties of exotic types of particles, known as anyons.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are two main properties of anyons that would make them great for this purpose. One is what happens when you use them to create composite particles, a process we call &lt;em&gt;fusion&lt;/em&gt;. Let's take the so called Ising anyons (also known as Majoranas) as an example. If you bring two of these particles together, it is could be that they will annihilate. But it could also be that they become a fermion.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are some cases where you will know which will happen. If the Ising anyons just pair created from the vacuum, you know that they'll go back to the vacuum when combined. If you just split a fermion into two Ising anyons, they'll go back to being that fermion. But if two Ising anyons meet for the first time, the result of their combination will be completely random. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;All these possibilities must be kept track of somehow. That is done by means of a Hilbert space, known as the fusion space. But the nature of a many-anyon Hilbert space is very different to that of many spin qubits, or superconducting qubits, etc. The fusion space doesn't describe any internal degrees of freedom of the particles themselves. You can prod and poke the anyons all you like, you won't learn anything about the state within this space. It only describes how the anyons relate to each other by fusion. So keep the anyons far apart, and decoherence will find it very hard to break into this Hilbert space and disturb any state you have stored there. This makes it a perfect place to store qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The other useful property of anyons is braiding. This describes what happens when you move them around each other. Even if they don't come close to each other in any way, these trajectories can affect the results of fusion. For example, if two Ising anyons were destined to annihilate, but another Ising anyon passes between them before they fuse, they will turn into a fermion instead. Even if there was half the universe between them all when it passed by, somehow they still know. This allows us to perform gates on the qubits stored in the fusion space. The effect of these gates only depends on the topology of the paths that the anyons take around each other, rather than any small details. So they too are less prone to errors than gates performed on other types of qubit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;These properties give topological quantum computing a built in protection that is similar to quantum error correction. Like QEC, information is spread out so that it cannot be easily disturbed by local errors. Like QEC, local errors leave a trace (like moving anyons a little, or creating a new pair of anyons from the vacuum). By detecting this, you can easily clean up. So qubits built from anyons could have much less noise than ones built from other physical systems.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The big problem is that anyons don't exist. Their properties are mathematically inconsistent in any universe with three or more spatial dimensions, like the one we happen to live in.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Fortunately, we can try to trick them into existing. Certain materials, for example, have localized excitations that behave as is they were particles. These are known as &lt;em&gt;quasiparticles&lt;/em&gt;. With a 2D material in a sufficiently exotic phase of matter, these quasiparticles can behave as anyons. Kitaev's original paper proposed some toy models of such materials.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Also, quantum error correcting codes based on 2D lattices can also play host to anyons. In the well known &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0110143&quot; rel=&quot;noreferrer&quot;&gt;surface code&lt;/a&gt;, errors cause pairs of anyons to be created from the vacuum. To correct the errors you must find the pairs and reannihilate them. Though these anyons are too simple to have a fusion space, we can create &lt;a href=&quot;https://arxiv.org/abs/1609.04673&quot; rel=&quot;noreferrer&quot;&gt;defects in the codes&lt;/a&gt; that can also be moved around like particles. These are sufficient to store qubits, and basic gates can be performed by braiding the defects.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Superconducting nanowires can also be created with so-called Majorana zero modes at the end points. Braiding these is not so easy: wires are inherently 1D objects, which doesn't give a lot of room for movement. But it can nevertheless be done by creating certain junctions. And when it is done, we find that they behave like Ising anyons (or at least, so theory predicts). Because of this, there is a big push at the moment to provide strong experimental evidence that these can indeed be used as qubits, and that they can be braided to perform gates. &lt;a href=&quot;https://www.nature.com/articles/nature26142&quot; rel=&quot;noreferrer&quot;&gt;Here&lt;/a&gt; is a paper on the issue that is hot off the press.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;After that broad intro, I should get on with answering your actual question. Topological quantum computation concerns any implementation of quantum computation that, at a high level, can be interpreted in terms of anyons.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This includes the use of the surface code, which is currently regarded as the most mainstream method for how a fault-tolerant circuit model based quantum computer can be built. So for this case, the answer to &quot;How do Topological Quantum Computers differ from others models of quantum computation?&quot; is that it doesn't differ at all. It is the same thing!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Topological quantum computation also includes Majoranas, which is the route that Microsoft are betting on. Essentially this will just use pairs of Majoranas as qubits, and braiding for basic gates. The difference between this superconducting qubits is little more than that between superconducting qubits and trapped ion qubits: it is just details of the hardware implementation. The hope is that Majorana qubits will be significantly less noisy, but that remains to be seen.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Topological quantum computation also includes much more abstract models of computing. If we figure out a way to realize Fibonacci anyons, for example we'll have a fusion space that cannot be so easily carved up into qubits. Finding the best ways to turn our programs into the braiding of anyons becomes a lot harder (see &lt;a href=&quot;https://arxiv.org/abs/1310.4150&quot; rel=&quot;noreferrer&quot;&gt;this paper&lt;/a&gt;, as an example). This is the kind of topological quantum computer that would be most different to standard methods. But if anyons can really be realized with very low noise, as promised, it would be well worth the small overheads required to use Fibonacci anyons to simulate the standard gate based approach.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-03-30T09:44:28.947" LastActivityDate="2018-03-30T09:44:28.947" CommentCount="0" />
  <row Id="1481" PostTypeId="2" ParentId="1474" CreationDate="2018-03-29T20:38:15.770" Score="26" Body="&lt;p&gt;Gate model hardware vendors have built out their own low level languages: &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Rigetti: &lt;a href=&quot;https://arxiv.org/pdf/1608.03355.pdf&quot; rel=&quot;noreferrer&quot;&gt;Quil&lt;/a&gt; &lt;/li&gt;&#xA;&lt;li&gt;IBM: &lt;a href=&quot;https://github.com/QISKit/openqasm&quot; rel=&quot;noreferrer&quot;&gt;QASM&lt;/a&gt; &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;These have higher level python sdk's available: &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Rigetti: &lt;a href=&quot;http://pyquil.readthedocs.io/en/latest/&quot; rel=&quot;noreferrer&quot;&gt;Pyquil&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;IBM: &lt;a href=&quot;https://github.com/QISKit/qiskit-sdk-py&quot; rel=&quot;noreferrer&quot;&gt;Qiskit&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Rigetti is also wrapping their language in a higher level library for calling pre-built applications called &lt;a href=&quot;http://grove-docs.readthedocs.io/en/latest/&quot; rel=&quot;noreferrer&quot;&gt;Grove&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Microsoft has developed &lt;a href=&quot;https://www.microsoft.com/en-us/quantum/development-kit&quot; rel=&quot;noreferrer&quot;&gt;Q#&lt;/a&gt; to run against their existing simulator, and eventually their physical hardware. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Since the languages above are vendor specific the main benefit is that you can run quantum programs on their computers. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Outside of the vendor specific languages is &lt;a href=&quot;https://www.cs.princeton.edu/research/techreps/TR-934-12&quot; rel=&quot;noreferrer&quot;&gt;Scaffold&lt;/a&gt; which is being developed by Princeton researchers. This language is interesting as it includes a &lt;a href=&quot;https://github.com/epiqc/ScaffCC&quot; rel=&quot;noreferrer&quot;&gt;toolchain&lt;/a&gt; for analyzing the programs to determine costs, performance potential, and scalability potential. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Edit: &lt;a href=&quot;https://projectq.ch/&quot; rel=&quot;noreferrer&quot;&gt;Project Q&lt;/a&gt; is another framework that allows you to develop programs utilizing Python which can run on an included simulator. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Oak Ridge National Labs has started work on a project called &lt;a href=&quot;https://github.com/ORNL-QCI/xacc&quot; rel=&quot;noreferrer&quot;&gt;XACC&lt;/a&gt; which is intended to abstract vendor specific code to allow users access to the various hardware platforms without duplicating code in each vendor specific language.  &lt;/p&gt;&#xA;" OwnerUserId="39" LastEditorUserId="39" LastEditDate="2018-04-02T20:50:14.177" LastActivityDate="2018-04-02T20:50:14.177" CommentCount="2" />
  <row Id="1482" PostTypeId="2" ParentId="1471" CreationDate="2018-03-29T20:54:26.297" Score="8" Body="&lt;p&gt;Majoranas are &lt;a href=&quot;https://en.wikipedia.org/wiki/Anyon&quot; rel=&quot;nofollow noreferrer&quot;&gt;anyons&lt;/a&gt; (a type of quasiparticles wich behave differently from fermions and bosons), and so are related to the idea of &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1429/how-do-topological-quantum-computers-differ-from-others-models-of-quantum-comput&quot;&gt;topological quantum computation&lt;/a&gt;. This means that a good implementation should have properties that help deal with noise built in. Their main problem is that it is difficult to prepare physical systems which behave as Majorana particles.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One way of building Majoranas is with superconducting nanowires. This is the kind that the press release and paper are referring to. Will these actually work well? We shall see. Will they be better than other qubits? We shall see.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Another way of building Majoranas is by performing code deformation in &lt;a href=&quot;https://en.wikipedia.org/wiki/Toric_code&quot; rel=&quot;nofollow noreferrer&quot;&gt;surface codes&lt;/a&gt; (a well studied family of quantum error correction codes). Examples can be found in this paper  (of which I am an author): &lt;a href=&quot;https://arxiv.org/abs/1609.04673&quot; rel=&quot;nofollow noreferrer&quot;&gt;Poking holes and cutting corners to achieve Clifford gates with the surface code&lt;/a&gt;. These will probably work pretty well. They won't have much in the way of advantages over more mainstream methods though, because using defects in surface codes &lt;em&gt;is&lt;/em&gt; the most mainstream method (whether they are Majoranas or not).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are other ways we could trick Majoranas into existing. But as far as I know, none are being actively pursued.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="1847" LastEditDate="2018-04-13T09:19:13.100" LastActivityDate="2018-04-13T09:19:13.100" CommentCount="2" />
  <row Id="1483" PostTypeId="2" ParentId="1451" CreationDate="2018-03-29T23:09:12.510" Score="18" Body="&lt;p&gt;The 'Hello World' equivalent in the D-Wave world is the 2D checkerboard example. In this example, you are given the following square graph with 4 nodes:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#xA;&lt;img src=&quot;https://image.ibb.co/juv4en/2d_checkerboard.png&quot; alt=&quot;square_graph&quot;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's define that we colour vertex $\sigma_{i}$ black if $\sigma_{i} = -1$ and white if $\sigma_{i} = +1$. The goal is to create a checkerboard pattern with the four vertices in the graph. There is various ways of defining&#xA;$h$ and $J$ to achieve this result. First of all, there are two possible solutions to this problem:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#xA;&lt;img src=&quot;https://image.ibb.co/fh1AKn/2d_checkerboard_solutions.png&quot; alt=&quot;checkerboard_solutions&quot;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The D-Wave quantum annealer minimizes the Ising Hamiltonian that we define and&#xA;it is important to understand the effect of the different coupler settings. Consider for example the $J_{0,1}$ coupler:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we set it to $J_{0,1}=-1$, the Hamiltonian is minimized if both qubits take the same value. We say &lt;em&gt;negative couplers correlate&lt;/em&gt;. Whereas if we set it to $J_{0,1}=+1$, the Hamiltonian is minimized if the two qubits take opposite values. Thus, &lt;em&gt;positive couplers anti-correlate&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the checkerboard example, we want to anti-correlate each pair of neighbouring qubits which gives rise to the following Hamiltonian:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$H = \sigma_{0}\sigma_{1} + \sigma_{0}\sigma_{2} + \sigma_{1}\sigma_{3} + \sigma_{2}\sigma_{3}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For the sake of demonstration, we also add a bias term on the $0$-th qubit such that we only get solution #1. This solution requires $\sigma_{0}=-1$ and we therefore set its bias $h_{0}=1$. The final Hamiltonian is now:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$H = \sigma_{0} + \sigma_{0}\sigma_{1} + \sigma_{0}\sigma_{2} + \sigma_{1}\sigma_{3} + \sigma_{2}\sigma_{3}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So let's code it up!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;NOTE: You DO NEED access to D-Wave's Cloud Service for anything to work.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;First of all, make sure you have the &lt;code&gt;dwave_sapi2&lt;/code&gt; (&lt;a href=&quot;https://cloud.dwavesys.com/qubist/downloads/&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://cloud.dwavesys.com/qubist/downloads/&lt;/a&gt;) Python package installed. Everything is going to be Python 2.7 since D-Wave currently doesn't support any higher Python version. That being said, let's import the essentials:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;from dwave_sapi2.core import solve_ising&#xA;from dwave_sapi2.embedding import find_embedding, embed_problem, unembed_answer&#xA;from dwave_sapi2.util import get_hardware_adjacency&#xA;from dwave_sapi2.remote import RemoteConnection&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;In order to connect to the D-Wave Solver API you will need a valid API token for their SAPI solver, the SAPI URL and you need to decide which quantum processor you want to use:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;DWAVE_SAPI_URL = 'https://cloud.dwavesys.com/sapi'&#xA;DWAVE_TOKEN = [your D-Wave API token]&#xA;DWAVE_SOLVER = 'DW_2000Q_VFYC_1'&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;I recommend using the D-Wave 2000Q Virtual Full Yield Chimera (VFYC) which is a fully functional chip without any dead qubits! Here's the Chimera chip layout:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&quot;https://preview.ibb.co/iO2szn/vfyc_dwave.png&quot; alt=&quot;dwave_chimera&quot;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;At this point I am splitting the tutorial into two distinct pieces. In the first section, we are manually embedding the problem onto the Chimera hardware graph and in the second section we are using D-Wave's embedding heuristics to find a hardware embedding.&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;Manual embedding&lt;/h1&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;The unit cell in the top left corner on the D-Wave 2000Q chip layout above looks like this:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&quot;https://image.ibb.co/bzkvKn/physical_qubits.png&quot; alt=&quot;physical_qubits&quot;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note, that not all couplers are visualized in this image. As you can see, there is no coupler between qubit $0$ and qubit $1$ which we would need to directly implement our square graph above. That's why we are now redefining $0\rightarrow0$, $1\rightarrow4$, $2\rightarrow7$ and $3\rightarrow3$. We then go on and define $h$ as a list and $J$ as a dictionary:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;J = {(0,4): 1, (4,3): 1, (3,7): 1, (7,0): 1}&#xA;h = [-1,0,0,0,0,0,0,0,0]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;$h$ has 8 entries since we use qubits 0 to 7. We now establish connection to the Solver API and request the D-Wave 2000Q VFYC solver:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;connection = RemoteConnection(DWAVE_SAPI_URL, DWAVE_TOKEN)&#xA;solver = connection.get_solver(DWAVE_SOLVER)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Now, we can define the number of readouts and choose &lt;code&gt;answer_mode&lt;/code&gt; to be &quot;histogram&quot; which already sorts the results by the number of occurrences for us. We are now ready to solve the Ising instance with the D-Wave quantum annealer:    &lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;params = {&quot;answer_mode&quot;: 'histogram', &quot;num_reads&quot;: 10000}&#xA;results = solve_ising(solver, h, J, **params)&#xA;print results&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;You should get the following result:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;{&#xA;  'timing': {&#xA;    'total_real_time': 1655206,&#xA;    'anneal_time_per_run': 20,&#xA;    'post_processing_overhead_time': 13588,&#xA;    'qpu_sampling_time': 1640000,&#xA;    'readout_time_per_run': 123,&#xA;    'qpu_delay_time_per_sample': 21,&#xA;    'qpu_anneal_time_per_sample': 20,&#xA;    'total_post_processing_time': 97081,&#xA;    'qpu_programming_time': 8748,&#xA;    'run_time_chip': 1640000,&#xA;    'qpu_access_time': 1655206,&#xA;    'qpu_readout_time_per_sample': 123&#xA;  },&#xA;  'energies': [-5.0],&#xA;  'num_occurrences': [10000],&#xA;  'solutions': [&#xA;      [1, 3, 3, 1, -1, 3, 3, -1, {&#xA;          lots of 3 's that I am omitting}]]}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;As you can see we got the correct ground state energy (&lt;code&gt;energies&lt;/code&gt;) of $-5.0$. The solution string is full of $3$'s which is the default outcome for unused/unmeasured qubits and if we apply the reverse transformations - $0\rightarrow0$, $4\rightarrow1$, $7\rightarrow2$ and $3\rightarrow3$ - we get the correct solution string $[1, -1, -1, 1]$. Done!&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;Heuristic embedding&lt;/h1&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;If you start creating larger and larger Ising instances you will not be able to perform manual embedding. So let's suppose we can't manually embed our 2D checkerboard example. $J$ and $h$ then remain unchanged from our initial definitions:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;J = {(0,1): 1, (0,2): 1, (1,3): 1, (2,3): 1}&#xA;h = [-1,0,0,0]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;We again establish the remote connection and get the D-Wave 2000Q VFYC solver instance:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;connection = RemoteConnection(DWAVE_SAPI_URL, DWAVE_TOKEN)&#xA;solver = connection.get_solver(DWAVE_SOLVER)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;In order to find an embedding of our problem, we need to first get the adjacency matrix of the current hardware graph:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;adjacency = get_hardware_adjacency(solver)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Now let's try to find an embedding of our problem:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;embedding = find_embedding(J.keys(), adjacency)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;If you are dealing with large Ising instances you might want to search for embeddings in multiple threads (parallelized over multiple CPUs) and then select the embedding with the smallest chain length! A &lt;em&gt;chain&lt;/em&gt; is when multiple qubits are forced to act as a single qubit in order to increase the degree of connectivity. However, the longer the chain the more likely that it breaks. And broken chains give bad results!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We are now ready to embed our problem onto the graph:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[h, j0, jc, embeddings] = embed_problem(h, J, embedding, adjacency)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;j0&lt;/code&gt; contains the original couplings that we defined and &lt;code&gt;jc&lt;/code&gt; contains the couplings that enforce the integrity of the chains (they correlate the qubits within the chains). Thus, we need to combine them again into one big $J$ dictionary:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;J = j0.copy()&#xA;J.update(jc)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Now, we're ready to solve the embedded problem:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;params = {&quot;answer_mode&quot;: 'histogram', &quot;num_reads&quot;: 10000}&#xA;raw_results = solve_ising(solver, h, J, **params)&#xA;&#xA;print 'Lowest energy found: {}'.format(raw_results['energies'])&#xA;print 'Number of occurences: {}'.format(raw_results['num_occurrences'])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;The &lt;code&gt;raw_results&lt;/code&gt; will not make sense to us unless we unembed the problem. In case, some chains broke we are fixing them through a majority vote as defined by the optional argument &lt;code&gt;broken_chains&lt;/code&gt;:    &lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;unembedded_results = unembed_answer(raw_results['solutions'],&#xA;                                    embedding, broken_chains='vote')&#xA;&#xA;print 'Solution string: {}'.format(unembedded_results)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;If you run this, you should get the correct result in all readouts:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Lowest energy found: [-5.0]&#xA;Number of occurences: [10000]&#xA;Solution string: [[1, -1, -1, 1]]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;I hope this answered your question and I highly recommend checking out all the additional parameters that you can pass to the &lt;code&gt;solve_ising&lt;/code&gt; function to improve the quality of your solutions such as &lt;code&gt;num_spin_reversal_transforms&lt;/code&gt; or &lt;code&gt;postprocess&lt;/code&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1234" LastEditorUserId="27" LastEditDate="2018-05-19T10:35:07.823" LastActivityDate="2018-05-19T10:35:07.823" CommentCount="0" />
  <row Id="1484" PostTypeId="2" ParentId="1474" CreationDate="2018-03-30T03:55:37.417" Score="4" Body="&lt;p&gt;Or even look at &lt;a href=&quot;https://www.mathstat.dal.ca/~selinger/quipper/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quipper&lt;/a&gt;, a functional Quantum programming language. With monadic semantics, built in functionality for reversible quantum computation, hierarchical circuit support, and more! &#xA;Used in actual practice too – for an &lt;a href=&quot;https://arxiv.org/abs/1611.05484&quot; rel=&quot;nofollow noreferrer&quot;&gt;algorithm to compute the solution of the Dirac equation&lt;/a&gt; by LaFlamme. &lt;/p&gt;&#xA;" OwnerUserId="429" LastEditorUserId="45" LastEditDate="2018-04-04T11:27:00.380" LastActivityDate="2018-04-04T11:27:00.380" CommentCount="0" />
  <row Id="1485" PostTypeId="1" AcceptedAnswerId="1535" CreationDate="2018-03-30T04:12:01.383" Score="6" ViewCount="133" Body="&lt;p&gt;One of the biggest drawbacks of Bayesian learning against deep learning is runtime: applying Bayes' theorem requires knowledge on how the data is distributed, and this usually requires either expensive integrals or some sampling mechanism (with the corresponding drawbacks).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Since at the end of the day is all about distribution propagations, and this is (as far as I understand) the nature of quantum computing, is there a way to perform these efficiently? If yes, what limitations do apply?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;EDIT: directly related links:&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/1622/1346&quot;&gt;What is the argument that practical quantum computers cannot be built?&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1432/1346&quot;&gt;https://quantumcomputing.stackexchange.com/a/1432/1346&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="1346" LastEditorUserId="1346" LastEditDate="2018-04-07T16:39:08.437" LastActivityDate="2018-04-07T16:39:08.437" Title="Can quantum computing speed up Bayesian learning?" Tags="&lt;machine-learning&gt;&lt;bayesian-learning&gt;" AnswerCount="1" CommentCount="2" />
  <row Id="1486" PostTypeId="1" AcceptedAnswerId="1499" CreationDate="2018-03-30T04:18:50.047" Score="8" ViewCount="287" Body="&lt;p&gt;As we all know, quantum algorithms scale faster than classical ones (at least for &lt;a href=&quot;https://en.wikipedia.org/wiki/BQP&quot; rel=&quot;nofollow noreferrer&quot;&gt;certain problem clases&lt;/a&gt;), meaning quantum computers would require a much smaller number of logical operations for inputs above a given size. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, it is not so commonly discussed how quantum computers compare to regular computers (a normal PC today) in terms of power consumption per logical operation. (Has this not been talked about much, because the main focus of quantum computers is how fast they can compute data?)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Can someone explain why quantum computing would be more or less power-efficient than classical computing, per logical operation?&lt;/p&gt;&#xA;" OwnerUserId="1348" LastEditorUserId="1847" LastEditDate="2018-04-07T07:05:50.220" LastActivityDate="2018-04-07T08:07:53.357" Title="How power-efficient are quantum computers?" Tags="&lt;quantum-computer&gt;&lt;architecture&gt;&lt;performance&gt;" AnswerCount="2" CommentCount="2" FavoriteCount="2" />
  <row Id="1487" PostTypeId="1" AcceptedAnswerId="1498" CreationDate="2018-03-30T04:46:38.663" Score="2" ViewCount="68" Body="&lt;p&gt;&lt;a href=&quot;https://physicstoday.scitation.org/action/showDoPubSecure?doi=10.1063%2FPT.6.1.20180328a&amp;amp;format=full&quot; rel=&quot;nofollow noreferrer&quot;&gt;This divulgation article&lt;/a&gt; by Prof. Brukner talks about the possibility of creating a situation where&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;A causing B&quot; and &quot;B causing A&quot; which we call a &lt;strong&gt;quantum switch&lt;/strong&gt;. Such a setup is similar to some predator–prey relationships, in which predator numbers influence prey numbers, yet prey numbers also influence predator numbers. Following &lt;a href=&quot;https://www.nature.com/articles/ncomms2076&quot; rel=&quot;nofollow noreferrer&quot;&gt;work&lt;/a&gt; that Ognyan Oreshkov, Fabio Costa, and I published in 2012, we now know that the quantum switch is just one example of an indefinite causal structure, in which it is not defined whether event A is a cause or an effect of event B, or whether the two are independent.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/julZN.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/julZN.jpg&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The work link leads to a paper that explains with great detail how to achieve that, and it also includes some applications, like to &lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.86.040301&quot; rel=&quot;nofollow noreferrer&quot;&gt;prove that two no-signalling channels that are not perfectly distinguishable in any ordinary quantum circuit can become perfectly distinguishable through the quantum superposition of circuits with different causal structures&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am a regular programmer without a background in quantum computing and don't quite understand the implications of such articles. What I get, and find very exciting is the possibility of having such expanded causality models as a tool. &lt;strong&gt;My question is: how/where could quantum switch fit in the classical computing landscape?&lt;/strong&gt; Be it low-level hardware design or the (surely upcoming) &lt;code&gt;else-then-if&lt;/code&gt; software pattern &lt;/p&gt;&#xA;" OwnerUserId="1346" LastEditorUserId="1346" LastEditDate="2018-03-30T05:18:06.393" LastActivityDate="2018-03-30T13:08:35.817" Title="What impact would have introducing the quantum switch effect in classical computing?" Tags="&lt;classical-computing&gt;" AnswerCount="1" CommentCount="3" />
  <row Id="1488" PostTypeId="1" AcceptedAnswerId="1511" CreationDate="2018-03-30T04:48:01.183" Score="8" ViewCount="116" Body="&lt;p&gt;I've heard that quantum computers pose a major threat to 1024 bit and possibly even 2048 bit RSA public-private key cryptography. In the future however, bigger size keys will probably become at risk at one point or another, as newer, faster quantum computers are created, for lots of (if not, all) algorithms. How can I reliably know if a key size, or even an algorithm itself is secure and safe to use at the current time? Is there a reliable resource/website that calculates which key sizes are currently at risk, based on how fast the newest quantum computers are? Or possibly, will new algorithms be created which try to prevent quantum computers from being able to crack them easily? The goal here is to keep the UX positive by not making a product slow due to encryption, but slower apps are worth it to guarantee a safe transfer of data.&lt;/p&gt;&#xA;" OwnerUserId="1348" LastActivityDate="2018-04-15T12:45:51.220" Title="How can we reliably know if a key size is still safe to use as new quantum computers are created?" Tags="&lt;cryptography&gt;&lt;post-quantum-crypto&gt;" AnswerCount="3" CommentCount="3" />
  <row Id="1489" PostTypeId="1" AcceptedAnswerId="1506" CreationDate="2018-03-30T05:14:41.020" Score="6" ViewCount="86" Body="&lt;p&gt;In words of &lt;a href=&quot;https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wikipedia&lt;/a&gt;, &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The Curry–Howard correspondence is the observation that two families of seemingly unrelated formalisms—namely, the proof systems on one hand, and the models of computation on the other—are in fact the same kind of mathematical objects [...] &lt;em&gt;a proof is a program, and the formula it proves is the type for the program&lt;/em&gt;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Further, under &lt;a href=&quot;https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence#General_formulation&quot; rel=&quot;nofollow noreferrer&quot;&gt;General Formulation&lt;/a&gt;, it provides the following table and the statement that bears my question:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/d0XKD.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/d0XKD.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;In its more general formulation, the Curry–Howard correspondence is a correspondence between formal proof calculi and type systems for models of computation. In particular, it splits into two correspondences. One at the level of formulas and types that is independent of which particular proof system or model of computation is considered, and one at the level of proofs and programs which, this time, &lt;strong&gt;is specific to the particular choice of proof system and model of computation considered&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Is quantum computing in this hindsight equivalent to classical computing, or is it a different &quot;model of computation&quot; (i.e. does it have a different set of elements in the &lt;em&gt;Programming side&lt;/em&gt;)?  Would it still correspond to the exact same &lt;em&gt;Logic side&lt;/em&gt;?&lt;/p&gt;&#xA;" OwnerUserId="1346" LastEditorUserId="1346" LastEditDate="2018-03-30T15:29:19.633" LastActivityDate="2018-03-30T15:29:19.633" Title="How does the Curry-Howard correspondence apply to quantum programs?" Tags="&lt;classical-computing&gt;&lt;quantum-programming&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="1490" PostTypeId="1" AcceptedAnswerId="1497" CreationDate="2018-03-30T05:36:52.240" Score="9" ViewCount="147" Body="&lt;p&gt;I'm a total beginner, I've been brought here by the &lt;a href=&quot;https://stackoverflow.blog/2018/03/27/quantum-computing-site-launches-with-the-help-of-strangeworks/?cb=1&quot;&gt;featured stackoverflow blog post&lt;/a&gt; so I started studying.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Watching this youtube video (&lt;a href=&quot;https://youtu.be/JRIPV0dPAd4?t=3m58s&quot; rel=&quot;noreferrer&quot;&gt;A Beginner’s Guide To Quantum Computing (3:58&lt;/a&gt;), I saw this slide where it talks about superposition:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/ckamO.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/ckamO.png&quot; alt=&quot;Quantum superposition&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;At first I thought that, besides qubits, which can be in a superposition of 0s and 1s, there's also a qsphere, which can be in a superposition of 5 zeros and 5 ones, when in fact it's &lt;em&gt;just&lt;/em&gt; 5 qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So when we say a qsphere, it's known to be 5 qubits? &lt;/p&gt;&#xA;" OwnerUserId="1115" LastEditorUserId="26" LastEditDate="2018-03-30T06:31:21.463" LastActivityDate="2018-03-30T08:53:09.390" Title="Is qsphere an actual term representing 5 qubits?" Tags="&lt;qubit&gt;&lt;superposition&gt;&lt;terminology&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="2" />
  <row Id="1491" PostTypeId="5" CreationDate="2018-03-30T06:03:26.720" Score="0" Body="&lt;p&gt;A &lt;strong&gt;qutrit&lt;/strong&gt; is a unit of quantum information that exists as a superposition of three orthogonal quantum states.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &lt;strong&gt;qutrit&lt;/strong&gt; is analogous to the classical &lt;em&gt;trit&lt;/em&gt;, just as the &lt;a href=&quot;/questions/tagged/qubit&quot; class=&quot;post-tag&quot; title=&quot;show questions tagged &amp;#39;qubit&amp;#39;&quot; rel=&quot;tag&quot;&gt;qubit&lt;/a&gt;, a quantum particle of two possible states, is analogous to the classical &lt;em&gt;bit&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;(source: &lt;a href=&quot;https://en.wikipedia.org/wiki/Qutrit&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wikipedia&lt;/a&gt;)&lt;/sup&gt;&lt;/p&gt;&#xA;" OwnerUserId="609" LastEditorUserId="609" LastEditDate="2018-03-30T06:52:11.180" LastActivityDate="2018-03-30T06:52:11.180" CommentCount="0" />
  <row Id="1492" PostTypeId="4" CreationDate="2018-03-30T06:03:26.720" Score="0" Body="For questions related to quantum trits i.e. three-level (dimensional) quantum mechanical systems. They are higher dimensional analogues of qubits (aka quantum bits), which are two-level (dimensional) quantum mechanical systems. " OwnerUserId="609" LastEditorUserId="26" LastEditDate="2018-07-05T09:05:51.457" LastActivityDate="2018-07-05T09:05:51.457" CommentCount="0" />
  <row Id="1494" PostTypeId="5" CreationDate="2018-03-30T06:07:35.130" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-30T06:07:35.130" LastActivityDate="2018-03-30T06:07:35.130" CommentCount="0" />
  <row Id="1495" PostTypeId="4" CreationDate="2018-03-30T06:07:35.130" Score="0" Body="Referring to the loss of quantum coherence, decoherence is often the result of loss of information from a system into the environment (often modelled as a heat bath)." OwnerUserId="609" LastEditorUserId="23" LastEditDate="2018-04-15T09:07:54.590" LastActivityDate="2018-04-15T09:07:54.590" CommentCount="0" />
  <row Id="1496" PostTypeId="2" ParentId="1490" CreationDate="2018-03-30T06:25:38.280" Score="7" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Is qsphere an actual term representing 5 qubits?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;If it is, it is not widely used. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I claim this because I looked around in &lt;a href=&quot;https://arxiv.org/find/all/1/all:+qsphere/0/1/0/all/0/1&quot; rel=&quot;noreferrer&quot;&gt;arXiv&lt;/a&gt;, a repository of electronic preprints of research articles, and found nothing. There are many other units of quantum information than just qubit though. All of the following appear at least occasionally in the relevant literature.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Qubit has a computational basis of two states and can be implemented by a two-level quantum system.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Qutrit has a computational basis of three states.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;Ququart is a (rare) term used by some, and it has a basis of four.&lt;/li&gt;&#xA;&lt;li&gt;Qudit is a common term. It is the $d$-dimensional generalization of a qubit. Often $d$ is left unspecified and these are used when comparing the effect of using different values of it.&lt;/li&gt;&#xA;&lt;li&gt;Qumode is again a bit less often used term in continuous-variable quantum computing, where now, informally speaking, the basis has infinitely many elements.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="144" LastActivityDate="2018-03-30T06:25:38.280" CommentCount="0" />
  <row Id="1497" PostTypeId="2" ParentId="1490" CreationDate="2018-03-30T07:27:30.733" Score="12" Body="&lt;p&gt;The qsphere is a way of representing multi-qubit states. So it could be used for 5 qubit states, but it could also be used for any other number.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It could also be used for just one qubit. But in this case it is important to note that the single qubit qsphere is &lt;strong&gt;not&lt;/strong&gt; the same as the &lt;em&gt;Bloch sphere&lt;/em&gt;, which is our standard way of representing single qubit states.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Instead, the qsphere is essentially a more visually appealing version of a histogram. It was &lt;a href=&quot;https://www.qiskit.org/ibmqx-user-guides/full-user-guide/001-The_IBM_Quantum_Experience/006-The_Results.html&quot; rel=&quot;noreferrer&quot;&gt;introduced by IBM&lt;/a&gt; as a visualization for the Quantum Experience, but doesn't seem to be used so much by them any more.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To construct the qsphere of a state, you have to think of the histogram you'd get if you measure in the $|0 \rangle,|1 \rangle$ basis. For example, suppose I have a 4 qubit state that would give me the results&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;{'0000':0.5, '0101':0.25, '0011:'0.125, '0111':0.125}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Here the bit string &lt;code&gt;0000&lt;/code&gt; comes out with probability $0.5$, and so on.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;On the qsphere, this would be represented by four points: one for each of these non-zero probabilities. The latitude of the points depends on the number of &lt;code&gt;0&lt;/code&gt;s and &lt;code&gt;1&lt;/code&gt;s in the bit string. Our result that has all &lt;code&gt;0&lt;/code&gt;s would be at the north pole. Our &lt;code&gt;0111&lt;/code&gt;, with mostly &lt;code&gt;1&lt;/code&gt;s, would be near the south pole. The two results &lt;code&gt;0101&lt;/code&gt; and &lt;code&gt;0011&lt;/code&gt; that we have in our example would be at the equator.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The probability is represented by the strength of the line. The two with probability of only $0.125$ would have quite faint lines. The one with probability $0.5$ would have a much thicker line. Those with $0.25$ would be somewhere in between.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So far, we have represented all aspects of the histogram, but have not included any phase information that the state might also have. This can be encoded using the colour of the points. The sphere then has all the information on the multi-qubit state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To see why it is not the nicest visualization there is, imagine performing a Hadamard gate. This transforms latitude and longitude information into colour, and vice-versa. Despite being a simple gate, it would have a very complex effect.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But then again, what visualization of many qubits doesn't have its weaknesses? If it was easy to visualize them, it would be easy to simulate them. And then we'd have no need to build quantum computers.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="609" LastEditDate="2018-03-30T08:53:09.390" LastActivityDate="2018-03-30T08:53:09.390" CommentCount="0" />
  <row Id="1498" PostTypeId="2" ParentId="1487" CreationDate="2018-03-30T08:16:59.953" Score="2" Body="&lt;p&gt;The answer depends on what exactly you mean by &quot;&lt;em&gt;fit&lt;/em&gt;&quot;, but, generally speaking, there do not seem to be direct applications of indefinite causal structures for classical computing.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Indeed, the interest of techniques like the quantum switch$^\dagger$ (aside from the purely fundamental aspects) is that they provide methods to create non-classical correlations, and more generally encoding quantum information (e.g. qubits) into &quot;causal&quot; degrees of freedoms, as nicely shown in Figure 1 &lt;a href=&quot;http://advances.sciencemag.org/content/advances/3/3/e1602589.full.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In other words, one could imagine a quantum computer in which the qubits are encoded into (a)causal structures.&#xA;However, apart from the notable impracticality of storing and maintaining many qubits encoded in such a way, it is also not known how one could apply operations between them.&#xA;Interestingly, in at least some limited form, this is possible, as recently demonstrated in &lt;a href=&quot;https://arxiv.org/abs/1712.06884&quot; rel=&quot;nofollow noreferrer&quot;&gt;1712.06884&lt;/a&gt;, where two different such qubits were entangled, and the associated Bell violations observed.&#xA;It is not known if or how one could scale such experiments to more qubits.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;$^\dagger$ It is worth mentioning that there have also been at least two (to my knowledge) experimental demonstrations of indefinite causal orders: &lt;a href=&quot;https://arxiv.org/abs/1608.01683&quot; rel=&quot;nofollow noreferrer&quot;&gt;1608.01683&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/abs/1712.06884&quot; rel=&quot;nofollow noreferrer&quot;&gt;1712.06884&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-03-30T13:08:35.817" LastActivityDate="2018-03-30T13:08:35.817" CommentCount="1" />
  <row Id="1499" PostTypeId="2" ParentId="1486" CreationDate="2018-03-30T08:42:55.620" Score="5" Body="&lt;p&gt;As usual, it is too soon to make comparisons like this.&#xA;The power consumption of a device will depend &lt;em&gt;strongly&lt;/em&gt; on the architecture it uses, for one.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, &lt;em&gt;in principle&lt;/em&gt;, there is no reason to suspect that quantum computers would consume more energy than classical devices performing the same operations.&#xA;Indeed, one would expect the opposite, the fundamental reason being that quantum computers work (mostly) via &lt;em&gt;unitary&lt;/em&gt; operations.&#xA;A &lt;em&gt;unitary&lt;/em&gt; operation is a &lt;em&gt;reversible&lt;/em&gt; operation, or, in other words, an operation during which &lt;em&gt;no information is lost to the environment&lt;/em&gt;.&#xA;Such an operation is basically &quot;perfectly&quot; energy efficient (for one, it wouldn't produce heat).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, &lt;em&gt;in principle&lt;/em&gt;, the elementary operations performed in a quantum algorithm which uses unitary operations &lt;em&gt;can&lt;/em&gt; be ideally energy efficient.&#xA;This is in direct contrast with what you have with classical devices, in which the elementary operations are non-reversible, and therefore necessarily &quot;waste&quot; some amount of information for every operation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Having said this, there are a million caveats to be taken into account.&#xA;For example, quantum computers in the real world will have to deal with decoherence, so that the operations are not really unitary. This implies that error-correction protocols are necessary to take this into account, and one should then go and track what is the added energy consumption of this whole process.&#xA;Also, while unitary operations are energy efficient, in practice when one acquires the result of the measurement, measurements have to be performed, and this are non-reversible operations which typically destroy the information. After each such measurement, one will need to generate the carriers of information again. Also, many quantum computing protocols rely on repeated measurements &lt;em&gt;during&lt;/em&gt; the computation.&#xA;One could go on for a long time, as this is very much uncharted territory.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One recent work that discusses in some measure the power consumption problem is &lt;a href=&quot;https://arxiv.org/abs/1610.02365&quot; rel=&quot;noreferrer&quot;&gt;1610.02365&lt;/a&gt;, in which the authors present a method for (classical machine learning) information processing using photonic chips.&#xA;One claim of the authors is that photonic chips allow to perform operations in an extremely energy efficient way, exploiting the natural evolution of coherent light.&#xA;&lt;em&gt;They do not demonstrate any form quantum computation&lt;/em&gt;, but their energy efficiency reasonings would not change much when using the same device for &lt;em&gt;quantum&lt;/em&gt; information processing.&lt;/p&gt;&#xA;" OwnerUserId="55" LastActivityDate="2018-03-30T08:42:55.620" CommentCount="0" />
  <row Id="1500" PostTypeId="1" AcceptedAnswerId="1503" CreationDate="2018-03-30T09:01:15.557" Score="4" ViewCount="104" Body="&lt;p&gt;On the &lt;a href=&quot;https://www.dwavesys.com/d-wave-two-system&quot; rel=&quot;nofollow noreferrer&quot;&gt;D-Wave 2000Q website&lt;/a&gt;, it is stated that the processor environment is kept &quot;in a high vacuum: pressure is 10 billion times lower than atmospheric pressure&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Why the pressure has to be such low? What would happen to the computer if the pressure increases?&lt;/p&gt;&#xA;" OwnerUserId="609" LastEditorUserId="26" LastEditDate="2018-03-30T10:00:09.517" LastActivityDate="2018-07-16T09:05:20.603" Title="Why D-Wave 2000Q requires such a low pressure?" Tags="&lt;quantum-computer&gt;&lt;architecture&gt;&lt;d-wave&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="1501" PostTypeId="2" ParentId="1462" CreationDate="2018-03-30T09:13:30.350" Score="2" Body="&lt;p&gt;To simplify things a bit, let's take a single qubit and a single qutrit for comparison.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;First, the amplitude damping channel (giving e.g. emission of a photon) for a qubit is $\mathcal E\left(\rho\right) = E_0\rho E_0^\dagger + E_1\rho E_1^\dagger$, where $$E_0 = \begin{pmatrix}1 &amp;amp;&amp;amp; 0 \\ 0 &amp;amp;&amp;amp;\sqrt{1-\gamma}\end{pmatrix}, \quad E_1 = \begin{pmatrix} 0 &amp;amp;&amp;amp; \sqrt \gamma \\ 0 &amp;amp;&amp;amp;0\end{pmatrix},$$ with $E_0$ being required for normalisation. This can also be written as $E_0 = \left|0\rangle\langle 0\right| + \sqrt{1-\gamma}\left|1\rangle\langle 1\right|$ and $E_1 = \sqrt{\gamma}\left|0\rangle\langle 1\right|$. When $\gamma = 1$, the amplitude damping channel gives the state $$\rho = \begin{pmatrix} 1 &amp;amp;&amp;amp; 0 \\ 0 &amp;amp;&amp;amp; 0\end{pmatrix} = \left|0\rangle\langle 0\right|$$ with certainty. However, this only applies at $0$ temperature, so to represent what happens at &lt;em&gt;finite&lt;/em&gt; temperature, the &lt;em&gt;generalised amplitude damping&lt;/em&gt; channel needs to be used. This has $\mathcal E\left(\rho\right) = \sum_kE_k\rho E_k^\dagger$, where $$E_0 = \sqrt p\begin{pmatrix}1 &amp;amp;&amp;amp; 0 \\ 0 &amp;amp;&amp;amp;\sqrt{1-\gamma}\end{pmatrix}, \quad E_1 = \sqrt p\begin{pmatrix} 0 &amp;amp;&amp;amp; \sqrt \gamma \\ 0 &amp;amp;&amp;amp;0\end{pmatrix},$$ $$E_2 = \sqrt{1-p}\begin{pmatrix}\sqrt{1-\gamma} &amp;amp;&amp;amp; 0 \\ 0 &amp;amp;&amp;amp;1\end{pmatrix}, \quad E_3 = \sqrt{1-p}\begin{pmatrix} 0 &amp;amp;&amp;amp; 0 \\ \sqrt \gamma &amp;amp;&amp;amp;0\end{pmatrix}.$$ Each of these can be split into four sections - an element in the upper left (bottom right) corner causes the amplitude of the upper left (bottom right) corner to decrease (here, this is really just a normalisation factor) while having a single element in a matrix, which is in the top right (bottom left) causes loss (gain) from the bottom right (top left) to the top left (bottom right) element of the density matrix. Now when $\gamma = 1$, this gives the state $$\rho = \begin{pmatrix}p &amp;amp;&amp;amp; 0\\ 0 &amp;amp;&amp;amp; 1-p\end{pmatrix} = p\left|0\rangle\langle 0\right| + \left(1-p\right)\left|1\rangle\langle 1\right|.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This shows that after a long time, the loss and gain cancel (i.e. no more loss or gain occurs), although this state is not very useful for computation, so lets try extending this a bit and adding another qubit. Lets go a bit further than that and take a pair of coupled spin-half fermions (such as a pair of electrons). This gives 4 states - the singlet state $S = \frac{1}{\sqrt 2}\left(\left|\uparrow\downarrow\right&amp;gt; - \left|\downarrow\uparrow\right&amp;gt;\right)$. It also gives a &lt;em&gt;subspace&lt;/em&gt; of triplet states $T = \left\lbrace \left|\uparrow\uparrow\right&amp;gt;, \frac{1}{\sqrt 2}\left(\left|\uparrow\downarrow\right&amp;gt; + \left|\downarrow\uparrow\right&amp;gt;\right), \left|\downarrow\downarrow\right&amp;gt;\right\rbrace = \left\lbrace T_0, T_1, T_2\right\rbrace$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Describing this as a qudit with $d=4$ and using an equivalent 'qudit generalised amplitude damping channel' gives a few possible interaction as in the qubit case:   &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;loss from the triplet subspace to the singlet state&lt;/li&gt;&#xA;&lt;li&gt;gain from the singlet state to the triplet subspace&lt;/li&gt;&#xA;&lt;li&gt;amplitude damping within the triplet subspace.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;By itself, this still doesn't help very much, so lets place this pair of spin-half particles in the centre of a larger system (a 'spin bath', here used as the environment, mediating the interaction) and allow it to interact. As the states in the triplet subspace are symmetric and it is in the centre of a bath, the probability rate of amplitude damping on the first qubit will, on average, equal the rate of amplitude damping on the second qubit. This means that, instead of having a single qudit amplitude damping channel, there are two copies of the same generalised amplitude damping channel, which reduces the number of possible interactions. In the limit of long time and taking $p=1/2$ (this is just setting the system to a certain non-zero temperature), these are, ignoring normalisation: &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;gain on the $\left|\downarrow\downarrow\right&amp;gt; = T_2$ state: $$T_2\rightarrow T_2' \propto T_2 + \beta T_1 + \beta^2T_0$$&lt;/li&gt;&#xA;&lt;li&gt;loss on the $\left|\uparrow\uparrow\right&amp;gt; = T_0$ state: $$T_0\rightarrow T_0' \propto T_0 + \beta T_1 + \beta^2T_2$$&lt;/li&gt;&#xA;&lt;li&gt;gain and loss on the $\frac{1}{\sqrt 2}\left(\left|\uparrow\downarrow\right&amp;gt;\pm  \left|\downarrow\uparrow\right&amp;gt;\right)$ states ($S$ and $T_1$ states): $$T_1\rightarrow T_1' \propto \left(1+\beta^2\right)T_1 + \beta \left(T_0+T_2\right)$$ $$S\rightarrow S' \propto\left(1-\beta^2\right) S.$$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;This shows that &lt;em&gt;oscillations&lt;/em&gt; in the triplet subspace occur &lt;em&gt;instead of decay&lt;/em&gt;, meaning that the &lt;strong&gt;triplet subspace is a &lt;em&gt;decoherence free subsystem&lt;/em&gt; and can be used as a qutrit&lt;/strong&gt;. In reality, interactions are more complicated and there will be other types of noise, so there will still be some decoherence, but the reasoning is still the same in that pairing two spin-half particles allows for the triplet state to be used as a decoherence free subsystem (or at least have less decoherence than a qubit) to mitigate the effects of some types of noise.&lt;/p&gt;&#xA;" OwnerUserId="23" LastActivityDate="2018-03-30T09:13:30.350" CommentCount="0" />
  <row Id="1502" PostTypeId="2" ParentId="115" CreationDate="2018-03-30T09:42:57.463" Score="6" Body="&lt;p&gt;A good summary on the current state of QRAM (as of 2017) can be found in &lt;a href=&quot;http://rspa.royalsocietypublishing.org/content/474/2209/20170551&quot; rel=&quot;noreferrer&quot;&gt;this paper&lt;/a&gt;, and a comparison of it with classical methods can be found in &lt;a href=&quot;http://pirsa.org/displayFlash.php?id=16080019&quot; rel=&quot;noreferrer&quot;&gt;this talk&lt;/a&gt;. The Giovannetti type &lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.100.160501&quot; rel=&quot;noreferrer&quot;&gt;&quot;bucket brigade&quot; QRAM&lt;/a&gt; still seems to be the best that is known, although modifications exist. There are serious caveats to the use of any such QRAM, and no alternative that avoids these has yet been proposed (other than using massively parallelized classical computers).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &quot;bucket brigade&quot; QRAM encodes in superposition $N$ $d$-dimensional vectors into $log(Nd)$ qubits using $(log(Nd))$ time. An alternative scheme with polynomial time reduction was proposed in &lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.86.010306&quot; rel=&quot;noreferrer&quot;&gt;this paper&lt;/a&gt;. In either case, the number of physical resources used is is exponential with the number of qubits. This could cause problems that limit the implementation and/or usefulness of the scheme.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The issue depends on how many components need to be active at once. Ideally, the number of active components needs only be linear with the number of qubits in the memory. However, actual implementations are usually far from ideal.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;http://iopscience.iop.org/article/10.1088/1367-2630/17/12/123010/meta&quot; rel=&quot;noreferrer&quot;&gt;This paper&lt;/a&gt;, for example, looks at the effects of noise, and concludes that the need for error correction could remove any advantages of the small number of active components. The severity of this potential problem depends on what algorithm is being used by the quantum computer, and so how many times the QRAM must be queried. For a polynomial number of queries, full fault-tolerance could be avoided. But for superpolynomial queries, such as for Grover's search, full-tolerance seems to be needed.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As far as comparing to other possibilities goes, it has been argued that the exponential number of resources for the QRAM should be compared to a classical parallel architecture with an exponential number of processors. The quantum algorithm does not look so great with this comparison. As explained &lt;a href=&quot;http://pirsa.org/displayFlash.php?id=16080019&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;, some algorithms for which we expect a quantum speedup are actually slower when this parallelism is taken into account.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Though not as general in scope, another proposal for putting classical data into superpositions was also proposed &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0208112&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt; and so deserves a mention.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-03-30T09:42:57.463" CommentCount="0" />
  <row Id="1503" PostTypeId="2" ParentId="1500" CreationDate="2018-03-30T09:50:02.863" Score="6" Body="&lt;p&gt;Pressure implies the presence of stray atoms flying around messing things up. The use of a vacuum is required to prevent this, as one of the ways of keeping the device well isolated from unwanted effects. I think that they are just intending the &quot;10 billion times lower than atmospheric pressure&quot; statement to demonstrate how good their vacuum is.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-03-30T12:10:27.273" LastActivityDate="2018-03-30T12:10:27.273" CommentCount="0" />
  <row Id="1504" PostTypeId="2" ParentId="1488" CreationDate="2018-03-30T09:51:34.647" Score="2" Body="&lt;p&gt;Given that you mention large key sizes (1024 bit and up), you are talking about asymmetric cryptography. Other (symmetric) cryptographic schemes are safe by simply doubling their key size (e.g. going from 128 to 256 bits) because that compensates for the theoretical advantage of Grover's algorithm for an exhaustive search.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Asymmetric cryptography can be divided into currently used, practical schemes (essentially RSA and ECC) and postquantum cryptography.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Since Shor's algorithm scales (in runtime) as $O(n^3)$, once a certain key size of RSA or ECC is unsafe, even doubling its size will only mean an 8-fold increase in the computational difficulty to calculate the new private key with a quantum computer: Once you conclude that RSA and ECC keys are no longer safe due to quantum computers, going to longer key lengths will not gain much. New algorithms (&quot;postquantum cryptography&quot;) are being designed that are believed to be safe against attacks using quantum computers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Postquantum cryptography already takes quantum computers as attack vectors into account. They typically require huge key sizes, though (such as more than 10 kbits).&lt;/p&gt;&#xA;" OwnerUserId="1039" LastEditorUserId="1039" LastEditDate="2018-04-14T15:58:08.860" LastActivityDate="2018-04-14T15:58:08.860" CommentCount="2" />
  <row Id="1505" PostTypeId="2" ParentId="1468" CreationDate="2018-03-30T10:27:29.263" Score="0" Body="&lt;p&gt;Even if you assume that your quantum computer will be based on qubits, it can operate with an arbitrarily large number of states (if it has enough qubits): The combination of two qubits allow it to calculate with a total of four states, that of three qubits with eight states, etc.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-03-30T10:27:29.263" CommentCount="0" />
  <row Id="1506" PostTypeId="2" ParentId="1489" CreationDate="2018-03-30T10:35:42.030" Score="2" Body="&lt;p&gt;Quantum computing doesn't change the Curry-Howard isomorphism, for the following reasons:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Quantum computers can simulate Turing machines and vice versa. These devices can be faster at certain tasks, but the computable languages remain the same. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;There is, a priori, no reason we cannot apply the model of the Turing machine of Lambda calculus to quantum computers, &lt;em&gt;even if they can compute different, mutually exclusive languages&lt;/em&gt;!&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;For practical purposes, I very much doubt quantum computing will be of use in automated theorem proving or proof assistance (by computers).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;So, as for your question, yes in the context of Curry-Howard, we can consider a quantum computer and a classical machine equivalent, as it is likely we wish to model both with the Lambda calculus for the purpose of the isomorphism.&lt;/p&gt;&#xA;" OwnerUserId="253" LastActivityDate="2018-03-30T10:35:42.030" CommentCount="4" />
  <row Id="1508" PostTypeId="1" AcceptedAnswerId="1592" CreationDate="2018-03-30T11:30:38.670" Score="14" ViewCount="453" Body="&lt;p&gt;Let, for a Quantum Turing machine (QTM), the state set be $Q$, and the alphabet of symbols be $\sum=\{0,1\}$, which appear at the tape head. Then, as per my understanding, at any given time while the QTM is calculating, the qubit that appears at its head will hold an arbitrary vector $V_\sum = a|1\rangle+b|0\rangle$. Also, if $|q_0\rangle , |q_1\rangle, ... \in Q$, then the state vector at that instance will also be an arbitrary vector $V_q=b_0|q_0\rangle + b_1 |q_1\rangle+ ...$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, after the instruction cycle is complete, the vectors $V_\sum$ and $V_q$ will decide whether the QTM will move left or right along the Qubit tape. My question is- since Hilbert space formed by $Q \otimes \sum$ is an uncountable infinite set and $\{\text{Left,Right}\}$ is a discrete set, the mapping between them will be difficult to create.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So how is the decision to move left or right made? Does the QTM move both left and right at the same time, meaning that the set $\{\text{Left,Right}\}$ also forms a different Hilbert space, and hence the motion of the QTM becomes something like $a|\text{Left}\rangle+b|\text{Right}\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Or, just like a Classical Turing machine, the QTM moves either left or right, but not both at the same time?&lt;/p&gt;&#xA;" OwnerUserId="1355" LastEditorUserId="124" LastEditDate="2018-03-31T11:24:12.663" LastActivityDate="2018-04-06T19:55:41.483" Title="In a Quantum Turing Machine, how is the decision to move along the memory tape made?" Tags="&lt;quantum-computer&gt;&lt;classical-computing&gt;&lt;quantum-computing-models&gt;&lt;quantum-turing-machine&gt;" AnswerCount="2" CommentCount="2" FavoriteCount="2" />
  <row Id="1509" PostTypeId="1" CreationDate="2018-03-30T11:45:20.377" Score="7" ViewCount="85" Body="&lt;p&gt;In the context of quantum control theory, it is common to see references to both &lt;em&gt;quantum control&lt;/em&gt; and &lt;em&gt;quantum optimal control&lt;/em&gt; (e.g. &lt;a href=&quot;https://arxiv.org/abs/0910.2350&quot; rel=&quot;noreferrer&quot;&gt;0910.2350&lt;/a&gt; or the &lt;a href=&quot;http://qutip.org/docs/latest/guide/guide-control.html&quot; rel=&quot;noreferrer&quot;&gt;guide on qutip quantrum control functions&lt;/a&gt;).&#xA;Sometimes it seems like the two terms are used interchangeably, while sometimes they are treated as different things.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, from the above link, it seems that &lt;em&gt;quantum optimal control&lt;/em&gt; is (unsurprisingly) a special kind of &lt;em&gt;quantum control&lt;/em&gt;.&#xA;It is however not too clear what the exact difference is between the two.&#xA;For example, are both approaches used to tackle the same classes of problems? Is the only difference in quantum optimal control theory looking for &lt;em&gt;optimal&lt;/em&gt; solutions, while &lt;em&gt;quantum control&lt;/em&gt; techniques have less strict requirements?&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-03-30T11:52:31.807" LastActivityDate="2018-03-30T11:52:31.807" Title="What is the difference between quantum control and quantum optimal control?" Tags="&lt;quantum-gate&gt;&lt;quantum-control&gt;" AnswerCount="0" CommentCount="6" FavoriteCount="3" />
  <row Id="1511" PostTypeId="2" ParentId="1488" CreationDate="2018-03-30T12:45:37.980" Score="6" Body="&lt;p&gt;We (i.e. the current state of research) just don't know, but we can guess. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;We &lt;em&gt;guess&lt;/em&gt; that there may be a problem if Post Quantum Crypto (PQC) lags behind, as &lt;em&gt;Shor's algorithm&lt;/em&gt; can solve the factoring problem efficiently (thereby breaking RSA public key crypto) or for &lt;em&gt;Grover's algorithm&lt;/em&gt; to force a doubling of the number of bits for &lt;em&gt;all keys&lt;/em&gt;, as it can search a keyspace of $n$ bits in $O(2^{n/2})$ time (proportional to the square root of the size of the space of all possible keys), instead of expected $O(2^n)$ for the classical brute force algorithm.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, PQC tries to create cryptography based on methods for which we &lt;em&gt;currently think&lt;/em&gt; that quantum computing offers little advantage, such as lattice based or coding based crypto. But we can't know this for certain, just as we don't know whether there are &lt;em&gt;classical&lt;/em&gt; algorithms that break current 'commercial grade' crypto.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that for RSA, increasing the key size simply doesn't work, as Shor can factor in time of a rather low order polynomial to crack the key. In other words, a key big enough for Shor to fail, is a key big enough such that any normal en/decryption operations are impossible. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, we really need replacements. Fortunately, I think that PQC started on time and that we will get a good replacement for RSA (and others!) when the truly powerful machines capable of running Shor and Grover effectively arrive.&lt;/p&gt;&#xA;" OwnerUserId="253" LastEditorUserId="253" LastEditDate="2018-04-15T11:08:47.643" LastActivityDate="2018-04-15T11:08:47.643" CommentCount="0" />
  <row Id="1512" PostTypeId="5" CreationDate="2018-03-30T13:39:20.780" Score="0" Body="&lt;p&gt;As stated by Jarosław Adam Miszczak in his book &quot;&lt;em&gt;&lt;a href=&quot;https://books.google.com/books?id=rZFhAQAAQBAJ&amp;amp;printsec=frontcover&quot; rel=&quot;nofollow noreferrer&quot;&gt;High-level Structures in Quantum Computing&lt;/a&gt;&lt;/em&gt;&quot;,&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Quantum programming is the process of assembling sequences of instructions, called quantum programs, that are capable of running on a quantum computer. Quantum programming languages help express quantum algorithms using high-level constructs.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="82" LastEditorUserId="82" LastEditDate="2018-03-30T15:59:54.563" LastActivityDate="2018-03-30T15:59:54.563" CommentCount="0" />
  <row Id="1513" PostTypeId="4" CreationDate="2018-03-30T13:39:20.780" Score="0" Body="For questions relating to the process of assembling quantum programs that can be executed on a quantum computer." OwnerUserId="82" LastEditorUserId="82" LastEditDate="2018-03-30T15:59:35.893" LastActivityDate="2018-03-30T15:59:35.893" CommentCount="0" />
  <row Id="1514" PostTypeId="1" CreationDate="2018-03-30T13:40:07.423" Score="8" ViewCount="144" Body="&lt;p&gt;With the integer factorisation problem, Shor's algorithm is known to provide a substantial (exponential?) speedup compared to classical algorithms. Are there similar results regarding more basic maths, such as evaluating transcendental functions?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's say I want to calculate $\sin2$, $\ln{5}$ or $\cosh10$. In the classical world, I might use an expansion like the Taylor series or some iterative algorithm. Are there quantum algorithms that can be faster than what a classical computer can do, be it asymptotically better, fewer iterations to the same precision, or faster by wall clock time?&lt;/p&gt;&#xA;" OwnerUserId="580" LastEditorUserId="580" LastEditDate="2018-03-30T21:43:07.883" LastActivityDate="2018-03-30T21:43:07.883" Title="Does quantum computing provide any speedup in evaluation of transcendental functions?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-speedup&gt;" AnswerCount="1" CommentCount="4" />
  <row Id="1515" PostTypeId="1" AcceptedAnswerId="1516" CreationDate="2018-03-30T14:12:09.133" Score="4" ViewCount="83" Body="&lt;p&gt;Do the latest D-Wave machines use compounds of $\require{\mhchem}\ce{^{3}He}$ and $\ce{^{4}He}$ for cooling? If not, how does D-Wave approach cooling its plates low enough to achieve Super Conductivity? What compounds does DWave use for the plates in their fridge, and at what temperature do its plates reach super conductivity?&lt;/p&gt;&#xA;" OwnerUserId="1437" LastEditorUserId="55" LastEditDate="2018-03-30T15:32:55.097" LastActivityDate="2018-03-30T15:32:55.097" Title="Do the latest D-Wave computers use Helium Compounds for cooling?" Tags="&lt;quantum-computer&gt;&lt;architecture&gt;&lt;d-wave&gt;&lt;superconducting-quantum-computing&gt;" AnswerCount="1" CommentCount="15" />
  <row Id="1516" PostTypeId="2" ParentId="1515" CreationDate="2018-03-30T14:28:22.083" Score="4" Body="&lt;p&gt;Yes, they use $\require{\mhchem}\ce{^3He}$ and $\ce{^4He}$. No, they do not use compounds of these but instead a solution of these two (at the operating temperature) liquid nobel gases. The details can be found in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Dilution_refrigerator&quot; rel=&quot;nofollow noreferrer&quot;&gt;wikipedia article on dilution refrigerators&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-03-30T14:28:22.083" CommentCount="0" />
  <row Id="1517" PostTypeId="1" AcceptedAnswerId="1518" CreationDate="2018-03-30T14:29:03.303" Score="4" ViewCount="99" Body="&lt;p&gt;&lt;a href=&quot;https://www.nature.com/articles/ncomms2076&quot; rel=&quot;nofollow noreferrer&quot;&gt;This article&lt;/a&gt; talks about correlation and causality in quantum mechanics. In the abstract, under &lt;em&gt;Framework for local quantum mechanics&lt;/em&gt;, it says (emphasis mine):&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The most studied, almost epitomical, quantum correlations are the &lt;strong&gt;non-signalling&lt;/strong&gt; ones, such as those obtained when Alice and Bob perform measurements on two entangled systems. &lt;strong&gt;Signalling&lt;/strong&gt; quantum correlations exist as well, such as those arising when Alice operates on a system that is subsequently sent through a &lt;strong&gt;quantum channel&lt;/strong&gt; to Bob who operates on it after that.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Basically, what is the difference between signalling and non-signalling, and what role does the channel play on that?&lt;/p&gt;&#xA;" OwnerUserId="1346" LastEditorUserId="26" LastEditDate="2018-03-30T14:49:31.147" LastActivityDate="2018-03-30T18:53:02.927" Title="What is the difference between signaling and non-signaling quantum correlations, and what is a signaling channel?" Tags="&lt;quantum-information&gt;&lt;quantum-channel&gt;&lt;quantum-correlation&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="1518" PostTypeId="2" ParentId="1517" CreationDate="2018-03-30T14:55:19.153" Score="6" Body="&lt;p&gt;Basically, it means that the correlations could be used to send a message. Or simply that Bob’s measurement outcomes can reveal some details of Alice’s actions.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is impossible when Alice and Bob each hold one qubit of a Bell pair. Despite the entanglement present, as well as &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Quantum_contextuality&quot; rel=&quot;nofollow noreferrer&quot;&gt;contextuality&lt;/a&gt;, signaling in this case would result faster than light communication. And that’s not allowed.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But if Alice does something to a qubit and then gives it to Bob, signaling is certainly allowed. Alice could simply encode bit values as $|0\rangle$ and $|1\rangle$, for example.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The process of handing over the qubit is referred to as the ‘quantum channel’. This could be done by physically sending it, using a technique such as teleportation to transfer the state, or just Alice shouting ‘Hey Bob, this qubit is yours now’ across the lab. Often channels come with the application of noise, because nothing in life in perfect. But sometimes they are just a concept we invoke in our stories about Alice and Bob.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that non-signaling correlations usually mean that some source correlated a couple of qubits, and then sent one to Alice and the other to Bob. There is then no causal link between what Alice does to hers, and what measurement results Bob gets from his. This is the reason for the lack of signaling.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Signaling correlations, however, usually mean that Alice was the source of the qubit that was sent to Bob. So there is a causal relation: Alice directly affects what state Bob gets, and can use this to send information.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is how we would usually want to describe things but this paper would not want to use such language. This is because it is probing situations where the causal order can be indefinite. It therefore tries to identify these different kinds of correlations in a more general way, and also see if there is anything else.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-03-30T18:53:02.927" LastActivityDate="2018-03-30T18:53:02.927" CommentCount="4" />
  <row Id="1519" PostTypeId="1" CreationDate="2018-03-30T15:27:57.613" Score="5" ViewCount="71" Body="&lt;p&gt;In Wikipedia we can read that&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;the Curry–Howard correspondence is a correspondence between formal proof calculi and type systems for models of computation. In particular, it splits into two correspondences. One at the level of formulas and types that is independent of which particular proof system or model of computation is considered, and one at the level of proofs and programs which, this time, is &lt;strong&gt;specific to the particular choice of proof system and model of computation considered&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;In &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/1489/1346&quot;&gt;this other related question&lt;/a&gt; I asked about the relation between the C-H correspondence &lt;strong&gt;as it was conceived&lt;/strong&gt; and quantum computing. Here the questions are:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Does this theory have to be updated to embrace quantum-specific phenomena like extended causality?&lt;/li&gt;&#xA;&lt;li&gt;If yes, what are the changes made?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="1346" LastActivityDate="2018-03-30T15:27:57.613" Title="Does the Curry-Howard correspondence have a quantum-specific type system?" Tags="&lt;quantum-programming&gt;" AnswerCount="0" CommentCount="0" />
  <row Id="1520" PostTypeId="2" ParentId="1514" CreationDate="2018-03-30T18:04:33.287" Score="5" Body="&lt;p&gt;The only thing I can think of is the &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0606229&quot; rel=&quot;noreferrer&quot;&gt;algorithm&lt;/a&gt; for finding matrix powers which has superpolynomial speed up. It's from &lt;a href=&quot;https://math.nist.gov/quantum/zoo/&quot; rel=&quot;noreferrer&quot;&gt;this list&lt;/a&gt; of quantum algorithms (it seems to be a bit outdated though).&lt;/p&gt;&#xA;" OwnerUserId="1472" LastActivityDate="2018-03-30T18:04:33.287" CommentCount="2" />
  <row Id="1522" PostTypeId="1" AcceptedAnswerId="1530" CreationDate="2018-03-30T23:12:48.783" Score="14" ViewCount="188" Body="&lt;p&gt;I've mostly worked with superconducting quantum computers I am not really familiar with the experimental details of photonic quantum computers that use photons to create continuous-variable cluster states such as the one that the Canadian startup &lt;a href=&quot;https://www.xanadu.ai&quot; rel=&quot;noreferrer&quot;&gt;Xanadu&lt;/a&gt; is building. How are gate operations implemented in these types of quantum computers? And what is the universal quantum gate set in this case?&lt;/p&gt;&#xA;" OwnerUserId="1234" LastEditorUserId="26" LastEditDate="2018-03-31T04:57:41.847" LastActivityDate="2018-03-31T17:27:04.257" Title="How are gates implemented in a continuous-variable quantum computer?" Tags="&lt;architecture&gt;&lt;quantum-gate&gt;&lt;universal-gates&gt;&lt;continuous-variable&gt;" AnswerCount="1" CommentCount="3" FavoriteCount="3" />
  <row Id="1524" PostTypeId="2" ParentId="1474" CreationDate="2018-03-31T06:47:59.563" Score="25" Body="&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_programming&quot; rel=&quot;noreferrer&quot;&gt;Wikipedia list of Quantum Computer programming languages&lt;/a&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;(This answer is not a copy of that webpage, it's more updated and with verified links. In some cases the author's paper or website link is added.)&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_programming#Quantum_instruction_sets&quot; rel=&quot;noreferrer&quot;&gt;Quantum instruction sets&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quil_(instruction_set_architecture)&quot; rel=&quot;noreferrer&quot;&gt;Quil&lt;/a&gt; - An instruction set architecture for quantum computing that first introduced a shared quantum/classical memory model. See also &lt;a href=&quot;https://github.com/rigetticomputing/pyquil/blob/master/README.md&quot; rel=&quot;noreferrer&quot;&gt;PyQuil&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/OpenQASM&quot; rel=&quot;noreferrer&quot;&gt;OpenQASM&lt;/a&gt; - The intermediate representation introduced by IBM for use with their &lt;a href=&quot;https://en.wikipedia.org/wiki/IBM_Quantum_Experience&quot; rel=&quot;noreferrer&quot;&gt;Quantum Experience&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_programming#Quantum_programming_languages&quot; rel=&quot;noreferrer&quot;&gt;Quantum programming languages&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Imperative languages&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_computation_language&quot; rel=&quot;noreferrer&quot;&gt;QCL&lt;/a&gt;&lt;/strong&gt; - One of the first implemented quantum programming languages.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Quantum pseudocode&lt;/strong&gt; - [Not actually a language, but a nice way to represent quantum algorithms and operations.] E. H. Knill. &quot;Conventions for Quantum Pseudocode&quot;, unpublished, LANL report LAUR-96-2724 (PDF Source &lt;a href=&quot;https://pdfs.semanticscholar.org/60d1/e63ca31555ec7013c5eb9a8a63788398fd14.pdf&quot; rel=&quot;noreferrer&quot;&gt;1&lt;/a&gt;, &lt;a href=&quot;https://digital.library.unt.edu/ark:/67531/metadc687305/&quot; rel=&quot;noreferrer&quot;&gt;2&lt;/a&gt;), Search at &lt;a href=&quot;http://search.arxiv.org:8081/?query=%22Conventions%20for%20Quantum%20Pseudocode%22&amp;amp;qid=1522470379946swap_nCnN_-1580011369&amp;amp;byDate=1&quot; rel=&quot;noreferrer&quot;&gt;arXiv&lt;/a&gt; for all papers referencing Knill's paper.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q|SI&gt;&lt;/strong&gt; - Original paper in &lt;a href=&quot;http://engine.scichina.com/publisher/scp/journal/SSI/47/10/10.1360/N112017-00095?slug=full%20text&quot; rel=&quot;noreferrer&quot;&gt;Chinese&lt;/a&gt; with English abstract. English version at arXiv: &quot;&lt;a href=&quot;https://arxiv.org/abs/1710.09500&quot; rel=&quot;noreferrer&quot;&gt;Q|SI&gt;: A Quantum Programming Environment&lt;/a&gt;&quot;.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_programming#Q_language&quot; rel=&quot;noreferrer&quot;&gt;Q language&lt;/a&gt;&lt;/strong&gt; - &lt;a href=&quot;https://web.archive.org/web/20090620011647/http://sra.itc.it/people/serafini/qlang/&quot; rel=&quot;noreferrer&quot;&gt;Software for the Q language&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;qGCL&lt;/strong&gt; - &quot;&lt;a href=&quot;https://arxiv.org/abs/1402.5172&quot; rel=&quot;noreferrer&quot;&gt;Alternation in Quantum Programming: From Superposition of Data to Superposition of Programs&lt;/a&gt;&quot;.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/lanl/qmasm&quot; rel=&quot;noreferrer&quot;&gt;QMASM&lt;/a&gt;&lt;/strong&gt; - Specific to D-Wave systems. &lt;a href=&quot;https://github.com/lanl/qmasm/wiki&quot; rel=&quot;noreferrer&quot;&gt;QMASM Documentation&lt;/a&gt;. Author Scott Pakin's &lt;a href=&quot;https://ccsweb.lanl.gov/~pakin/software/&quot; rel=&quot;noreferrer&quot;&gt;edif2qmasm and QMASM&lt;/a&gt; webpage at LANL.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Functional languages&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;QFC and QPL&lt;/strong&gt; - &lt;a href=&quot;https://www.mscs.dal.ca/~selinger/papers.html&quot; rel=&quot;noreferrer&quot;&gt;Author's website&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;QML&lt;/strong&gt; - Main site: &lt;a href=&quot;http://sneezy.cs.nott.ac.uk/QML/&quot; rel=&quot;noreferrer&quot;&gt;http://sneezy.cs.nott.ac.uk/QML/&lt;/a&gt; (not responding, a month later), &lt;a href=&quot;https://web.archive.org/web/20070926230222/http://sneezy.cs.nott.ac.uk/QML/&quot; rel=&quot;noreferrer&quot;&gt;Archive.Org copy of sneezy.cs.nott.ac.uk&lt;/a&gt;, author's PhD thesis: &quot;&lt;a href=&quot;http://eprints.nottingham.ac.uk/10250/1/thesis.pdf&quot; rel=&quot;noreferrer&quot;&gt;A functional quantum programming language&lt;/a&gt;&quot; (PDF).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://stationq.github.io/Liquid/&quot; rel=&quot;noreferrer&quot;&gt;LIQUi|&gt;&lt;/a&gt;&lt;/strong&gt; - Extension to F# (F Sharp).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Quantum lambda calculi&lt;/strong&gt; - Wikipedia &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_programming#Quantum_lambda_calculi&quot; rel=&quot;noreferrer&quot;&gt;lists a few versions&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.mathstat.dal.ca/~selinger/quipper/&quot; rel=&quot;noreferrer&quot;&gt;Quipper&lt;/a&gt;&lt;/strong&gt; - A Haskell based scalable functional programming language for quantum computing. See also &lt;a href=&quot;https://arxiv.org/abs/1706.02630&quot; rel=&quot;noreferrer&quot;&gt;Proto-Quipper&lt;/a&gt;. A Talk by Peter Selinger (FSCD 2018) titled &quot;&lt;a href=&quot;http://drops.dagstuhl.de/opus/volltexte/2018/9173/&quot; rel=&quot;noreferrer&quot;&gt;Challenges in Quantum Programming Languages&lt;/a&gt;&quot; (&lt;a href=&quot;http://drops.dagstuhl.de/opus/volltexte/2018/9173/pdf/LIPIcs-FSCD-2018-3.pdf&quot; rel=&quot;noreferrer&quot;&gt;.PDF&lt;/a&gt;) discusses these languages.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Multi-Paradigm languages&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/quantum/quantum-qr-intro?view=qsharp-preview&quot; rel=&quot;noreferrer&quot;&gt;Q# (Q Sharp)&lt;/a&gt;&lt;/strong&gt; - A domain-specific programming language used for expressing quantum algorithms. It was initially released to the public by Microsoft as part of the Quantum Development Kit. Also available are Microsoft &lt;a href=&quot;https://cloudblogs.microsoft.com/quantum/2018/07/23/learn-at-your-own-pace-with-microsoft-quantum-katas/&quot; rel=&quot;noreferrer&quot;&gt;Quantum Katas&lt;/a&gt;, a series of self-paced tutorials aimed at teaching elements of quantum computing and Q# programming at the same time.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/XanaduAI/strawberryfields/blob/master/README.rst&quot; rel=&quot;noreferrer&quot;&gt;Strawberry Fields&lt;/a&gt; (from &lt;a href=&quot;https://www.xanadu.ai/tag/quantum-computing/&quot; rel=&quot;noreferrer&quot;&gt;XanduAI&lt;/a&gt;) is a full-stack Python library for designing, simulating, and optimizing continuous variable quantum optical circuits.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;The website &lt;a href=&quot;https://quantumcomputingreport.com/resources/tools/&quot; rel=&quot;noreferrer&quot;&gt;Quantum Computing Report has a Tools webpage&lt;/a&gt; listing over a dozen links, some new and some repeating the above list.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;See also QuanTiki's webpage: &quot;&lt;a href=&quot;https://www.quantiki.org/wiki/list-qc-simulators&quot; rel=&quot;noreferrer&quot;&gt;List of QC simulators&lt;/a&gt;&quot;, for a huge list of simulators and programming languages based on: C/C++, CaML, OCaml, F#, along with GUI based, Java, JavaScript, Julia, Maple, Mathematica, Maxima, Matlab/Octave, .NET, Perl/PHP, Python, Scheme/Haskell/LISP/ML and other online services providing calculators, compilers, simulators, and toolkits, etc.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Are there certain benefits to choosing particular ones?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;If you plan on using a particular quantum computer then one would hope that the programming language developed by the manufacturer is both best suited for that particular machine and well supported.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Choosing a language with a larger following means that there are more Forums available and hopefully more bug fixes and support.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Unfortunately that leaves some great niche products to struggle to gain a user base. Trying to find one language that is both powerful/expressive and supported across various platforms is the trick, the answer is an opinion ATM.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;An evaluation of four software platforms: Forest (pyQuil), QISKit, ProjectQ, and the Quantum Developer Kit is offered by Ryan LaRose in &quot;&lt;a href=&quot;https://arxiv.org/abs/1807.02500&quot; rel=&quot;noreferrer&quot;&gt;Overview and Comparison of Gate Level Quantum Software Platforms&lt;/a&gt;&quot; (6 Jul 2018).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I will return to this answer from time to time to make updates, without excessive &lt;a href=&quot;https://www.webopedia.com/TERM/T/thread_bump.html&quot; rel=&quot;noreferrer&quot;&gt;bumping&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="278" LastEditorUserId="278" LastEditDate="2018-07-29T03:22:06.163" LastActivityDate="2018-07-29T03:22:06.163" CommentCount="2" />
  <row Id="1525" PostTypeId="5" CreationDate="2018-03-31T08:26:30.023" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-03-31T08:26:30.023" LastActivityDate="2018-03-31T08:26:30.023" CommentCount="0" />
  <row Id="1526" PostTypeId="4" CreationDate="2018-03-31T08:26:30.023" Score="0" Body="For questions mainly related to qudits, the unit of quantum information in d-level quantum systems." OwnerUserId="1005" LastEditorUserId="1005" LastEditDate="2018-04-10T20:27:36.837" LastActivityDate="2018-04-10T20:27:36.837" CommentCount="0" />
  <row Id="1527" PostTypeId="1" AcceptedAnswerId="1528" CreationDate="2018-03-31T13:47:03.780" Score="10" ViewCount="121" Body="&lt;p&gt;The circuit&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/rM5Cb.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/rM5Cb.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;can be translated to the following code: &lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;operation Teleport(msg, there) {&#xA;    let register = AllocateRegister();&#xA;    let here = register;&#xA;    H(here);&#xA;    CNOT(here, there);&#xA;    CNOT(msg, here);&#xA;    H(msg);&#xA;    // Measure out the entanglement.&#xA;    if (M(msg) == One)  { Z(there); }&#xA;    if (M(here) == One) { X(there); }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;How do the if-statements come about?  Why are double-lines used after measurements?&lt;/p&gt;&#xA;" OwnerUserId="1589" LastEditorUserId="26" LastEditDate="2018-03-31T14:26:34.173" LastActivityDate="2018-03-31T14:26:34.173" Title="What do double wires mean in quantum circuits, and how do they relate to if statements?" Tags="&lt;circuit-model&gt;&lt;notation&gt;" AnswerCount="1" CommentCount="2" />
  <row Id="1528" PostTypeId="2" ParentId="1527" CreationDate="2018-03-31T13:56:58.460" Score="12" Body="&lt;p&gt;The double lines are one common convention for classical bits in quantum circuit diagrams. In this case, they represent the bits arising from the measurements of the qubits &lt;code&gt;msg&lt;/code&gt; and &lt;code&gt;here&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The controlled operations involving the classical bits are just operations which are performed &lt;em&gt;if&lt;/em&gt; those classical bits happen to have the value 1, which is what the &lt;code&gt;if&lt;/code&gt; statements are for in the pseudocode. &lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-03-31T14:10:37.630" LastActivityDate="2018-03-31T14:10:37.630" CommentCount="0" />
  <row Id="1529" PostTypeId="1" CreationDate="2018-03-31T16:20:43.957" Score="8" ViewCount="265" Body="&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Transmon&quot; rel=&quot;noreferrer&quot;&gt;Transmon&lt;/a&gt; and Xmon qubits are two types of superconducting &lt;a href=&quot;https://en.wikipedia.org/wiki/Charge_qubit&quot; rel=&quot;noreferrer&quot;&gt;charge qubits&lt;/a&gt; that seem to be often used in superconducting quantum devices.&#xA;However, I wasn't able to easily find direct comparisons between them.&#xA;The Xmon architecture seems (&lt;a href=&quot;https://arxiv.org/abs/1304.2322&quot; rel=&quot;noreferrer&quot;&gt;1304.2322&lt;/a&gt;) to have been introduced by Martinis' group, as an alternative to the transmon qubit, so I would expect the former architecture to be better in at least some respects.&#xA;On the other hand, it also seems (&lt;a href=&quot;https://arxiv.org/abs/cond-mat/0703002&quot; rel=&quot;noreferrer&quot;&gt;cond-mat/0703002&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/abs/0712.3581&quot; rel=&quot;noreferrer&quot;&gt;0712.3581&lt;/a&gt; seem to be the relevant references) that the devices from IBM use transmon qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What are the main differences between the two, from a practical point of view (in other words, when and why does one prefer one over the other)? &lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-03-31T16:43:07.160" LastActivityDate="2018-07-24T18:57:56.190" Title="What is the difference between transmon and Xmon qubits?" Tags="&lt;qubit&gt;&lt;architecture&gt;&lt;superconducting-quantum-computing&gt;" AnswerCount="2" CommentCount="1" FavoriteCount="2" />
  <row Id="1530" PostTypeId="2" ParentId="1522" CreationDate="2018-03-31T17:27:04.257" Score="4" Body="&lt;p&gt;Taking an $n$-mode simple harmonic oscillator (SHO) in a (Fock) space $\mathcal F = \bigotimes_k\mathcal H_k$, where $\mathcal H_k$ is the Hilbert space of a SHO on mode $k$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This gives &lt;a href=&quot;https://en.wikipedia.org/wiki/Creation_and_annihilation_operators&quot; rel=&quot;nofollow noreferrer&quot;&gt;the usual&lt;/a&gt; annihilation operator $a_k$, which act on a number state as $a_k\left|n\right&amp;gt; = \sqrt n\left|n-1\right&amp;gt;$ for $n\geq 1$ and $a_k\left|0\right&amp;gt; = 0$ and the creation operator on mode $k$ as $a_k^\dagger$, acting on a number state as $a_k^\dagger\left|n\right&amp;gt; = \sqrt{n+1}\left|n+1\right&amp;gt;$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Hamiltonian of the SHO is $H = \omega\left(a_k^\dagger a_k+\frac 12\right)$ (in units where $\hbar = 1$).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We can then define the quadratures $$X_k = \frac{1}{\sqrt 2}\left(a_k + a_k^\dagger\right)$$ $$P_k = -\frac{i}{\sqrt 2}\left(a_k - a_k^\dagger\right)$$ which are observables. At this point there are various operations (Hamiltonians) that can be performed. The effect of such an operation on the quadratures can be found by using the time evolution of an operator $A$ as $\dot A = i\left[H, A\right]$. Applying these for time $t$ gives: $$X:P\mapsto P-t$$ $$P:X\mapsto X+t$$  $$\frac 12\left(X^2 + P^2\right): X\mapsto \cos t X - \sin t P,\, P\mapsto \cos t P + \sin t X,$$ which is just the Hamiltonian of a SHO with $\omega = 1$ and gives a phase shift. $$\pm S = \pm\frac 12\left(XP+PX\right): X\mapsto e^{\pm t}X,\, P\mapsto e^{\mp t}P,$$ which is known as the squeezing operator, where $+S\,\left(-S\right)$ squeezes $P\,\left(X\right)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Any Hamiltonian of the form $aX+bP+c$ can be built by applying $X$ and $P$. Adding $S$ and $H$ allows for any quadratic Hamiltonian to be built. Further adding the (nonlinear) Kerr Hamiltonian $$\left(X^2 + P^2\right)^2$$ allows for &lt;em&gt;any&lt;/em&gt; polynomial Hamiltonian to be created.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Finally, including the beamsplitter operation (on two modes $j$ and $k$) $$\pm B_{jk} = \pm\left(P_jX_k - X_jP_k\right): A_j\mapsto \cos tA_j + \sin tA_k,\, A_k\mapsto \cos tA_k - \sin tA_j$$ for $A_j = X_j, P_j$ and $A_k = X_k, P_k$, which acts as a beamsplitter on the two modes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;The above operations form the universal gate-set for continuous variable quantum computing.&lt;/strong&gt; More details can be found in e.g. &lt;a href=&quot;https://arxiv.org/pdf/quant-ph/9810082.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;To implement these unitaries:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Applying these operations is generally hinted at in the name:&#xA;Coupling a current is acting as the displacement operator $D\left(\alpha\left(t\right)\right)$ where, for an electric field $\varepsilon$ and current $j$, $\alpha\left(t\right) = i\int_{t_0}^t\int j\left(r, t'\right)\cdot\varepsilon e^{-i\left(k\cdot r - w_kt'\right)} dr\, dt'$. The displacement operator shifts $X$ by the real part of $\alpha$ and $P$ by the imaginary part of $\alpha$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A phase shift can be applied by simply letting the system evolve by itself, as the system is a harmonic oscillator. It can also be performed by using a physical phase shifter.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Squeezing is the hard bit and is something that needs to experimentally be improved. Such methods can be found in e.g. &lt;a href=&quot;https://arxiv.org/abs/1401.4118&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://www.osapublishing.org/optica/abstract.cfm?uri=optica-3-4-362&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt; is one experiment using a limited amount of squeezed light. One possible way of squeezing is using a Kerr $\left(\chi^{\left(3\right)}\right)$ nonlinearity.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This same nonlinearity also allows for the Kerr Hamiltonian to be implemented.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Beamsplitter operation is, unsurprisingly, performed using a beamsplitter.&lt;/p&gt;&#xA;" OwnerUserId="23" LastActivityDate="2018-03-31T17:27:04.257" CommentCount="0" />
  <row Id="1531" PostTypeId="1" CreationDate="2018-03-31T18:19:41.093" Score="8" ViewCount="216" Body="&lt;p&gt;Using quantum control techniques it is possible to control quantum systems in a wide range of different scenarios (e.g. &lt;a href=&quot;https://arxiv.org/abs/0910.2350&quot; rel=&quot;nofollow noreferrer&quot;&gt;0910.2350&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/abs/1406.5260&quot; rel=&quot;nofollow noreferrer&quot;&gt;1406.5260&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In particular, it was shown that using these techniques it is possible to implement gates like the (quantum) Toffoli gate (&lt;a href=&quot;https://arxiv.org/abs/1501.04676&quot; rel=&quot;nofollow noreferrer&quot;&gt;1501.04676&lt;/a&gt;) with good fidelities.&#xA;More precisely, they show that given the Toffoli gate $\newcommand{\on}[1]{\operatorname{#1}}\mathcal{U}_{\on{Toff}}$, defined as the C-CNOT gate&#xA;$$&#xA;\newcommand{\ketbra}[2]{\lvert#1\rangle\langle#2\rvert}&#xA;\newcommand{\ket}[1]{\lvert#1\rangle}&#xA;\newcommand{\bra}[1]{\langle#1\rvert}&#xA;\mathcal{U}_{\on{Toff}}\equiv \ket{0}_1\!\bra{0}\otimes \on{CNOT}&#xA;    + \ket{1}_1\!\bra{1}\otimes I,&#xA;$$&#xA;and a time-dependent Hamiltonian $H(t)$ containing a specific set of interactions, one can find a set of (time-dependent) parameters of $H(t)$ such that&#xA;$$&#xA;\mathcal T \exp\left(-i \int_0^\Theta H(\tau)d\tau\right) \simeq \mathcal U_{\on{Toff}}.&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Are there known results on the universality of such an approach?&#xA;In other words, do the tools provided by quantum control theory allow to say when, given set of constraints on the allowed Hamiltonian parameters, a given target gate can be realized? &lt;strong&gt;(1)&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;More precisely, the problem is the following: fix a target gate $\mathcal U$ acting over a set of qubits (or more generally qudits), and a parametrised Hamiltonian of the form $H(t)=\sum_k c_k(t) \sigma_k$, where $\{\sigma_k\}_k$ is a fixed set of (Hermitian) operators, and $c_k(t)$ are time-dependent parameters to be determined.&#xA;Is there a way to tell whether there are coefficients $\{c_k(t)\}_k$ such that&#xA;$$&#xA;\mathcal T\exp\left(-i\int_0^{\Theta} H(\tau)d\tau\right) \stackrel{?}{=} \mathcal U.&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;(1)&lt;/strong&gt; Note that I here talk of &lt;em&gt;quantum control&lt;/em&gt; only because that is the term used in the paper. If this is not the most suitable term to use to refer to this kind of problems please let me know.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Moreover, note also that the problem solved in the paper is slightly different than the one I stated here. In particular, the Hamiltonian they consider actually acts in the space of three &lt;em&gt;four&lt;/em&gt;-dimensional qudits, and the Toffoli is only implemented as an effective dynamics in the lower levels of each ququart.&#xA;I'm also ok with results of this sort of course.&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-04-03T11:08:42.073" LastActivityDate="2018-04-23T11:10:01.127" Title="Does quantum control allow to implement any gate?" Tags="&lt;quantum-gate&gt;&lt;quantum-control&gt;" AnswerCount="2" CommentCount="9" FavoriteCount="1" />
  <row Id="1532" PostTypeId="2" ParentId="1208" CreationDate="2018-04-01T03:31:13.443" Score="5" Body="&lt;p&gt;Much of the work done so far with quantum computers has been focused on solving combinatorial optimization problems. Both D-Wave style Quantum Annealers and the more recent Gate Model machines from Rigetti, IBM, and Google have been solving combinatorial optimization problems. &lt;strong&gt;One promising approach to connecting machine learning and quantum computing involves finding optimization problems within standard machine learning tasks.&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example the recent Rigetti paper&#xA;&lt;a href=&quot;https://arxiv.org/abs/1712.05771&quot; rel=&quot;noreferrer&quot;&gt;Unsupervised Machine Learning on a Hybrid Quantum Computer&#xA;&lt;/a&gt; essentially recasts the unsupervised machine learning problem of clustering data into two groups, also known as 2-means clustering, into the combinatorial optimization problem of MaxCut. The folks at Rigetti then solve the MaxCut problem with the Quantum Approximate Optimization Algorithm (QAOA).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I would expect to see more of this style of work in the future, especially given the natural connections between optimization and machine learning.&lt;/p&gt;&#xA;" OwnerUserId="1658" LastActivityDate="2018-04-01T03:31:13.443" CommentCount="0" />
  <row Id="1533" PostTypeId="2" ParentId="1437" CreationDate="2018-04-01T03:49:31.920" Score="2" Body="&lt;p&gt;Flux Noise can be a major source of dephasing for superconducting qubits. If you look at the history of the field this makes complete sense. The ideas behind Superconducting Qubits can be traced to the &lt;a href=&quot;https://en.wikipedia.org/wiki/SQUID&quot; rel=&quot;nofollow noreferrer&quot;&gt;SQUID&lt;/a&gt;, which itself was designed to be a very accurate magnetometer. So in general superconducting qubits tend to be quite sensitive to magnetic fields. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;One challenge is to balance this senstivity to magnetic noise with the need to manipulate the qubits. Addressing this challenge is the subject of the Rigetti paper on the &lt;a href=&quot;https://journals.aps.org/prapplied/abstract/10.1103/PhysRevApplied.8.024004&quot; rel=&quot;nofollow noreferrer&quot;&gt;Charge- and Flux-Insensitive Tunable Superconducting Qubit&#xA;&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1658" LastEditorUserId="1658" LastEditDate="2018-04-02T15:18:53.230" LastActivityDate="2018-04-02T15:18:53.230" CommentCount="0" />
  <row Id="1534" PostTypeId="1" AcceptedAnswerId="1539" CreationDate="2018-04-01T03:53:27.287" Score="6" ViewCount="156" Body="&lt;p&gt;Edward Farhi's paper on the &lt;a href=&quot;https://arxiv.org/abs/1411.4028&quot; rel=&quot;noreferrer&quot;&gt;Quantum Approximate Optimization Algorithm&lt;/a&gt;&#xA;introduces a way for gate model quantum computers to solve combinatorial optimization algorithms. However, D-Wave style quantum annealers have focused on combinatorial optimization algorithms for some time now. What is gained by using QAOA on a gate model quantum computer instead of using a Quantum Annealer?&lt;/p&gt;&#xA;" OwnerUserId="1658" LastEditorUserId="26" LastEditDate="2018-04-01T05:28:36.603" LastActivityDate="2018-04-01T15:32:37.367" Title="What is the difference between QAOA and Quantum Annealing?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-speedup&gt;&lt;quantum-annealing&gt;&lt;optimization&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="0" />
  <row Id="1535" PostTypeId="2" ParentId="1485" CreationDate="2018-04-01T03:56:41.350" Score="3" Body="&lt;p&gt;Gaussian Processes are a key component of the model-building procedure at the core of Bayesian Optimization. Therefore speeding up the training of Gaussian processes directly enhances Bayesian Optimization. The recent paper by Zhao et. al on &lt;a href=&quot;https://arxiv.org/abs/1803.10520&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum algorithms for training Gaussian Processes&#xA;&lt;/a&gt; does exactly this.&lt;/p&gt;&#xA;" OwnerUserId="1658" LastActivityDate="2018-04-01T03:56:41.350" CommentCount="1" />
  <row Id="1536" PostTypeId="1" CreationDate="2018-04-01T04:26:16.580" Score="4" ViewCount="60" Body="&lt;p&gt;Given the theoretical infinite quantum states that a qbit can be expressed as is there any practical limit to the processing density in any given quantum processor as compared to the absolute limits imparted in a binary system such as our current binary processors ? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;By this I mean with current binary processors each gate can only have one of two states, and yet in quantum theory it appears as though every single gate can have an infinite number of states, what sort of practical limit, if any would we see in quantum processing, and given this infinite state capability wouldn't we then be in the position that largely every single quantum processor could be expressed as a single qbit with every qbit in effect acting as its own quantum processor with infinite states stand alone from other parallel qbits?&lt;/p&gt;&#xA;" OwnerUserId="1663" LastEditorUserId="26" LastEditDate="2018-04-01T04:37:05.653" LastActivityDate="2018-04-01T09:19:46.420" Title="Processing density capabilities in a quantum processor" Tags="&lt;qubit&gt;&lt;quantum-gate&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="1537" PostTypeId="2" ParentId="1529" CreationDate="2018-04-01T04:34:06.057" Score="6" Body="&lt;p&gt;The transmon is a Josephson junction and capacitor in parallel.&#xA;Transmons have generally been differential circuits, i.e. two transmons on the same chip were not galvanically connected in any way.&#xA;In other words, transmons didn't share a ground reference.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The big difference with the xmon was that xmons are grounded.&#xA;Each xmon on a chip connect to a common ground plane with a presumably fixed voltage.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Much more could be written. If someone leaves a comment asking for more details on any particular aspect of the difference between transmon and xmon, I will write more.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;History of the name&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Rob Schoelkopf told me the story of where the name &quot;transmon&quot; came from while we were at the Les Houches summer school on &quot;Quantum Machines&quot;.&#xA;The charge qubit suffered from low frequency noisey charge fluctuations that lead to dephasing.&#xA;To get around the problem, Professor Schoelkopf thought to shunt the junction with a bit of transmission line.&#xA;The line would be a short circuit at dc, allowing low frequency charge to equalize, but it would be a high impedance at the qubit's resonance frequency allowing the resonance to remain.&#xA;The combination of a &lt;strong&gt;trans&lt;/strong&gt;mission line with the junction plas&lt;strong&gt;mon&lt;/strong&gt; mode lead to the name &quot;transmon&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the end, it turned out that a capacitor was simpler than a transmission line and served a purpose equivalent to the transmission line, so the qubit wound up being a capacitor in parallel with the junction.&#xA;However, the name &quot;transmon&quot; had already stuck (or maybe &quot;capmon&quot; just didn't sound as good).&lt;/p&gt;&#xA;" OwnerUserId="32" LastEditorUserId="32" LastEditDate="2018-07-24T18:57:56.190" LastActivityDate="2018-07-24T18:57:56.190" CommentCount="1" />
  <row Id="1538" PostTypeId="2" ParentId="1536" CreationDate="2018-04-01T05:01:55.680" Score="0" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;By this I mean with current binary processors each gate can only have&#xA;  one of two states, and yet in quantum theory &lt;strong&gt;it appears as though&#xA;  every single gate can have an infinite number of states&lt;/strong&gt;, what sort&#xA;  of practical limit, if any would we see in quantum processing, and&#xA;  given this infinite state capability wouldn't we then be in the&#xA;  position that largely every single quantum processor could be&#xA;  expressed as a single qbit with every qbit in effect acting as its own&#xA;  quantum processor with infinite states stand alone from other parallel&#xA;  qbits?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Well, it is not the gates which have an infinite number of states. It is the qubits themselves. I see lot of fundamental misconceptions in the question. &#xA;A qubit stays a linear superposition of two basis states, like $a|0\rangle + b |1\rangle$ (where $a,b$ are complex numbers). Also note that $a|0\rangle+b|1\rangle$ is an element of a 2-dimensional complex vector space.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Secondly, yes they can exist in an infinite number of superposition states, however when &quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics&quot; rel=&quot;nofollow noreferrer&quot;&gt;measured&lt;/a&gt;&quot; in the $|0\rangle,|1\rangle$ basis, you get either the state $|0\rangle$ (with probability $|a|^2$) or the state $|1\rangle$ (with probability $|b|^2$). Hence, the information of a qubit's initial superposition state gets lost during measurement.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Secondly, consider a 2-qubit system. Unlike in a 1-qubit system, its state lies in a 4-dimensional complex vector space (i.e. $\Bbb{C}^2\times\Bbb{C}^2$), and the superposition state looks something like $c|00\rangle+d|01\rangle+e|10\rangle+f|11\rangle$ (where $c,d,e,f\in\Bbb{C}$). Firstly a 4-dimensional complex vector space is &quot;larger&quot; than a 2-dimensional one, so it cannot be replicated by a single qubit. Also, note that now there are 4 possible basis states to which the system's state can &lt;a href=&quot;https://en.wikipedia.org/wiki/Copenhagen_interpretation&quot; rel=&quot;nofollow noreferrer&quot;&gt;collapse to&lt;/a&gt; upon measuring the first and second qubits in the appropriate basis.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Hence, the answer is an emphatic &lt;strong&gt;no&lt;/strong&gt; for your question &quot;given this infinite state capability wouldn't we then be in the position that largely every single quantum processor could be expressed as a single qbit with every qbit in effect acting as its own quantum processor with infinite states stand alone from other parallel qbits?&quot;&lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-04-01T05:01:55.680" CommentCount="0" />
  <row Id="1539" PostTypeId="2" ParentId="1534" CreationDate="2018-04-01T05:17:44.837" Score="3" Body="&lt;p&gt;One of the advantages, as stated in the paper you linked, is that with QAOA you can increase the precision arbitrarily, whereas QA will only find the solution with probability 1 as $T \to \infty$ which is impractical. In addition if $T$ is too long you're likely to not find the solution as the probability is not monotonic. I believe an example of this can be found in a fair-sampling paper by Matsuda et al. Figure 4 shows that for large $\tau$, using quantum annealing on a 5-qubit system, you only likely to find 2 of the 3 possible states. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/0808.0365v3&quot; rel=&quot;nofollow noreferrer&quot;&gt;[arXiv:0808.0365v3] Ground-state statistics from annealing algorithms: Quantum vs classical approaches&lt;/a&gt; - Matsuda et al. &lt;/p&gt;&#xA;" OwnerUserId="54" LastEditorUserId="54" LastEditDate="2018-04-01T15:32:37.367" LastActivityDate="2018-04-01T15:32:37.367" CommentCount="0" />
  <row Id="1541" PostTypeId="2" ParentId="1536" CreationDate="2018-04-01T09:19:46.420" Score="4" Body="&lt;p&gt;The fact that a qubit has infinite allowed states can seem as though we could fit more than a bit inside it. However, no matter how fancy our proposed encoding, &lt;a href=&quot;https://en.wikipedia.org/wiki/Holevo%27s_theorem&quot; rel=&quot;nofollow noreferrer&quot;&gt;Holevo's bound&lt;/a&gt; shows us that we can never get more than a bit out. This is one effect that provides a bottleneck for how much density we can fit in a quantum processor.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;given this infinite state capability wouldn't we then be in the position that largely every single quantum processor could be expressed as a single qbit with every qbit in effect acting as its own quantum processor&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Suppose $B$ is some bit string of arbitrary length. We want to use this as input for some program $P$ to get the corresponding output bit string $P(B)$. It is true that we could associate $B$ with some state within the Bloch sphere, and then associate $P(B)$ with some other state. Then we could construct a unitary $U_P$ which rotates between them to reproduce the effect of the program.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As a simple example, we could use $| B \rangle = | 0 \rangle$, $| P(B) \rangle = | 1 \rangle$, and $U_P = Y$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we ignore the Holevo bound for a moment, it might seem as if we've reproduced an arbitrarily large computation within a single qubit. But remember that programs aren't designed for only a single input, but for many possible inputs. And they must be able to guide each to their corresponding output.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So let's take another possible input $B'$ and its corresponding output $P(B')$, and find some states within the Bloch sphere to encode them. Now our $U_P$ must simultaneously have the effect&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$U_P | B \rangle = | P(B) \rangle$$&#xA;$$U_P | B' \rangle = | P(B') \rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We could do this perhaps with $| B' \rangle = | + \rangle$, $| P(B') \rangle = | - \rangle$, and still use $U_P = Y$ as before.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now what if we add another output? What states will we use? Will $Y$ still be a good choice to implement the program? Should we change the states we've chosen already to fit the new inputs and outputs in?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The more possible inputs we add, the more of these constraints we get. Hopefully it is clear that it would become increasingly difficult to make it all work. For many programs, it would be impossible.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Let's also ignore this for a second, and suppose that a large problem that we want to solve &lt;em&gt;could&lt;/em&gt; be squeezed into a single qubit. We are very good at simulating single qubits with standard computers. Even if numerical accuracy starts to cause problems, we can just add some more bits to make everything right again. So if we can do everything efficiently with a single qubit, we could also do it efficiently with a classical computer. Either that, or the 'compilation' process is so hard that all our computational complexity is moved to that task instead. In either case, there is no heavy lifting that we would actually need the qubit for.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;So though a single qubit contains a lot of possible states, it is nevertheless too simple to outperform a classical computer. We can't get enough information out, its state space is not big enough to guide large computations from input to output, and it can be classically simulated. Many qubits are needed to overcome all of these issues.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-04-01T09:19:46.420" CommentCount="0" />
  <row Id="1542" PostTypeId="1" CreationDate="2018-04-01T09:53:46.993" Score="9" ViewCount="151" Body="&lt;p&gt;I want to understand what quantum entanglement is and what role does it play in quantum error correction. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;:&#xA;As per the suggestions of @JamesWootton and @NielDeBeaudrap, I have asked a separate question for the classical analogy &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/1554/1678&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1678" LastEditorUserId="26" LastEditDate="2018-05-07T13:19:35.633" LastActivityDate="2018-05-07T13:19:35.633" Title="Quantum entanglement and quantum error correction" Tags="&lt;quantum-entanglement&gt;&lt;quantum-error-correction&gt;" AnswerCount="4" CommentCount="4" />
  <row Id="1543" PostTypeId="2" ParentId="1542" CreationDate="2018-04-01T10:11:42.990" Score="3" Body="&lt;p&gt;There is no classical equivalent to entanglement. Entanglement is perhaps best understood using Dirac (bra-ket) notation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Each qubit can be in the (ket) state $\left|0\right&amp;gt;$ or in the state $\left|1\right&amp;gt;$ or in a superposition $\alpha\left|0\right&amp;gt; + \beta \left|1\right&amp;gt;$ where $\alpha$ and $\beta$ are complex numbers that fulfill $|\alpha|^2 + |\beta|^2 = 1$. If you have two qubits, the basis states of the 2-qubit system are $\left|0\right&amp;gt; \otimes \left|0\right&amp;gt;$, $\left|0\right&amp;gt; \otimes \left|1\right&amp;gt;$, $\left|1\right&amp;gt; \otimes \left|0\right&amp;gt;$, and $\left|1\right&amp;gt; \otimes \left|1\right&amp;gt;$. To simplify the notation, physicists often write these as $\left|00\right&amp;gt;$, $\left|01\right&amp;gt;$, $\left|10\right&amp;gt;$, and $\left|11\right&amp;gt;$. So being in state $\left|01\right&amp;gt;$ means that the first qubit is in state $\left|0\right&amp;gt;$ and the second qubit is in state $\left|1\right&amp;gt;$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now consider a superposition of the kind $\alpha \left|01\right&amp;gt; + \beta \left|10\right&amp;gt;$. This means that the first qubit is in state $\left|0\right&amp;gt;$ with probability $|\alpha|^2$ and in state $\left|1\right&amp;gt;$ otherwise, whilst the second qubit is always in the opposite state that the first one is in: The two particles are entangled.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is unimportant that in this example, the entangled qubits happen to be in opposite states: They might as well be in the same state and still be entangled. What matters is that their states are not independent from each other. This has caused major headaches for physicists because it means that qubits (or the particles carrying them) cannot simultaneously have strictly local properties and be governed by a concept called realism (reflect their states as intrinsic property). Einstein famously called the resulting paradox (if you still assume locaility and realism) &quot;spooky action at a distance.&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Entanglement does not play a special role in quantum error correction: Error correction must work for every state in the computational basis (which does not have entanglement). Then it automatically works also for superpositions of these states (which may be entangled states).&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-04-01T10:11:42.990" CommentCount="7" />
  <row Id="1544" PostTypeId="2" ParentId="1542" CreationDate="2018-04-01T11:01:42.660" Score="3" Body="&lt;p&gt;Entanglement is a natural part of quantum information and quantum computation. If it isn't present --- if you try to do things in such a way that entanglement does not arise --- then you get no benefit from quantum computation. And if a quantum computer is doing something interesting, it will produce a lot of entanglement, at least as a side-effect. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, this does not mean that entanglement is &quot;what makes quantum computers go&quot;. Entanglement is like the spinning gears of a machine: nothing happens if they aren't turning, but that doesn't mean that having those gears spin quickly is enough to make the machine do what you want. (Entanglement &lt;em&gt;is&lt;/em&gt; a primitive resource in this way for &lt;em&gt;communication&lt;/em&gt;, but not for computation as far as anyone has seen.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is as true for quantum error correction as it is for computation. Like all forms of error correction, quantum error correction works by distributing information around a larger system, in particular in the correlations of certain measurable pieces of information. Entanglement is just the usual way in which quantum systems become correlated, so it should come as no surprise that a good quantum error correction code then involves a lot of entanglement. But that doesn't mean that trying to &quot;pump your system full of entanglement&quot;, like some sort of helium balloon, is something which is useful or meaningful to do to protect quantum information. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;While quantum error correction is sometimes described vaguely in terms of entanglement,  more important is how it involves parity checks using different 'observables'. The most important tool for describing this is the stabiliser formalism. The stabiliser formalism can be used to describe some states with large amounts of entanglement, but more importantly it allows you to reason about multi-qubit properties (&quot;observables&quot;) fairly easily. From that perspective, one can come to understand that quantum error correction is much more closely related to low-energy many-body physics of spin-Hamiltonians, than just entanglement in general. &lt;/p&gt;&#xA;" OwnerUserId="124" LastActivityDate="2018-04-01T11:01:42.660" CommentCount="0" />
  <row Id="1545" PostTypeId="2" ParentId="1542" CreationDate="2018-04-01T11:15:33.637" Score="5" Body="&lt;p&gt;Classical correlations between variables occur when the variables &lt;em&gt;appear&lt;/em&gt; random, but whose values are found to systematically agree (or disagree) in some way. However, there will always be someone (or something) that 'knows' exactly what the variables are doing in any given case.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Entanglement between variables is the same, except for the last part. The randomness is truly random. Random outcomes are completely undecided until the time of measurement. But somehow the variables, though they may be separated by galaxies, still know to agree.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;So what does this mean for error correction? Let's start by thinking about error correction for a simple &lt;em&gt;bit&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When storing a classical bit, the kinds of errors you need to worry about are things like bit flips and erasures. So something might make your &lt;code&gt;0&lt;/code&gt; become a &lt;code&gt;1&lt;/code&gt;, or vice-versa. Or your bit might wander off somewhere.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To protect the information, we can ensure that our &lt;em&gt;logical bits&lt;/em&gt; (the actual information we want to store) are not just concentrated on single &lt;em&gt;physical bits&lt;/em&gt;. Instead, we spread it out. So we could use a simple repetition encoding, for example, where we copy our information across many physical bits. This lets us still get our information out, even if some of the physical bits have failed.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is the basic job of error correction: we spread our information out, to make it hard for errors to mess it up.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For qubits, there are more kinds of error to worry about. For example, you may know that qubits can be in superposition states, and that measurements change these. Unwanted measurements are therefore another source of noise, caused by the environment interacting with (and so in some sense 'looking at' our qubits). This type of noise is known as decoherence.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So how does this affect things? Suppose we use the repetition encoding with qubits. So we replace the $|0\rangle$  in our desired logical qubit state with $|000...000\rangle$, repeated across many physical qubits, and replace the $|1\rangle$ with $|111...111\rangle$. This again protects against bit flips and erasures, but it makes it even easier for stray measurements. Now the environment measure whether we have $|0\rangle$ or $|1\rangle$ by looking at any of many qubits. This will make the effect of decoherence much stronger, which is not what we wanted at all!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To fix this, we need to make it hard for decoherence to disturb our logical qubit information, just as we made it hard for bit flips and erasures. To to this, we have to make it harder to measure our logical qubit. Not too hard that we can't do it whenever we want to, of course, but too hard for environment to do easily. This means ensuring that measuring a single physical qubit should tell us nothing about the logical qubit. In fact, we must make it so that a whole bunch of qubits need to be measured and their results compared to extract any information about the qubit. In some sense, it is a form of encryption. You need enough pieces of the puzzle to have any idea what the picture is.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We could try to do this classically. Information could be spread out in complex correlations among many bits. By looking at enough of the bits and analyzing the correlations, we can we extract some information about the logical bit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But this would not be the only way to get this information. As I mentioned before, classically there is always that someone or something that already knows everything. It doesn't matter whether it is a person, or just the patterns in the air caused when the encryption was carried out. Either way, the information exists outside of our encoding, and this is essentially an environment that knows everything. Its very existence means that decoherence has occurred to an irreparable degree.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So that's why we need entanglement. With it, we can hide the information away using correlations in the true and unknowable random outcomes of quantum variables.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-04-01T11:15:33.637" CommentCount="0" />
  <row Id="1546" PostTypeId="2" ParentId="1508" CreationDate="2018-04-01T11:53:39.637" Score="4" Body="&lt;p&gt;The quantum Turing machine &lt;em&gt;can&lt;/em&gt; move into a superposition of moving left and right. This is different from the classical Turing machine which can only move either left or right.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-04-01T11:53:39.637" CommentCount="0" />
  <row Id="1547" PostTypeId="2" ParentId="1531" CreationDate="2018-04-01T12:17:05.650" Score="2" Body="&lt;p&gt;Quantum control does not necessarily allow implementing just any gate. Imagine your control of the system is a time-dependent energy. That corresponds to the Hamiltonian $\hat{H}(t) = c(t) \hat{Z}$. Then you can only ever rotate about one axis of the Bloch sphere and your only choice is how fast to rotate when. This is obviously insufficient to even generate arbitrary single-qubit gates because then you would need to be able to effect rotations about any (arbitrary) axis.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I cannot answer the second part of your question, about known results for the universality. Note, however, that I picked a very special case to illustrate that simple quantum control is not enough. Imagine I had picked the Hamiltonian $\hat{H}(t) = c(t) \hat{X} + \frac{E_0}{2} \hat{Z}$. This is a constant rotation about one axis (due to an energy difference $E_0$ between the two states of the single qubit involved) plus a rotation you completely control about an orthogonal axis. Since you can produce arbitrary rotation with a suitable combination of such rotations, this is universal (for a single qubit system). This is my attempt at illustrating that not having universal control if you have any control could be seen as a special case rather than the rule.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-04-01T12:17:05.650" CommentCount="1" />
  <row Id="1548" PostTypeId="1" AcceptedAnswerId="1555" CreationDate="2018-04-01T12:22:37.357" Score="6" ViewCount="76" Body="&lt;p&gt;Is there an intuitive explanation why the surface code fares so much better than older quantum error correction codes in terms of its high error threshold, with thresholds of up to a few percent rather than some ppm? If so, what is it?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am particularly interested in having it clarified if such a comparison is a fair (apples to apples) comparison. I understand that the results for older quantum error correction are usually analytic results whilst those for surface codes tend to be numeric. Could it be that the analytic solutions indeed take into account the worst possible (coherent) errors whilst numerical solutions perhaps do not capture the worst possible errors because they can only explore a subset of all possible errors?&lt;/p&gt;&#xA;" OwnerUserId="1039" LastEditorUserId="1039" LastEditDate="2018-04-01T12:30:04.637" LastActivityDate="2018-04-01T16:14:34.093" Title="Why does the surface (quantum error correction) code have such a high threshold for errors?" Tags="&lt;quantum-error-correction&gt;" AnswerCount="2" CommentCount="4" />
  <row Id="1549" PostTypeId="1" AcceptedAnswerId="1551" CreationDate="2018-04-01T12:27:24.017" Score="12" ViewCount="199" Body="&lt;p&gt;I know that qubits are represented by quantum particles (for example photons) and that their state is given by one property (for example spin).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is about the &lt;strong&gt;quantum memory&lt;/strong&gt;: how are the qubits stored in a quantum computer. I suppose we require a kind of black box for Heisenberg's uncertainty principle to work. If I understand this correctly this principle is relevant for the superposition of the qubit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;How is this kind of &lt;em&gt;black box&lt;/em&gt; implemented in real quantum computers?&lt;/p&gt;&#xA;" OwnerUserId="11" LastEditorUserId="1847" LastEditDate="2018-04-24T15:28:44.817" LastActivityDate="2018-04-24T15:28:44.817" Title="How to store qubits while preserving Heisenberg's uncertainty principle?" Tags="&lt;quantum-computer&gt;&lt;qubit&gt;&lt;architecture&gt;&lt;quantum-decoherence&gt;&lt;quantum-memory&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="1550" PostTypeId="2" ParentId="1548" CreationDate="2018-04-01T12:27:32.263" Score="3" Body="&lt;p&gt;The surface error correction code always uses eigenstates of just a few stabilizers. By changing operators rather than states, it never needs to apply any state correction to the quantum states (but only to the classically controlled operators or measurements). Hence it is very simple, only repeatedly measuring syndromes. Since the syndromes do not even need actual computations (one only ever measures $\hat{Z}$ and $\hat{X}$), there is very little opportunity for errors to accumulate. Hence the error threshold is high.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I cannot answer if published error thresholds are an apple-to-apple comparison to those published for more traditional quantum error correction schemes.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-04-01T12:27:32.263" CommentCount="1" />
  <row Id="1551" PostTypeId="2" ParentId="1549" CreationDate="2018-04-01T12:36:49.397" Score="10" Body="&lt;p&gt;What you call a &lt;em&gt;black box&lt;/em&gt; is simply isolating the quantum system that stores (or represents) your qubits from the environment. This can be done in several ways depending on your physical realization. For example, in an ion trap based quantum computer, one uses states of a single ion to represent a qubit, and isolates that from the environment by levitating it in empty space (using an ion trap) and by shielding it from the kind of laser radiation or other light sources that affects the chosen states.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-04-01T12:36:49.397" CommentCount="4" />
  <row Id="1552" PostTypeId="1" CreationDate="2018-04-01T12:38:55.040" Score="5" ViewCount="114" Body="&lt;p&gt;The &lt;a href=&quot;https://math.nist.gov/quantum/zoo/&quot; rel=&quot;noreferrer&quot;&gt;Quantum Algorithm Zoo&lt;/a&gt; includes a host of algorithms for which Quantum Computing offers speedups (exponential, polynomial, etc). However, those speedups are based on &lt;strong&gt;asymptotic computational complexity&lt;/strong&gt; (Big-O complexity).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For a realistic implementation on a quantum computer (or even a simulator), the algorithm might require other add-ons to get a satisfiable result. For e.g., for multiple quantum state tomography trials, or probabilistic cloning.&#xA;I am not considering an ideal quantum computer, thus, overheads of physical to logical qubit mapping for Quantum Error Correction; overheads of nearest neighbour mapping; or experimental environmental errors are not considered. I am only considering the effect of projective measurement and no-cloning.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;How can I compare a quantum algorithm taking into account such factors? The overheads might be polynomial, linear, or even constant, so asymptotically it will outperform the corresponding classical algorithm. But, asymptotically means, for a large enough problem size. I am interested in determining if that cross-over point (&lt;strong&gt;quantum supremacy problem size&lt;/strong&gt;) is realistic for my case.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The specific algorithm I am currently working with is an improvement of Grover's search as proposed by &lt;a href=&quot;https://arxiv.org/pdf/quant-ph/9807027.pdf&quot; rel=&quot;noreferrer&quot;&gt;Biham et. al&lt;/a&gt;, where the initial amplitude distribution is not uniform, and there are multiple solutions.&lt;/p&gt;&#xA;" OwnerUserId="1153" LastActivityDate="2018-04-01T13:14:32.417" Title="How to compare a quantum algorithm with its classical version?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-speedup&gt;&lt;complexity-theory&gt;" AnswerCount="1" CommentCount="4" FavoriteCount="1" ClosedDate="2018-04-02T08:04:37.560" />
  <row Id="1553" PostTypeId="2" ParentId="1552" CreationDate="2018-04-01T13:14:32.417" Score="0" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;I am only considering the effect of projective measurement and no-cloning.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Consider that a (long) realistical quantum computation would have to involve quantum error correction which only works if the errors are rather limited: Your projective measurement will be rather close (to within 1% or so) to not incorporating errors other than quantum projection noise. This is usually irrelevant because a typical algorithm will not require you to do state tomography but instead distill a binary result into the qubits to be measured in the end. If it would involve state tomography, the (asymptotic) overhead would enter the big-O notation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There is indeed some overhead from the no-cloning theorem: The (quantum part of the) result of e.g. Shor's algorithm must be read more than once to form the greatest common denominator. Such an overhead obviously depends on the algorithm; in the case of Shor's algorithm, it is small (typically 2 to 3, in detail depending if you are willing to take care of small factors classically, as is simple). A similarly (but not quite as) small overhead occurs if you want to generalize Grover's algorithm to the case where an unknown number of solutions exist.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-04-01T13:14:32.417" CommentCount="1" />
  <row Id="1554" PostTypeId="1" CreationDate="2018-04-01T14:34:13.610" Score="4" ViewCount="79" Body="&lt;p&gt;I want to know if there is any classical analogy for understanding quantum entanglement.&lt;/p&gt;&#xA;" OwnerUserId="1678" LastActivityDate="2018-04-01T14:34:13.610" Title="Is there any classical analogy for quantum entanglement?" Tags="&lt;quantum-entanglement&gt;" AnswerCount="0" CommentCount="6" ClosedDate="2018-04-01T16:48:48.327" />
  <row Id="1555" PostTypeId="2" ParentId="1548" CreationDate="2018-04-01T16:08:41.540" Score="5" Body="&lt;p&gt;Thresholds are often calculated by treating $X$ and $Z$ errors as occurring with the same probability. Any code that corrects one more effectively than the other will then be at a disadvantage: whichever it corrects least effectively will be the bottleneck that determines the threshold. The surface code avoids this by treating these errors in an identical way.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For fault-tolerance thresholds, the fidelity of stabilizer measurements is also taken into account. This includes errors that occur in the required entangling gates. Stabilizers that act on more qubits, and so require more entangling gates, will have less reliable measurements. But the surface code has essentially all stabilizers the same size: they all act on four qubits. And that size is relatively low. They are also quasilocal, so there is no error overhead in shunting qubits around to be measured.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The combination of these effects means that it competes well in terms of threshold, and should be moderately easy to implement.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It's true that analytic results are always worse, because they aim to establish lower bounds rather than exact values. They came more from the era when it was important to determine whether fault-tolerant quantum computation was actually possible, even in principle. Just finding a non-zero threshold was a big deal. Now we focus more on things that can be done on real devices, and how they might perform, and seek thresholds as high as we can for practical reasons.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The surface code nevertheless wins in a typical apples-to-apples comparison of numerically calculated thresholds (I'll update with a reference when I find one). But it should ne noted that the choice of noise model can be used to change the goal posts in the favour of your favourite code.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-04-01T16:14:34.093" LastActivityDate="2018-04-01T16:14:34.093" CommentCount="0" />
  <row Id="1558" PostTypeId="1" AcceptedAnswerId="1559" CreationDate="2018-04-01T21:25:07.217" Score="6" ViewCount="49" Body="&lt;p&gt;You can make a natural correspondence between a quantum state vector and a classical &lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_vector&quot; rel=&quot;noreferrer&quot;&gt;probability vector&lt;/a&gt;, and between a quantum unitary operator and a classical &lt;a href=&quot;https://en.wikipedia.org/wiki/Stochastic_matrix&quot; rel=&quot;noreferrer&quot;&gt;stochastic matrix&lt;/a&gt;. There is also a correspondence between the quantum annealing algorithm and the classical simulated annealing algorithm. I am wondering whether it is possible to write down simulated annealing in the language of probability vectors and stochastic matrices, and then see what additional power is obtained by changing to the quantum counterparts.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;More generally, I would like to bridge the language gaps between probabilistic algorithms and quantum algorithms, and I am wondering whether recasting probabilistic algorithms in terms of probability vectors and stochastic matrices has been tried before.&lt;/p&gt;&#xA;" OwnerUserId="1658" LastActivityDate="2018-04-03T06:25:06.460" Title="Assessing speed-up via Quantum-Stochastic correspondence" Tags="&lt;quantum-algorithms&gt;&lt;quantum-speedup&gt;&lt;quantum-annealing&gt;&lt;classical-computing&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="1559" PostTypeId="2" ParentId="1558" CreationDate="2018-04-01T23:59:23.467" Score="6" Body="&lt;p&gt;Yes. This has been done by Morita and Nishimori in their 2008 publication, &quot;Mathematical Foundations of Quantum Annealing.&quot; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/0806.1859&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/0806.1859&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In Section 5 they derive the convergence conditions from path integral Monte Carlo and Green function Monte Carlo methods. To quote;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;In Sec. 5 we have derived the convergence condition of QA implemented by Quantum Monte Carlo simulations of path-integral and Green function methods. These approaches bear important practical significance because only stochastic methods allow us to treat practical large-size problems on the classical computer. A highly non-trivial result in this section is that the convergence condition for the stochastic methods is essentially the same power-law decrease of the transverse-field term as in the Schrödinger dynamics of Sec. 2. This is surprising since the Monte Carlo (stochastic) dynamics is completely different from the Schrödinger dynamics. Something deep may lie behind this coincidence and it should be an interesting target of future studies.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="54" LastEditorUserId="26" LastEditDate="2018-04-03T06:25:06.460" LastActivityDate="2018-04-03T06:25:06.460" CommentCount="0" />
  <row Id="1560" PostTypeId="1" AcceptedAnswerId="1564" CreationDate="2018-04-02T00:44:12.713" Score="9" ViewCount="156" Body="&lt;p&gt;It is well-known that by utilizing quantum parallelism we can calculate a function $f(x)$ for many different values of $x$ simultaneously. However, some clever manipulations is needed to extract the information of each value, i.e. with Deutsch's algorithm. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Consider the reverse case: can we use quantum parallelism to calculate &lt;em&gt;many functions&lt;/em&gt; (say $f(x),g(x),\dots$) simultaneously for a single value $x_0$?&lt;/p&gt;&#xA;" OwnerUserId="1341" LastActivityDate="2018-04-02T22:38:36.237" Title="Can we use quantum parallelism to calculate many functions at once?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-speedup&gt;" AnswerCount="4" CommentCount="3" />
  <row Id="1562" PostTypeId="2" ParentId="1560" CreationDate="2018-04-02T08:46:45.883" Score="2" Body="&lt;p&gt;Yes, one can. The trick is to define (and implement) a new function $f_\mathrm{all}(y,x)$ that evaluates to $f(x)$ if $y=0$, to $g(x)$ if $y=1$, etc. Then one prepares the qubits representing $y$ in the desired superposition and set $x$ to $x_0$.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-04-02T08:46:45.883" CommentCount="0" />
  <row Id="1563" PostTypeId="2" ParentId="1560" CreationDate="2018-04-02T08:56:41.897" Score="5" Body="&lt;p&gt;The functions $f,g,\ldots $ that you want to evaluate in different computational branches must, in order to be computable at all, be specifiable in some way (e.g. a sequence of classical logic gates). And the &lt;em&gt;set&lt;/em&gt; $\{ f_1, f_2 , \ldots \}$ of the functions you wish to compute ought itself to be computable: for a given $t $, you must be able to compute a specification of how $f_t $ is to be computed on its argument. In effect: you must have a means of describing the functions $f_t $ as stored programs. (These are all necessary, even before we consider quantum computation, for the question of &quot;computing one/all of the functions $f_1, f_2, \ldots $ on an input $x_0$&quot; to be meaningful.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Once you have a way of specifying functions as stored programs, you're basically done: a program is essentially another kind of input, which you can prepare in superposition, and e.g. evaluate on a fixed input, or a superposition of inputs, by computing the functions from their specifications in each branch.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To gain a comptational advantage from doing so is a different matter, and will have to involve some specific structure in the functions $f_t $ that you can take advantage of,  but simply to &quot;evaluate in superposition&quot; is easily done if you have enough information for the question to be sensible. &lt;/p&gt;&#xA;" OwnerUserId="124" LastActivityDate="2018-04-02T08:56:41.897" CommentCount="0" />
  <row Id="1564" PostTypeId="2" ParentId="1560" CreationDate="2018-04-02T09:34:45.497" Score="5" Body="&lt;p&gt;The exact answer depends on the exact kind of superposition you want. The answers by pyramids and Niel both give you something like&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$A\sum_{t=1}^n |\,\,f_t (x)\,\,\rangle \otimes |F_t\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here I've followed Niel in labelling the different functions $f_1$, $f_2$, etc, with $n$ as the total number of functions you want to superpose. Also I've used $F_t$ to denotes some description of the function $f_t$ as a stored program. The $A$ is just whatever number needs to be there for the state to be normalized.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that this is not simply a superposition of the $f_t(x)$. It is entangled with the stored program. If you were to trace out the stored program, you'd just have a mixture of the $f_t(x)$. This means that the stored program could constitute 'garbage', which prevents interference effects that you might be counting on. Or it might not. It depends on how this superposition will be used in your computation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you want rid of the garbage, things get more tricky. For example, suppose what you want is a unitary $U$ that has the effect&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$U : \,\,\, | x \rangle \otimes |0\rangle^{\otimes N} \rightarrow A \sum_{t=1}^n |\,\,f_t (x)\,\,\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;for all possible inputs $x$ (which I am assuming are bit strings written in the computational basis). Note that I've also included some blank qubits on the input side, in case the functions have longer outputs than inputs.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;From this we can very quickly find a condition that the functions must satisfy: since the input states form an orthogonal set, so must the outputs. This will put a significant restriction on the kinds of functions that can be combined in this way.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-04-02T09:40:29.180" LastActivityDate="2018-04-02T09:40:29.180" CommentCount="2" />
  <row Id="1565" PostTypeId="2" ParentId="1560" CreationDate="2018-04-02T09:37:54.337" Score="3" Body="&lt;h2&gt;Yes (depending on what &quot;calculate many functions at once&quot; means)&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Describing the circuit that gives the function $f$ as $U_f$ and the circuit giving $g$ as $U_g$, there are a few ways to go about doing this:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Starting with the qubit registers in $\left|00x\right&amp;gt;$, Prepare a state $\alpha\left|01\right&amp;gt;+\beta\left|10\right&amp;gt;$ on the first two registers. This can be done by applying a unitary&lt;sup&gt;1&lt;/sup&gt; on the first register to put that register in the state $\alpha\left|0\right&amp;gt; + \beta\left|1\right&amp;gt;$ before applying CNOT, then $I\otimes X$. Then, apply $CU_f$ from the first register to the third and $CU_g$ from the second to the third.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1.1. This gives that the third register is now in the state $\left(\alpha U_f + \beta U_g\right)\left|x\right&amp;gt;$, when the initial operations (up to $I\otimes X$) on the first two registers are reversed. However, owing to the general difficulties of implementing arbitrary controlled-unitary operations (as well as using extra qubits unnecessarily) it would probably be easier to implement this directly by dialling up the unitary $\alpha U_f + \beta U_g$. Note that this is neither implementing $f$ nor $g$, but a new, different function $f+g$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1.2. Not reversing the initial operations on the first two registers puts the third in some entangled state of $f$ and $g$, which is discussed in other answers.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Starting with the state $\left|xx\right&amp;gt;$ and applying $U_f$ to the first register and $U_g$ to the second. This is the closest to classical parallelism, where both functions are applied independently to copies of the same state. Aside from requiring twice the number of qubits, the issue here is that, due to no-cloning, in order to copy $\left|x\right&amp;gt;$, it either has to be known, or be a classical state (i.e. not involve superpositions in the computational basis). &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0511088v1&quot; rel=&quot;nofollow noreferrer&quot;&gt;Approximate cloning&lt;/a&gt; could also be used.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Start with the state $\left|0x\right&amp;gt;$, as well as a classical register. Apply a unitary&lt;sup&gt;1&lt;/sup&gt; to put the first register in the superposition $\alpha\left|0\right&amp;gt;+\beta\left|1\right&amp;gt;$. Now, &lt;em&gt;measure&lt;/em&gt; this register (putting the result in the classical register) and apply the &lt;em&gt;classical&lt;/em&gt; operation &lt;code&gt;IF RESULT = 0 U_f ELSE U_g&lt;/code&gt;. While this may seem less powerful than either of the above operations, this is in some sense, equivalent to the quantum channel $\mathcal E\left(\rho\right) = \lvert\alpha\rvert^2U_f\rho U_f^\dagger + \lvert\beta\rvert^2U_g\rho U_g^\dagger$. Such methods can be used to make random unitaries, which have applications in e.g. &lt;a href=&quot;https://en.wikipedia.org/wiki/Boson_sampling&quot; rel=&quot;nofollow noreferrer&quot;&gt;boson sampling&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/abs/0707.0963&quot; rel=&quot;nofollow noreferrer&quot;&gt;randomised benchmarking&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;1 given by $$\begin{pmatrix}\alpha &amp;amp;&amp;amp;-\beta^* \\ \beta &amp;amp;&amp;amp; \alpha^*\end{pmatrix}$$&lt;/sup&gt;&lt;/p&gt;&#xA;" OwnerUserId="23" LastEditorUserId="23" LastEditDate="2018-04-02T10:09:33.963" LastActivityDate="2018-04-02T10:09:33.963" CommentCount="1" />
  <row Id="1568" PostTypeId="1" AcceptedAnswerId="1569" CreationDate="2018-04-02T14:39:19.600" Score="10" ViewCount="120" Body="&lt;p&gt;Quantum computers are efficiently able to simulate any other quantum system. Hence there must be some sort of equivalent of a (possibly simulated) quantum eraser setup. I would like to see such an equivalent drawn as a quantum circuit, ideally in the variant of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Delayed_choice_quantum_eraser&quot; rel=&quot;noreferrer&quot;&gt;delayed choice quantum eraser&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One (quantum) experimental realization of a quantum eraser is this: You create a double slit interference experiment where you obtain which-way information by &quot;doubling&quot; photons in front of each slit using &lt;a href=&quot;https://en.wikipedia.org/wiki/Spontaneous_parametric_down-conversion&quot; rel=&quot;noreferrer&quot;&gt;spontaneous parametric down conversion&lt;/a&gt; (the physics of which are not important for my argument, the point being that we have a new photon we can measure to obtain which-way information). The interference pattern naturally disappears, unless we build a quantum eraser: If the two &quot;doubled&quot; photons carrying the which-way information are superimposed via a 50-50 beamsplitter in such a manner that the which-way information can no longer be measured, the interference pattern reappears. Curiously, this is experimentally the case even if this superimposing happens after the interference pattern is recorded.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I seem to be unable to find a convincing equivalence for the interference pattern and for the quantum eraser in simple qubit gates. But I would love to make the thought (and ideally, the real) experiment on a quantum computer, too. What program (quantum circuit) would I need to run on a quantum computer to do that?&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-04-02T21:46:58.673" Title="What is the quantum circuit equivalent of a (delayed choice) quantum eraser?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-gate&gt;&lt;quantum-eraser&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="2" />
  <row Id="1569" PostTypeId="2" ParentId="1568" CreationDate="2018-04-02T19:44:15.497" Score="6" Body="&lt;p&gt;I will try to translate the Kim &lt;em&gt;et. al.&lt;/em&gt; experiment from an optics description into a quantum information description. Here is the experimental setup as you find it in &lt;a href=&quot;https://en.wikipedia.org/wiki/Delayed_choice_quantum_eraser&quot; rel=&quot;nofollow noreferrer&quot;&gt;the linked wikipedia article&lt;/a&gt;:&lt;br&gt;&#xA;&lt;a href=&quot;https://i.stack.imgur.com/HRgmw.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/HRgmw.png&quot; alt=&quot;the experiment&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We associate the blue path with $|0\rangle$ and the red with $|1\rangle$. The double slit can be described by a Hadamard gate. The BBO corresponds to a CNOT-gate. The state after the BBO is $\frac{1}{\sqrt{2}}(|00\rangle + |11\rangle)$. There is a phase $\varphi$ depending on the position $x$ of detector $D_0$, which corresponds to a phase gate $R_\varphi=\operatorname{diag}(1,e^{i\varphi})$. Finally superposing the beams on $D_0$ corresponds to another Hadamard gate and the measurement of $D_0$ can be seen to project onto $|0\rangle$. The complete circuit looks like this:&lt;br&gt;&#xA;&lt;a href=&quot;https://i.stack.imgur.com/qIQro.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/qIQro.png&quot; alt=&quot;The quantum circuit&quot;&gt;&lt;/a&gt;  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The state before the measurement is:&#xA;$$\frac{1}{2}(|00\rangle+|10\rangle + e^{i\varphi}|01\rangle - e^{i\varphi}|11\rangle)=\frac{1}{2}(((1+e^{i\varphi})|0\rangle+(1-e^{i\varphi})|1\rangle)|+\rangle + ((1-e^{i\varphi})|0\rangle +(1+e^{i\varphi})|1\rangle)|-\rangle)$$&lt;br&gt;&#xA;Let's look at the probability to measure the first photon in $D_0$ ($|0\rangle\langle 0|$).&lt;br&gt;&#xA;If we measure the second in z-basis ($D_3$ and $D_4$), the probability for a click in $D_0$ is $\frac{1}{2}$ (the post-measurement state is $|\pm\rangle$). This is independent of the phase: no interference here. For the x-basis ($D_1$ and $D_2$) the probability for a click at $D_0$ is $\frac{1}{2}(1\mp \cos \varphi)$, so here we see the interference. Whether we see interference or not depends on the basis choice on the second system, which can be delayed. Of course we need to know the outcome, so faster than light communication is not possible with this setup.  &lt;/p&gt;&#xA;" OwnerUserId="104" LastEditorUserId="104" LastEditDate="2018-04-02T21:46:58.673" LastActivityDate="2018-04-02T21:46:58.673" CommentCount="3" />
  <row Id="1570" PostTypeId="1" AcceptedAnswerId="1573" CreationDate="2018-04-02T21:14:13.097" Score="8" ViewCount="212" Body="&lt;p&gt;I am aware that IBM, Rigetti, and Google have built some small-scale devices. Which of them are available for access by an undergraduate student? For how long? With how many qubits?&lt;/p&gt;&#xA;" OwnerUserId="1658" LastEditorUserId="26" LastEditDate="2018-04-03T06:12:43.283" LastActivityDate="2018-04-03T08:56:15.130" Title="What real Quantum Computers are available for students to use?" Tags="&lt;quantum-computer&gt;&lt;quantum-programming&gt;&lt;resource-request&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="2" />
  <row Id="1571" PostTypeId="2" ParentId="1570" CreationDate="2018-04-02T22:27:01.177" Score="6" Body="&lt;p&gt;An undergrad can create an account with the IBM quantum experience. Users have some points that they can use to run simulations of their design on a real quantum computer. You can use five qubits. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am unaware of any way for someone to use Google's quantum computer unless you get a job with them. Rigetti has a device, but what people use online is a simulator of a quantum computer, meant to assist with writing quantum algorithms, that runs up to 36 qubits. It uses a language called Quil.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are multiple simulators available. IBM has one as a part of its IBM quantum experience, there is Quirk, and there are multiple &quot;programming&quot; languages like QCL, most of which are available on github or with the creation of an account, so definitely open to an undergrad.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To summarize: if you don't have a quantum computer of your own and wish to try out a circuit on a real quantum computer, your options seem to be limited to IBM's quantum experience, which has five qubits.&lt;/p&gt;&#xA;" OwnerUserId="91" LastActivityDate="2018-04-02T22:27:01.177" CommentCount="1" />
  <row Id="1572" PostTypeId="2" ParentId="1323" CreationDate="2018-04-03T04:13:08.670" Score="5" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Why can you not subdivide a quantum bitcoin?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Anyone can create a Cryptocurrency, &lt;strong&gt;how it works&lt;/strong&gt; is &lt;strong&gt;up to them&lt;/strong&gt;, how well it is received is up to the public, generally &lt;a href=&quot;https://masterthecrypto.com/guide-how-to-value-a-cryptocurrency/&quot; rel=&quot;noreferrer&quot;&gt;it is decided by&lt;/a&gt;: Utility, Scarcity, Perceived Value.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As of today a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bitcoin&quot; rel=&quot;noreferrer&quot;&gt;Bitcoin&lt;/a&gt; is worth USD 7,073.54, A Bitcoin is 10$^8$ Satoshis which are 0.00000001 Bitcoins, so a Satoshi is worth: 7,073.54 * 0.00000001 = 7.07354 × 10$^{-5}$ USD or 0.00707354 pennies. In total there can be 21 million bitcoin units (2.1 quadrillion Satoshis). The creators of Bitcoin chose that it would be divided into Satoshis.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In Jogenfors' paper, which you cited, he decided that the Quantum Bitcoin protocol (not to be confused with the &lt;a href=&quot;https://qubitcoin.cc/&quot; rel=&quot;noreferrer&quot;&gt;Qubitcoin&lt;/a&gt; (Q2C) a CPU and GPU based Cryptocurrency) will use the no-cloning theorem of quantum mechanics to construct quantum shards and two blockchains.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &lt;strong&gt;answer to your question is&lt;/strong&gt;, according to section 4.4 - Preventing the Reuse Attack:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;With Bitcoin the blockchain records all transactions and a miner therefore&#xA;relinquishes control over the mined bitcoin as soon as it is handed over to a recipient. In Quantum Bitcoin, however, there is no record of who owns what, so there is no way to distinguish between the real and counterfeit quantum bitcoin.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We prevent the reuse attack by adding a secondary stage to the minting algorithm, where data is also appended to a new ledger $\mathcal{L^′}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;...&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quantum shard miners create and sell the quantum shards on a marketplace, another miner (called a quantum bitcoin miner) purchases $m$ quantum shards ${(s, ρi, σi)}1≤i≤m$ on the marketplace that, for all $1 ≤ i ≤ m$, fulfill the following conditions:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;$\mathsf{Verify}\mathcal{_M} ((s, ρi, σi))$ accepts&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;The timestamp $T$ of the quantum shard in the Quantum Shard ledger $\mathcal{L}$ fulfills $t − T ≤ T_{max}$, where $t$ is the current time&quot;. See section &quot;A.2 The Reuse Attack&quot; for further proof.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Shards have a lifetime of $T_{max}$&lt;/strong&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;While a shard is designed to have a short lifetime the Quantum Bitcoin is designed to have a great longevity (&lt;strong&gt;as long as it is intact, undivided&lt;/strong&gt;), see section &quot;A.3 Quantum Bitcoin Longevity&quot;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;strong&gt;Theorem 4 (Quantum Bitcoin Longevity)&lt;/strong&gt; The number of times a quantum bitcoin can be verified and reconstructed is exponentially large in $n$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Proof&lt;/strong&gt; Corollary 1 shows that the completeness error $\varepsilon$ of $\mathcal{Q}$ is exponentially small in $n$. When verifying a genuine quantum bitcoin \$, the verifier performs the measurement $\mathsf{Verify}\mathcal{_Q}$(\$) on the underlying quantum states $ρ$, which yields the outcome “Pass” with probability $1 − \varepsilon$. Then lemma 2 shows that we can recover the underlying quantum states $\widetilde{p}_{i}$ of \$ so that $ \Vert \widetilde{p}_{i} − p_i \Vert _{tr} \le \sqrt\varepsilon$. As $\varepsilon$ is exponentially small in $n$, the trace distance becomes exponentially small in $n$ as well. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Each time such a quantum bitcoin is verified and reconstructed, the trace distance between the “before” and “after” is exponentially small in $n$. Given &lt;strong&gt;any threshold after which&lt;/strong&gt; we consider the quantum bitcoin “worn out”, the number of verifications it survives before passing this threshold is exponential in $n$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Theorem 4 shows that a quantum bitcoin \$ can be verified and re-used many times before the quantum state is lost (&lt;strong&gt;assuming the absence of noise and decoherence&lt;/strong&gt;). This is of course analogous to traditional, physical banknotes and coins which are expected to last for a large enough number of transactions before wearing out.&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, much like paper money, you need the whole bill (blockchain) undivided. Of course, that doesn't prevent you from exchanging one Quantum Bitcoin for however many Bitcoins and then offering Bitcoins (or fiat) as change.&lt;/p&gt;&#xA;" OwnerUserId="278" LastActivityDate="2018-04-03T04:13:08.670" CommentCount="0" />
  <row Id="1573" PostTypeId="2" ParentId="1570" CreationDate="2018-04-03T08:56:15.130" Score="11" Body="&lt;p&gt;The first cloud device was made available back in 2013. It is a &lt;a href=&quot;http://www.bristol.ac.uk/physics/research/quantum/engagement/qcloud/&quot; rel=&quot;noreferrer&quot;&gt;photonic chip&lt;/a&gt; at the University of Bristol. Though it is an example of something we could build quantum computers from, it is quite different from the usual 'circuit model' architecture. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then 2016 brought some devices from IBM. There are 5 qubit processors anyone can use with the &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx&quot; rel=&quot;noreferrer&quot;&gt;Quantum Experience GUI&lt;/a&gt; or using a the &lt;a href=&quot;https://www.qiskit.org/&quot; rel=&quot;noreferrer&quot;&gt;QISKit SDK&lt;/a&gt;. There's also a 16 qubit device that you can use only with QISKit. Larger devices also exist, but they are not publically available.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then came Rigetti's &lt;a href=&quot;http://pyquil.readthedocs.io/en/stable/qpu_overview.html&quot; rel=&quot;noreferrer&quot;&gt;19 qubit QPU&lt;/a&gt; at the end of last year, which can be used via &lt;a href=&quot;http://pyquil.readthedocs.io/en/stable/overview.html&quot; rel=&quot;noreferrer&quot;&gt;pyQuil&lt;/a&gt;. You have to apply for an appointment to get access for a few hours, but I see no reason why anyone with a serious interest would not have it granted.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Finally, Alibaba and the Chinese Academy of Sciences have teamed up to put an &lt;a href=&quot;http://quantumcomputer.ac.cn/index.html&quot; rel=&quot;noreferrer&quot;&gt;11 qubit device&lt;/a&gt; on the cloud. The interface is via a GUI, and is quite similar to IBM's Quantum Experience.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-04-03T08:56:15.130" CommentCount="0" />
  <row Id="1575" PostTypeId="5" CreationDate="2018-04-03T09:40:56.517" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-03T09:40:56.517" LastActivityDate="2018-04-03T09:40:56.517" CommentCount="0" />
  <row Id="1576" PostTypeId="4" CreationDate="2018-04-03T09:40:56.517" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-03T09:40:56.517" LastActivityDate="2018-04-03T09:40:56.517" CommentCount="0" />
  <row Id="1577" PostTypeId="1" AcceptedAnswerId="1578" CreationDate="2018-04-03T13:23:59.997" Score="10" ViewCount="218" Body="&lt;p&gt;From what I understood, there seems to be a difference between quantum annealing and adiabatic quantum computation models but the only thing I found on this subject implies some strange results (see below).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is the following: what is exactly the difference/relation between quantum annealing and adiabatic quantum computation? &lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;The &quot;strange&quot; result:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;On &lt;a href=&quot;https://en.wikipedia.org/wiki/Adiabatic_quantum_computation&quot; rel=&quot;noreferrer&quot;&gt;Wikipedia&lt;/a&gt;, adiabatic quantum computation is depicted as &quot;a subclass of quantum annealing&quot;.&lt;/li&gt;&#xA;&lt;li&gt;On the other hand we know that:&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Adiabatic quantum computation is equivalent to quantum circuit model (&lt;a href=&quot;https://arxiv.org/pdf/quant-ph/0405098.pdf&quot; rel=&quot;noreferrer&quot;&gt;arXiv:quant-ph/0405098v2&lt;/a&gt;)&lt;/li&gt;&#xA;&lt;li&gt;DWave computers use quantum annealing.&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;So by using the 3 facts above, DWave quantum computers should be universal quantum computers. But from what I know, DWave computers are restricted to a very specific kind of problem so they cannot be universal.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As a side question, what is the problem with the reasoning above?&lt;/p&gt;&#xA;" OwnerUserId="1386" LastEditorUserId="673" LastEditDate="2018-04-03T16:17:24.090" LastActivityDate="2018-04-03T16:17:24.090" Title="What is the difference between quantum annealing and adiabatic quantum computation models?" Tags="&lt;quantum-annealing&gt;&lt;quantum-computing-models&gt;&lt;adiabatic-model&gt;" AnswerCount="1" CommentCount="1" FavoriteCount="1" />
  <row Id="1578" PostTypeId="2" ParentId="1577" CreationDate="2018-04-03T14:29:38.580" Score="3" Body="&lt;p&gt;Vinci and Lidar have a nice explanation in their introduction of non-stoquastic Hamiltonians in quantum annealing (which is necessary to a quantum annealing device to simulate gate model computation). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1701.07494&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/1701.07494&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;It is well known that the solution of computational problems can be encoded into the ground state of a time-dependent quantum Hamiltonian. This approach is known as adiabatic quantum computation (AQC), and is universal for quantum computing (for a review of AQC see  arXiv:1611.04471). Quantum annealing (QA) is a framework that incorporates algorithms and hardware designed to solve computational problems via quantum evolution towards the ground states of final Hamiltonians that encode classical optimization problems, without necessarily insisting on universality or adiabaticity.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;QA thus inhabits a regime that is intermediate between the idealized assumptions of universal AQC and unavoidable experimental compromises. Perhaps the most significant of these compromises has been the design of stoquastic quantum annealers. A Hamiltonian $H$ is stoquastic with respect to a given basis if $H$ has only real nonpositive offdiagonal matrix elements in that basis, which means that its ground state can be expressed as a classical probability distribution. Typically, one chooses the computational basis, i.e., the basis in which the final Hamiltonian is diagonal. The computational power of stoquastic Hamiltonians has been carefully scrutinized, and is suspected to be limited in the ground-state AQC setting. E.g., it is unlikely that ground-state stoquastic AQC is universal. Moreover, under various assumptions ground-state stoquastic AQC can be efficiently simulated by classical algorithms such as quantum Monte Carlo, though certain exceptions are known.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="54" LastActivityDate="2018-04-03T14:29:38.580" CommentCount="2" />
  <row Id="1579" PostTypeId="2" ParentId="1441" CreationDate="2018-04-03T17:25:00.800" Score="7" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;I'm looking for an explicit upper bound on the probability of successful counterfeiting ...&quot;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;In &quot;&lt;a href=&quot;https://arxiv.org/abs/1404.1507v4&quot; rel=&quot;noreferrer&quot;&gt;An adaptive attack on Wiesner's quantum money&lt;/a&gt;&quot;, by Aharon Brodutch, Daniel Nagaj, Or Sattath, and Dominique Unruh, last revised on 10 May 2016, the authors claim a success rate of: &quot;~100%&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The paper makes these claims:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;Main results.&lt;/strong&gt; We show that &lt;strong&gt;in a strict testing variant&lt;/strong&gt; of Wiesner's scheme (that is, if only valid money is returned to the owner), given a single valid quantum money state $(s,\left|\$_s\right&amp;gt;)$, a counterfeiter can efficiently create as many copies of $\left|\$_s\right&amp;gt;$ as he wishes (hence, the &lt;strong&gt;scheme is insecure&lt;/strong&gt;). He can rely on the quantum Zeno effect for protection – if he disturbs the quantum money state only slightly, the bill is likely to be projected back to the original state after a test. Interestingly, this allows a counterfeiter to distinguish the four different qubit states with an &lt;strong&gt;arbitrarily small probability&lt;/strong&gt; of being caught.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;...&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;In this paper, we have focused on Wiesner's money in a noiseless environment. That is, the bank rejects the money if even a single qubit is measured incorrectly. In &lt;strong&gt;a more realistic setting&lt;/strong&gt;, we have to deal with noise, and &lt;strong&gt;the bank would want to tolerate a limited amount of errors&lt;/strong&gt; in the quantum state [PYJ+12], say 10%.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Also see: &quot;&lt;a href=&quot;https://arxiv.org/abs/1604.01383&quot; rel=&quot;noreferrer&quot;&gt;Quantum Bitcoin: An Anonymous and Distributed Currency Secured by the No-Cloning Theorem of Quantum Mechanics&lt;/a&gt;&quot;, by Jonathan Jogenfors, 5 Apr 2016, where he discusses Wiesner's scheme and proposes one of his own.&lt;/p&gt;&#xA;" OwnerUserId="278" LastActivityDate="2018-04-03T17:25:00.800" CommentCount="0" />
  <row Id="1580" PostTypeId="1" AcceptedAnswerId="1582" CreationDate="2018-04-03T18:40:26.300" Score="6" ViewCount="148" Body="&lt;p&gt;There are many different ways to build quantum computers, such as superconducting qubits, quantum dots, and ion traps.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What I would like to understand is why some universities and research organizations have chosen to study trapped ion quantum computers.&#xA;I understand that it is better in some respects, but what are the fundamental differences?&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/Qma4P.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/Qma4P.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Source: &lt;a href=&quot;https://youtu.be/90U_SmKyfGI&quot; rel=&quot;nofollow noreferrer&quot;&gt;Youtube video&lt;/a&gt;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Domain of Science&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Dominic Walliman&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="245" LastEditorUserId="253" LastEditDate="2018-04-04T08:39:14.987" LastActivityDate="2018-04-04T08:39:14.987" Title="What are the fundamental differences between trapped ion quantum computers and other architectures?" Tags="&lt;quantum-computer&gt;&lt;quantum-computing-models&gt;&lt;universal-gates&gt;&lt;superconducting-quantum-computing&gt;" AnswerCount="1" CommentCount="7" />
  <row Id="1581" PostTypeId="1" AcceptedAnswerId="1587" CreationDate="2018-04-03T22:02:33.580" Score="11" ViewCount="250" Body="&lt;p&gt;The typically used gate set for quantum computation is composed of the single qubits Cliffords (Paulis, H and S) and the controlled-NOT and/or controlled-Z.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To go beyond Clifford we like to have full single qubit rotations. But if we are being minimal, we just go for T (the fourth root of Z).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This particular form of the gate set pops up everything. Such as IBM’s Quantum Experiment p, for example.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Why these gates, exactly? For example, H does the job of mapping between X and Z. S similarly does the job of mapping between Y and X, but a factor of $-1$ also gets introduced. Why don’t we use a Hadamard-like unitary $(X+Y)/\sqrt{2}$ instead of S? Or why don’t we use the square root of Y instead of H? It would be equivalent mathematically, of course, but it would just seem a bit more consistent as a convention.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And why is our go-to non-Clifford gate the fourth root of Z? Why not the fourth root of X or Y?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What historical conventions led to this particular choice of gate set?&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="2417" LastEditDate="2018-08-06T08:04:15.023" LastActivityDate="2018-08-06T08:04:15.023" Title="Why do we use the standard gate set that we do?" Tags="&lt;quantum-gate&gt;&lt;notation&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="1" />
  <row Id="1582" PostTypeId="2" ParentId="1580" CreationDate="2018-04-04T00:53:26.050" Score="7" Body="&lt;p&gt;&lt;em&gt;Disclosure: while I am not an experimental physicist, I am part of the &lt;a href=&quot;https://nqit.ox.ac.uk&quot; rel=&quot;noreferrer&quot;&gt;NQIT project&lt;/a&gt;, which is aiming to develop quantum hardware which is suitable to realise scalable quantum computers. The architecture that we're investing most heavily in is optically linked ion traps.&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Ions represent some of the physically best understood systems to experimental and theoretical physics, and the idea of performing quantum computation with ion traps is a very old one, as far as proposed implementations go. The main features of ion traps as a potential approach to realising quantum computation are &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;They can give rise to very stable qubits, with life times on the order of a minute or more; and&lt;/li&gt;&#xA;&lt;li&gt;For well-chosen ion species, the electron state transitions are very well understood, in principle allowing for very high precision gates.&lt;/li&gt;&#xA;&lt;li&gt;Furthermore, these features can be realised without the need for heavy cryogenics.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;See for instance [&lt;a href=&quot;https://arxiv.org/pdf/0805.2450.pdf&quot; rel=&quot;noreferrer&quot;&gt;arXiv:0805.2450&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1606.08409&quot; rel=&quot;noreferrer&quot;&gt;arXiv:1606.08409&lt;/a&gt;]. To be sure, there are obstacles to using ion traps as a basis for quantum technologies. Most importantly, you need to solve the problem of cross-talk between the ions due to collective motional excitation, either through clever quantum control or through isolation of groups of ions. If the latter, you have to find a way to regroup collections of ions in a very large trap architecture, or find a way for ions in different traps to communicate.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The scaling problems for ion traps are not easy problems. However, significant obstacles exist for all quantum architectures; while well-resourced multinational corporations have placed their bets elsewhere, it seems to me far too early to reliably predict which platform will solve their scaling problems first. To my knowledge, none of the approaches have managed to get to the point where the only problem left is engineering.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you could solve the scaling problems for ion traps, you would likely realise computers through the unitary circuit model, the measurement-based model, or some closely related model to these, according to how you negotiated the scaling problem. Of course, this is how one might describe computation at the lowest level, i.e. to realise error correction. At higher levels, tradition would exert a significant amount of pressure to use the primitive operations to realise fault-tolerant unitary circuit model operations, unless some other computational model was somehow compelling enough to displace it for the scalable error-corrected system.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In any case &amp;mdash; it is not really meaningful at this stage to call ion traps in general a &quot;non-universal model&quot;, as your diagram suggests, just because some groups have aimed for quantity before versatility. This would be similar to pigeon-holing transistors as a non-universal computational platform in the 1950s, just because they were used to make radios before they were used to make computers. Even if (as the linked YouTube video suggests) the ion trap groups on the U.S. eastern seaboard are aiming first for many ions and then attempting to master versatile quantum control,  other groups such as the one at Oxford are taking the opposite approach of controlling very few qubits very well, then attempting to approach the problem of scaling up. Both are possible trajectories towards solving the difficult problem of designing scalable quantum computers.&lt;/p&gt;&#xA;" OwnerUserId="124" LastActivityDate="2018-04-04T00:53:26.050" CommentCount="2" />
  <row Id="1584" PostTypeId="1" AcceptedAnswerId="1594" CreationDate="2018-04-04T06:17:09.467" Score="17" ViewCount="1393" Body="&lt;p&gt;Is there a general statement about what kinds of problems can be solved more efficiently using quantum computers (quantum gate model only)? Do the problems for which an algorithm is known today have a common property?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As far as i understand quantum computing helps with the hidden subgroup problem (Shor); Grover's algorithm helps speedup search problems. I have read that quantum algorithms can provide speed-up if you look for a 'global property' of  a function (Grover/Deutsch).&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Is there a more concise and correct statement about where quantum computing can help? &lt;/li&gt;&#xA;&lt;li&gt;Is it possible to give an explanation why quantum physics can help there (preferably something deeper that 'interference can be exploited')? And why it possibly will not help for other problems (e.g. for NP-complete problems)?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Are there relevant papers that discuss just that?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I had asked this question before over on &lt;a href=&quot;https://cstheory.stackexchange.com/questions/38118/general-statement-what-kinds-of-problems-can-be-solved-more-efficiently&quot;&gt;cstheory.stackexchange.com&lt;/a&gt; but it may be more suitable here.&lt;/p&gt;&#xA;" OwnerUserId="1185" LastEditorUserId="26" LastEditDate="2018-04-04T06:59:28.887" LastActivityDate="2018-04-05T08:43:47.650" Title="Is there any general statement about what kinds of problems can be solved more efficiently using a quantum computer?" Tags="&lt;quantum-computer&gt;&lt;quantum-algorithms&gt;&lt;quantum-speedup&gt;&lt;complexity-theory&gt;" AnswerCount="3" CommentCount="0" FavoriteCount="7" />
  <row Id="1585" PostTypeId="2" ParentId="1584" CreationDate="2018-04-04T07:29:37.973" Score="8" Body="&lt;p&gt;&lt;strong&gt;TL;DR: No, we do not have any &lt;em&gt;precise&lt;/em&gt; &quot;general&quot; statement about exactly which type of problems quantum computers can &lt;em&gt;solve&lt;/em&gt;, in complexity theory terms. However, we do have a rough idea.&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;According to Wikipedia's sub-article on &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_computing#Relation_to_computational_complexity_theory&quot; rel=&quot;noreferrer&quot;&gt;Relation to to computational complexity theory&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The class of problems that can be efficiently solved by quantum&#xA;  computers is called &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/BQP&quot; rel=&quot;noreferrer&quot;&gt;BQP&lt;/a&gt;&lt;/strong&gt;, for &quot;bounded error, quantum, polynomial&#xA;  time&quot;. Quantum computers only run &lt;a href=&quot;https://en.wikipedia.org/wiki/Randomized_algorithm&quot; rel=&quot;noreferrer&quot;&gt;probabilistic algorithms&lt;/a&gt;, so &lt;strong&gt;BQP&lt;/strong&gt; on&#xA;  quantum computers is the counterpart of &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/BPP_(complexity)&quot; rel=&quot;noreferrer&quot;&gt;BPP&lt;/a&gt;&lt;/strong&gt; (&quot;bounded error,&#xA;  probabilistic, polynomial time&quot;) on classical computers. &lt;strong&gt;It is defined&#xA;  as the set of problems solvable with a polynomial-time algorithm,&#xA;  whose probability of error is bounded away from one half&lt;/strong&gt;. A&#xA;  quantum computer is said to &quot;solve&quot; a problem if, for every instance,&#xA;  its answer will be right with high probability. If that solution runs&#xA;  in polynomial time, then that problem is in BQP.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;BQP is contained in the complexity class &lt;a href=&quot;https://en.wikipedia.org/wiki/Sharp-P&quot; rel=&quot;noreferrer&quot;&gt;#P&lt;/a&gt; (or more precisely in the&#xA;  associated class of decision problems P&lt;sup&gt;#P&lt;/sup&gt;), which is a subclass of&#xA;  &lt;a href=&quot;https://en.wikipedia.org/wiki/PSPACE&quot; rel=&quot;noreferrer&quot;&gt;PSPACE&lt;/a&gt;.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;BQP is suspected to be disjoint from NP-complete and a strict superset&#xA;  of P, but that is not known. Both integer factorization and discrete&#xA;  log are in BQP. Both of these problems are&#xA;  &lt;a href=&quot;https://en.wikipedia.org/wiki/NP_(complexity)&quot; rel=&quot;noreferrer&quot;&gt;NP&lt;/a&gt; problems suspected&#xA;  to be outside BPP, and hence outside P. Both are suspected to not be&#xA;  NP-complete. There is a common misconception that quantum computers&#xA;  can solve NP-complete problems in polynomial time. That is not known&#xA;  to be true, and is generally suspected to be false.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;The capacity of a quantum computer to accelerate classical algorithms&#xA;  has rigid limits—upper bounds of quantum computation's complexity. The&#xA;  overwhelming part of classical calculations cannot be accelerated on a&#xA;  quantum computer. A similar fact takes place for particular&#xA;  computational tasks, like the search problem, for which Grover's&#xA;  algorithm is optimal.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Bohmian Mechanics is a non-local hidden variable interpretation of&#xA;  quantum mechanics. It has been shown that a non-local hidden variable&#xA;  quantum computer could implement a search of an N-item database at&#xA;  most in ${\displaystyle O({\sqrt[{3}]{N}})}$ steps. This is slightly&#xA;  faster than the $\displaystyle O({\sqrt  {N}})$ steps taken by&#xA;  Grover's algorithm. Neither search method will allow quantum computers&#xA;  to solve NP-Complete problems in polynomial time.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;strong&gt;Although quantum computers may be faster than classical computers for&#xA;  some problem types, those described above can't solve any problem that&#xA;  classical computers can't already solve.&lt;/strong&gt; A Turing machine can simulate&#xA;  these quantum computers, so such a quantum computer could never solve&#xA;  an undecidable problem like the halting problem. The existence of&#xA;  &quot;standard&quot; quantum computers does not disprove the Church–Turing&#xA;  thesis. It has been speculated that theories of quantum gravity, such&#xA;  as M-theory or loop quantum gravity, may allow even faster computers&#xA;  to be built. Currently, defining computation in such theories is an&#xA;  open problem due to the problem of time, i.e., there currently exists&#xA;  no obvious way to describe what it means for an observer to submit&#xA;  input to a computer and later receive output.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;As for &lt;em&gt;why&lt;/em&gt; quantum computers can &lt;em&gt;efficiently&lt;/em&gt; solve BQP problems:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;ol&gt;&#xA;  &lt;li&gt;&lt;p&gt;The number of qubits in the computer is allowed to be a polynomial&#xA;  function of the instance size. For example, algorithms are known for&#xA;  factoring an $n$-bit integer using just over $2n$ qubits (Shor's&#xA;  algorithm).&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Usually, computation on a quantum computer ends with a measurement.&#xA;  This leads to a collapse of quantum state to one of the basis states.&#xA;  It can be said that the quantum state is measured to be in the correct&#xA;  state with high probability.&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Interestingly, if we theoretically allow post-selection (which doesn't have any scalable practical implementation), we get the complexity class &lt;a href=&quot;https://en.wikipedia.org/wiki/PostBQP&quot; rel=&quot;noreferrer&quot;&gt;post-BQP&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;In computational complexity theory, PostBQP is a complexity class&#xA;  consisting of all of the computational problems solvable in polynomial&#xA;  time on a quantum Turing machine with postselection and bounded error&#xA;  (in the sense that the algorithm is correct at least 2/3 of the time&#xA;  on all inputs). However, Postselection is not considered to be a&#xA;  feature that a realistic computer (even a quantum one) would possess,&#xA;  but nevertheless postselecting machines are interesting from a&#xA;  theoretical perspective.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I'd like to add what &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1584/is-there-any-general-statement-about-what-kinds-of-problems-can-be-solved-more-e#comment1262_1585&quot;&gt;@Discrete lizard&lt;/a&gt; mentioned in the comments section. You have not explicitly defined what you mean by &quot;can help&quot;, however, the rule of thumb in complexity theory is that if a quantum computer &quot;can help&quot; in terms of solving in polynomial time (with an error bound) iff the class of problem it can solve lies in BQP but not in P &lt;em&gt;or&lt;/em&gt; BPP. The general relation between the complexity classes we discussed above is &lt;strong&gt;suspected&lt;/strong&gt; to be:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\text{P $\subseteq$ BPP $\subseteq$ BQP $\subseteq$ PSPACE}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/y2yXMm.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/y2yXMm.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, P=PSPACE, is &lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_unsolved_problems_in_computer_science&quot; rel=&quot;noreferrer&quot;&gt;an open problem in Computer Science&lt;/a&gt;. Also, the &lt;a href=&quot;https://en.wikipedia.org/wiki/P_versus_NP_problem&quot; rel=&quot;noreferrer&quot;&gt;relationship between P and NP&lt;/a&gt; is not known yet.&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-04T08:31:08.383" LastActivityDate="2018-04-04T08:31:08.383" CommentCount="7" />
  <row Id="1586" PostTypeId="2" ParentId="1584" CreationDate="2018-04-04T07:39:24.650" Score="5" Body="&lt;p&gt;There is no such general statement and it is unlikely there will be one soon. I will explain why this is the case. For a partial answer to your question, looking at the problems in the two complexity classes BQP and PostBQP might help.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;The complexity classes that come closest to the problems that can be solved efficiently by quantum computers of the quantum gate model are &lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/BQP&quot; rel=&quot;noreferrer&quot;&gt;BQP&lt;/a&gt;; and&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/PostBQP&quot; rel=&quot;noreferrer&quot;&gt;PostBQP&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;BQP consists of the problems that can be solved in polynomial time on a quantum circuit. Most important quantum algorithms, such as Shor's algorithm, solve problems in BQP.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;PostBQP consists of the problems that can be solved in polynomial time on a quantum circuit that can additionally perform postselection. This is a lot more powerful, as PostBQP$=$&lt;a href=&quot;https://en.wikipedia.org/wiki/PP_(complexity)&quot; rel=&quot;noreferrer&quot;&gt;PP&lt;/a&gt;, a class that contains PP. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, there currently are no methods to &lt;em&gt;practically&lt;/em&gt; implement postselection, so PostBQP is more of theoretical interest. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The relation between P, NP and BQP is currently unknown; and an open problem on the order of P vs. NP. As a general statement about what kinds of problems can be solved more efficiently using quantum computers &lt;em&gt;must&lt;/em&gt; answer the BQP vs. P question (if BQP=P, then apparently quantum computers aren't more efficient (to complexity theorists, at least) )&lt;/p&gt;&#xA;" OwnerUserId="253" LastEditorUserId="253" LastEditDate="2018-04-04T07:55:43.660" LastActivityDate="2018-04-04T07:55:43.660" CommentCount="8" />
  <row Id="1587" PostTypeId="2" ParentId="1581" CreationDate="2018-04-04T09:23:45.920" Score="10" Body="&lt;p&gt;Anyone who has written a paper, and asked themselves whether they could improve the notation, or present the analysis a bit differently to make it more elegant, is familiar with the fact that choices of notation, description, and analysis can be an accident &amp;mdash; chosen without deep motivations. There's nothing wrong with it, it just doesn't have a strong justification to be a particular way. In large communities of people more concerned (possibly with reason) with getting things done rather than presenting the cleanest possible picture, this is going to happen all the time.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I think that the ultimate answer to this question is going to be along these lines: it is mostly a historical accident. I doubt that there are any &lt;em&gt;deeply considered&lt;/em&gt; reasons for the gate-sets being as they are, any more than there are deeply considered reasons why we talk about the Bell state $\lvert \Phi^+ \rangle = ( \lvert 00 \rangle + \lvert 11 \rangle ) \big/ \sqrt 2$ somewhat more often than the state $\lvert \Psi^- \rangle = ( \lvert 01 \rangle - \lvert 10 \rangle ) \big/ \sqrt 2$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But we can still consider how the accident came about, and whether there is something we can learn about systematic ways of thinking which might have led us there. I expect that the reasons ultimately come from the cultural priorities of computer scientists, with both deep and superficial biases playing a role in how we describe things.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;A digression on Bell states&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you'll bear with me, I'd like to dwell on the example of the two Bell states $\lvert \Phi^+ \rangle$ and $\lvert \Psi^- \rangle$ as an  indicative example of how an ultimately arbitrary convention can come about by accident, in part because of biases which do not have deep mathematical roots.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One obvious reason for preferring $\lvert \Phi^+ \rangle$ over $\lvert \Psi^- \rangle$ is that the former is more obviously symmetric.&#xA;As we add the two components for $\lvert \Phi^+ \rangle$, there is no clear need to defend why we write it as we do. In contrast, we could just as easily define $\lvert \Psi^- \rangle = (\lvert 10 \rangle - \lvert 01 \rangle) \big/ \sqrt 2$ with the opposite sign, which is no better or worse motivated than the choice $\lvert \Psi^- \rangle = (\lvert 01 \rangle - \lvert 10 \rangle) \big/ \sqrt 2$. This makes it feel as though we are making more arbitrary choices when defining $\lvert \Psi^- \rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Even the choice of basis is somewhat flexible in the case of $\lvert \Phi^+ \rangle$: we can write $\lvert \Phi^+ \rangle := (\lvert ++ \rangle + \lvert -- \rangle)\big/\sqrt 2$ and obtain the same state. But things start going a little worse if you start considering the eigenstates $\lvert \pm i \rangle := (\lvert 0 \rangle \pm i \lvert 1 \rangle)\big/\sqrt 2$ of the $Y$ operator: we have $\lvert \Phi^+ \rangle = (\lvert +i \rangle\lvert -i \rangle + \lvert -i \rangle \lvert +i \rangle)\big/\sqrt 2$. This still looks pretty symmetric, but it becomes clear that our choice of basis plays a non-trivial role in how we define $\lvert \Phi^+ \rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The joke is on us. The reason why $\lvert \Phi^+ \rangle$ seems &quot;more symmetric&quot; than $\lvert \Psi^- \rangle$ is because $\lvert \Psi^- \rangle$ is literally the least symmetric two-qubit state, and this makes it &lt;em&gt;better&lt;/em&gt; motivated than $\lvert \Phi^+\rangle$ instead of less motivated. The $\lvert \Psi^- \rangle$ state is the unique &lt;em&gt;antisymmetric&lt;/em&gt; state: the unique state which is the $-1$ eigenvector of the SWAP operation, and therefore implicated in the controlled-SWAP test for qubit state distinguishability, among other things.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;We can describe $\lvert \Psi^- \rangle$ up to a global phase as $(\lvert \alpha \rangle \lvert \alpha^\perp \rangle - \lvert \alpha^\perp \rangle \lvert \alpha \rangle)\big/\sqrt 2$ for literally any single-qubit state $\lvert \alpha \rangle$ and orthogonal state $\lvert \alpha^\perp \rangle$, meaning that the properties which make it interesting are independent of the choice of basis.&lt;/li&gt;&#xA;&lt;li&gt;Even the global phase which you use to write the state $\lvert \alpha^\perp \rangle$ doesn't affect the definition of $\lvert \Psi^-\rangle$ up to more than a global phase. The same isn't true of $\vert \Phi^+\rangle$: as an exercise for the reader, if $\lvert 1' \rangle = i \lvert 1 \rangle$, then what is $(\lvert 00 \rangle + \lvert 1' 1' \rangle)\big/\sqrt 2$?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Meanwhile, $\lvert \Phi^+ \rangle$ is just one maximally entangled state in the three-dimensional symmetric subspace on two qubits &amp;mdash; the subspace of $+1$ eigenvectors of the SWAP operation &amp;mdash; and therefore no more distinguished in principle than, say,  $\lvert \Phi^- \rangle \propto \lvert 00 \rangle - \lvert 11 \rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;After learning a thing or two about the Bell states, it becomes clear that our interest in $\lvert \Phi^+ \rangle$ in particular is motivated only by a superficial symmetry of notation, and not any truly meaningful mathematical properties. It is certainly a more arbitrary choice than $\lvert \Psi^- \rangle$. The only obvious motivation for preferring $\lvert \Phi^+ \rangle$ are sociological reasons having to do with avoiding minus signs and imaginary units. And the only justifiable reason I can think of for that are cultural: specifically, in order to better accomodate students or computer scientists.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Who ordered CNOT?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You ask why we don't talk more about $(X + Y)\big/\sqrt 2$. To me the more interesting question that you also ask: we do we talk so much about $H = (X + Z)\big/\sqrt 2$, when $\sqrt Y$ does many of the same things? I have seen talks given by experimental optical physicists to students, who even describe performing $\sqrt Y$ on a standard basis state &lt;em&gt;as&lt;/em&gt; performing a Hadamard gate: but it was a $\sqrt Y$ gate that was actually more natural for him. The operator $\sqrt Y$ is also more directly related to the Pauli operators, obviously. A serious physicist might consider it curious that we dwell so much on the Hadamard instead.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But there is a bigger elephant in the room &amp;mdash; when we talk about CNOT, &lt;em&gt;why&lt;/em&gt; are we talking about CNOT, instead of another entangling gate $\mathrm{CZ} = \mathrm{diag}(+1,+1,+1,-1)$ which is symmetric on its tensor factors, or better yet $U = \exp(-i \pi (Z \otimes Z)/2)$ which is more closely related to the natural dynamics of many physical systems? Not to mention a unitary such as $U' = \exp(-i \pi (X \otimes X)/2)$ or other such variants.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The reason, of course, is that we are explicitly interested in computation rather than physics per se. We care about CNOT because how it transforms the standard basis (a basis which is preferred not for mathematical or physical reasons, but for &lt;em&gt;human-centered&lt;/em&gt; reasons).&#xA;The gate $U$ above is slightly mysterious from the point of a computer scientist: it is not obvious on the surface of it what it is &lt;em&gt;for&lt;/em&gt;, and worse, it is full of icky complex coefficients. And the gate $U'$ is even worse. By contrast, CNOT is a permutation operator, full of 1s and 0s, permuting the standard basis in a way which is obviously relevant to the computer scientist. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Though I'm making a bit of fun here, in the end &lt;em&gt;this is what we're studying quantum computation for&lt;/em&gt;. The physicist can have deeper insights into the ecology of the elementary operations, but what the computer scientist cares about at the end of the day is how primitive things can be composed into comprehensible procedures involving classical data. And that means not caring too much about symmetry on the lower logical levels, so long as they can get what they want out of those lower levels.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We talk about CNOT because it is the gate that we want to spend time thinking about. From a physical perspective gates such as $U$ and $U'$ as above are in many cases the operations we would think about for &lt;em&gt;realising&lt;/em&gt; CNOT, but the CNOT is the thing that we care about.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Deep, and not so deep, reasons to prefer the Hadamard gate&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I expect that the priorities of computer scientists motivate a lot of our conventions, such as why we talk about $(X + Z)\big/\sqrt 2$, instead of $\sqrt Y \propto (\mathbb 1 - i Y)\big/\sqrt 2$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Hadamard operation is already slightly scary to computer scientists who are not already acquainted with quantum information theory. (The way it is used sounds like non-determinism, and it even uses irrational numbers!) But once a computer scientist gets past the initial revulsion, the Hadamard gate does have properties that they can like: at least it only involves real coefficients, it is self-inverse, and you can even describe the eigenbasis of $H$ with just real coefficients.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One way in which the Hadamard often arises is in describing toggling between the standard basis $\lvert 0 \rangle, \lvert 1 \rangle$ and 'the' conjugate basis $\lvert + \rangle, \lvert - \rangle$ (that is to say, the eigenbasis of the $X$ operator, as opposed to the $Y$ operator) &amp;mdash; the so-called 'bit' and the 'phase' bases, which are two conjugate bases that you can express using only real coefficients. Of course, $\sqrt Y$ also transforms between these bases, but also introduces a non-trivial transformation if you perform it twice.&#xA;If you want to think of &quot;toggling between two different bases in which you might store information&quot;, the Hadamard gate is better. But &amp;mdash; this can only be defensible if you think it is important specifically to have &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;a gate $H$ transforming between the standard basis and the very specific basis of $\lvert + \rangle, \lvert - \rangle$;&lt;/li&gt;&#xA;&lt;li&gt;if you care specifically about $H$ having order $2$.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;You might protest and say that it is very natural to consider toggling between the 'bit' and 'phase' bases. But where did we get this notion of two specific bases for 'bit' and 'phase', anyway? The only reason why we single out $\lvert + \rangle, \lvert - \rangle$ as 'the' phase basis, as opposed for instance to $\lvert +i \rangle, \lvert -i \rangle$, is because it can be expressed with only real coefficients in the standard basis. As for preferring an operator with order $2$, to mesh with the notion of toggling, this seems to indicate a particular preference for considering things by 'flips' rather than reversible changes of basis. These priorities smack of the interests of computer science.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Unlike the case between $\lvert \Phi^+ \rangle$ versus $\lvert \Psi^- \rangle$, the computer scientist does have one really good &lt;em&gt;high-level&lt;/em&gt; argument for preferring $H$ over $\sqrt Y$: the Hadamard gate is the unitary representation of the boolean Fourier transform (that is, it is the quantum Fourier transform on qubits). This is not very important from a physical perspective, but it is very helpful from a computational perspective, and a very large fraction of theoretical results in quantum computation and communication ultimately rest on this observation. But the boolean Fourier transform already bakes in the asymmetries of computer science, in pre-supposing the importance of the standard basis and in using only real coefficients: an operator such as $(X + Y)\big/\sqrt 2$ would never be considered on these grounds.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Diagonal argument&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you're a computer scientist, once you have Hadamard and CNOT, all that's left is to get those pesky complex phases sorted as an afterthought. These phases are extremely important, of course. But just the way we talk about relative phases reveals a discomfort with the idea. Even describing the standard basis as the 'bit' basis, for storing information, puts a strong emphasis that whatever 'phase' is, it's not the usual way that you would consider storing information. Phases of all sorts are something to be dealt with &lt;em&gt;after&lt;/em&gt; the 'real' business of dealing with magnitudes of amplitudes; &lt;em&gt;after&lt;/em&gt; confronting the fact that one can store information in more than one basis. We barely talk at all about even purely imaginary relative phases if we can help it.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One can cope with relative phases pretty easily using diagonal operators. These have the advantage of being sparse (with respect to the standard basis...) and of &lt;em&gt;only&lt;/em&gt; affecting the relative phase, which is after all the detail which we're trying to address at this stage. Hence $T \propto \sqrt[4]Z$. And once you've done that, why do more? Sure, we could as easily consider arbitrary $X$ rotations (and because of Euler decomposition, we do play some lip-service to these operations) and arbitrary $Y$ rotations, which would motivate $\sqrt[4]X$ and $\sqrt[4]Y$. But these don't actually add anything of interest for the computer scientist, who considers the job done already.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And not a moment too soon &amp;mdash; because computer scientists don't really care about precisely what the primitive operations being used are as soon as they can justify move on to something higher-level.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Summary&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I don't think there is likely to be any very interesting physically-motivated reason why we use a particular gate-set. But it is certainly possible to explore the &lt;em&gt;psychologically-motivated&lt;/em&gt; reasons why we do. The above is a speculation in this direction, informed by long experience.&lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-04-04T17:39:15.527" LastActivityDate="2018-04-04T17:39:15.527" CommentCount="3" />
  <row Id="1588" PostTypeId="1" AcceptedAnswerId="1589" CreationDate="2018-04-04T10:49:17.640" Score="13" ViewCount="912" Body="&lt;p&gt;Consider the &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1348/144&quot;&gt;unitary circuit&lt;/a&gt; model of quantum computation. If we need to generate entanglement between the input qubits with the circuit, it must have multi-qubit gates such as CNOT, as &lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.53.2046&quot; rel=&quot;noreferrer&quot;&gt;entanglement cannot increase under local operations and classical communication&lt;/a&gt;. Consequently, we can say that quantum computing with multi-qubit gates is inherently different from quantum computing with just local gates. But what about measurements?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Does including simultaneous measurements of multiple qubits make a difference in quantum computing or can we perhaps emulate this with local measurements with some overhead? &lt;strong&gt;EDIT:&lt;/strong&gt; &lt;em&gt;by &quot;emulate with local measurements&quot;, I mean have the same effect with local measurements + any unitary gates.&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Please notice that I am not merely asking how measuring one qubit changes the others, which has already been &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1206/how-does-measurement-of-one-qubit-affect-the-others&quot;&gt;asked and answered&lt;/a&gt;, or if such measurements are possible. I am interested to know whether including such measurements could bring something new to the table.&lt;/p&gt;&#xA;" OwnerUserId="144" LastEditorUserId="144" LastEditDate="2018-04-05T08:01:02.507" LastActivityDate="2018-04-05T08:01:02.507" Title="Do multi-qubit measurements make a difference in quantum circuits?" Tags="&lt;qubit&gt;&lt;circuit-model&gt;&lt;measurement&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="1589" PostTypeId="2" ParentId="1588" CreationDate="2018-04-04T11:09:31.463" Score="12" Body="&lt;p&gt;Entangling measurements are powerful. In fact, they are so powerful that universal quantum computation can be performed by sequences of entangling measurements only (i.e., without extra need for unitary gates or special input state preparations):&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Nielsen showed that universal quantum computation is possible given a quantum memory and the ability to perform projective measurements on up to 4-qubits [&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0108020&quot; rel=&quot;nofollow noreferrer&quot;&gt;quant-ph/0310189&lt;/a&gt;].&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;The above result was extended to 3-qubit measurements by Fenner and Zhang [&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0111077&quot; rel=&quot;nofollow noreferrer&quot;&gt;quant-ph/0111077&lt;/a&gt;].&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Later on, Leung gave an improved method that requires only 2-qubit measurements, which are also both sufficient and necessary [&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0310189&quot; rel=&quot;nofollow noreferrer&quot;&gt;quant-ph/0111122&lt;/a&gt;].&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;The idea there is to combine sequences of measurements to drive the computation. This is quite similar to Raussendorf-Briegel's model of measurement based quantum computation (MBQC) (aka the &lt;a href=&quot;https://en.wikipedia.org/wiki/One-way_quantum_computer&quot; rel=&quot;nofollow noreferrer&quot;&gt;one way quantum computer&lt;/a&gt;), but in standard MBQC you also restrict your measurements to be non-entangling (i.e., they must act on single qubits) and you start with an entangled resource state as input (canonically, a cluster state&lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.86.5188&quot; rel=&quot;nofollow noreferrer&quot;&gt; [Phys. Rev. Lett. 86, 5188&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0301052&quot; rel=&quot;nofollow noreferrer&quot;&gt;quant-ph/0301052]&lt;/a&gt;). In the afore-mentioned protocols by Nielsen, Fenner-Zhang, Leung you are allowed to do entangling measurements but you do not rely on any other additional resource (i.e., no gates, no special inputs such as cluster states).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;In short, the difference between entangling and local measurements is analogous to the difference between entangling and local gates.&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;PS: As discussed in other answers you can simulate entangling measurements with entangling gates (such as CNOTS and local measurements). Viceversa, the above results show you can trade entangling gates for entangling measurements. If your all of your resources are local you cannot use them to simulate entangling ones though. In particular, you cannot simulate entangling measurements with local gates and inputs.&lt;/p&gt;&#xA;" OwnerUserId="1779" LastEditorUserId="1779" LastEditDate="2018-04-05T06:24:32.673" LastActivityDate="2018-04-05T06:24:32.673" CommentCount="3" />
  <row Id="1591" PostTypeId="2" ParentId="1441" CreationDate="2018-04-04T13:30:19.310" Score="11" Body="&lt;p&gt;Abel Molina, Thomas Vidick, and I proved that the correct answer is $c=3/4$ in this paper:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;A. Molina, T. Vidick, and J. Watrous. Optimal counterfeiting attacks&#xA;  and generalizations for Wiesner's quantum money. Proceedings of the&#xA;  7th Conference on Theory of Quantum Computation, Communication, and&#xA;  Cryptography, volume 7582 of Lecture Notes in Computer Science, pages&#xA;  45–64, 2013. (See also arXiv: 1202.4010.)&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;This assumes the counterfeiter uses what we call a &quot;simple counterfeiting attack,&quot; which means a one-shot attempt to transform one copy of a money state into two. (I interpret your question to be about such attacks.) &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The attack of Brodutch, Nagaj, Sattath, and Unruh that @Rob referred to (and which is a fantastic result in my opinion) requires the counterfeiter to interact repeatedly with the bank and assumes the bank will provide the counterfeiter with the same money state after each verification.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The paper describes the optimal channel, which is not an entanglement breaking (i.e., measure and prepare) channel. It's an example of a cloner, and explicitly it looks like this:&#xA;$$&#xA;\Phi(\rho) = A_0 \rho A_0^{\dagger} + A_1 \rho A_1^{\dagger}&#xA;$$&#xA;where&#xA;$$&#xA;A_0 = \frac{1}{\sqrt{12}}&#xA;\begin{pmatrix}&#xA;3 &amp;amp; 0\\&#xA;0 &amp;amp; 1\\&#xA;0 &amp;amp; 1\\&#xA;1 &amp;amp; 0&#xA;\end{pmatrix}&#xA;\quad\text{and}\quad&#xA;A_1 = \frac{1}{\sqrt{12}}&#xA;\begin{pmatrix}&#xA;0 &amp;amp; 1\\&#xA;1 &amp;amp; 0\\&#xA;1 &amp;amp; 0\\&#xA;0 &amp;amp; 3&#xA;\end{pmatrix}.&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For different sets of money states and figures of merit, you may end up with different optimal values and cloners. For example, if the money states also include $| 0\rangle \pm i |1\rangle$, then the Bužek-Hillery cloner is optimal and the correct value of $c$ drops to 2/3.&lt;/p&gt;&#xA;" OwnerUserId="1764" LastActivityDate="2018-04-04T13:30:19.310" CommentCount="0" />
  <row Id="1592" PostTypeId="2" ParentId="1508" CreationDate="2018-04-04T14:43:33.397" Score="7" Body="&lt;p&gt;If we have a QTM with state set $Q$ and a tape alphabet $\Sigma = \{0,1\}$, we cannot say that the qubit being scanned by the tape head &quot;holds&quot; a vector $a|0\rangle + b|1\rangle$ or that the (internal) state is a vector with basis states corresponding to $Q$. The qubits on the tape can be correlated with one another and with the internal state, as well as with the tape head position.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As an analogy, we would not describe a probabilistic Turing machine's global state by independently specifying a distribution for the internal state and for each of the tape squares. Rather, we have to describe everything together so as to properly represent correlations among the different parts of the machine. For example, the bits stored in two distant tape squares might be perfectly correlated, both 0 with probability 1/2 and both 1 with probability 1/2.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, in the quantum case, and assuming we're talking about pure states of quantum Turing machines with unitary evolutions (as opposed to a more general model based on mixed states), the global state is represented by a vector whose entries are indexed by configurations (i.e., classical descriptions of the internal state, the location of the tape head, and the contents of every tape square) of the Turing machine. It should be noted that we generally assume that there is a special blank symbol in the tape alphabet (which could be 0 if we want our tape squares to store qubits) and that we start computations with at most finitely many squares being non-blank, so that the set of all reachable configurations is countable. This means that the state will be represented by a unit vector in a separable Hilbert space.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Finally, and perhaps this is the actual answer to the question interpreted literally, the movement of the tape head is determined by the transition function, which will assign an &quot;amplitude&quot; to each possible action (new state, new symbol, and tape head movement) for every classical pair $(q,\sigma)$ representing the current state and currently scanned symbol. Nothing forces the tape head to move deterministically -- a nonzero amplitude could be assigned to two or more actions that include tape head movements to both the left and right -- so it is possible for a QTM tape head to move both left and right in superposition.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, you can imagine a QTM with $Q = \{0,1\}$ and $\Sigma = \{0,1\}$ (and we'll take 0 to be the blank symbol). We start in state 0 scanning a square that stores 1, and all other squares store 0. I won't explicitly write down the transition function, but will just describe the behavior in words. On each move, the contents of the scanned tape square is interpreted as a control bit for a Hadamard operation on the internal state. After the controlled-Hadamard is performed, the head moves left if the (new) state is 0 and moves right if the (new) state is 1. (In this example we never actually change the contents of the tape.) After one step, the QTM will be in an equally weighted superposition between being in state 0 with the tape head scanning square -1, and being in state 1 with the tape head scanning square +1. On all subsequent moves the controlled-Hadamard does nothing because every square aside from square 0 contains the 0 symbol. The tape head will therefore continue to move simultaneously both left and right, like a particle travelling to the left and to the right in superposition.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you wanted to, you could of course define a variant of the quantum Turing machine model for which the tape head location and movement is deterministic, and this would not ruin the computational universality of the model, but the &quot;classic&quot; definition of quantum Turing machines does not impose this restriction.&lt;/p&gt;&#xA;" OwnerUserId="1764" LastActivityDate="2018-04-04T14:43:33.397" CommentCount="4" />
  <row Id="1593" PostTypeId="2" ParentId="1328" CreationDate="2018-04-04T18:26:40.737" Score="4" Body="&lt;p&gt;Your question asks two questions that are less-related than you might hope.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;First&lt;/strong&gt;, how do we increase the probability of down-conversion &lt;em&gt;occuring&lt;/em&gt;?  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is fundamentally a question about material properties: the chance per unit length of down-conversion occurring is proportional to $\chi^{(2)}$; if our material of choice doesn't have good phase-matching conditions then we can &quot;cheat&quot; and use quasiphasematching at a hit of ~$2/\pi$.  As it happens, PPLN is just about as good as you're going to do, at least to within an order of magnitude.  A very long device, say with a waveguide, lets you get more unit lengths; things still scale linearly, so to get much higher conversion you'd need a much longer device, which brings its own problems (such as absorption). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;(This is setting aside other options, such as spontaneous four-wave mixing and true single photon sources.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Second&lt;/strong&gt;, you ask &quot;...and therefore entanglement between photons?&quot;.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This &lt;em&gt;does not&lt;/em&gt; immediately follow from the first problem (increasing conversion from pump to daughter photons).   Depending on what kind of entanglement one is interested in, it's not at all the case that making more photons per (pulse/unit time) increases the entanglement of those photons.  Generally speaking, SPDC sources for (discrete-variable) optical quantum computing are limited by the multi-fold emission rate, not by the pump power; this literally cannot be avoided by an SPDC scheme.  If you're looking at achievable squeezing for CV experiments that's another kettle of fish that I'm not an expert in; my understanding is that the limits in total squeezing at present are not due to limited $\chi^{(2)}$, but other noise.  (I may be mistaken on this count.) &lt;/p&gt;&#xA;&#xA;&lt;p&gt;As it turns out, this leads to people trying to make &lt;em&gt;un&lt;/em&gt;entangled photons pairs and heralding one of them to try and simulate a &quot;true&quot; single photon source; a multiplexing scheme using space, delay lines, or a memory can then be used to put your known-good photon in the mode of interest.  Once you have a device that can spit out a photon in a particular mode in a pure state, you're good to go.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If, on the other hand, you're interested in large amounts of time-frequency entanglement, that too is not set by the conversion efficiency, but by the phase-matching conditions in the crystal: the opposite problem from the papers posted by glS.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;To conclude&lt;/strong&gt;, while there are reasons to want to increase conversion efficiency (for one thing it seems awfully wasteful to have conversion efficiencies as low as we do), it's not immediately obvious that doing so is a rate-limiting step in most experiments at present.  It's unfortunately also not at all clear how to do so in a more than marginal way; leading to people working on related problems such as increasing heralding efficiency and purity of the single-photon states instead.  &lt;/p&gt;&#xA;" OwnerUserId="1807" LastActivityDate="2018-04-04T18:26:40.737" CommentCount="0" />
  <row Id="1594" PostTypeId="2" ParentId="1584" CreationDate="2018-04-04T18:53:50.707" Score="11" Body="&lt;p&gt;&lt;strong&gt;On computational helpfulness in general&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Without perhaps realising it, you are asking a version of one of the most difficult questions you can possibly ask about theoretical computer science. You can ask the same question about classical computers, only instead of asking whether adding 'quantumness' is helpful, you can ask:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;em&gt;Is there a concise statement about where &lt;em&gt;randomised&lt;/em&gt; algorithms can help?&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It's possible to say something very vague here &amp;mdash; if you think that solutions are plentiful (or that the number of solutions to some &lt;em&gt;sub-problem&lt;/em&gt; are plentiful) but that it might be difficult to systematically construct one, then it's helpful to be able to make choices at random in order to get past the problem of systematic construction. But beware, sometimes the reason &lt;em&gt;why&lt;/em&gt; you know that there are plentiful solutions to a sub-problem is because there is a proof using &lt;em&gt;the probabilistic method&lt;/em&gt;. When this is the case, you know that the number of solutions is plentiful by reduction to what is in effect a helpful randomised algorithm!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Unless you have another way of justifying the fact that the number of solutions is plentiful for those cases, there is no simple description of when a randomised algorithm can help. And if you have high enough demands of 'helpfulness' (a super-polynomial advantage), then what you are asking is whether $\mathsf P \ne \mathsf{BPP}$, which is an unsolved problem in complexity theory.  &lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;em&gt;Is there a concise statement about where &lt;em&gt;parallelised&lt;/em&gt; algorithms can help?&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here things may be slightly better. If a problem looks as though it can be broken down into many independent sub-problems, then it can be parallelised &amp;mdash; though this is a vague, &quot;you'll know it when you see it&quot; sort of criterion. The main question is, &lt;em&gt;will&lt;/em&gt; you know it when you see it? Would you have guessed that testing feasibility of systems of linear equations over the rationals is not only parallelisable, but could be solved using $O(\log^2 n)$-depth circuits [c.f.&amp;nbsp;&lt;a href=&quot;https://link.springer.com/content/pdf/10.1007%2Fs000370050023.pdf&quot; rel=&quot;noreferrer&quot;&gt;Comput. Complex.&amp;nbsp;&lt;strong&gt;8&lt;/strong&gt; (pp.&amp;thinsp;99--126), 1999&lt;/a&gt;]?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One way in which people try to paint a big-picture intuition for this is to approach the question from the opposite direction, and say when it is known that a parallelised algorithm &lt;em&gt;won't&lt;/em&gt; help. Specifically, it won't help if the problem has an inherently sequential aspect to it. But this is circular, because 'sequential' just means that the structure that you can see for the problem is one which is not parallelised. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Again, there is no simple, comprehensive description of when a parallelised algorithm can help. And if you have high enough demands of 'helpfulness' (a poly-logarithmic upper bound on the amount of time, assuming polynomial parallelisation), then what you are asking is whether &lt;a href=&quot;https://en.wikipedia.org/wiki/NC_(complexity)#Open_problem:_Is_NC_proper?&quot; rel=&quot;noreferrer&quot;&gt;$\mathsf P \ne \mathsf{NC}$&lt;/a&gt;, which is again an unsolved problem in complexity theory.  &lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;The prospects for &quot;concise and correct descriptions of when [X] is helpful&quot; are not looking too great by this point. Though you might protest that we're being too strict here: on the grounds of demanding more than a polynomial advantage, we couldn't even claim that non-deterministic Turing machines were 'helpful' (which is clearly absurd). We shouldn't demand such a high bar &amp;mdash; in the absence of techniques to efficiently solve satisfiability, we should at least accept that &lt;em&gt;if&lt;/em&gt; we somehow could obtain a non-deterministic Turing machine, we would indeed find it &lt;em&gt;very very helpful&lt;/em&gt;. But this is different from being able to characterise &lt;em&gt;precisely which problems&lt;/em&gt; we would find it helpful for.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;On the helpfulness of quantum computers&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Taking a step back, is there &lt;em&gt;anything&lt;/em&gt; we can say about where quantum computers are helpful?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We can say this: a quantum computer can only do something interesting if it is taking advantage of the structure of a problem, which is unavailable to a classical computer. (This is hinted at by the remarks about a &quot;global property&quot; of a problem, as you mention). But we can say more than this: problems solved by quantum computers in the unitary circuit model will instantiate some features of that problem &lt;em&gt;as unitary operators&lt;/em&gt;. The features of the problem which are unavailable to classical computers will be all those which do not have a (provably) statistically significant relationship to the standard basis.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;In the case of Shor's algorithm, this property is the eigenvalues of a permutation operator which is defined in terms of multiplication over a ring.&lt;/li&gt;&#xA;&lt;li&gt;In the case of Grover's algorithm, this property is whether the reflection about the set of marked states, commutes with the reflection about the uniform superposition &amp;mdash; this determines whether the Grover iterator has any eigenvalues which are not $\pm 1$.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;It is not especially surprising to see that in both cases, the information relates to eigenvalues and eigenvectors. This is an&#xA;   excellent example of a property of an operator which need not have&#xA;   any meaningful relationship to the standard basis. But there is no particular reason why the information has to be an eigenvalue. All that is needed is to be able to describe a unitary operator, encoding some relevant feature of the problem which is not obvious from inspection of the standard basis, but &lt;em&gt;is&lt;/em&gt; accessible in some other easily described way.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the end, all this says is that a quantum computer is useful when you can find a quantum algorithm to solve a problem. But at least it's a broad outline of a strategy for finding quantum algorithms, which is no worse than the broad outlines of strategies I've described above for randomised or parallelised algorithms.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Remarks on when a quantum computer is 'helpful'&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As other people have noted here, &quot;where quantum computing can help&quot; depends on what you mean by 'help'.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Shor's algorithm is often trotted out in such discussions, and once in a while people will point out that we don't know that factorisation &lt;em&gt;isn't&lt;/em&gt; solvable in polynomial-time. So do we actually know that &quot;quantum computing would be helpful for factorising numbers&quot;?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Aside from the difficulty in realising quantum computers, I think&#xA;here the reasonable answer is 'yes'; not because we know that you can't factorise efficiently using conventional computers, but because &lt;em&gt;we don't know how&lt;/em&gt; you would do it using conventional computers. If quantum computers help you to do something that you have no better approach to doing, it seems to me that this is 'helping'.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;You mention Grover's algorithm, which yields a well-known square-root speedup over brute-force search.&#xA;This is only a polynomial speedup, and a speedup over a naive classical algorithm &amp;mdash; we have better classical algorithms than brute-force search, even for &lt;strong&gt;NP&lt;/strong&gt;-compelete problems. For instance, in the case of 3-SAT instances with a single satisfying assignment, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_satisfiability_problem#Algorithms_for_solving_SAT&quot; rel=&quot;noreferrer&quot;&gt;PPSZ algorithm&lt;/a&gt; has a runtime of $O(2^{0.386\,n})$, which outperforms Grover's original algorithm. So is Grover's algorithm 'helpful'?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Perhaps Grover's algorithm &lt;em&gt;as such&lt;/em&gt; is not especially helpful. However, it may be helpful if you use it to elaborate more clever classical strategies beyond brute-force search: using &lt;a href=&quot;https://en.wikipedia.org/wiki/Amplitude_amplification&quot; rel=&quot;noreferrer&quot;&gt;amplitude amplification&lt;/a&gt;, the natural generalisation of Grover's algorithm to more general settings, we can improve on the performance of many non-trivial algorithms for SAT (see e.g. [ACM SIGACT News&amp;nbsp;&lt;strong&gt;36&lt;/strong&gt; (pp.103--108), 2005 &amp;mdash; &lt;a href=&quot;https://digitalcommons.utep.edu/cgi/viewcontent.cgi?article=1256&amp;amp;context=cs_techrep&quot; rel=&quot;noreferrer&quot;&gt;free PDF link&lt;/a&gt;]; hat tip to Martin Schwarz who pointed me to this reference in the comments).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As with Grover's algorithm, amplitude amplification only yields polynomial speed-ups: but speaking practically, even a polynomial speedup may be interesting if it isn't washed out by the overhead associated with protecting quantum information from noise.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-04-05T08:43:47.650" LastActivityDate="2018-04-05T08:43:47.650" CommentCount="6" />
  <row Id="1595" PostTypeId="1" CreationDate="2018-04-04T19:18:22.410" Score="16" ViewCount="304" Body="&lt;p&gt;Many people are interested in the subject of quantum annealing, as an application of quantum technologies, not least because of D-WAVE's work on the subject. The &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_annealing&quot; rel=&quot;noreferrer&quot;&gt;Wikipedia article on quantum annealing&lt;/a&gt; implies that if one performs the 'annealing' slowly enough, one realises (a specific form of) adiabatic quantum computation. Quantum annealing seems to differ mostly in that it does not seem to presuppose doing evolution in the adiabatic regime &amp;mdash; it allows for the possibility of diabatic transitions.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Still, there seems to be more intuition at play with quantum annealing than just &quot;adiabatic computation done hastily&quot;. It seems that one specifically chooses an initial Hamiltonian consisting of a transverse field, and that this is specifically meant to allow for tunnelling effects in the energy landscape (as described in the standard basis, one presumes). This is said to be analogous to (possibly even to formally generalise?) the temperature in classical simulated annealing. This raises the question of whether quantum annealing pre-supposes features such as specifically an initial transverse field, linear interpolation between Hamiltonians, and so forth; and whether these conditions may be fixed in order to be able to make precise comparisons with classical annealing.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Is there a more-or-less formal notion of what quantum annealing consists of, which would allow one to point to something and say &quot;this is quantum annealing&quot; or &quot;this is not precisely quantum annealing because [it involves some additional feature or lacks some essential feature]&quot;?&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Alternatively: can quantum annealing be described in reference to some canonical&#xA;framework &amp;mdash; possibly in reference to one of the originating&#xA;papers, such as &lt;a href=&quot;https://journals.aps.org/pre/abstract/10.1103/PhysRevE.58.5355&quot; rel=&quot;noreferrer&quot;&gt;Phys. Rev.&amp;nbsp;E&amp;nbsp;58 (5355),&#xA;1998&lt;/a&gt;&#xA;[&lt;a href=&quot;http://www.stat.phys.titech.ac.jp/~nishimori/papers/98PRE5355.pdf&quot; rel=&quot;noreferrer&quot;&gt;freely available PDF&#xA;here&lt;/a&gt;]&#xA;&amp;mdash; together with some typical variations which are accepted as&#xA;also being examples of quantum annealing?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Is there at least a description which is precise enough that we can say that quantum annealing properly generalises classical simulated annealing, not by &quot;working better in practise&quot;, or &quot;working better under conditions X, Y, and Z&quot;, but in the specific sense in that any classical simulated annealing procedure can be efficiently simulated or provably surpassed by a noiseless quantum annealing procedure (just as unitary circuits can simulate randomised algorithms)?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-04-05T09:35:33.340" LastActivityDate="2018-05-16T16:34:48.583" Title="What precisely is quantum annealing?" Tags="&lt;quantum-annealing&gt;&lt;adiabatic-model&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="4" />
  <row Id="1596" PostTypeId="2" ParentId="1595" CreationDate="2018-04-04T20:20:21.457" Score="5" Body="&lt;p&gt;I'll do my best to address your three points. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;My previous answer to an earlier question about the difference between quantum annealing and adiabatic quantum computation can be found &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1578/54&quot;&gt;here&lt;/a&gt;. I'm in agreement with Lidar that quantum annealing can't be defined without considerations of algorithms and hardware.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;That being said, the canonical framework for quantum annealing and the inspiration for the D-Wave is the work by Farhi et al. (&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0001106&quot; rel=&quot;nofollow noreferrer&quot;&gt;quant-ph/0001106&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Finally, I'm not sure one can generalize classical simulated annealing using quantum annealing, again without discussing hardware. Here's a thorough comparison: &lt;a href=&quot;https://arxiv.org/abs/1304.4595&quot; rel=&quot;nofollow noreferrer&quot;&gt;1304.4595&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Addressing comments:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;(1) I saw your previous answer, but don't get the point you make here. It's fine for QA not to be universal, and not to have a provable performance to solve a problem, and for these to be motivated by hardware constraints; but surely quantum annealing is something independent of specific hardware or instances, or else it doesn't make sense to give it a name.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;(2) You're linking the AQC paper, together with the excerpt by Vinci and Lidar, strongly suggests that QA is just adiabatic-ish evolution in the not-necessarily-adiabatic regime. Is that essentially correct? Is this true regardless of what the initial and final Hamiltonians are, or what path you trace through Hamiltonian-space, or the parameterisation with respect to time? If there are any extra constraints beyond &quot;possibly somewhat rushed adiabatic-ish computation&quot;, what are those constraints, and why are they considered important to the model?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;(1+2) Similar to AQC, QA reduces the transverse magnetic field of a Hamiltonian, however, the process is no longer adiabatic and dependent on the qubits and noise levels of the machine. The initial Hamiltonians are called gauges in D-Wave's vernacular and can be simple or complicated as long as you know the ground state. As for the 'parameterization with respect to time,' I think you mean the annealing schedule and as stated above this is restricted hardware constraints. &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;(3) I also don't see why hardware is necessary to describe the comparison with classical simulated annealing. Feel free to assume that you have perfect hardware with arbitrary connectivity: define quantum annealing as you imagine a mathematician might define annealing, free of niggling details; and consider particular realisations of quantum annealing as attempts to approximate the conditions of that pure model, but involving the compromises an engineer is forced to make on account of having to deal with the real world. Is it not possible to make a comparison? &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;The only relation classical simulated annealing has with quantum annealing is they both have annealing in the name.&lt;/strong&gt;&#xA;The Hamiltonians and process are fundamentally different. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$H_{\rm{classical}} = \sum_{i,j} J_{ij} s_i s_j$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$H_{\rm{quantum}} = A(t) \sum_{i,j} J_{ij} \sigma_i^z \sigma_j^z + B(t) \sum_i \sigma_i^x$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, if you would like to compare simulated quantum annealing with quantum annealing, Troyer's group at ETH are the pros when it comes to simulated quantum annealing. I highly recommend these slides largely based on the Boxio et al. paper I linked above.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://www.isi.edu/sites/default/files/top_level/events/aqc2014/day2-talk5-Troyer.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://www.isi.edu/sites/default/files/top_level/events/aqc2014/day2-talk5-Troyer.pdf&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;(4) Your remark about the initial Hamiltonian is useful and suggests something very general lurking in the background. Perhaps arbitrary (but efficiently computable, monotone, and first differentiable) schedules are also acceptable in principle, with limitations only arising from architectural constraints, and of course also the aim to obtain a useful outcome?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I'm not sure what you're asking. Are arbitrary schedules useful? I'm not familiar with work on arbitrary annealing schedules. In principle, the field should go from high to low, slow enough to avoid a Landau-Zener transition and fast enough to maintain the quantum effects of qubits.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Related; The latest iteration of the D-Wave can anneal individual qubits at different rates but I'm not aware of any D-Wave unaffiliated studies where this has been implemented. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://www.dwavesys.com/sites/default/files/14-1002A_B_tr_Boosting_integer_factorization_via_quantum_annealing_offsets.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://www.dwavesys.com/sites/default/files/14-1002A_B_tr_Boosting_integer_factorization_via_quantum_annealing_offsets.pdf&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;(5) Perhaps there is less of a difference between the Hamiltonians in QA and CSA than you suggest. $H_{cl}$ is clearly obtained from $H_{qm}$ for $A(t)=1,B(t)=0$ if you impose a restriction to standard basis states (which may be benign if $H_{qm}$ is non-degenerate and diagonal). There's clearly a difference in 'transitions', where QA seems to rely on suggestive intuitions of tunnelling/quasiadiabaticity, but perhaps this can be (or already has been?) made precise by a theoretical comparison of QA to a quantum walk. Is there no work in this direction?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;$A(t)=1,B(t)=0$ With this schedule you're no longer annealing anything. The machine is just sitting there at a finite temperature so the only transitions you'll get are thermal ones. This can be slightly useful as shown by Nishimura et al. The following publication talks about the uses of a non-vanishing transverse field. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1605.03303&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/1605.03303&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1708.00236&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/1708.00236&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Regarding the relation of quantum annealing with quantum walks. It's possible to treat quantum annealing in this way as shown by Chancellor.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1606.06800&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/1606.06800&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;(6) One respect in which I suppose the hardware may play an important role --- but which you have not explicitly mentioned yet --- is the role of dissipation to a bath, which I now vaguely remember being relevant to DWAVE. Quoting from Boixo et al.: &quot;Unlike adiabatic quantum computing [...] quantum annealing is a positive temperature method involving an open quantum system coupled to a thermal bath.&quot; Clearly, what bath coupling one expects in a given system is hardware dependent; but is there no notion of what bath couplings are reasonable to consider for hypothetical annealers?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;I don't know enough about the hardware aspects to answer this, but if I had to guess, the lower temperature the better to avoid all the noise-related problems. &lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;You say &quot;In principle the field should go from high to low, slow enough to avoid a Landau-Zener transition and fast enough to maintain the quantum effects of qubits.&quot; This is the helpful thing to do, but you usually don't know just how slow that can or should be, do you?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;This would be the coherence time of the qubits. The D-Wave annealing schedules are on the order of microseconds with T2 for superconducting qubits being around 100 microseconds. If I had to give a definitive definition of annealing schedule it would be 'an evolution of the transverse field within a length of time less than the decoherence time of the qubit implementation.' This allows for different starting strengths, pauses, and readouts of field strengths. It need not be monotonic.  &lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;I thought maybe dissipation to a bath was sometimes considered helpful to how quantum annealers work, when operating in the non-adiabatic regime (as it often will be when working on NP-hard problems, because we're interested in obtaining answers to problems despite the eigenvalue gap possibly being very small). Is dissipation not potentially helpful then?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I consulted with S. Mandra and while he pointed me to a few papers by P. Love and M. Amin, which show that certain baths can speedup quantum annealing and thermalization can help find the ground state faster, in reality no baths really help quantum annealing. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/cond-mat/0609332.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/pdf/cond-mat/0609332.pdf&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;I think that maybe if we can get the confusion about the annealing schedules, and whether or not it the transition has to be along a liner interpolation between two Hamiltonians (as opposed to a more complicated trajectory), ...&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;$A(t)$ and $B(t)$ don't necessarily have to be linear or even monotonic. In a recent presentation D-Wave showed the advantages of pausing the annealing schedule and backwards anneals.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://www.dwavesys.com/sites/default/files/mwj_dwave_qubits2018.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://www.dwavesys.com/sites/default/files/mwj_dwave_qubits2018.pdf&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Feel free to condense these responses however you'd like. Thanks.&lt;/p&gt;&#xA;" OwnerUserId="54" LastEditorUserId="54" LastEditDate="2018-05-16T16:34:48.583" LastActivityDate="2018-05-16T16:34:48.583" CommentCount="16" />
  <row Id="1598" PostTypeId="1" CreationDate="2018-04-05T01:34:23.260" Score="10" ViewCount="116" Body="&lt;p&gt;As the name already suggests, this question is a follow-up of &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/1584/1346&quot;&gt;this other&lt;/a&gt;. I was delighted with the quality of the answers, but I felt it would be immensely interesting if insights regarding optimization and approximation techniques were added, but might fall off-topic, hence this question.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;From Blue's answer:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;the rule of thumb in complexity theory is that if a quantum computer &quot;can help&quot; in terms of solving in polynomial time (with an error bound) iff the class of problem it can solve lies in BQP but not in P or BPP&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;How does this apply to approximation classes? Is there any specific topological, numerical, etc property of quantum computing that can be leveraged?&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;As an example of what could I be asking (but definitely not restricted to that!), take the &lt;a href=&quot;https://en.wikipedia.org/wiki/Christofides_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;Christofides algorithm&lt;/a&gt;: it exploits specific geometrical properties of the graph that it optimizes on (symmetry, triangle inequality): the salesman travels on a feasible world. But salesmen have also huge mass, and we can know their position and momentum at the same time with great precision. Maybe a quantum model could work as well for other kind of metrics with more relaxed restrictions, like the &lt;a href=&quot;https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence#Relation_to_metrics&quot; rel=&quot;nofollow noreferrer&quot;&gt;K-L divergence&lt;/a&gt;? In that case solving it would still be NP complete, but the optimization would apply for a broader topology. This example is maybe a long shot, but I hope you get what I mean. I don't really know if it makes sense at all, but the answer could also address it in that case :)&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;RELATED:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/126/1346&quot;&gt;Level of advantage provided by annealing for traveling salesman&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="1346" LastEditorUserId="1346" LastEditDate="2018-04-07T18:09:42.493" LastActivityDate="2018-04-07T18:09:42.493" Title="Is there any general statement about what kinds of problems can be approximated more efficiently using a quantum computer?" Tags="&lt;quantum-algorithms&gt;&lt;complexity-theory&gt;&lt;optimization&gt;&lt;approximation&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="3" />
  <row Id="1599" PostTypeId="2" ParentId="1588" CreationDate="2018-04-05T05:31:04.843" Score="4" Body="&lt;p&gt;While multi-qubit measurements can be incredibly powerful, as already described elsewhere, they do not give you anything new compared to unitary operations and local measurements. Think of a projective measurement for example, with projectors $P_m$. If you write down the observable $O=\sum_m P_m$, then there will be a unitary $U$ that diagonalises $O$. So, measuring $O$ is equivalent to implementing the unitary $U$ with a normal quantum circuit (including multi-qubit gates), and then performing local measurements in the standard basis.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Alternatively, this gives you some insight about multi-qubit measurements. Any unitary circuit followed by projective measurements could be wrapped up as a single multi-qubit measurement by inverting the above process.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A similar construction can be applied to more general measurements, but you have to extend the unitary operation to include some ancilla qubits. This is sometimes referred to as “the church of the larger Hilbert space”. There's a proof that unitaries + projective measurements are equivalent to generalised measurements in section 2.2.8 of Nielsen &amp;amp; Chuang.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-04-05T06:23:08.683" LastActivityDate="2018-04-05T06:23:08.683" CommentCount="4" />
  <row Id="1600" PostTypeId="2" ParentId="1531" CreationDate="2018-04-05T06:39:29.357" Score="2" Body="&lt;p&gt;There is the concept of controllability of a quantum system, i.e. do the given set of controls permit you to create any state or unitary? Usually this is computed by looking at the &lt;a href=&quot;https://en.wikipedia.org/wiki/Lie_algebra&quot; rel=&quot;nofollow noreferrer&quot;&gt;Lie Algebra&lt;/a&gt; of the system, and can be quite messy; you need to take the individual Hamiltonian terms that you can control, and calculate all their commutators to arbitrary orders. If you can take linear combinations of those and make any arbitrary Hamiltonian, then your full Hilbert space is controllable; you can make any unitary you want, and any quantum state is said to be reachable from any other. See &lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.63.063410&quot; rel=&quot;nofollow noreferrer&quot;&gt;Complete controllability of quantum systems (PRA 2001)&lt;/a&gt; for an example.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One important point to emphasise, however, is that this tells you nothing about efficiency, i.e. how long it takes you to reach a given state (as a function of the system size). There is an explicit construction that you can make based on the above decomposition in terms of commutators, but the time required scales exponentially in the order of the commutator required. Numerical techniques of control theory are methods that attempt to find the required control fields (as a function of time) in a more efficient manner, but (to my knowledge) rarely give you any guarantees. So, if you have fixed $\Theta$ and bounded $c_k(t)$, the controllability concept may not be sufficient.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1847" LastEditDate="2018-04-23T11:10:01.127" LastActivityDate="2018-04-23T11:10:01.127" CommentCount="0" />
  <row Id="1602" PostTypeId="1" AcceptedAnswerId="1673" CreationDate="2018-04-05T07:54:31.160" Score="2" ViewCount="211" Body="&lt;p&gt;In &lt;a href=&quot;https://arxiv.org/abs/1506.03815&quot; rel=&quot;nofollow noreferrer&quot;&gt;Classical Simulation of Quantum Error Correction in a Fibonacci Anyon Code&lt;/a&gt;, the authors state on page 2 in section I. BACKGROUND - A. Topological model:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;We consider a system supporting nonabelian &lt;strong&gt;Fibonacci anyon&lt;/strong&gt; excitations, denoted by $\tau$. Two such anyons can have total charge that is either $\tau$ or $ \mathbb I$ (vacuum), or any superposition of these, and so the fusion space in this case is 2-dimensional. We can represent basis states for this space using diagrams of definite total charge for the Wilson loops, and arbitrary states as linear combinations of these diagrams:&#xA;  &lt;a href=&quot;https://i.stack.imgur.com/rR2hj.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/rR2hj.png&quot; alt=&quot;Definite total charge for the Wilson loops.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;For $n$ anyons of type $\tau$, the dimension of the fusion space grows asymptotically as $\varphi^n$, where $\varphi$ = $\frac{1+\sqrt 5}{2}$ is the &lt;strong&gt;golden ratio&lt;/strong&gt;.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Observables associated with non-intersecting loops commute, and so a &lt;strong&gt;basis for the space&lt;/strong&gt; can be built from a maximal set of disjoint, nested loops.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Finally, in &quot;&lt;a href=&quot;https://arxiv.org/abs/1104.5550&quot; rel=&quot;nofollow noreferrer&quot;&gt;Coherence Frame, Entanglement Conservation, and Einselection&lt;/a&gt;&quot; the authors state on page 3:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Preferred basis problem. From the method of CF, we discuss the preferred basis problem (PBP), which has been studied via the einselection approach [7, 8]. We will show, yet, the method of einselection is incomplete.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;This method is described via the Stern-Gerlach experiment, as shown in the Fig. 1 of Ref. &lt;a href=&quot;https://en.wikipedia.org/wiki/Four-valued_logic&quot; rel=&quot;nofollow noreferrer&quot;&gt;7&lt;/a&gt;. The system is represented by the spin states (up and down) along some directions. One atom is put near one channel to serve&#xA;  as the apparatus to interact with the spin, causing entanglement. In this measurement, the PBP means that there is no physical difference between states&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;We also demonstrated that the &lt;strong&gt;preferred basis&lt;/strong&gt; problem &lt;strong&gt;can be resolved more naturally&lt;/strong&gt; by the method of &lt;strong&gt;coherence frame&lt;/strong&gt; than the &lt;strong&gt;einselection method&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; Are there different bases for each part of the model. &lt;strong&gt;Is there a preferred basis&lt;/strong&gt; for a &lt;a href=&quot;https://en.wikipedia.org/wiki/Qubit#Variations_of_the_qubit&quot; rel=&quot;nofollow noreferrer&quot;&gt;qudit&lt;/a&gt; or does it depend upon the underlying technology used to implement the qudits. How is the basis integral to the control and measurement?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sub&gt;Note: This may be related to, but is not a duplicate of: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1410/what-is-the-computational-basis&quot;&gt;What is the Computational Basis?&lt;/a&gt;, nor is one of the answers currently offered there an answer to this question.&lt;/sub&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;Initially, efforts where made to address some comments but this only succeeded in making the question longer and less clear, I've stripped it down but the edits can be reviewed by the curious in the edit history.&lt;/sup&gt;&lt;/p&gt;&#xA;" OwnerUserId="278" LastEditorUserId="58" LastEditDate="2018-04-11T08:52:31.537" LastActivityDate="2018-04-11T08:52:31.537" Title="What is the most economical and preferred basis for the qudit?" Tags="&lt;quantum-computer&gt;&lt;architecture&gt;&lt;performance&gt;&lt;qudit&gt;" AnswerCount="2" CommentCount="9" FavoriteCount="1" />
  <row Id="1604" PostTypeId="2" ParentId="1602" CreationDate="2018-04-05T11:40:28.613" Score="4" Body="&lt;p&gt;You may be confusing two uses of the word &quot;base&quot;. One definition of &quot;base&quot; has to do with how many digits are used to represent a number. For example, base two uses the digits 0 and 1, and the number five is written as 101 in base two. But in quantum mechanics there is another use of the word &quot;base&quot; which has to do with &lt;strong&gt;basis vectors&lt;/strong&gt; for a vector space. This is almost entirely unrelated to the &quot;base&quot; of a number system.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I see that once you start talking about qubits versus qudits there is further confusion. Perhaps you could try thinking of a qubit as a two dimensional space, and the &lt;strong&gt;basis within&lt;/strong&gt; that space as giving a preferred &quot;direction&quot;, or coordinate axes. Similarly, a qutrit is a three dimensional space, etc. (This is a geometric intuition that might help you get started with thinking about quantum states, it needs some more work before it is precise.)&lt;/p&gt;&#xA;" OwnerUserId="263" LastActivityDate="2018-04-05T11:40:28.613" CommentCount="5" />
  <row Id="1605" PostTypeId="5" CreationDate="2018-04-05T12:08:49.453" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-05T12:08:49.453" LastActivityDate="2018-04-05T12:08:49.453" CommentCount="0" />
  <row Id="1606" PostTypeId="4" CreationDate="2018-04-05T12:08:49.453" Score="0" Body="For questions about the usage of, origin of or reasons for specific notation used in the context of quantum computing." OwnerUserId="253" LastEditorUserId="253" LastEditDate="2018-04-05T13:30:16.217" LastActivityDate="2018-04-05T13:30:16.217" CommentCount="0" />
  <row Id="1607" PostTypeId="5" CreationDate="2018-04-05T12:49:37.600" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-05T12:49:37.600" LastActivityDate="2018-04-05T12:49:37.600" CommentCount="0" />
  <row Id="1608" PostTypeId="4" CreationDate="2018-04-05T12:49:37.600" Score="0" Body="For questions about quantum information theory.  In physics and computer science, quantum information is information that is held in the state of a quantum system. Quantum information is the basic entity of study in quantum information theory and can be manipulated using engineering techniques known as quantum information processing. (from Wikipedia)" OwnerUserId="253" LastEditorUserId="26" LastEditDate="2018-07-06T08:20:14.553" LastActivityDate="2018-07-06T08:20:14.553" CommentCount="0" />
  <row Id="1609" PostTypeId="1" AcceptedAnswerId="1610" CreationDate="2018-04-05T13:04:02.313" Score="7" ViewCount="59" Body="&lt;p&gt;In the last decades, the field of &lt;em&gt;parameterised algorithms&lt;/em&gt;, with &lt;a href=&quot;https://en.wikipedia.org/wiki/Parameterized_complexity#FPT&quot; rel=&quot;nofollow noreferrer&quot;&gt;fixed parameter tractibility&lt;/a&gt; (FPT) as its main tool has been provided new methods to analyse old algorithms and design techniques for new algorithms.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The basic idea of parameterised algorithms is that we 'pick' another parameter of our input other than the size (such as treewidth) and design algorithms that are efficient under the assumption that the chosen parameter is a (small) constant.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I wonder if the analysis and design of quantum algorithms can benefit from this approach. Has this been done, or are there good reasons why this is likely ineffective or ignored so far? &lt;/p&gt;&#xA;" OwnerUserId="253" LastEditorUserId="23" LastEditDate="2018-04-05T16:25:02.440" LastActivityDate="2018-04-05T16:25:02.440" Title="Can the analysis or design of quantum algorithms benefit from parameterised algorithmics?" Tags="&lt;quantum-algorithms&gt;&lt;complexity-theory&gt;" AnswerCount="1" CommentCount="2" />
  <row Id="1610" PostTypeId="2" ParentId="1609" CreationDate="2018-04-05T13:52:04.270" Score="3" Body="&lt;p&gt;Indeed, there are already parameterised quantum algorithms. I describe just two examples, one fairly famous and one fairly recent:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_algorithm_for_linear_systems_of_equations&quot; rel=&quot;nofollow noreferrer&quot;&gt;HHL subroutine for producing quantum states representing solutions to systems of equations&lt;/a&gt; and related algorithms depend on the sparseness of the matrix, but also the condition number $\kappa$ of the matrix, in the system of equations. The condition number in particular plays a prominent role in many analyses of this problem &amp;mdash; the results are typically $O(\mathrm{poly}(\kappa) \log(N))$ algorithms for matrices of size at most $N \times N$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;While it doesn't seem as though there is much scope for interesting&#xA;development on the dependency on $\kappa$, bear in mind that it is probably more informative to consider the &lt;em&gt;logarithm&lt;/em&gt; of the condition number as the more natural feature of the input. (It is easy to efficiently express matrices with exponentially large condition number.) If we write $\lambda = \log(\kappa)$, suddenly that $\mathrm{poly}(\kappa) = 2^{O(\lambda)}$ dependency seems more important. And there are other ways in which $\lambda$ seems the relevant thing to consider from a complexity-theoretic standpoint fixed-parameter complexity &amp;mdash; for instance, if a quantum algorithm could be found with only $\mathrm{poly}(\lambda)$ dependency, it would imply that $\mathsf{BQP = PSPACE}$. If we consider this to be unlikely in the same way that we consider $\mathsf{P = NP}$ to be unlikely, it seems that fixed-parameter tractability in terms of $\lambda$ fits in the same spirit as fixed-parameter tractability of $\mathsf{NP}$-complete problems.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;There are also &lt;a href=&quot;https://arxiv.org/abs/1609.05537&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum algorithms for semidefinite programming&lt;/a&gt;, with complexity parameterised by the dimension of the input matrix, the row-sparsity of the input matrix, the number of constraints, and bounds on the size of primal and dual solutions.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;As quantum computers will initially be much more expensive and less available than classical computers, and have a slower clock speed to boot, it makes a great deal of sense to look for parameterised quantum algorithms: ones which will prove effective for problems of interest, under conditions of interest, allowing us to pinpoint use-cases where quantum computers can be particularly effective.&lt;/p&gt;&#xA;" OwnerUserId="124" LastActivityDate="2018-04-05T13:52:04.270" CommentCount="1" />
  <row Id="1611" PostTypeId="2" ParentId="1353" CreationDate="2018-04-05T14:00:28.597" Score="2" Body="&lt;p&gt;I will attempt to address the following question only.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;I'm asking whether the method of 'running' quantum algorithms on a 'quantum computer' 'simulated' on a classical computer would be able to outperform normal classical algorithms (preferably for problems that not obviously involve quantum simulation)&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The closest thing to this that I am aware of are heuristic methods that employ &lt;a href=&quot;https://en.wikipedia.org/wiki/Natural_computing&quot; rel=&quot;nofollow noreferrer&quot;&gt;natural computing&lt;/a&gt;, in particular the ones that take inspiration from quantum physics for the development of novel problem-solving techniques. These are known as &lt;strong&gt;quantum inspired algorithms&lt;/strong&gt;. Please notice that: &lt;em&gt;i)&lt;/em&gt; I do not claim that such methods could be rigorously shown to be superior to conventional algorithms, but it seems that they can be at least competitive; &lt;em&gt;ii)&lt;/em&gt; the algorithms may or may not actually simulate a quantum computer, the faithfulness to the original source of inspiration varies.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I will briefly outline the framework of a particular type of a quantum-inspired evolutionary algorithm (QIEA). A more complete treatment may be found in chapter 24 of the book &quot;Natural computing algorithms&quot; by Anthony Brabazon et al [1]. Concrete examples can be found for example in arXiv. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The basic ingredients of a conventional &lt;a href=&quot;https://en.wikipedia.org/wiki/Evolutionary_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;evolutionary algorithm&lt;/a&gt; (EA) are a population of individuals $P(t)$, an update rule for the population, and a fitness function $f$. Here, each individual in $P(t)$ represents a possible solution to some problem, and $f$ quantifies how good the solution is. After initialization, for each step $t$ one evaluates $f$ on every individual in $P(t)$, records best ones and updates $P(t)$. This is iterated until a stopping criterion is reached, and the best found individual(s) are returned. In the simplest case, the update rule could be just random variation of individuals, but it can also be more complicated and engineered to introduce selection pressure towards better values of $f$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In a QIEA, solutions are represented by bit strings of a fixed length, say, $m$. A quantum population $Q(t)$ is used, where each quantum individual consists of $m$ qubits. At each $t$, classical population $P(t)$ is determined from $Q(t)$ by &quot;measuring&quot; the qubits. $P(t)$ is ranked by $f$ and best results are recorded. $Q(t)$ is updated by acting on each qubit with a local gate, and iteration is continued. Often for $Q(0)$, all qubits are set to balanced superposition $(1/\sqrt{2},1/\sqrt{2})^T$, making each particular solution equally likely in the beginning.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As the quantum individuals remain essentially in a product state of $m$ qubits, there is no entanglement involved at any point, making QIEA not very quantum. On the other hand, we can effectively simulate the evolution of $Q(t)$ and make as many measurements as we want without needing extra qubits. The claimed advantage is over conventional EAs, based on supposedly needing fewer individuals or being better at maintaining diversity as the population evolves, as even a fixed $Q(t)$ can lead to many $P(t)$. All in all, QIEA by its design is meant to be run only as a simulation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As a final remark, suppose that we wish to make QIEA more quantum without making it intractable. Can we? Perhaps. Consider the update rule of QIEA as a quantum circuit. It is rather boring, with a qubit register of size $m$ and a local gate acting once on each qubit. One could try to introduce some tractable quantumness to QIEA by taking the update circuit to be some Clifford quantum circuit, mentioned and outlined for example &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1203/144&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1183/144&quot;&gt;here&lt;/a&gt;. I do not know if this could offer any benefits at all, and as far as I know, this hasn't been tried.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[1] S. M. Anthony Brabazon, Michael O’Neill, Natural Computing Algorithms. Springer-Verlag Berlin&#xA;Heidelberg, 2015.&lt;/p&gt;&#xA;" OwnerUserId="144" LastActivityDate="2018-04-05T14:00:28.597" CommentCount="0" />
  <row Id="1612" PostTypeId="1" CreationDate="2018-04-05T17:11:12.980" Score="6" ViewCount="80" Body="&lt;p&gt;In &lt;a href=&quot;https://en.wikipedia.org/wiki/Empirical_algorithmics&quot; rel=&quot;noreferrer&quot;&gt;Empirical Algorithmics&lt;/a&gt;, researchers aim to understand the performance of algorithms through analyzing their empirical performance. This is quite common in machine learning and optimization. Right now, we would like to know something about the relative performance of quantum algorithms and their classical counterparts based on preliminary data from quantum computer emulators. My concern is that we might see encouraging empirical data that shows quantum computers with better scaling using simulators up to about 35 qubits, but then this advantage will disappear in the future once we have more data. What are the best practices for analyzing relative performance of classical and quantum algorithms in a robust way that gives insight about scaling? Or is this simply not yet possible? &lt;/p&gt;&#xA;" OwnerUserId="1658" LastEditorUserId="1658" LastEditDate="2018-04-05T23:46:29.407" LastActivityDate="2018-04-05T23:46:29.407" Title="Empirical Algorithmics for Near-Term Quantum Computing" Tags="&lt;quantum-speedup&gt;&lt;complexity-theory&gt;&lt;classical-computing&gt;" AnswerCount="0" CommentCount="4" FavoriteCount="1" />
  <row Id="1613" PostTypeId="1" AcceptedAnswerId="1619" CreationDate="2018-04-05T17:36:59.923" Score="9" ViewCount="300" Body="&lt;p&gt;In &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1386/253&quot;&gt;this answer&lt;/a&gt;, Grover's algorithm is explained. The explanation indicates that the algorithm relies heavily on the &lt;em&gt;Grover Diffusion Operator&lt;/em&gt;, but does not give details on the inner workings of this operator.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Briefly, the Grover Diffusion Operator creates an 'inversion about the mean' to iteratively make the tiny differences in earlier steps large enough to be  measurable. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The questions are now:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;How does the Grover diffusion operator achieve this?&lt;/li&gt;&#xA;&lt;li&gt;Why is the resulting $O(\sqrt{n})$ in total time to search an unordered database optimal?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="253" LastEditorUserId="253" LastEditDate="2018-04-06T15:27:23.217" LastActivityDate="2018-04-06T15:27:23.217" Title="How does the Grover diffusion operator work and why is it optimal?" Tags="&lt;quantum-algorithms&gt;&lt;grovers-algorithm&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="1614" PostTypeId="2" ParentId="1613" CreationDate="2018-04-05T18:56:36.610" Score="4" Body="&lt;p&gt;One way of defining the diffusion operator is&lt;sup&gt;1&lt;/sup&gt; $D = -H^{\otimes n}U_0H^{\otimes n}$, where $U_0$ is the &lt;em&gt;phase oracle&lt;/em&gt; $$U_0\left|0^{\otimes n}\right&amp;gt; = -\left|0^{\otimes n}\right&amp;gt;,\,U_0\left|x\right&amp;gt; = \left|x\right&amp;gt;\,\text{for} \left|x\right&amp;gt;\neq\left|0^{\otimes n}\right&amp;gt;.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This shows that $U_0$ can also be written as $U_0 = I-2\left|0^{\otimes n}\rangle\langle0^{\otimes n}\right|$, giving $$D= 2\left|+\rangle\langle+\right| - I,$$ where $\left|+\right&amp;gt; = 2^{-n/2}\left(\left|0\right&amp;gt; + \left|1\right&amp;gt;\right)^{\otimes n}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Writing a state $\left|\psi\right&amp;gt; = \alpha\left|+\right&amp;gt; + \beta\left|+^\perp\right&amp;gt;$ where $\left|+^\perp\right&amp;gt;$ is orthogonal to $\left|+\right&amp;gt;$ (i.e. $\left&amp;lt;+^\perp\mid+\right&amp;gt; =0)$ gives that $D\left|\psi\right&amp;gt; = \alpha\left|+\right&amp;gt; - \beta\left|+^\perp\right&amp;gt;$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This gives&lt;sup&gt;2&lt;/sup&gt; that &lt;strong&gt;the diffusion operator is a reflection about $\left|+\right&amp;gt;$&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As the other part of Grover's algorithm is &lt;em&gt;also&lt;/em&gt; a reflection, these combine to rotate the current state closer to the 'searched-for' value $x_0$. This angle decreases linearly with the number of rotations (until it overshoots the searched-for value), giving that the probability of correctly measuring the correct value increases quadratically.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/9701001&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bennet et. al.&lt;/a&gt; showed that this is optimal. By taking a classical solution to an NP-problem, Grover's algorithm can be used to quadratically speed this up. However, taking a language $\mathcal L_A = \left\lbrace y:\exists x\, A\left(x\right) = y\right\rbrace$ for a length preserving function $A$ (here, an oracle), any bounded-error oracle based quantum turing machine cannot accept this language in a time $T\left(n\right)=\mathcal o\left(2^{n/2}\right)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is achieved by taking a set of oracles where $\left|1\right&amp;gt;^{\otimes n}$ has no inverse (so is not contained in the language). However, this is contained in some new language $\mathcal L_{A_y}$ by definition. The difference in probabilities of a machine accepting $\mathcal L_A$ and a different machine accepting $\mathcal L_{A_y}$ in time $T\left(n\right)$ is then less than $1/3$ and so neither language is accepted and Grover's algorithm is indeed asymptotically optimal.&lt;sup&gt;3&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/9711070v2&quot; rel=&quot;nofollow noreferrer&quot;&gt;Zalka&lt;/a&gt; later showed that Grover's algorithm is &lt;em&gt;exactly&lt;/em&gt; optimal.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;1 In Grover's algorithm, minus signs can be moved round, so where the minus sign is, is somewhat arbitrary and doesn't necessarily have to be in the definition of the diffusion operator&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;2 alternatively, defining the diffusion operator &lt;em&gt;without&lt;/em&gt; the minus sign gives a reflection about $\left|+^\perp\right&amp;gt;$&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;3 Defining the machine using the oracle $A$ as $M^A$ and the machine using oracle $A_y$ as $M^{A_y}$, this is a due to the fact that there is a set $S$ of bit strings, where the states of $M^A$ and $M^{A_y}$ at a time $t$ are $\epsilon$-close&lt;sup&gt;4&lt;/sup&gt;, with a cardinality $&amp;lt;2T^2/\epsilon^2$. Each oracle where $M^A$ correctly decides if $\left|1\right&amp;gt;^{\otimes n}$ is in $\mathcal L_A$ can be mapped to $2^n - \text{Card}\left(S\right)$ oracles where $M^A$ &lt;em&gt;fails&lt;/em&gt; to correctly decide if $\left|1\right&amp;gt;^{\otimes n}$ is in that oracle's language. However, it must give one of the other $2^n-1$ potential answers and so if $T\left(n\right)=\mathcal o\left(2^{n/2}\right)$, the machine is unable to determine membership of $\mathcal L_A$.&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;4 Using the Euclidean distance, twice the &lt;a href=&quot;https://en.wikipedia.org/wiki/Trace_distance&quot; rel=&quot;nofollow noreferrer&quot;&gt;trace distance&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&#xA;" OwnerUserId="23" LastEditorUserId="23" LastEditDate="2018-04-05T22:28:48.290" LastActivityDate="2018-04-05T22:28:48.290" CommentCount="0" />
  <row Id="1617" PostTypeId="2" ParentId="1598" CreationDate="2018-04-06T00:10:07.927" Score="1" Body="&lt;p&gt;The &lt;a href=&quot;https://arxiv.org/abs/1411.4028&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Approximate Optimization Algorithm&lt;/a&gt; is a good place to start for analyzing the relative performance of quantum algorithms on approximation problems. One result so far is that at p=1 QAOA can theoretically achieve an approximation ratio of 0.624 for MaxCut on 3-regular graphs. This result was obtained using brute force enumeration of the different possible cases. This is not a technique is which easily generalizable, so relatively little is known about the performance of QAOA on other problems.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As it currently stands QAOA uses very little structure in the combinatorial optimization problem and operates more along the lines of a direct search method. One possible consequence is that QAOA would be best used for problems where there is minimal structure. In this case there is nothing that classical algorithms could use to accelerate the search process.&lt;/p&gt;&#xA;" OwnerUserId="1658" LastEditorUserId="1658" LastEditDate="2018-04-06T20:24:39.440" LastActivityDate="2018-04-06T20:24:39.440" CommentCount="2" />
  <row Id="1619" PostTypeId="2" ParentId="1613" CreationDate="2018-04-06T07:28:12.270" Score="4" Body="&lt;p&gt;$\newcommand{\bra}[1]{\left&amp;lt;#1\right|}\newcommand{\ket}[1]{\left|#1\right&amp;gt;}\newcommand{\braket}[2]{\left&amp;lt;#1\middle|#2\right&amp;gt;}\newcommand{\bke}[3]{\left&amp;lt;#1\middle|#2\middle|#3\right&amp;gt;}\newcommand{\proj}[1]{\left|#1\right&amp;gt;\left&amp;lt;#1\right|}$&#xA;Since the &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1386/253&quot;&gt;original question&lt;/a&gt; was about a layman's description, I offer a slightly different solution which is perhaps easier to understand (background dependent), based on a continuous time evolution. (I make no pretense that it is suitable for a layman, however.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We start from an initial state which is a uniform superposition of all states,&#xA;$$&#xA;\ket{\psi}=\frac{1}{\sqrt{2^n}}\sum_{y\in\{0,1\}^n}\ket{y}&#xA;$$&#xA;and we are aiming to find a state $\ket{x}$ that can be recognised as the correct answer (assuming there is exactly one such state, although this can be generalised). To do this, we evolve in time under the action of a Hamiltonian&#xA;$$&#xA;H=\proj{x}+\proj{\psi}.&#xA;$$&#xA;The really beautiful feature of Grover's search is that at this point, we can reduce the maths to a subspace of just two states $\{\ket{x},\ket{\psi}\}$, rather than requiring all $2^n$.  It's easier to describe if we make an orthonormal basis from these states, $\{\ket{x},\ket{\psi^\perp}\}$ where&#xA;$$&#xA;\ket{\psi^{\perp}}=\frac{1}{\sqrt{2^n-1}}\sum_{y\in\{0,1\}^n:y\neq x}\ket{y}.&#xA;$$&#xA;Using this basis, the time evolution $e^{-iHt}\ket{\psi}$ can be written as&#xA;$$&#xA;e^{-it\left(\mathbb{I}+2^{-n}Z+\frac{\sqrt{2^n-1}}{2^{n}}X\right)}\cdot\left(\begin{array}{c}\frac{1}{\sqrt{2^n}} \\ \sqrt{1-\frac{1}{2^n}} \end{array}\right),&#xA;$$&#xA;where $X$ and $Z$ are the standard Pauli matrices. This can be rewritten as&#xA;$$&#xA;e^{-it}\left(\mathbb{I}\cos\left(\frac{t}{2^{n/2}}\right)-i\frac{1}{2^{n/2}}\sin\left(\frac{t}{2^{n/2}}\right)\left(Z+X\sqrt{2^n-1}\right)\right)\left(\begin{array}{c}\frac{1}{\sqrt{2^n}} \\ \sqrt{1-\frac{1}{2^n}} \end{array}\right).&#xA;$$&#xA;So, if we evolve for a time $t=\frac{\pi}{2}2^{n/2}$, and ignoring global phases, the final state is&#xA;$$&#xA;\frac{1}{2^{n/2}}\left(Z+X\sqrt{2^n-1}\right)\left(\begin{array}{c}\frac{1}{\sqrt{2^n}} \\ \sqrt{1-\frac{1}{2^n}} \end{array}\right)=\left(\begin{array}{c}\frac{1}{2^n} \\ -\frac{\sqrt{2^n-1}}{2^n} \end{array}\right)+\left(\begin{array}{c} 1-\frac{1}{2^n} \\ \frac{\sqrt{2^n-1}}{2^n}\end{array}\right)=\left(\begin{array}{c} 1 \\ 0 \end{array}\right).&#xA;$$&#xA;In other words, with probability 1, we get the state $\ket{x}$ that we were searching for. The usual circuit-based description of Grover's search is really just this continuous time evolution broken into discrete steps, with the slight disadvantage that you usually can't get exactly probability 1 for your outcome, just very close to it.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One caveat is the following: you could redefine $\tilde H=5H$, and evolve using $\tilde H$ and the evolution time would be 5 times shorter. If you wanted to be really radical, replace the 5 with $2^{n/2}$, and Grover's search runs in constant time! But you're not allowed to do this arbitrarily. Any given experiment would have a fixed maximum coupling strength (i.e. a fixed multiplier). So, different experiments have different running times, but their scaling is the same, $2^{n/2}$. It's just like saying that the gate cost in the circuit model is constant, rather than assuming that if we use a circuit of depth $k$ each gate can be made to run in time $1/k$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The optimality proof essentially involves showing that if you made detection of one possible marked state $\ket{x}$ any quicker, it would make detection of a different marked state, $\ket{y}$, slower. Since the algorithm should work equally well whichever state is marked, this solution is the best one.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-04-06T07:28:12.270" CommentCount="0" />
  <row Id="1620" PostTypeId="1" CreationDate="2018-04-06T09:01:35.267" Score="17" ViewCount="308" Body="&lt;p&gt;Lieb-Robinson bounds describe how effects are propagated through a system due to a local Hamiltonian. They are often described in the form&#xA;$$&#xA;\left|[A,B(t)]\right|\leq Ce^{vt-l},&#xA;$$&#xA;where $A$ and $B$ are operators that are separated by a distance $l$ on a lattice where the Hamiltonian has, for example, nearest neighbour interactions on that lattice, bounded by some strength $J$. The &lt;a href=&quot;http://www.mathphys.org/AZschool/material/AZ09-nachtergaele-sims.pdf&quot; rel=&quot;noreferrer&quot;&gt;proofs&lt;/a&gt; of the Lieb Robinson bound typically show the existence of a velocity $v$ (that depends on $J$). This is often really useful for bound properties in these sorts of systems. For example, there were some really nice results &lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.97.050401&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt; to do with, for example, how long it takes to generate a GHZ state using a nearest-neighbour Hamiltonian.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The difficulty that I've had is that the proofs are sufficiently generic that it is difficult to get a tight value on what the velocity actually &lt;em&gt;is&lt;/em&gt; for any given system.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To be specific, imagine a one dimensional chain of qubits coupled by a Hamiltonian&#xA;$$&#xA;H=\sum_{n=1}^N\frac{B_n}{2}Z_n+\sum_{n=1}^{N-1}\frac{J_n}{2}(X_nX_{n+1}+Y_nY_{n+1}), \tag{1}&#xA;$$&#xA;where $J_n\leq J$ for all $n$. Here $X_n$, $Y_n$ and $Z_n$ represent a Pauli operator being applied to a given qubit $n$, and $\mathbb{I}$ everywhere else. &lt;strong&gt;Can you give a good (i.e. as tight as possible) upper bound for the Lieb-Robinson velocity $v$ for the system in Eq. (1)?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This question can be asked under two different assumptions:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;The $J_n$ and $B_n$ are all fixed in time&lt;/li&gt;&#xA;&lt;li&gt;The $J_n$ and $B_n$ are allowed to vary in time.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;The former is a stronger assumption which may make proofs easier, while the latter is usually included in the statement of Lieb-Robinson bounds.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Motivation&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Quantum computation, and more generally quantum information, comes down to making interesting quantum states. Through works such as &lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.97.050401&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt;, we see that information takes a certain amount of time to propagate from one place to another in a quantum system undergoing evolution due to a Hamiltonian such as in Eq. (1), and that quantum states, such as GHZ states, or states with a topological order, take a certain amount of time to produce. What the result currently shows is a scaling relation, e.g. the time required is $\Omega(N)$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, let's say I come up with a scheme that does information transfer, or produces a GHZ state etc. if a way that scales linearly in $N$. How good is that scheme actually? If I have an explicit velocity, I can see how closely matched the scaling coefficient is in my scheme compared to the lower bound.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If I think that one day what I want to see is a protocol implemented in the lab, then I very much care about optimising these scaling coefficients, not just the broad scaling functionality, because the faster I can implement a protocol, the less chance there is for noise to come along and mess everything up.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Further Information&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;$\newcommand{\bra}[1]{\left&amp;lt;#1\right|}\newcommand{\ket}[1]{\left|#1\right&amp;gt;}\newcommand{\bk}[2]{\left&amp;lt;#1\middle|#2\right&amp;gt;}\newcommand{\bke}[3]{\left&amp;lt;#1\middle|#2\middle|#3\right&amp;gt;}\newcommand{\proj}[1]{\left|#1\right&amp;gt;\left&amp;lt;#1\right|}$There are some nice features of this Hamiltonian which I assume make calculation easier. In particular, the Hamiltonian has a subspace structure based on the number of 1s in the standard basis (it is said to be excitation preserving) and, even better, the Jordan-Wigner transformation shows that all the properties of higher excitation subspaces can be derived from the 1-excitation subspace. This essentially means we only have to do the maths on an $N\times N$ matrix $h$ instead of the full $2^N\times 2^N$ matrix $H$, where&#xA;$$&#xA;h=\sum_{n=1}^NB_n\proj{n}+\sum_{n=1}^{N-1}J_n(\ket{n}\bra{n+1}+\ket{n+1}\bra{n}).&#xA;$$&#xA;There is some evidence that the Lieb-Robinson velocity is $v=2J$, such as &lt;a href=&quot;http://link.aps.org/doi/10.1103/PhysRevA.82.022318&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;http://file:///C:/Users/Alastair/Zotero/storage/QVRSWC5P/PhysRevA.85.html&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;, but these all use a close to uniformly coupled chain, which has a group velocity $2J$ (and I assume the group velocity is closely connected to the Lieb-Robinson velocity). It doesn't prove that all possible choices of coupling strength have a velocity that is so bounded.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I can add a bit further to the motivation. Consider the time evolution of a single excitation starting at one end of the chain, $\ket{1}$, and what its amplitude is for arriving at the other end of the chain $\ket{N}$, a short time $\delta t$ later. To first order in $\delta t$, this is&#xA;$$&#xA;\bra{N}e^{-ih\delta t}\ket{1}=\frac{\delta t^{N-1}}{(N-1)!}\prod_{n=1}^{N-1}J_n+O(\delta t^{N}).&#xA;$$&#xA;You can see the exponential functionality that you would expect being outside the 'light cone' defined by a Lieb-Robinson system, but more importantly, if you wanted to maximise that amplitude, you'd set all the $J_n=J$. So, at short times, the uniformly coupled system leads to the most rapid transfer. Trying to push this further, you can ask, as a bit of a fudge, when can &#xA;$$&#xA;\frac{t^{N-1}}{(N-1)!}\prod_{n=1}^{N-1}J_n\sim 1&#xA;$$&#xA;Taking the large $N$ limit, and using Stirling's formula on the factorial leads to&#xA;$$&#xA;\frac{etJ}{N-1}\sim 1,&#xA;$$&#xA;which suggests a maximum velocity of about $eJ$. Close, but hardly rigorous (as the higher order terms are non-negligible)!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;\newcommand{\bra}[1]{\left&amp;lt;#1\right|}\newcommand{\ket}[1]{\left|#1\right&amp;gt;}\newcommand{\bk}[2]{\left&amp;lt;#1\middle|#2\right&amp;gt;}\newcommand{\bke}[3]{\left&amp;lt;#1\middle|#2\middle|#3\right&amp;gt;}\newcommand{\proj}[1]{\left|#1\right&amp;gt;\left&amp;lt;#1\right|}&#xA;$$&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-04-11T06:48:13.243" LastActivityDate="2018-04-11T06:48:13.243" Title="Explicit Lieb-Robinson Velocity Bounds" Tags="&lt;simulation&gt;&lt;performance&gt;&lt;many-body-systems&gt;" AnswerCount="0" CommentCount="19" FavoriteCount="3" />
  <row Id="1621" PostTypeId="1" AcceptedAnswerId="1623" CreationDate="2018-04-06T13:40:02.570" Score="14" ViewCount="217" Body="&lt;p&gt;I see many papers (e.g. &lt;a href=&quot;https://arxiv.org/pdf/1307.0401.pdf&quot; rel=&quot;noreferrer&quot;&gt;Quantum principal component analysis&lt;/a&gt;) in which the existence of qRAM is necessary. What's the actual purpose of qRAM in quantum algorithms?&lt;/p&gt;&#xA;" OwnerUserId="1850" LastEditorUserId="1847" LastEditDate="2018-04-10T08:03:26.913" LastActivityDate="2018-06-11T14:06:08.470" Title="What is the purpose of a quantum RAM in quantum algorithms?" Tags="&lt;quantum-computer&gt;&lt;quantum-memory&gt;" AnswerCount="1" CommentCount="3" FavoriteCount="2" />
  <row Id="1622" PostTypeId="1" AcceptedAnswerId="1627" CreationDate="2018-04-06T16:35:16.583" Score="18" ViewCount="656" Body="&lt;p&gt;&lt;a href=&quot;https://cs.stackexchange.com/a/90292/71105&quot;&gt;An answer to another question&lt;/a&gt; mentions that  &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;There are &lt;a href=&quot;https://www.math.ucdavis.edu/~deloera/TEACHING/VIDEOS/Kalai-Lectures/hkD.pdf&quot; rel=&quot;noreferrer&quot;&gt;arguments&lt;/a&gt; that suggests that such machines [&quot;quantum Turing machines&quot;] cannot even be built...  &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I'm not sure I fully understand the problem, so perhaps I'm not asking the right question, but here's what I could gather.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The slides are &lt;a href=&quot;https://www.youtube.com/watch?v=YSpphjNm33g&quot; rel=&quot;noreferrer&quot;&gt;presented in a lecture (from 2013)&lt;/a&gt; by Professor Gil Kalai (Hebrew University of Jerusalem and Yale University). I watched most of the lecture, and it seems his claim is that there is a barrier to creating fault-tolerant quantum computers (FTCQ), and this barrier probably lies around creating logical qubits from physical components. (timestamp 26:20): &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/7vIPj.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/7vIPj.png&quot; alt=&quot;barrier between physical and logical qubits&quot;&gt;&lt;/a&gt;  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;It sounds like the reason for such a barrier is due to the problem of noise and error-correction. And even though current research takes into account noise, it doesn't do so in the right manner (this is the part I don't understand).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I know many people (e.g., Scott Aaronson) are skeptical of this claim of impossibility, but I'm just trying to better understand the argument: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;What is the reason for suggesting that practical quantum computers cannot be built&lt;/strong&gt; (as presented by Professor Gil Kalai, and has anything changed since 2013)?  &lt;/p&gt;&#xA;" OwnerUserId="1869" LastActivityDate="2018-07-13T14:42:34.190" Title="What is the argument that practical quantum computers cannot be built?" Tags="&lt;quantum-computer&gt;&lt;architecture&gt;" AnswerCount="4" CommentCount="5" FavoriteCount="3" />
  <row Id="1623" PostTypeId="2" ParentId="1621" CreationDate="2018-04-06T17:33:25.527" Score="4" Body="&lt;p&gt;This is discussed in chapter 5 of &lt;a href=&quot;http://rspa.royalsocietypublishing.org/content/474/2209/20170551#sec-6&quot; rel=&quot;nofollow noreferrer&quot;&gt;Ciliberto &lt;em&gt;et al.&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The purpose of most &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_machine_learning#Quantum-enhanced_machine_learning&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum(-enhanced) machine learning algorithms&lt;/a&gt; is to speed-up the processing of &lt;em&gt;classical&lt;/em&gt; data over what is possible with &lt;em&gt;classical&lt;/em&gt; machine learning algorithms.&#xA;In other words, the context is that you have a set of classical vectors $\{\boldsymbol x_k\}_k$, and you want to compute some function $\boldsymbol f(\boldsymbol x_k)$ of this data (which may then be used as an estimator of some property, or as a function characterising a classifier to be used for new data points, or something else).&#xA;Most quantum machine learning algorithms tell you that, provided you are able to efficiently perform the mapping &#xA;$$\{\boldsymbol x_k\}_k\mapsto\lvert \{\boldsymbol x_k\}\rangle= N\sum_{kj} x_{kj}\lvert k,j\rangle,$$&#xA;then it is sometimes possible to compute $\boldsymbol f(\{\boldsymbol x_k\})$ more efficiently.&#xA;It is, however, highly nontrivial how to perform such mapping &lt;em&gt;efficiently&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To maintain the potential exponential speed-ups of the quantum algorithms, this conversion needs to be efficient. If this is not the case, then one ends up in a situation in which the quantum algorithm can solve the problem very efficiently, but only after a lengthy preprocessing of the data has been performed, therefore killing the whole point of using the quantum algorithm.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is where QRAMs come into play. &#xA;A QRAM is a device that can (theoretically) encode $N$ $d$-dimensional classical vectors into (the amplitudes of) a quantum state of $\log(Nd)$ qubits, in time $\mathcal O(\log(Nd))$.&#xA;As discussed in &lt;a href=&quot;http://rspa.royalsocietypublishing.org/content/474/2209/20170551#sec-6&quot; rel=&quot;nofollow noreferrer&quot;&gt;Ciliberto &lt;em&gt;et al.&lt;/em&gt;&lt;/a&gt;, as well as in &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1502/55&quot;&gt;this related answer&lt;/a&gt;, the actual feasibility of QRAMs is still not entirely clear, and many caveats remain.&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-06-11T14:06:08.470" LastActivityDate="2018-06-11T14:06:08.470" CommentCount="0" />
  <row Id="1624" PostTypeId="2" ParentId="1622" CreationDate="2018-04-06T17:51:11.440" Score="-3" Body="&lt;p&gt;This is a false argument, considering that they have already been built. &lt;a href=&quot;https://www.dwavesys.com/press-releases/d-wave%C2%A0announces%C2%A0d-wave-2000q-quantum-computer-and-first-system-order&quot; rel=&quot;nofollow noreferrer&quot;&gt;DWave's 2000 qubit&lt;/a&gt; system is an adiabatic quantum computer using Grover's algorithm and can work on NP-complete problems. Shor's algorithm is currently implemented for NP-incomplete problems by &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/devices&quot; rel=&quot;nofollow noreferrer&quot;&gt;IBM cloud computing&lt;/a&gt; with 16 (cloud maintentance today), 20 (cloud online) and 50 qubit (offline) systems.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;br&gt;The arguments presented by Kalai and others are talking about qubit computing as reliable as silicon computation. As a programmer, I would treat the Shor's algorithm systems as a &quot;guess with quantum and check with silicon&quot; computing platform. The &quot;check&quot; is usually fast enough it can be done in middleware like python. IBM's systems are available using Python and QSM, so a single platform stack can do both on the cloud.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;br&gt;I personally think that Kalai created a paper to further his career. &lt;a href=&quot;https://arxiv.org/pdf/quant-ph/0212002.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Other people have contributed&lt;/a&gt; more reliable quantum circuits recently, but the circuit designs are very problem specific and algorithm implementation specific.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;br&gt;Making full Turing Complete quantum computers (to avoid some silicon components) could involve quantum storage for tracking state. I've discussed but not read about some methods for immutable crystal storage, and the results may involve quantum level storage in extremely durable formats (more durable than thumb drives). Making many assumptions about how Turing Complete Quantum Machines is probably very premature, please  &lt;a href=&quot;https://cstheory.stackexchange.com/questions/5695/is-there-a-name-for-physical-things-out-of-which-one-can-build-a-turing-machine&quot;&gt; consider the answers&lt;/a&gt; regarding Turing Machines.&lt;/p&gt;&#xA;" OwnerUserId="1008" LastEditorUserId="1008" LastEditDate="2018-04-06T18:04:02.323" LastActivityDate="2018-04-06T18:04:02.323" CommentCount="15" />
  <row Id="1625" PostTypeId="2" ParentId="1622" CreationDate="2018-04-06T20:56:40.533" Score="3" Body="&lt;p&gt;I can’t comment on the specifics of his arguments, because I don’t claim to understand them fully. But in general, we have to wonder whether quantum mechanics will continue to be valid for many qubit systems and states that are deep within the Hilbert space.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Physics is all about observing nature, building theories, confirming the theories, and then finding where they break down. Then the cycle begins again.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We have never had quantum systems as clean, well-controlled and large as current quantum processors. Devices capable of pulling off ‘supremacy’ are even further beyond our current experimental experience. So it is valid to wonder if this unprobed corner of QM might be where it all breaks down. Perhaps new ‘post-quantum’ effects will appear, that effectively act as uncorrectable forms of noise.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Of course, most of us don’t think it will. And we hope it won’t, or there will be no quantum computers. Nevertheless, we must be open to the possibility we are wrong.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And the minority who think quantum computing will fail should be open to the idea that they are wrong, too. Hopefully, they won’t turn out to be the new brand of ‘Bell violation deniers’.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="26" LastEditDate="2018-07-13T14:42:34.190" LastActivityDate="2018-07-13T14:42:34.190" CommentCount="0" />
  <row Id="1626" PostTypeId="2" ParentId="1622" CreationDate="2018-04-06T22:53:08.397" Score="5" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Q: &quot;What is the reason for suggesting that practical quantum computers cannot be built (&lt;strong&gt;as presented by Professor Gil Kalai&lt;/strong&gt;, and has anything changed since 2013)?&quot;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;In an interview titled &quot;&lt;a href=&quot;https://rjlipton.wordpress.com/2012/01/30/perpetual-motion-of-the-21st-century/&quot; rel=&quot;noreferrer&quot;&gt;Perpetual Motion of The 21st Century?&lt;/a&gt;&quot; Prof. Kalai states:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;For quantum systems there are special obstacles, such as the inability to make exact copies of quantum states in general. Nevertheless, much of the theory of error-correction has been carried over, and the famous threshold theorem shows that fault-tolerant quantum computation (FTQC) is possible if certain conditions are met. The most-emphasized condition sets a threshold for the absolute rate of error, one still orders of magnitude more stringent than what current technology achieves but approachable. One issue raised here, however, is whether the errors have sufficient independence for these schemes to work or correlations limited to what they can handle.&quot;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;In an earlier paper of his titled &quot;&lt;a href=&quot;https://arxiv.org/abs/0904.3265&quot; rel=&quot;noreferrer&quot;&gt;Quantum Computers: Noise Propagation and Adversarial Noise Models&lt;/a&gt;&quot; he states:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;Page 2:&lt;/strong&gt; &quot;The feasibility of computationally superior quantum computers is one of the most fascinating scientific problems of our time. The main concern regarding quantum-computer feasibility is that quantum systems are inherently noisy. The theory of quantum error correction and fault-tolerant quantum computation (FTQC) provides strong support for the possibility of building quantum computers. In this paper we will discuss adversarial noise models that may fail quantum computation. This paper presents a critique of quantum error correction and skepticism on the feasibility of quantum computers.&quot;.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;strong&gt;Page 19:&lt;/strong&gt; &quot;The main issue is therefore to understand and describe the fresh (or infinitesimal) noise operations. The adversarial models we consider here should be regarded as models for fresh noise. But the behavior of accumulative errors in quantum circuits that allow error propagation is sort of a “role model” for our models of fresh noise.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;The common picture of FTQC asserts:&lt;/p&gt;&#xA;  &#xA;  &lt;ul&gt;&#xA;  &lt;li&gt;Fault tolerance will work if we are able to reduce the fresh gate/qubit&#xA;  errors to below a certain threshold. In this case error propagation will be suppressed.&lt;/li&gt;&#xA;  &lt;/ul&gt;&#xA;  &#xA;  &lt;p&gt;What we propose is:&lt;/p&gt;&#xA;  &#xA;  &lt;ul&gt;&#xA;  &lt;li&gt;Fault tolerance will not work because the overall error will behave like accumulated errors for standard error propagation (for circuits that allow error propagation), although not necessarily because of error propagation.&lt;/li&gt;&#xA;  &lt;/ul&gt;&#xA;  &#xA;  &lt;p&gt;Therefore, for an appropriate modeling of noisy quantum computers the fresh errors should behave like accumulated errors for standard error propagation (for circuits that allow error propagation).&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;(As a result, in the end we will not be able to avoid error propagation.)&quot;.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;strong&gt;Page 23:&lt;/strong&gt; &quot;Conjecture B: In any noisy quantum computer in a highly entangled state there will be a strong effect of error synchronization. &lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;We should informally explain already at this point why these conjectures, if true, are damaging. We start with Conjecture B. The states of quantum computers that apply error-correcting codes needed for FTQC are highly entangled (by any formal definition of “high entanglement”). Conjecture B&#xA;  will imply that at every computer cycle there will be a small but substantial probability that the number of faulty qubits will be much larger than the threshold. This is in contrast to standard assumptions that the probability of the number of faulty qubits being much larger than the threshold decreases exponentially with the number of qubits. Having a small but substantial probability of a large number of qubits to be faulty is enough to fail the quantum error correction codes.&quot;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;See also his paper: &quot;&lt;a href=&quot;https://arxiv.org/abs/1106.0485&quot; rel=&quot;noreferrer&quot;&gt;How Quantum Computers Fail: Quantum Codes, Correlations in Physical Systems, and Noise Accumulation&lt;/a&gt;&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Many people disagee, and much has changed, see this Wikipedia page: &quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_threshold_theorem&quot; rel=&quot;noreferrer&quot;&gt;Quantum Threshold Theorem&lt;/a&gt;&quot;, or this paper &quot;&lt;a href=&quot;https://arxiv.org/abs/1403.5426&quot; rel=&quot;noreferrer&quot;&gt;Experimental Quantum Computations on a Topologically Encoded Qubit&lt;/a&gt;&quot;, there's even this paper on quantum metrology where the authors claim that: &quot;Making use of coherence and entanglement as metrological quantum resources allows to improve the measurement precision from the shot-noise or quantum limit to the Heisenberg limit.&quot; in their paper: &quot;&lt;a href=&quot;https://arxiv.org/abs/1711.06172v2&quot; rel=&quot;noreferrer&quot;&gt;Quantum metrology with a transmon qutrit&lt;/a&gt;&quot; by utilizing additional dimensions.&lt;/p&gt;&#xA;" OwnerUserId="278" LastActivityDate="2018-04-06T22:53:08.397" CommentCount="0" />
  <row Id="1627" PostTypeId="2" ParentId="1622" CreationDate="2018-04-06T22:59:19.870" Score="8" Body="&lt;p&gt;If your intent is to understand Gil Kalai's arguments, I recommend the following blog post of his: &lt;a href=&quot;https://gilkalai.wordpress.com/2018/02/08/my-argument-against-quantum-computers-an-interview-with-katia-moskvitch-on-quanta-magazine/&quot; rel=&quot;noreferrer&quot;&gt;My Argument Against Quantum Computers: An Interview with Katia Moskvitch on Quanta Magazine&lt;/a&gt; (and the links therein).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For good measure, I'd also throw in &lt;a href=&quot;https://rjlipton.wordpress.com/2012/01/30/perpetual-motion-of-the-21st-century/&quot; rel=&quot;noreferrer&quot;&gt;Perpetual Motion of The 21st Century?&lt;/a&gt; (especially the comments). You can also see the highlights in &lt;a href=&quot;https://gilkalai.wordpress.com/2013/03/16/my-quantum-debate-with-aram-harrow-timeline-non-technical-highlights-and-flashbacks-i/&quot; rel=&quot;noreferrer&quot;&gt;My Quantum Debate with Aram Harrow: Timeline, Non-technical Highlights, and Flashbacks I&lt;/a&gt; and &lt;a href=&quot;https://gilkalai.wordpress.com/2013/03/19/my-quantum-debate-with-aram-ii/&quot; rel=&quot;noreferrer&quot;&gt;My Quantum Debate with Aram II&lt;/a&gt;. Finally, if you haven't already, see Scott Aaronson's &lt;a href=&quot;https://www.scottaaronson.com/blog/?p=902&quot; rel=&quot;noreferrer&quot;&gt;Whether or not God plays dice, I do&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Edit.&lt;/strong&gt; In response to the comment by @heather, here are some quotes:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;First, a brief summary of Kalai's view from his &lt;a href=&quot;http://dx.doi.org/10.1090/noti1380&quot; rel=&quot;noreferrer&quot;&gt;Notices article&lt;/a&gt; (see also &lt;a href=&quot;https://gilkalai.wordpress.com/2016/04/22/the-quantum-computer-puzzle-notices-of-the-ams/&quot; rel=&quot;noreferrer&quot;&gt;The Quantum Computer Puzzle @ Notices of the AMS&lt;/a&gt;):&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Understanding quantum computers in the presence of noise requires consideration of behavior at different scales. In the small scale, standard models of noise from the mid-90s are suitable, and quantum evolutions and states described by them manifest a very low-level computational power. This small-scale behavior has far-reaching consequences for the behavior of noisy quantum systems at larger scales. On the one hand, it does not allow reaching the starting points for quantum fault tolerance and quantum supremacy, making them both impossible at all scales. On the other hand, it leads to novel implicit ways for modeling noise at larger scales and to various predictions on the behavior of noisy quantum systems.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Second, a &lt;a href=&quot;https://gilkalai.wordpress.com/2017/10/16/if-quantum-computers-are-not-possible-why-are-classical-computers-possible/&quot; rel=&quot;noreferrer&quot;&gt;recent argument&lt;/a&gt; for why he thinks classical error correction is possible but quantum error correction is not.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Unlike the repetition/majority mechanism which is supported by very primitive computational power, creating a quantum error correcting code and the easier task of demonstrating quantum supremacy are not likely to be achieved by devices which are very low-level in terms of computational complexity.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;(In the above mentioned conversation with Aram Harrow, it is &lt;a href=&quot;https://rjlipton.wordpress.com/2012/02/06/flying-machines-of-the-21st-century/&quot; rel=&quot;noreferrer&quot;&gt;pointed out&lt;/a&gt; that if one were to take Kalai's initial arguments directly, then even classical error correction would not possible.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the post, Kalai goes on to argue that a primitive quantum computer would not be able to do error correction.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Q: But why can’t you simply create good enough qubits to allow universal quantum circuits with 50 qubits?&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;A: This will allow very primitive devices (in terms of the asymptotic behavior of computational complexity) to perform superior computation.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Kalai also gave a lecture (&lt;a href=&quot;https://youtu.be/L5gSZsezhoQ&quot; rel=&quot;noreferrer&quot;&gt;YouTube&lt;/a&gt;) on why topological quantum computing would not work.&lt;/p&gt;&#xA;" OwnerUserId="1813" LastEditorUserId="1813" LastEditDate="2018-04-07T03:19:23.420" LastActivityDate="2018-04-07T03:19:23.420" CommentCount="5" />
  <row Id="1628" PostTypeId="2" ParentId="1486" CreationDate="2018-04-07T06:29:48.643" Score="1" Body="&lt;p&gt;The answer to the first question (why is energy efficiency in quantum vs classical not discussed as often as speed?) is: in part because the problem is less univocal and in part because the answer is less flattering.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The answer to the second question (are quantum computers more or less energetically efficient?) will change with time, since it depends on technological developments of the different architectures. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;At the present time, quantum computing is obviously less energetically efficient. A minimal classical computer can be designed to be extremely cheap, also in terms of energy (e.g. 1.5 W (average when idle) to 6.7 W (maximum under stress) for a &lt;a href=&quot;https://en.wikipedia.org/wiki/Raspberry_Pi&quot; rel=&quot;nofollow noreferrer&quot;&gt;Raspberry Pi&lt;/a&gt; ). In contrast, today to build and operate a minimal quantum computer is an engineering feat with staggering energy cost, even if the number of qubits is well below 100 and the maximum number of operations is orders of magnitude below what is achieved in a fraction of a second by a minimal classical computer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the future, one can either speculate or take into account the fundamentals. Let us avoid speculation and stick to the fundamentals: &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;There is no absolute fundamental physical reason for quantum computers to be more or less energy efficient than classical ones.&lt;/li&gt;&#xA;&lt;li&gt;Energy efficiency will always depend on the architecture, and thus on available technological solutions.&lt;/li&gt;&#xA;&lt;li&gt;To evaluate energy consumption, it will always be important to distinguish between the idle consumption and the cost of operation. &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;To elaborate on the latter point, present devices, both in commercial and academic settings, are bulky. Not ENIAC-sized, but larger-than-a-large-fridge-sized. Furthermore, to be controlled they require an auxiliary classical computer. The size-per-qubit is expected to get better, the need for an auxiliary classical computer is not.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But besides direct electrical power, there are often further physical requirements which cost energy, and which are fundamentally needed to keep the device in the desired quantum regime. For example, popular architectures today include different solid-state devices that need to be kept at temperatures of the order of a few Kelvin or lower. These temperatures are achieved with the help of liquid Helium, which is energetically very costly to liquify (cryogenic gases and electricity are among the main costs in Electronic Paramagnetic Resonance laboratories such as &lt;a href=&quot;https://nationalmaglab.org/user-facilities/emr&quot; rel=&quot;nofollow noreferrer&quot;&gt;the Electron Magnetic Resonance Facility (EMR) at the MagLab&lt;/a&gt;, or, closer to my experience, in the pulsed Electron Paramagnetic Resonance section at the &lt;a href=&quot;http://icmol.es/equipment.php&quot; rel=&quot;nofollow noreferrer&quot;&gt;ICMol&lt;/a&gt;). I have no experience with ion/atom traps, which are also popular architectures, so while they require mantaining a high-quality vacuum, for al I know it may be that these are more energy efficient.&lt;/p&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="1847" LastEditDate="2018-04-07T08:07:53.357" LastActivityDate="2018-04-07T08:07:53.357" CommentCount="4" />
  <row Id="1629" PostTypeId="1" AcceptedAnswerId="1641" CreationDate="2018-04-07T09:50:58.210" Score="15" ViewCount="488" Body="&lt;p&gt;In order to represent the single qubit $|\psi\rangle$ we use an unitary vector in a $\mathbb{C}^2$ Hilbert space whose (one of the) orthonormal base is $(|0\rangle, |1\rangle)$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;We can draw $|\psi\rangle$ using a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bloch_sphere&quot; rel=&quot;noreferrer&quot;&gt;Bloch ball&lt;/a&gt;. However, I found this notation quite confusing, because orthogonal vectors are spatially antiparallel (&lt;a href=&quot;https://physics.stackexchange.com/questions/204090/understanding-the-bloch-sphere&quot;&gt;brief explanation in this Physics Stackexchange question&lt;/a&gt;). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/U9pdD.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/U9pdD.png&quot; alt=&quot;Block sphere&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Do you know any different graphical representation for a single qubit?&lt;/p&gt;&#xA;" OwnerUserId="1874" LastActivityDate="2018-08-07T21:11:53.030" Title="Alternative to Bloch sphere to represent a single qubit" Tags="&lt;qubit-state&gt;" AnswerCount="4" CommentCount="0" FavoriteCount="2" />
  <row Id="1630" PostTypeId="2" ParentId="1629" CreationDate="2018-04-07T10:27:17.920" Score="1" Body="&lt;p&gt;The Bloch sphere historically came about to describe spins where up and down can actually be viewed as being (anti)parallel rather than (mathematically) orthogonal.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can naturally (and perhaps more naturally!) depict a qubit's state in a way that orthogonal states are indeed orthogonal. Then a pure 1-qubit state occupies a point on the surface of a 4-dimensional sphere.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-04-07T10:27:17.920" CommentCount="0" />
  <row Id="1631" PostTypeId="1" AcceptedAnswerId="1632" CreationDate="2018-04-07T10:41:55.107" Score="8" ViewCount="461" Body="&lt;p&gt;I have done some sort of online research on qubits and the factors making them infamous i.e allowing qubits to hold 1 and 0 at the same time and another is that qubits can be entangled somehow so that they can have related data in them no matter how far they are (even at opposite sides of the galaxies).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;While reading about this on Wikipedia I have seen some equation which is still difficult for me to comprehend. Here's the &lt;a href=&quot;https://en.wikipedia.org/wiki/Qubit#Entanglement&quot; rel=&quot;noreferrer&quot;&gt;link to Wikipedia&lt;/a&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Questions:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;How are they entangled in the first place?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;How do they relate their data?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="1875" LastEditorUserId="55" LastEditDate="2018-04-07T16:30:39.740" LastActivityDate="2018-04-08T10:18:35.997" Title="What does it mean for two qubits to be entangled?" Tags="&lt;qubit&gt;&lt;quantum-entanglement&gt;" AnswerCount="2" CommentCount="1" FavoriteCount="1" />
  <row Id="1632" PostTypeId="2" ParentId="1631" CreationDate="2018-04-07T11:51:35.390" Score="8" Body="&lt;p&gt;For a simple example suppose you have two qubits in definite states $|0\rangle$ and $|0\rangle$. The combined state of the system is $|0\rangle\otimes |0\rangle$ or $|00\rangle$ in shorthand.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then if we apply the following operators to the qubits (image is cut from &lt;a href=&quot;https://en.wikipedia.org/wiki/Superdense_coding&quot; rel=&quot;noreferrer&quot;&gt;superdense coding&lt;/a&gt; wiki page), the resulting state is an entangled state, one of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bell_state&quot; rel=&quot;noreferrer&quot;&gt;bell states&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/xV4Lq.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/xV4Lq.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;First in the image we have the hadamard gate acting on the first qubit, which in a longer form is $H\otimes I$ so that it is the identity operator on the second qubit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The hadamard matrix looks like &#xA;$$H=\frac{1}{\sqrt{2}} \begin{pmatrix} 1 &amp;amp; 1 \\ 1 &amp;amp; -1 \end{pmatrix}$$ where the basis is ordered $\{|0\rangle,|1\rangle\}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So after the hadamard operator acts the state is now&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$(H\otimes I)(|0\rangle\otimes|0\rangle)=H|0\rangle\otimes I |0\rangle=\frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)\otimes (|0\rangle)=\frac{1}{\sqrt{2}}(|00\rangle+|10\rangle)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The next part of the circuit is a controlled not gate, which only acts on the second qubit if the first qubit is a $1$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can represent $CNOT$ as $|0\rangle\langle0|\otimes I+|1\rangle\langle1|\otimes X$, where $|0\rangle\langle0|$ is a projection operator onto the bit $0$, or in matrix form $\begin{pmatrix} 1 &amp;amp; 0 \\ 0 &amp;amp; 0 \end{pmatrix}$. Similarly $|1\rangle\langle1|$ is $\begin{pmatrix} 0 &amp;amp; 0 \\ 0 &amp;amp; 1 \end{pmatrix}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The $X$ operator is the bit flip operator represented as $\begin{pmatrix} 0 &amp;amp; 1 \\ 1 &amp;amp; 0 \end{pmatrix}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Overall the $CNOT$ matrix is $\begin{pmatrix} 1 &amp;amp; 0 &amp;amp;0 &amp;amp; 0 \\ 0 &amp;amp; 1 &amp;amp;0 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp;0 &amp;amp; 1 \\0 &amp;amp; 0 &amp;amp;1 &amp;amp; 0 \\\end{pmatrix}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When we apply the $CNOT$ we can either use matrix multiplication by writing our state as a vector $\begin{pmatrix}\frac{1}{\sqrt{2}} \\ 0 \\ \frac{1}{\sqrt{2}} \\0 \end{pmatrix}$, or we can just use the tensor product form.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$CNOT (\frac{1}{\sqrt{2}}(|00\rangle+|10\rangle))=\frac{1}{\sqrt{2}}(|00\rangle+|11\rangle)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We see that for the first part of the state $|00\rangle$ the first bit is $0$, so the second bit is left alone; the second part of the state $|10\rangle$ the first bit is $1$, so the second bit is flipped from $0$ to $1$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Our final state is $$\frac{1}{\sqrt{2}}(|00\rangle+|11\rangle)$$ which is one of the four Bell states which are maximally entangled states. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;To see what it means for them to be entangled, notice that if you were to measure the state of the first qubit say, if you found out that it was a $0$ it immediately tells you the second qubit also has to be a $0$, because thats our only possibility.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Compare to this state for instance:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\frac{1}{2}(|00\rangle+|01\rangle+|10\rangle+|11\rangle).$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you measure that the first qubit is a zero, then the state collapses to $\frac{1}{\sqrt{2}}(|00\rangle+|01\rangle)$, where there is still a 50-50 chance the second qubit is a $0$ or a $1$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Hopefully this gives an idea how states can be entangled. If you want to know a particular example, like entangling photons or electrons etc, then you would have to look into how certain gates can be implemented, but still you might write the mathematics the same way, the $0$ and $1$ might represent different things in different physical situations.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Update 1: Mini Guide to QM/QC/Dirac notation&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Usually there's a standard computational (ortho-normal) basis for a single qubit which is $\{|0\rangle,|1\rangle\}$, say $\mathcal{H}=\operatorname{span}\{|0\rangle,|1\rangle\}$ is the vector space. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In this ordering of the basis we can identify $|0\rangle$ with $\begin{pmatrix} 1\\ 0 \end{pmatrix}$ and $|1\rangle$ with $\begin{pmatrix} 0\\ 1 \end{pmatrix}$. Any single qubit operator then can be written in matrix form using this basis. E.g. a bit flip operator $X$ (after pauli-$\sigma_x$) which should take $|0\rangle\mapsto |1\rangle$ and $|1\rangle \mapsto |0\rangle$, can be written as $\begin{pmatrix} 0 &amp;amp; 1\\ 1 &amp;amp; 0 \end{pmatrix}$, the first column of the matrix is the image of the first basis vector and so on.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When you have multiple say $n$-qubits they should belong to the space $\mathcal{H}^{\otimes n}:=\overbrace{\mathcal{H}\otimes\mathcal{H}\otimes\cdots\otimes \mathcal{H}}^{n-times}$. A basis for this space is labelled by strings of zeros and ones, e.g. $|0\rangle\otimes|1\rangle\otimes |1\rangle\otimes\ldots \otimes|0\rangle$, which is usually abbreviated for simplicity as $|011\ldots0\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A simple example for two qubits, the basis for $\mathcal{H}^{\otimes 2}=\mathcal{H}\otimes \mathcal{H}$, is $\{|0\rangle\otimes|0\rangle,|0\rangle\otimes|1\rangle,|1\rangle\otimes|0\rangle,|1\rangle\otimes|1\rangle\}$ or in the shorthand $\{|00\rangle,|01\rangle,|10\rangle,|11\rangle\}$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;There's different ways to order this basis in order to use matrices, but one natural one is to order the strings as if they are numbers in binary so as above. For example for $3$ qubits you could order the basis as $$\{|000\rangle,|001\rangle,|010\rangle,|011\rangle,|100\rangle,|101\rangle,|110\rangle,|111\rangle\}.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The reason why this can be useful is that it corresponds with the &lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_product&quot; rel=&quot;noreferrer&quot;&gt;Kronecker product&lt;/a&gt; for the matrices of the operators. For instance, first looking at the basis vectors: &#xA;$$|0\rangle\otimes |0\rangle=\begin{pmatrix} 1\\ 0 \end{pmatrix}\otimes \begin{pmatrix} 1\\ 0 \end{pmatrix}:=\begin{pmatrix} 1\cdot\begin{pmatrix} 1\\ 0 \end{pmatrix} \\ 0\cdot\begin{pmatrix} 1\\ 0 \end{pmatrix} \end{pmatrix}=\begin{pmatrix} 1\\ 0\\0\\0 \end{pmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;and&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$|0\rangle\otimes |1\rangle=\begin{pmatrix} 1\\ 0 \end{pmatrix}\otimes \begin{pmatrix} 0\\ 1 \end{pmatrix}:=\begin{pmatrix} 1\cdot\begin{pmatrix} 0\\ 1 \end{pmatrix} \\ 0\cdot\begin{pmatrix} 1\\ 0 \end{pmatrix} \end{pmatrix}=\begin{pmatrix} 0\\ 1\\0\\0 \end{pmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;and similarly&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$|1\rangle\otimes |0\rangle=\begin{pmatrix} 0\\ 0\\1\\0 \end{pmatrix},\quad |1\rangle\otimes |1\rangle=\begin{pmatrix} 0\\ 0\\0\\1 \end{pmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you have an operator e.g. $X_1X_2:=X\otimes X$ which acts on two qubits and we order the basis as above we can take the kronecker product of the matrices to find the matrix in this basis:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$X_1X_2=X\otimes X=\begin{pmatrix} 0 &amp;amp; 1\\ 1 &amp;amp; 0 \end{pmatrix}\otimes \begin{pmatrix} 0 &amp;amp; 1\\ 1 &amp;amp; 0 \end{pmatrix} = \begin{pmatrix} 0\cdot\begin{pmatrix} 0 &amp;amp; 1\\ 1 &amp;amp; 0 \end{pmatrix} &amp;amp; 1\cdot\begin{pmatrix} 0 &amp;amp; 1\\ 1 &amp;amp; 0 \end{pmatrix}\\ 1\cdot\begin{pmatrix} 0 &amp;amp; 1\\ 1 &amp;amp; 0 \end{pmatrix} &amp;amp; 0\cdot \begin{pmatrix} 0 &amp;amp; 1\\ 1 &amp;amp; 0 \end{pmatrix} \end{pmatrix}=\begin{pmatrix} 0 &amp;amp;0&amp;amp;0&amp;amp;1\\ 0 &amp;amp;0&amp;amp;1&amp;amp;0\\0 &amp;amp;1&amp;amp;0&amp;amp;0\\1 &amp;amp;0&amp;amp;0&amp;amp;0\\  \end{pmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we look at the example of $CNOT$ above given as $|0\rangle\langle0|\otimes I+|1\rangle\langle1|\otimes X$.$^*$ This can be computed in matrix form as $\begin{pmatrix} 1 &amp;amp; 0\\ 0 &amp;amp; 0 \end{pmatrix}\otimes \begin{pmatrix} 1 &amp;amp; 0\\ 0 &amp;amp; 1 \end{pmatrix}+\begin{pmatrix} 0 &amp;amp; 0\\ 0 &amp;amp; 1 \end{pmatrix}\otimes\begin{pmatrix} 0 &amp;amp; 1\\ 1 &amp;amp; 0 \end{pmatrix}$, which you can check is the $CNOT$ matrix above.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It's worthwhile getting used to using the shorthands and the tensor products rather than converting everything to matrix representation since the computational space grows as $2^n$ for $n$-qubits, which means for three cubits you have $8\times 8$ matrices, $4$-qubits you have $16\times 16$ matrices and it quickly becomes less than practical to convert to matrix form. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Aside$^*$: There are a few common ways to use dirac notation, to represent vectors like $|0\rangle$; dual vectors e.g. $\langle 0|$, inner product $\langle 0|1\rangle$ between the vectors $|0\rangle$ and $|1\rangle$; operators on the space like $X=|0\rangle\langle1|+|1\rangle\langle0|$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;An operator like $P_0=|0\rangle\langle0|$ is a projection operator is a (orthogonal) projection operator because it satisfies $P^2=P$ and $P^\dagger=P$.&lt;/p&gt;&#xA;" OwnerUserId="197" LastEditorUserId="197" LastEditDate="2018-04-07T19:30:32.730" LastActivityDate="2018-04-07T19:30:32.730" CommentCount="4" />
  <row Id="1633" PostTypeId="2" ParentId="1629" CreationDate="2018-04-07T13:18:01.977" Score="6" Body="&lt;p&gt;Adding to what &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1630/26&quot;&gt;@pyramids conveyed in their answer&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A qubit's state is generally written as $\alpha|0\rangle + \beta|1\rangle$, where $\alpha, \beta \in \Bbb{C}$, and $|\alpha|^2+|\beta|^2=1$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\Bbb{C}^2(\Bbb{R})$ is a four-dimensional vector space, over the field of real numbers. Since &lt;a href=&quot;https://math.stackexchange.com/a/2170600/400242&quot;&gt;any $n$-dimensional real vector space is isomorphic to $\Bbb{R}^n(\Bbb{R})$&lt;/a&gt;, you can represent any qubit's state as a point in a $4$-dimensional real space, too, whose basis vectors you can consider to be $(1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1)$. In such a case a qubit's state would be represented as $a(1,0,0,0)+b(0,1,0,0)+c(0,0,1,0)+d(0,0,0,1)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Say, $\alpha = a + i b$ (where $a,b\in \Bbb{R}$) and $\beta = c + id$ (where $c,d\in \Bbb{R}$). You need the condition $|a+ib|^2+|c+id|^2=1\implies a^2+b^2+c^2+d^2=1$ to be satisfied, which implies the state of the qubit would be a point on a &lt;a href=&quot;https://en.wikipedia.org/wiki/N-sphere&quot; rel=&quot;nofollow noreferrer&quot;&gt;3-sphere&lt;/a&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;As you know, it is difficult to efficiently represent a $4$-dimensional space on a $2$-dimensional surface like a paper, or your screen. Hence, you don't see that representation used often. &lt;a href=&quot;https://en.wikipedia.org/wiki/Bloch_sphere&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bloch sphere&lt;/a&gt; is pretty much the &lt;strong&gt;most efficient representation&lt;/strong&gt; out there (for a single qubit), since it &lt;a href=&quot;https://en.wikipedia.org/wiki/Qubit#Bloch_sphere&quot; rel=&quot;nofollow noreferrer&quot;&gt;reduces one degree of freedom&lt;/a&gt; (of the complex numbers $\alpha,\beta$ each of which have two degrees of freedom) due to the fact that a qubit's state is usually normalized to a magnitude of $1$ i.e. $|\alpha|^2+|\beta|^2=1$.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Now, using the &lt;a href=&quot;https://en.wikipedia.org/wiki/3-sphere#Hopf_coordinates&quot; rel=&quot;nofollow noreferrer&quot;&gt;Hopf&#xA;  coordinates&lt;/a&gt;&#xA;  let's say:&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;$$\alpha = e^{i\psi}\cos(\theta/2)$$&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;$$\beta = e^{i(\psi+\phi)}\sin(\theta/2)$$&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Here, $\theta$ can run from $0$ to $\pi$ whereas, $\psi$ and&#xA;  $\phi+\psi$ can take values between $0$ to $\pi$.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;em&gt;In case you're wondering why $\theta/2$ is being used instead of $\theta$ have a look at the answers on &lt;a href=&quot;https://physics.stackexchange.com/questions/174562/why-is-theta-over-2-used-for-a-bloch-sphere-instead-of-theta&quot;&gt;this&lt;/a&gt; excellent thread on Physics Stack Exchange.&lt;/em&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Okay, even now you notice three degrees of freedom $\psi,\phi,\theta$, whereas in a unit radii sphere, you only have two angles which you can change to get the different states of a qubit. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Notice that $\phi$ is basically the &quot;relative phase&quot; between $\alpha$ and $\beta$. On the other hand $\psi$ does not contribute to the &quot;relative phase&quot; of $\alpha,\beta$. Also, neither $\phi$ nor $\psi$ contribute to the magnitude of $\alpha,\beta$ (since $|e^{i\varphi}|=1$ for any angle $\varphi$). Since $\psi$ contributes neither to &quot;relative phase&quot; nor to the &quot;magnitudes&quot; of $\alpha,\beta$ it is said to have &lt;strong&gt;no physically observable consequences&lt;/strong&gt; and we can &lt;em&gt;arbitrarily choose&lt;/em&gt; $\alpha$ to be real by eliminating the factor of $e^{i\psi}$.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Thus we end up with:&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;$$\alpha = \cos(\theta/2)$$ and $$\beta=e^{i\phi}\sin(\theta/2)$$&#xA;  Where $\theta$ can run from $0$ to $\pi$, and $\phi$ can run from $0$ to $2\pi$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;This practical simplification allows you to represent a qubit's state using just $2$ degrees of freedom on $3$-dimensional spherical surface having unit radius, which again can again efficiently be &quot;drawn&quot; on a $2$-dimensional surface, as shown in the following image.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/uUcQH.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/uUcQH.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Mathematically, it is not possible to reduce the degrees of freedom any further, and so, I'd say there is no other &quot;more efficient&quot; geometrical representation of a single qubit than the Bloch sphere.&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sub&gt;Source: &lt;a href=&quot;https://en.wikipedia.org/wiki/Qubit#Bloch_sphere&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wikipedia:Bloch_Sphere&lt;/a&gt;&lt;/sub&gt;&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-08T05:52:01.640" LastActivityDate="2018-04-08T05:52:01.640" CommentCount="5" />
  <row Id="1634" PostTypeId="1" AcceptedAnswerId="1647" CreationDate="2018-04-07T17:51:30.817" Score="10" ViewCount="164" Body="&lt;p&gt;This question is based on a scenario that is partly hypothetical and partly based on the experimental features of molecule-based quantum devices, which often present a quantum evolution and have some potential to be scalable, but are generally extremely challenging to characterize in detail (a relevant but not unique example is a series of works related to this &lt;a href=&quot;http://science.sciencemag.org/content/344/6188/1135&quot; rel=&quot;noreferrer&quot;&gt;electrical control of nuclear spin qubits in single molecules&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The scenario: Let us say we have a variety of black boxes, each of which is are able to process information. We don't control the quantum evolution of the boxes; in the language of the quantum circuit model, we do not control the sequence of quantum gates. We know each black box is hardwired to a different algorithm, or, more realistically, to a different time-dependent Hamiltonian, including some incoherent evolution. We don't know the details of each black box. In particular, we don't know whether &lt;strong&gt;their quantum dynamics are coherent enough to produce a useful implementation of a quantum algorithm&lt;/strong&gt; (let us herein call this &quot;&lt;em&gt;quantumness&lt;/em&gt;&quot;; the lower bound for this would be &quot;it's distinguishable from a classical map&quot;). To work with our black boxes towards this goal, &lt;strong&gt;we only know how to feed them classical inputs and obtain classical outputs&lt;/strong&gt;. Let us here distinguish between two sub-scenarios:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;We cannot perform entanglement ourselves: we employ product states as&#xA;inputs, and single qubit measurements on the outputs. However, we can choose the basis of our input preparation and of our measurements (at minimum, between two orthogonal bases).&lt;/li&gt;&#xA;&lt;li&gt;As above, but we cannot choose the bases and have to worked on some fixed, &quot;natural&quot; base.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;The goal: to check, for a given black box, the &lt;em&gt;quantumness&lt;/em&gt; of its dynamics. At least, for 2 or 3 qubits, as a proof-of-concept, and ideally also for larger input sizes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The question: in this scenario, is there a series of correlation tests, in the style of &lt;a href=&quot;https://en.wikipedia.org/wiki/Bell&amp;#39;s_theorem#Bell_inequalities&quot; rel=&quot;noreferrer&quot;&gt;Bell's inequalities&lt;/a&gt;, which can achieve this goal?&lt;/p&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="1847" LastEditDate="2018-04-08T13:47:39.213" LastActivityDate="2018-04-09T06:50:56.757" Title="Can one interrogate black boxes for quantum coherence?" Tags="&lt;quantum-algorithms&gt;&lt;architecture&gt;&lt;experimental-results&gt;&lt;quantum-decoherence&gt;" AnswerCount="3" CommentCount="2" FavoriteCount="1" />
  <row Id="1635" PostTypeId="1" CreationDate="2018-04-07T18:07:42.913" Score="7" ViewCount="89" Body="&lt;p&gt;This question is a follow-up on &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/1485/1346&quot;&gt;this one&lt;/a&gt;, with the hope of getting more specific clues, and was motivated by &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1432/1346&quot;&gt;this answer&lt;/a&gt; by user Rob.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In &lt;a href=&quot;https://www.dwavesys.com/quantum-computing&quot; rel=&quot;noreferrer&quot;&gt;D-Wave Systems&lt;/a&gt;' webpage, we can read a description of how an annealing QPU like their &lt;em&gt;2000Q&lt;/em&gt; flagship is able perform optimization on a given distribution by regarding many paths simultaneously, which makes the optimization process more robust against local minima and such.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;After that, they claim that &quot;it is best suited to tackling complex optimization problems that exist across many domains&quot;, and they cite (among others), &lt;strong&gt;optimization&lt;/strong&gt;, &lt;strong&gt;machine learning&lt;/strong&gt; and &lt;strong&gt;sampling / Monte Carlo&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Furthermore, in &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_annealing&quot; rel=&quot;noreferrer&quot;&gt;Wikipedia&lt;/a&gt;, we see that&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Quantum annealing (QA) is a metaheuristic for finding the global minimum of a given objective function over a given set of candidate solutions [...]. Quantum annealing starts from a quantum-mechanical superposition of all possible states (candidate states) with equal weights. Then the system evolves [...] The transverse field is finally switched off, and the system is expected to have reached the ground state. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;At this point, we see that both explanations (with different detail levels) &lt;strong&gt;address the question of how annealing can help non-convex optimization (&lt;a href=&quot;https://arxiv.org/abs/1412.0233&quot; rel=&quot;noreferrer&quot;&gt;among other things&lt;/a&gt;)&lt;/strong&gt;. And that isn't even specifically related to quantum computing since &lt;a href=&quot;https://en.wikipedia.org/wiki/Simulated_annealing&quot; rel=&quot;noreferrer&quot;&gt;simulated annealing&lt;/a&gt; stands on its own. But it is D-Wave claiming their hardware can help to perform sampling.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Maybe the connection is obvious and I'm missing it, but I think sampling is a distinct enough task from optimization to require its own explanation. The specific questions that I have are:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Given some data following a possibly unknown distribution, how can the D-Wave be used to perform sampling on it? What are the constraints?&lt;/li&gt;&#xA;&lt;li&gt;To what extent is it advantageous against other SoTA classical sampling algorithms like, say, &lt;a href=&quot;https://en.wikipedia.org/wiki/Gibbs_sampling&quot; rel=&quot;noreferrer&quot;&gt;Gibbs&lt;/a&gt;?&lt;/li&gt;&#xA;&lt;li&gt;Are the possible advantages specific to annealing QPUs, to any QPUs or a general property of simulated annealing?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="1346" LastActivityDate="2018-04-09T00:12:29.043" Title="How can a D-Wave style Annealing QPU help sampling?" Tags="&lt;d-wave&gt;&lt;quantum-annealing&gt;&lt;bayesian-learning&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="1636" PostTypeId="2" ParentId="1629" CreationDate="2018-04-07T22:11:10.687" Score="0" Body="&lt;p&gt;(Firstly, the &quot;reputation points&quot; requirement is stupid - this remark should be a comment on the previous post.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A single qubit in a pure state has 2 real degrees of freedom, not 3, when you quotient out both magnitude and phase (i.e., complex normalization). So, most reasonable two-dimensional surfaces could be used (e.g., the 2-sphere or anything topologically equivalent).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Finding a &lt;em&gt;useful&lt;/em&gt; representation is another story. The Bloch sphere has a natural extension to mixed states (which have 3 degrees of freedom), whereas this does not appear to be the case otherwise..&lt;/p&gt;&#xA;" OwnerUserId="1885" LastEditorUserId="1837" LastEditDate="2018-05-22T10:58:26.647" LastActivityDate="2018-05-22T10:58:26.647" CommentCount="1" />
  <row Id="1637" PostTypeId="2" ParentId="1635" CreationDate="2018-04-08T00:34:26.797" Score="1" Body="&lt;p&gt;This answer reflects my understanding of what D-wave have to say about this, in the 2013 whitepaper they link to: &lt;a href=&quot;https://www.dwavesys.com/sites/default/files/Map%20Coloring%20WP2.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Programming With D-Wave: Map Coloring Problem&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;To back up the question, we find once again the claim: &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;superposition&quot; states [...] give a quantum computer the ability to quickly solve certain classes of complex problems such as optimization, machine learning and sampling problems. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;And the explanation for the optimization problem:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The processor considers all the possibilities simultaneously to determine the lowest energy required to form those relationships. &#xA;  Because a quantum computer is probabilistic rather than deterministic, the computer returns many very good answers in a &#xA;  short amount of time -  10,000 answers in one second.  This gives the user not only the optimal solution or a single answer,&lt;br&gt;&#xA;  but also other alternatives to choose from.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Then, the statement that the QPU naturally returns samples:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;If the D-Wave quantum computer has no registers or memory locations, a natural question arises: how do we learn anything from having executed a quantum machine instruction? The answer is that &lt;strong&gt;we are given samples from a distribution, as a side effect of executing the QMI&lt;/strong&gt; (quantum machine instruction).&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;But how? First, they explain what is the interface for such QMIs:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;&quot;The D-Wave system has many qubits [...]. &lt;strong&gt;The programming model does not allow the programmer to directly set the value of these qubits&lt;/strong&gt;&quot;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Instead, the state of the $q_i$ qbits can be influenced by setting a weight $a$ for each qbit, and a weight $b_{ij}$ (called &lt;em&gt;coupler&lt;/em&gt;) for each connection between any 2 qbits. The qbits are linearly combined into an &quot;objective function that &lt;strong&gt;will define the distribution from which our samples will be selected&lt;/strong&gt;&quot;: $O(a,b;q) = \sum_{i=1}^N{a_i q_i} + \sum_{&amp;lt;i,j&amp;gt;}b_{ij} q_i q_j$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&quot;&lt;strong&gt;Each QMI consists of exactly the $a$ and $b_{ij}$ values&lt;/strong&gt; that appear in the [...] objective function&quot;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;And then they describe the protocol for such QMIs:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;As a programmer, &lt;strong&gt;it is our job is to encode the various possible solutions to an optimization problem in the qubit variables&lt;/strong&gt; $q_i$. Then we translate the constraints in our optimization problem into values of the weights $a_i$ and strengths $b_{ij}$ such that when the objective is minimized the qubits will satisfy the constraints.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;In this context,&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;ul&gt;&#xA;  &lt;li&gt;&lt;p&gt;&quot;&lt;em&gt;Each sample is simply the collection of $q_i$ values for the entire set of qubits which enter into our problem&lt;/em&gt;&quot;.&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;&quot;&lt;em&gt;The distribution is an equal weighting across all the samples that give the minimum (or slightly above in practice) value of our objective function&lt;/em&gt;&quot;.&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;So as far as I understood, three things are known to the programmer in beforehand:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;The set of constraints (weights and couplers)&lt;/li&gt;&#xA;&lt;li&gt;The distribution's domain (encoding of the qbits)&lt;/li&gt;&#xA;&lt;li&gt;The fact that the distribution is a linear mixture model&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Then, running the program &lt;em&gt;once&lt;/em&gt; will return a distribution which is by itself an average of all the possible optimal samples in the domain that satisfy the constraints.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And now I will try to answer my questions:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;ul&gt;&#xA;  &lt;li&gt;&lt;strong&gt;Given some data following a possibly unknown distribution, how can the D-Wave be used to perform sampling on it? What are the constraints?&lt;/strong&gt;&lt;/li&gt;&#xA;  &lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I will start with the constraints:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;The distribution has to be representable as a linear mixture model of qbit distributions.&lt;/li&gt;&#xA;&lt;li&gt;The hardware has to be capable of encoding the whole domain of the distribution&lt;/li&gt;&#xA;&lt;li&gt;The programmer has to be able to express the desired distribution as a combination of sets of constraints within the mixture model. Therefore the distribution has to be &lt;em&gt;implicitly&lt;/em&gt; known, but not &lt;em&gt;explicitly&lt;/em&gt;: this suits in fact very well machine learning and data-driven workflows.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Given this assumptions, it should be possible to extract the probability density function by running the program once per constraint set, and performing the pertinent combination. &lt;em&gt;Note that the linearity of the mixture model is somehow a limitation, but also has its &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_system&quot; rel=&quot;nofollow noreferrer&quot;&gt;advantages&lt;/a&gt; regarding such combinations&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;ul&gt;&#xA;  &lt;li&gt;&lt;strong&gt;To what extent is it advantageous against other SoTA classical sampling algorithms like, say, Gibbs?&lt;/strong&gt;&lt;/li&gt;&#xA;  &lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The advantage comes from the speedup that &quot;superimposed&quot; states give by enabling a single program's output to collapse multiple samples. But there is one big caveat: the output returns all the &lt;strong&gt;minimum&lt;/strong&gt; states for the given constraint. This means that the speedup depends on the programmer's ability of encoding the constraints in a way that collapse as many outputs as possible. Without getting into big-O, this doesn't seem trivial at all to me.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;ul&gt;&#xA;  &lt;li&gt;&lt;strong&gt;Are the possible advantages specific to annealing QPUs, to any QPUs or a general property of simulated annealing?&lt;/strong&gt;&lt;/li&gt;&#xA;  &lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I don't know about other QPUs (help very welcome), but regarding Wikipedia's &lt;a href=&quot;https://en.wikipedia.org/wiki/Simulated_annealing#Pseudocode&quot; rel=&quot;nofollow noreferrer&quot;&gt;pseudocode for simulated annealing&lt;/a&gt; we see that the output is a single sample. So, given the big caveat discussed before, this is already the worst-case scenario for a D-Wave sampler.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h3&gt;POSSIBLE APPLICATION EXAMPLES:&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1803.10520&quot; rel=&quot;nofollow noreferrer&quot;&gt;This related paper&lt;/a&gt; (linked by user &lt;code&gt;hopefully coherent&lt;/code&gt;) presents an algorithm that could be a candidate for this case: At the end of page 2, &#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;We address the first term in (1) by describing a quantum procedure to efficiently sample the eigenvalues of an $n\times n$ Hermitian matrix $A$ uniformly at random&quot;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;It would be very interesting to see if/how the constraints for eigenvalues can be encoded as the above discussed QMIs.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Insert here some example for the encoding of some data-driven setup like &quot;given this $N$-dimensional dataset, find the projection or embedding that minimizes some non-convex objective&quot; into such QMIs.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="1346" LastEditorUserId="1346" LastEditDate="2018-04-09T00:12:29.043" LastActivityDate="2018-04-09T00:12:29.043" CommentCount="6" />
  <row Id="1638" PostTypeId="2" ParentId="1631" CreationDate="2018-04-08T08:55:21.140" Score="1" Body="&lt;p&gt;Although the linked wikipedia article is trying to use entanglement as a distinguishing feature from classical physics, I think one can start to get some understanding about entanglement by looking at classical stuff, where our intuition works a little better...&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Imagine you have a random number generator that, each time, spits out a number 0,1,2 or 3. Usually you'd make these equally probability, but we can assign any probability to each outcome that we want. For example, let's give 1 and 2 each with probability 1/2, and never give 0 or 3. So, each time the random number generator picks something, it gives 1 or 2, and you don't know in advance what it's going to be. Now, let's write these numbers in binary, 1 as 01 and 2 as 10. Then, we give each bit to a different person, say Alice and Bob. Now, when the random number generator picks a value, either 01 or 10, Alice has one part, and Bob has the other. So, Alice can look at her bit, and whatever value she gets, she knows that Bob has the opposite value. We say these bits are perfectly anti-correlated.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Entanglement works much the same way. For example, you might have a quantum state $$\left|\psi\right\rangle=\frac{1}{\sqrt{2}}\left(\left|01\right\rangle-\left|10\right\rangle\right)$$&#xA;where Alice holds one qubit of $\left|\psi\right\rangle$, and Bob holds the other. Whatever single-qubit projective measurement Alice chooses to make, she'll get an answer 0 or 1. If Bob makes the same measurement on his qubit, he always gets the opposite answer. This includes measuring in the Z-basis, which reproduces the classical case.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The difference comes from the fact that this holds true for every possible measurement basis, and for that to be the case, the measurement outcome must be unpredictable, and that's where it differs from the classical case (you may like to read up about Bell tests, specifically the &lt;a href=&quot;https://en.wikipedia.org/wiki/CHSH_inequality&quot; rel=&quot;nofollow noreferrer&quot;&gt;CHSH test&lt;/a&gt;). In the classical random number example I described at the start, once the random number generator has picked something, there's no reason why it can't be copied. Somebody else would be able to know what answer both Alice and Bob would get. However, in the quantum version, the answers that Alice and Bob get do not exist is advance, and therefore nobody else can know them. If somebody did know them, the two answers would not be perfectly anti-correlated. This is the basis of &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_key_distribution#E91_protocol:_Artur_Ekert_(1991)&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Key Distribution&lt;/a&gt; as it basically describes being able to detect the presence of an eavesdropper.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Something further that may help in trying to understand entanglement: mathematically, it’s no different to superposition, it’s just that, at some point, you separate the superposed parts over a great distance, and the fact that that is in some sense difficult to do means that making the separation provides you with a resource that you can do interesting things with. Really, entanglement is the resource of what one might call ‘distributed superposition’.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-04-08T10:18:35.997" LastActivityDate="2018-04-08T10:18:35.997" CommentCount="0" />
  <row Id="1639" PostTypeId="2" ParentId="1634" CreationDate="2018-04-08T10:50:02.473" Score="3" Body="&lt;p&gt;Why not input one half of a maximally entangled state as the input to the black box (so that half has the same dimension as the input dimension)? Then you could &lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.88.217901&quot; rel=&quot;nofollow noreferrer&quot;&gt;test your favourite measure&lt;/a&gt;, such as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Purity_(quantum_mechanics)&quot; rel=&quot;nofollow noreferrer&quot;&gt;purity&lt;/a&gt;, of the full output state. If the oracle corresponds to a unitary evolution, the purity is 1. The less coherent the smaller the purity. Incidentally, the output state describes the map that the black box implements, via the &lt;a href=&quot;https://en.wikipedia.org/wiki/Channel-state_duality&quot; rel=&quot;nofollow noreferrer&quot;&gt;Choi-Jamiołkowski isomorphism&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-04-08T12:02:39.677" LastActivityDate="2018-04-08T12:02:39.677" CommentCount="2" />
  <row Id="1640" PostTypeId="2" ParentId="1634" CreationDate="2018-04-08T12:19:27.233" Score="1" Body="&lt;p&gt;I'm not exactly sure what you mean by &lt;em&gt;quantumness&lt;/em&gt; of your black box. So maybe there are some more sophisticated approaches (similar to the other answer you could use an entanglement witness to show that your black box is not entanglement breaking). However, in general you could perform &lt;strong&gt;quantum process tomography&lt;/strong&gt; (see e.g. &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9611013&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv:quant-ph/9611013&lt;/a&gt;).&lt;/p&gt;&#xA;" OwnerUserId="104" LastActivityDate="2018-04-08T12:19:27.233" CommentCount="3" />
  <row Id="1641" PostTypeId="2" ParentId="1629" CreationDate="2018-04-08T19:44:46.173" Score="5" Body="&lt;p&gt;In the link included in your question, about another question written by user098876, &quot;Understanding the Bloch sphere&quot;, Daniel makes a helpful comment:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;Drawing points on the sphere to represent the state of a quantum two-level system does not mean that you should think of those points as real vectors in 3D space. – DanielSank Sep 3 '15 at 20:17&quot;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Oversimplified explanation: It's a two-side plane (or two planes) projected on a sphere.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;I found this notation quite confusing, because orthogonal vectors are spatially antiparallel (&lt;a href=&quot;https://physics.stackexchange.com/questions/204090/understanding-the-bloch-sphere&quot;&gt;brief explanation in this Physics Stackexchange question&lt;/a&gt;). Do you know any different graphical representation for a single qubit?&quot;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There are a number of efforts underway to provide a more general representation that extends from qubits to qudits. This explanation and representation using a &lt;a href=&quot;https://phys.org/news/2016-12-method-majorana-fermions.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Majorana&lt;/a&gt; sphere isn't so &lt;em&gt;different&lt;/em&gt;, it's still a sphere, but perhaps it's less confusing:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For qubits on a Majorana sphere see: &quot;&lt;a href=&quot;https://arxiv.org/abs/0910.0630&quot; rel=&quot;nofollow noreferrer&quot;&gt;N-qubit states as points on the Bloch sphere&lt;/a&gt;&quot;.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;Abstract. We show how the Majorana representation can be used to express the pure states of an N-qubit system ... In conclusion, the Majorana representation is useful when spin-$S$ particles are studied, while the alternative representation is preferable when the states of an $N$-qubit system are discussed. Besides helping to visualize $N$-qubit states and the way they transform in rotations and other operations, the latter representation may also help to identify some special $N$-qubit states, like the Majorana representation did in the context of spinor Bose-Einstein condensates.&quot;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;See: &quot;&lt;a href=&quot;https://arxiv.org/abs/1703.06102&quot; rel=&quot;nofollow noreferrer&quot;&gt;Majorana representation, qutrit Hilbert space and NMR implementation of qutrit gates&lt;/a&gt;&quot;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Page 1:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;The Bloch sphere provides a representation of the quantum states of a single qubit onto $\mathcal S^2$ (a unit sphere in three real dimensions), with pure states mapped onto the surface and the mixed states lying in the interior. This geometrical representation is useful in providing a visualization of quantum states and their transformations, particularly in the case of NMR-based quantum computation, where the spin-&lt;s&gt;&lt;s&gt;$\frac{1}{2}$&lt;/s&gt;&lt;/s&gt; magnetization and its transformation through NMR rf pulses is visualized on the Bloch sphere. There have been several proposals for the geometrical representation for higher-level quantum systems however, extensions of a Bloch sphere-like picture to higher spins is not straightforward. A geometrical representation was proposed by Majorana in which, a pure state of a spin ‘$s$’ is represented by ‘2$_s$’ points on the surface of a unit sphere, called the Majorana sphere.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;The Majorana representation for spin−$s$ systems has found widespread applications such as determining geometric phase of spins, representing $N$ spinors by $N$ points, geometrical representation of multi-qubit entangled states, statistics of chaotic quantum dynamical systems and characterizing polarized light. A single qutrit (three-level quantum system) is of particular importance in qudit-based ($d$-level quantum system) quantum computing schemes. &lt;strong&gt;A qutrit is the smallest system that exhibits inherent quantum features such as contextuality, which has been conjectured to be a resource for quantum computing&lt;/strong&gt;. NMR qudit quantum computing can be performed by using nuclei with spin s &gt; &lt;s&gt;&lt;s&gt;$\frac{1}{2}$&lt;/s&gt;&lt;/s&gt; or can be modeled by two or more coupled spin-&lt;s&gt;&lt;s&gt;$\frac{1}{2}$&lt;/s&gt;&lt;/s&gt; nuclei. In this work we use the Majorana sphere description of a single qutrit, where states of a qutrit are represented by a pair of points on a unit sphere, to provide insights into the qutrit state space. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Page 5:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;The magnitude of the magnetization vector $\vert-$&lt;s&gt;&lt;s&gt;$\vec{M}$&lt;/s&gt;&lt;/s&gt;$\vert$ in a pure ensemble of a single qutrit can assume values in the range $[0,1]$. On the contrary, the pure ensemble of a qubit always possesses &lt;a href=&quot;https://www.mathsisfun.com/algebra/vector-unit.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;unit magnitude&lt;/a&gt; of the magnetization vector associated with it&lt;/strong&gt;. The geometrical picture of the single qutrit magnetization vector is provided by the Majorana representation. The value $\vert-$&lt;s&gt;&lt;s&gt;$\vec{M}$&lt;/s&gt;&lt;/s&gt;$\vert$ depends upon the length of the bisector $OO'$ and lies along the $z$-axis and is rotationally invariant. Thus corresponding to a given value of the length of the bisector, one can assume concentric spheres with continuously varying radii, whose surfaces are the surfaces of constant magnetization. The radii of these spheres are equal to $\vert-$&lt;s&gt;&lt;s&gt;$\vec{M}$&lt;/s&gt;&lt;/s&gt;$\vert$, that vary in the range $[0,1]$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Page 10:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;CONCLUDING REMARKS&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;A geometrical representation of a qutrit is described in this work, wherein qutrit states are represented by two points on a unit sphere as per the Majorana representation. A parameterization of single-qutrit states was obtained to generate arbitrary states from a one-parameter family of canonical states via the action of $SO(3)$ transformations. The spin-$1$ magnetization vector was represented on the Majorana sphere and states were identified as ‘pointing’ or ‘non-pointing’ depending on the zero or non-zero value of the spin magnetization. The transformations generated by the action of $SU(3)$ generators were also integrated into the Majorana geometrical picture. Unlike qubits, the decomposition of single-qutrit quantum gates in terms of radio-frequency pulses is not straightforward and the Majorana sphere representation provides a way to geometrically describe these gates. Close observations of the dynamics of points representing a qutrit on the Majorana sphere under the action of various quantum gates were used to obtain the rf pulse decompositions and basic single-qutrit gates were experimentally implemented using NMR.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/5a7HX.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/5a7HX.jpg&quot; alt=&quot;Majorana Sphere - Dogra, Dorai, and Arvind&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;FIG. 1. A qutrit on the Majorana sphere is represented by two points $P_1$ and $P_2$, connected with the center of the sphere by lines shown in red and blue respectively. $\theta_1$, $\phi_1$ are the polar and azimuthal angles corresponding to point $P_1$ ($\theta_2$, $\phi_2$ are the angles for point $P_2$). (a) Roots of the Majorana polynomial are shown in the plane $z = 0$ by points $P'_1$ and $P'_2$, whose stereographic projection give rise to the Majorana representation. Three examples are shown corresponding to the Majorana representation of single-qutrit basis vectors $(b)\;\vert+1\rangle$, $(c)\;\vert0\rangle$ and $(d)\;\vert-1\rangle$. One of the points is shown as a solid (red) circle, while the other point is represented by an empty (blue) circle.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;See: &quot;&lt;a href=&quot;http://www.reed.edu/physics/faculty/wheeler/documents/Quantum%20Mechanics/Miscellaneous%20Essays/Angular%20Momentum,%20Spin/D2.%20Majorana.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Majorana Representation of Higher Spin States&lt;/a&gt;&quot; (.PDF) by &lt;a href=&quot;http://www.reed.edu/physics/faculty/wheeler/documents/index.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wheeler&lt;/a&gt; (Website) or &quot;&lt;a href=&quot;https://arxiv.org/abs/1707.08465&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wigner tomography of multispin quantum states&lt;/a&gt;&quot;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;What does it look like using Tomography - &quot;In this paper, we theoretically develop a tomography scheme for spherical functions of arbitrary multispin quantum states. We study experimental schemes to reconstruct the generalized Wigner representation of a given density operator (representing mixed or pure quantum states).&quot;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Compare that to the complexity of the Bloch sphere depicted in: &quot;&lt;a href=&quot;https://www.researchgate.net/publication/255994952_Bloch-sphere_representation_of_three-vertex_geometric_phases&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bloch-sphere representation of three-vertex geometric phases&lt;/a&gt;&quot;. The shape is the same it's all how you visualize the projection used.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here's a less busy image:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/uZkH3.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/uZkH3.jpg&quot; alt=&quot;Bloch sphere&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Think of the Bloch sphere cut in half by a very large sheet of paper. At the edge of the paper (infinity) any point on the top of the sheet draws a line to (infinity) the top of the ball (the bottom of the ball for the underside of the sheet). Points nearest the center of the paper (mixed states) draw lines to the center of the sphere. That represents the distance up to infinity on a tiny ball, a qubit/qudit is finite so the &lt;em&gt;paper&lt;/em&gt; is not so big.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now draw points on the 2D paper, draw lines from the paper to the ball, remove the paper, and look at or through the clear ball to see the other endpoint of the line.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A much more accurate and difficult explanation is offered in the links above.&lt;/p&gt;&#xA;" OwnerUserId="278" LastEditorUserId="278" LastEditDate="2018-04-09T14:12:12.490" LastActivityDate="2018-04-09T14:12:12.490" CommentCount="2" />
  <row Id="1642" PostTypeId="1" AcceptedAnswerId="1683" CreationDate="2018-04-08T20:53:56.737" Score="5" ViewCount="160" Body="&lt;p&gt;&lt;strong&gt;Chemistry background&lt;/strong&gt;: In magnetic molecules, it is sometimes the case that one can adjust the time-independent Hamiltonian by chemical design. This means there is freedom to adjust parameters in the time-independent Hamiltonian during the design phase, but when the device is prepared these parameters cannot be adjusted further. An example would be molecules containing magnetic ions with a well-defined spin anisotropy and which communicate with each other via dipolar interactions: if it is chemically possible to position the spins in 3D space and to orient their magnetization axes, one has a certain control over the final form of the time-independent Hamiltonian. (For a state-of-the-art example, see &lt;a href=&quot;https://www.nature.com/articles/ncomms11377&quot; rel=&quot;nofollow noreferrer&quot;&gt;A modular design of molecular qubits to implement universal quantum gates&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Operational problem&lt;/strong&gt;: In a given experimental setup aiming to implement quantum computing, there will be a collection of physical operations (described by a time-dependent Hamiltonian) which in principle allow for arbitrary quantum logical operations.  In practice, the number of physical operations needed to implement a certain quantum algorithm (or even an elementary logical quantum gate) also depends on the details of the time-independent Hamiltonian. (See for example &lt;a href=&quot;https://arxiv.org/pdf/cond-mat/0703501.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Spin qubits with electrically gated polyoxometalate molecules&lt;/a&gt;, where sqrt(SWAP) is spontaneously &quot;implemented&quot; by a simple waiting time).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Goal + question&lt;/strong&gt;: Whenever one aims for a certain quantum logical manipulation (such as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_Fourier_transform&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Fourier Transform&lt;/a&gt;), it seems obvious that there will be some time-independent Hamiltonians that will require a smaller number of physical operations than others. Our goal would be to find design criteria; &lt;strong&gt;to find the parameters that we can adjust by chemical design that makes the number of operations small&lt;/strong&gt;, not in a particular case but &lt;strong&gt;for a typical collection of quantum transformations&lt;/strong&gt;. In the form of a question: is there a reasonable set of quantum logical operations that could be used in this context to benchmark the typical efficiency of time-dependent spin Hamiltonians?&lt;/p&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="1847" LastEditDate="2018-04-11T09:19:29.377" LastActivityDate="2018-04-23T11:26:58.473" Title="What set of quantum logical operations can one use to benchmark spin Hamiltonians?" Tags="&lt;quantum-algorithms&gt;&lt;architecture&gt;&lt;quantum-gate&gt;" AnswerCount="1" CommentCount="1" />
  <row Id="1643" PostTypeId="2" ParentId="1339" CreationDate="2018-04-08T21:12:58.903" Score="1" Body="&lt;p&gt;The first paper you mention, by Tejada et al, does not actually refer to conventional nanoparticles as such, but rather to single molecule magnets. This other paper by Loss, &lt;a href=&quot;https://www.nature.com/articles/35071024&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum computing in molecular magnets&lt;/a&gt;, is about the same systems but perhaps more clear in quantum computing terms, since it gives more details on the underlying Hamiltonian and gives a suggestion for a quantum algorithm. Magnetic molecules do present decoherence (see for example &lt;a href=&quot;https://www.nature.com/articles/nature10314&quot; rel=&quot;nofollow noreferrer&quot;&gt;Decoherence in crystals of quantum molecular magnets&lt;/a&gt;), but their mechanisms are different from those of magnetic nanoparticles, at least in the details, meaning Barkhausen noise is not be a sufficient description for those. In any case, you may want to check the supporting information of this latter reference by Stamp et al, since it includes methodological details on how to estimate the different decoherent sources.&lt;/p&gt;&#xA;" OwnerUserId="1847" LastActivityDate="2018-04-08T21:12:58.903" CommentCount="2" />
  <row Id="1644" PostTypeId="2" ParentId="1635" CreationDate="2018-04-08T22:03:45.990" Score="0" Body="&lt;p&gt;Chancellor proposes how to do sampling around specific states with quantum annealing. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1606.06800&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/1606.06800&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="54" LastActivityDate="2018-04-08T22:03:45.990" CommentCount="0" />
  <row Id="1646" PostTypeId="2" ParentId="1549" CreationDate="2018-04-09T05:31:21.510" Score="2" Body="&lt;p&gt;Your question revolves implicitly around the concept of &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_decoherence&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum decoherence&lt;/a&gt; and how to protect real-world implementations of qubits from it for a long time.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is an incredibly general problem, and at the same time, the details are wildly dependent on the technology used. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you have access to it, you can check chapter 5 : &quot;Noise and decoherence&quot; of &lt;a href=&quot;http://www.langtoninfo.com/web_content/9780521113694_frontmatter.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Theory and Design of Quantum Coherent Structures&lt;/a&gt;. Also, for illustration on the current state-of-the-art of different approaches, you can check this Europen project on &lt;a href=&quot;https://cordis.europa.eu/result/rcn/199908_en.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Engineering electronic quantum coherence and correlations in hybrid nanostructures&lt;/a&gt;, or this other European project (&lt;em&gt;disclaimer: this is my own approach&lt;/em&gt;) on &lt;a href=&quot;https://www.uv.es/gaita/pdf/ERC_CoG_2014_B2_20-05.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;A Chemical Approach to Molecular Spin Qubits&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Since the problem of storage of quantum information is vital, some general strategies have been developed. In a nutshell: &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_error_correction&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Error Correction&lt;/a&gt; (also, for a slightly outdated pedagogical review see &lt;a href=&quot;https://arxiv.org/abs/0905.2794&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Error Correction for Beginners&lt;/a&gt;) which is a huge field by itself and which is based precisely on admitting the failure in building a sufficient protection to qubits and therefore the necessity for an active intervention to protect quantum information from degrading. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Different approaches to hybrid quantum devices exist, where the information is processed in qubits that interact strongly and quickly with each other and our external stimuli (and also with noise sources) and subsequently stored in qubits that interact very weakly and slowly with every stimulus (desirable or not). Again, this family of approaches is too much dependent on the technological details to make general statements.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="58" LastEditDate="2018-04-11T07:11:40.420" LastActivityDate="2018-04-11T07:11:40.420" CommentCount="0" />
  <row Id="1647" PostTypeId="2" ParentId="1634" CreationDate="2018-04-09T06:50:56.757" Score="1" Body="&lt;p&gt;Let's assume that your black box processes classical inputs (i.e. a bit string) to classical outputs in a deterministic way, i.e. it defines a function $f:x\mapsto y$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you can only prepare and measure separable states in that basis, all you can determine is what that function $f$ is. Assuming that all the outputs are different, it could have been computed either by a reversible classical computation or a quantum computation, and you wouldn't be able to tell.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, let's assume you can prepare product states and measure in two different bases, $X$ and $Z$ for the sake of argument. One thing that you could do (which may be hopelessly inefficient for all I know, but it's somewhere to start) is first determine the function $f(x)$ using the $Z$ basis. Then, for any pair of bit string $x_1$ and $x_2$ that differ in only one position, prepare the state $(\left|x_1\right\rangle\pm\left|x_2\right\rangle)/\sqrt{2}$. This is a product state, using the $Z$ basis on all but one site. Let's assume that the outputs $y_1=f(x_1)$ and $y_2f(x_2)$ differ on $k&amp;gt;0$ sites. (If $k=0$, the evolution wasn't coherent anyway.) For the bits where $y_1$ and $y_2$ are supposed to be equal, just measure them in the $Z$ basis to make sure you get what you expect to get. On the remaining $k$ sites, if the black box is coherent, you receive a GHZ state of $k$ qubits,&#xA;$$&#xA;\frac{1}{\sqrt{2}}(\left|y_1\right\rangle\pm\left|y_2\right\rangle).&#xA;$$&#xA;If it were completely incoherent, you'd get a rank two mixed state&#xA;$$&#xA;\frac{1}{2}\left(\left|y_1\right\rangle\left\langle y_1\right|+\left|y_2\right\rangle\left\langle y_2\right|\right).&#xA;$$&#xA;If $k=1$, you can distinguish these directly by measuring that qubit in the $X$ basis (repeating a few times to get statistics). For $k&amp;gt;1$ you have a few options. Either you can peform a Bell test ($k=2$) or equivalent for GHZ states (such as all versus nothing proofs), or apply an entanglement witness (there are some based on single-qubit observables). Alternatively, measure every qubit in the $X$ basis and record the outcomes. In the case of the entangled state, the last outcome should be entirely predictable based on the previous outcomes. For the mixed state, the answer will be completely unpredictable. If you want to make a more quantitative statement, you could use something like an entropy, $H(X|Y)$ where $X$ is the random variable describing the output of the last measurement, and $Y$ is the random variable describing the outcome of all the previous measurements.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One possible issue is that by testing only inputs with a single site prepared in the $X$ basis, there are a lot of options you're not testing, so I don't know whether testing all of these coherences is enough, or whether one ought to start analysing what happens if you prepare pairs of sites in the $X$ basis, and so on. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Of course, while this tells you something about how coherent the implementation of the black box is, whether or not that coherence contributes to the speed of operation of the black box is a completely different matter (for example, that's the sort of thing people want to know about with transport processes in photosynthetic bacteria, or even something like D-Wave).&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-04-09T06:50:56.757" CommentCount="0" />
  <row Id="1648" PostTypeId="1" CreationDate="2018-04-09T07:15:14.043" Score="13" ViewCount="324" Body="&lt;p&gt;Now that we know of bio/molecular tools that allow living organisms to deal with quantum computations e.g. the fancy proteins that allow birds to handle quantum coherence (e.g. &lt;a href=&quot;http://www.pnas.org/content/early/2016/03/30/1600341113&quot; rel=&quot;noreferrer&quot;&gt;The quantum needle of the avian magnetic compass&lt;/a&gt; or &lt;a href=&quot;http://www.cell.com/current-biology/fulltext/S0960-9822(17)31605-6&quot; rel=&quot;noreferrer&quot;&gt;Double-Cone Localization and Seasonal Expression Pattern Suggest a Role in Magnetoreception for European Robin Cryptochrome 4&lt;/a&gt;) I wonder:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Are these tools already solving problems you (quantum computing researchers) have?&lt;/li&gt;&#xA;&lt;li&gt;Is there any specific issue these tools 'must' be solving somehow that you are struggling with at your labs?&lt;/li&gt;&#xA;&lt;li&gt;Could we use them (although this will imply a paradigm shift towards biotechnology)?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="1894" LastEditorUserId="1847" LastEditDate="2018-04-22T16:59:45.310" LastActivityDate="2018-05-28T13:39:58.597" Title="Is Quantum Biocomputing ahead of us?" Tags="&lt;architecture&gt;&lt;solid-state&gt;&lt;biocomputing&gt;" AnswerCount="3" CommentCount="1" FavoriteCount="5" />
  <row Id="1650" PostTypeId="5" CreationDate="2018-04-09T15:50:10.437" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-09T15:50:10.437" LastActivityDate="2018-04-09T15:50:10.437" CommentCount="0" />
  <row Id="1651" PostTypeId="4" CreationDate="2018-04-09T15:50:10.437" Score="0" Body="for questions regarding the superposition of qubits and how superposition is relevant for quantum computers" OwnerUserId="11" LastEditorUserId="11" LastEditDate="2018-04-10T20:27:25.990" LastActivityDate="2018-04-10T20:27:25.990" CommentCount="0" />
  <row Id="1652" PostTypeId="5" CreationDate="2018-04-09T15:53:55.137" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-09T15:53:55.137" LastActivityDate="2018-04-09T15:53:55.137" CommentCount="0" />
  <row Id="1653" PostTypeId="4" CreationDate="2018-04-09T15:53:55.137" Score="0" Body="For questions concerning how to improve quantum computers on different aspects like performance, efficiency or fault-tolerance" OwnerUserId="11" LastEditorUserId="26" LastEditDate="2018-04-15T15:05:13.033" LastActivityDate="2018-04-15T15:05:13.033" CommentCount="0" />
  <row Id="1654" PostTypeId="1" AcceptedAnswerId="1656" CreationDate="2018-04-09T18:37:41.830" Score="16" ViewCount="619" Body="&lt;p&gt;This can be seen as the software complement to &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1289/how-does-a-quantum-computer-do-basic-math-at-the-hardware-level&quot;&gt;How does a quantum computer do basic math at the hardware level?&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The question was asked by a member of the audience at the &lt;a href=&quot;http://benasque.org/2017ice4/&quot; rel=&quot;noreferrer&quot;&gt;4th network of the Spanish Network on Quantum Information and Quantum Technologies&lt;/a&gt;. The context the person gave was: &quot;&lt;em&gt;I'm a materials scientist. You are introducing advanced sophisticated theoretical concepts, but I have trouble picturing the practical operation of a quantum computer for a simple task. If I was using diodes, transistors etc I could easily figure out myself the classical operations I need to run to add 1+1. How would you do that, in detail, on a quantum computer?&lt;/em&gt; &quot;.&lt;/p&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="58" LastEditDate="2018-04-11T08:32:53.843" LastActivityDate="2018-04-14T20:16:39.237" Title="How do I add 1+1 using a quantum computer?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-gate&gt;&lt;circuit-model&gt;" AnswerCount="3" CommentCount="0" FavoriteCount="5" />
  <row Id="1655" PostTypeId="2" ParentId="1654" CreationDate="2018-04-09T20:16:37.313" Score="3" Body="&lt;p&gt;A new method for computing sums on a quantum computer is introduced. This technique uses the quantum Fourier transform and reduces the number of qubits necessary for addition by removing the need for temporary carry bits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;http://cds.cern.ch/record/450434/files/0008033.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;PDF link for 'addition on a quantum computer'&lt;/a&gt;, written by Thomas G. Draper, written September 1, 1998, revised: June 15, 2000.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To summarize the above link, addition is performed according to the following circuit diagram (taken from page 6):&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/H0S8T.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/H0S8T.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To quote the paper (again, page 6):&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The quantum addition is performed using a sequence of conditional rotations&#xA;  which are mutually commutative. The structure is very similar to the quantum&#xA;  Fourier transform, but the rotations are conditioned on $n$ external bits.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="1875" LastEditorUserId="91" LastEditDate="2018-04-14T20:16:39.237" LastActivityDate="2018-04-14T20:16:39.237" CommentCount="0" />
  <row Id="1656" PostTypeId="2" ParentId="1654" CreationDate="2018-04-09T20:34:30.567" Score="11" Body="&lt;p&gt;As per the linked question, the simplest solution is just to &lt;strong&gt;get the classical processor to perform such operations if possible&lt;/strong&gt;. Of course, that may not be possible, so we want to create an &lt;em&gt;adder&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are two types of single bit adder - the &lt;em&gt;half-adder&lt;/em&gt; and the &lt;em&gt;full adder&lt;/em&gt;. The half-adder takes the inputs $A$ and $B$ and outputs the 'sum' (XOR operation) $S = A\oplus B$ and the 'carry' (AND operation) $C = A\cdot B$. A full adder also has the 'carry in' $C_{in}$ input and the 'carry out' output $C_{out}$, replacing $C$. This returns $S=A\oplus B\oplus C_{in}$ and $C_{out} = C_{in}\cdot\left(A+B\right) + A\cdot B$.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Quantum version of the half-adder&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Looking at the CNOT gate on qubit register $A$ controlling register $B$: \begin{align*}\text{CNOT}_{A\rightarrow B}\left|0\right&amp;gt;_A\left|0\right&amp;gt;_B &amp;amp;= \left|0\right&amp;gt;_A\left|0\right&amp;gt;_B \\ \text{CNOT}_{A\rightarrow B}\left|0\right&amp;gt;_A\left|1\right&amp;gt;_B &amp;amp;= \left|0\right&amp;gt;_A\left|1\right&amp;gt;_B \\\text{CNOT}_{A\rightarrow B}\left|1\right&amp;gt;_A\left|0\right&amp;gt;_B &amp;amp;= \left|1\right&amp;gt;_A\left|1\right&amp;gt;_B \\\text{CNOT}_{A\rightarrow B}\left|1\right&amp;gt;_A\left|1\right&amp;gt;_B &amp;amp;= \left|1\right&amp;gt;_A\left|0\right&amp;gt;_B, \\&#xA;\end{align*} which immediately gives the output of the $B$ register as $A\oplus B = S$. However, we have yet to compute the carry and the state of the $B$ register has changed so we also need to perform the AND operation. This can be done using the 3-qubit Toffoli (controlled-CNOT/CCNOT) gate. This can be done using registers $A$ and $B$ as control registers and initialising the third register $\left(C\right)$ in state $\left|0\right&amp;gt;$, giving the output of the third register as $A\cdot B = C$. Implementing Toffoli on registers $A$ and $B$ controlling register $C$ followed by CNOT with $A$ controlling $B$ gives the output of register $B$ as the sum and the output of register $C$ as the carry. A quantum circuit diagram of the half-adder is shown in figure 1.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/p1TU8.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/p1TU8.png&quot; alt=&quot;Circuit diagram of a half-adder&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Figure 1: Circuit Diagram of a half-adder, consisting of Toffoli followed by CNOT. Input bits are $A$ and $B$, giving the sum $S$ with carry out $C$.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Quantum version of the full adder&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Shown in figure 2, a simple way of doing this for single bits is by using $4$ qubit registers, here labelled $A$, $B$, $C_{in}$ and $1$, where $1$ starts in state $\left|0\right&amp;gt;$, so the initial state is $\left|A\right&amp;gt;\left|B\right&amp;gt;\left|C_{in}\right&amp;gt;\left|0\right&amp;gt;$:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Apply Toffoli using $A$ and $B$ to control $1$: $\left|A\right&amp;gt;\left|B\right&amp;gt;\left|C_{in}\right&amp;gt;\left|A\cdot B\right&amp;gt;$&lt;/li&gt;&#xA;&lt;li&gt;CNOT with $A$ controlling $B$: $\left|A\right&amp;gt;\left|A\oplus B\right&amp;gt;\left|C_{in}\right&amp;gt;\left|A\cdot B\right&amp;gt;$&lt;/li&gt;&#xA;&lt;li&gt;Toffoli with $B$ and $C_{in}$ controlling $1$: $\left|A\right&amp;gt;\left|A\oplus B\right&amp;gt;\left|C_{in}\right&amp;gt;\left|A\cdot B\oplus\left(A\oplus B\right)\cdot C_{in} = C_{out}\right&amp;gt;$&lt;/li&gt;&#xA;&lt;li&gt;CNOT with $B$ controlling $C_{in}$: $\left|A\right&amp;gt;\left|A\oplus B\right&amp;gt;\left|A\oplus B\oplus C_{in} = S\right&amp;gt;\left|C_{out}\right&amp;gt;$&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;A final step to get back the inputs $A$ and $B$ is to apply a CNOT with register $A$ controlling register $B$, giving the final output state as $$\left|\psi_{out}\right&amp;gt; = \left|A\right&amp;gt;\left|B\right&amp;gt;\left|S\right&amp;gt;\left|C_{out}\right&amp;gt;$$ &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This gives the output of register $C_{in}$ as the sum and the output of register $2$ as carry out.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/zHwlR.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/zHwlR.png&quot; alt=&quot;Quantum version of the full adder&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Figure 2: Circuit diagram of a full adder. Input bits are $A$ and $B$ along with a carry in $C_{in}$, giving the sum $S$ with carry out $C_{out}$.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Quantum version of the ripple carry adder&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;A simple extension of the full adder is a ripple carry adder, named as it 'ripples' the carry out to become the carry in of the next adder in a series of adders, allowing for arbitrarily-sized (if slow) sums. A quantum version of such an adder can be found e.g. &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0410184v1&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Actual implementation of a half-adder&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;For many systems, implementing a Toffoli gate is far from as simple as implementing a single qubit (or even two qubit) gate. &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1661/23&quot;&gt;This answer&lt;/a&gt; gives a way of decomposing Toffoli into multiple smaller gates. However, in real systems, such as &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx&quot; rel=&quot;nofollow noreferrer&quot;&gt;IBMQX&lt;/a&gt;, there can also be issues on which qubits can be used as targets. As such, a real life implementation on &lt;a href=&quot;https://github.com/QISKit/ibmqx-backend-information/blob/master/backends/ibmqx2/README.md&quot; rel=&quot;nofollow noreferrer&quot;&gt;IBMQX2&lt;/a&gt; looks like this:&#xA;&lt;a href=&quot;https://i.stack.imgur.com/6Dekg.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/6Dekg.png&quot; alt=&quot;Single qubit half-adder on IBMQX2&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Figure 3: Implementation of a half-adder on IBMQX2. In addition to decomposing the Toffoli gate into multiple smaller gates, additional gates are required as not all qubit registers can be used as targets. Registers q[0] and q[1] are added to get the sum in q[1] and the carry in q[2]. In this case, the result q[2]q[1] should be 10. Running this on the processor gave the correct result with a probability of 42.8% (although it was still the most likely outcome).&lt;/p&gt;&#xA;" OwnerUserId="23" LastEditorUserId="23" LastEditDate="2018-04-14T14:37:33.730" LastActivityDate="2018-04-14T14:37:33.730" CommentCount="5" />
  <row Id="1657" PostTypeId="1" AcceptedAnswerId="1659" CreationDate="2018-04-10T00:46:03.353" Score="13" ViewCount="1588" Body="&lt;p&gt;The term &quot;&lt;em&gt;&lt;a href=&quot;https://www.quantiki.org/wiki/church-larger-hilbert-space&quot; rel=&quot;noreferrer&quot;&gt;Church of the Higher Hilbert Space&lt;/a&gt;&lt;/em&gt;&quot; is used in quantum information frequently when analysing quantum channels and quantum states.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What does this term mean (or, alternately, what does the term &quot;Going to To the Church of the Higher Hilbert Space&quot; mean)?&lt;/p&gt;&#xA;" OwnerUserId="429" LastEditorUserId="23" LastEditDate="2018-04-11T08:03:30.013" LastActivityDate="2018-04-12T00:10:53.753" Title="Significance of The Church of the Higher Hilbert space" Tags="&lt;quantum-state&gt;&lt;quantum-channel&gt;&lt;terminology&gt;" AnswerCount="2" CommentCount="1" />
  <row Id="1658" PostTypeId="2" ParentId="1657" CreationDate="2018-04-10T01:35:45.070" Score="5" Body="&lt;p&gt;&quot;Church of the higher hilbert space&quot; is a term coined by John Smolin. According to &lt;a href=&quot;https://www.quantiki.org/wiki/church-larger-hilbert-space&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantiki&lt;/a&gt; it is:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;for the dilation constructions of channels and states, which [...] provide a neat characterization of the set of permissible quantum operations&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;and to quote &lt;a href=&quot;https://en.wikipedia.org/wiki/John_A._Smolin&quot; rel=&quot;nofollow noreferrer&quot;&gt;wikipedia&lt;/a&gt;, it:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;describe[s] the habit of regarding every mixed state of a quantum system as a pure entangled state of a larger system, and every irreversible evolution as a reversible (unitary) evolution of a larger system.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;See also &lt;a href=&quot;https://physics.stackexchange.com/questions/35648/if-i-go-to-the-church-of-the-greater-hilbert-space-can-i-have-unitary-collapse?utm_medium=organic&amp;amp;utm_source=google_rich_qa&amp;amp;utm_campaign=google_rich_qa&quot;&gt;this Physics.SE answer&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="91" LastEditorUserId="91" LastEditDate="2018-04-12T00:10:53.753" LastActivityDate="2018-04-12T00:10:53.753" CommentCount="1" />
  <row Id="1659" PostTypeId="2" ParentId="1657" CreationDate="2018-04-10T06:02:30.410" Score="18" Body="&lt;p&gt;The church of the larger (or higher, or greater) Hilbert space is just a trick that some people like (myself included) for rewriting some operations.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The most general operations that you can write down for a system are described by completely positive maps, while we like describing things with unitaries, which you can always do by moving from the original Hilbert space to a larger one (i.e. adding more qubits). Similarly, for measurements, you can turn general measurements into projective measurements by increasing the size of the Hilbert space. Also, mixed states can be described as pure states of a larger system.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Example&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Consider the map that takes a qubit and with probability $1-p$ does nothing, and with probability, $p$ applies the bit-flip operation $X$:&#xA;$$&#xA;|\psi\rangle\langle\psi|\mapsto (1-p)|\psi\rangle\langle\psi|+pX|\psi\rangle\langle\psi|X&#xA;$$&#xA;This is not unitary, but you can describe it as a unitary on two qubits (i.e. by moving from a Hilbert space dimension 2 to Hilbert space dimension 4). This works by introducing an extra qubit in the state $\sqrt{1-p}|0\rangle+\sqrt{p}|1\rangle$ and performing a controlled-not controlled by the new qubit and targeting the original one.&#xA;$$&#xA;|\psi\rangle(\sqrt{1-p}|0\rangle+\sqrt{p}|1\rangle)\mapsto|\Psi\rangle=\sqrt{1-p}|\psi\rangle|0\rangle+\sqrt{p}\left(X|\psi\rangle\right)|1\rangle.&#xA;$$&#xA;To get back the action of the system on just the original qubit, you trace out the new qubit:&#xA;$$&#xA;\rho={\rm Tr}_2\left(|\Psi\rangle\langle\Psi|\right)= (1-p)|\psi\rangle\langle\psi|+pX|\psi\rangle\langle\psi|X.&#xA;$$&#xA;In other words, you just ignore the existence of the new qubit after you’ve implemented the unitary! Note that as well as demonstrating the church of the larger Hilbert space for operations, this also demonstrates it for states - the mixed state $\rho$ can be made into the pure state $|\Psi\rangle$ by increasing the size of the Hilbert space.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-04-11T07:24:43.767" LastActivityDate="2018-04-11T07:24:43.767" CommentCount="0" />
  <row Id="1660" PostTypeId="1" CreationDate="2018-04-10T13:33:34.807" Score="4" ViewCount="120" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;em&gt;&quot;Quantum magic won't be enough&quot;&lt;/em&gt; (Bennett et al. 1997)&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;If you throw away the problem structure, and just consider the space of $2^n$ possible solutions, then even a quantum computer needs about $\sqrt{2^n}$ steps to find the correct one (using Grover's algorithm)&#xA;  If a quantum polynomial time algorithm for an $\text{NP}$-complete problem is ever found, it &lt;b&gt;must&lt;/b&gt; exploit the problem structure in some way.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;(...)&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;I've some (basic) questions that no one seems to have asked so far on this site (maybe because they are basic). Suppose someone finds a bounded error quantum polynomial time algorithm for $\text{SAT}$ (or any other $\text{NP}$-complete problem), thus placing $\text{SAT}$ in $\text{BQP}$, and implying $\text{NP} \subseteq \text{BQP}$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Questions&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Which would be the theoretical consequences of such a discovery? How would the overall picture of complexity classes be affected? Which classes would become equal to which others?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sub&gt;&lt;a href=&quot;https://cstheory.stackexchange.com/questions/6154/consequences-of-sat-in-bqp&quot;&gt;Source&lt;/a&gt;&lt;/sub&gt;&lt;/p&gt;&#xA;" OwnerUserId="58" LastEditorUserId="1847" LastEditDate="2018-04-27T16:50:58.827" LastActivityDate="2018-04-27T16:50:58.827" Title="Consequences of SAT ∈ BQP" Tags="&lt;quantum-algorithms&gt;&lt;complexity-theory&gt;&lt;bqp&gt;" AnswerCount="0" CommentCount="4" />
  <row Id="1661" PostTypeId="2" ParentId="1654" CreationDate="2018-04-10T13:36:03.373" Score="5" Body="&lt;p&gt;``&lt;em&gt;If I was using diodes, transistors etc I could easily figure out myself the classical operations I need to run to add 1+1. How would you do that, in detail, on a quantum computer?&lt;/em&gt;''&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Impressive! I suspect that most people cannot easily figure out themselves how to combine diodes and transistors to implement a classical two-bit adde (though I do not doubt this material scientist can probably do it). ;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Theoretically, the way you implement a classical adder is pretty similar in a classical and quantum computer: you can do that in both cases by implementing a &lt;a href=&quot;https://en.wikipedia.org/wiki/Toffoli_gate&quot; rel=&quot;noreferrer&quot;&gt;Toffoli gate&lt;/a&gt;! (See @Mithrandir24601's answer.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But the material scientist probably wants to understand how to implement such an gate (or an equivalence sequence of other quantum gates) on a physical device. There are probably an infinite ways to do that using different quantum technologies, but here are two direct realizations of this gate using trapped ions and superconducting qubits:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Realization of the Quantum Toffoli Gate with Trapped Ions, T. Monz, K. Kim, W. Hänsel, M. Riebe, A. S. Villar, P. Schindler, M. Chwalla, M. Hennrich, and R. Blatt, &lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.102.040501&quot; rel=&quot;noreferrer&quot;&gt;Phys. Rev. Lett. 102&lt;/a&gt;, 040501, &lt;a href=&quot;https://arxiv.org/abs/0804.0082&quot; rel=&quot;noreferrer&quot;&gt;arXiv:0804.0082&lt;/a&gt;.&lt;/li&gt;&#xA;&lt;li&gt;Implementation of a Toffoli gate with superconducting circuits&#xA;A. Fedorov, L. Steffen, M. Baur, M. P. da Silva &amp;amp; A. Wallraff&#xA;&lt;a href=&quot;https://www.nature.com/articles/nature10713&quot; rel=&quot;noreferrer&quot;&gt;Nature 481&lt;/a&gt;, 170–172, &lt;a href=&quot;https://arxiv.org/abs/1108.3966&quot; rel=&quot;noreferrer&quot;&gt;arXiv:1108.3966&lt;/a&gt;.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;You can also decompose the Toffoli gate as a sequence of single-qubit and CNOT gates. &#xA;&lt;a href=&quot;https://media.nature.com/lw926/nature-assets/srep/2016/160802/srep30600/images/srep30600-f5.jpg&quot; rel=&quot;noreferrer&quot;&gt;https://media.nature.com/lw926/nature-assets/srep/2016/160802/srep30600/images/srep30600-f5.jpg&lt;/a&gt;&lt;a href=&quot;https://i.stack.imgur.com/6FIMq.jpg&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/6FIMq.jpg&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&#xA;You can read about how to implement these with photonics, cavity-QED and trapped ions in &lt;a href=&quot;http://www.michaelnielsen.org/qcqi/&quot; rel=&quot;noreferrer&quot;&gt;Nielsen and Chuang&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1779" LastActivityDate="2018-04-10T13:36:03.373" CommentCount="2" />
  <row Id="1663" PostTypeId="1" AcceptedAnswerId="1668" CreationDate="2018-04-10T16:16:02.317" Score="3" ViewCount="159" Body="&lt;h2&gt;Context&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Lately, I have been reading a scholarly paper entitled &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9809016&quot; rel=&quot;nofollow noreferrer&quot;&gt;An Introduction to Quantum Computing for Non-Physicists&lt;/a&gt; which discusses the &lt;a href=&quot;https://en.wikipedia.org/wiki/EPR_paradox&quot; rel=&quot;nofollow noreferrer&quot;&gt;EPR Paradox&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9809016&quot; rel=&quot;nofollow noreferrer&quot;&gt;paper&lt;/a&gt; states that:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Einstein, Podolsky and Rosen proposed a gedanken experiment that uses entangled particles in a manner that seemed to violate fundamental principles of relativity.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;It concludes that the paradox is resolved as the symmetry shown by changing observers indicates that they cannot use their EPR pair to communicate faster than the speed of light. However, the paper fails to adequately explain what an EPR pair is used for and does not even define the term. The best definition I could find is referenced to in the Wikipedia article, &lt;a href=&quot;https://en.wikipedia.org/wiki/Bell_state&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bell state&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;An EPR pair is a pair of qubits (or quantum bits) that are in a Bell state together.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;This definition doesn't provide much detail beyond the basics of what an EPR pair is.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;The Question&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;How are EPR Pairs used in quantum computing?&lt;/p&gt;&#xA;" OwnerUserId="82" LastEditorUserId="1847" LastEditDate="2018-04-18T18:37:02.110" LastActivityDate="2018-04-18T18:37:02.110" Title="How are EPR Pairs used in quantum computing?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-entanglement&gt;&lt;quantum-state&gt;&lt;quantum-correlation&gt;" AnswerCount="2" CommentCount="1" />
  <row Id="1664" PostTypeId="1" AcceptedAnswerId="1666" CreationDate="2018-04-10T16:34:37.553" Score="6" ViewCount="88" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;em&gt;&quot;Quantum magic won't be enough&quot;&lt;/em&gt; (Bennett et al. 1997)&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;If you throw away the problem structure, and just consider the space of $2^n$ possible solutions, then even a quantum computer needs about $\sqrt{2^n}$ steps to find the correct one (using Grover's algorithm)&#xA;  If a quantum polynomial time algorithm for a $\text{NP}$-complete problem is ever found, it &lt;b&gt;must&lt;/b&gt; exploit the problem structure in some way.&#xA;  I've some (basic) questions that no one seems to have asked so far on this site (maybe because they are basic). Suppose someone finds a bounded error quantum polynomial time algorithm for $\text{SAT}$ (or any other $\text{NP}$-complete problem), thus placing $\text{SAT}$ in $\text{BQP}$, and implying $\text{NP} \subseteq \text{BQP}$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Questions&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;The possibility (or not) to exploit the problem structure in a general enough (i.e. specific-instance independent) manner seems to be the very core of the $\text{P = NP}$ question. Now if a bounded error polynomial-time quantum algorithm for $\text{SAT}$ is found, and it &lt;em&gt;must&lt;/em&gt; exploit the problem structure, wouldn't its structure-exploitation-strategy be usable also in the classical scenario? Is there any evidence indicating that such a structure-exploitation may be possible for quantum computers, while remaining impossible for classical ones?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&quot;https://books.google.ch/books?id=Ul1RDwAAQBAJ&amp;amp;pg=PT112&amp;amp;lpg=PT112&amp;amp;dq=SAT%E2%88%88BQP&amp;amp;source=bl&amp;amp;ots=I4FvjLMbxm&amp;amp;sig=HLPf5gMqJjTtpHwBnkxJ1oRQWVI&amp;amp;hl=fr&amp;amp;sa=X&amp;amp;ved=0ahUKEwjky7rK7K_aAhXJC8AKHYkJDr0Q6AEIOzAC#v=onepage&amp;amp;q=SAT%E2%88%88BQP&amp;amp;f=false&quot; rel=&quot;noreferrer&quot;&gt;Sources&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1660/consequences-of-textsat-in-textbqp&quot;&gt;Related&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&#xA;" OwnerUserId="58" LastEditorUserId="26" LastEditDate="2018-04-10T17:05:41.173" LastActivityDate="2018-04-10T18:12:59.743" Title="Quantum Algorithm SAT structure" Tags="&lt;quantum-algorithms&gt;&lt;complexity-theory&gt;" AnswerCount="1" CommentCount="1" FavoriteCount="2" />
  <row Id="1665" PostTypeId="2" ParentId="1289" CreationDate="2018-04-10T17:54:36.817" Score="9" Body="&lt;p&gt;Here is my process for doing arithmetic on a quantum computer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Step 1: Find a classical circuit that does the thing you're interested in.&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In this example, a full adder.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/5sRyc.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/5sRyc.png&quot; alt=&quot;classical full adder&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Step 2: Convert each classical gate into a reversible gate.&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Have your output bits present from the start, and initialize them with CNOTs, CCNOTs, etc.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/VUqY6.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/VUqY6.png&quot; alt=&quot;semi-reversible full adder&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Step 3: Use temporary outputs.&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you were doing this addition to e.g. control whether a Grover oracle phases by -1 or not, now is the time to apply a Z gate to your output qubit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Step 4: Get rid of intermediate values by doing exactly the opposite of what you did to compute them.&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This may or may not include getting rid of the output bits, depending on how the circuit fits into your overall algorithm.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/6HfGR.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/6HfGR.png&quot; alt=&quot;semi-reversible full adder 2&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Step 5: (Sometimes) for each output bit you keep, get rid of an input bit.&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And I don't mean &quot;drop them on the floor&quot;, I mean apply operations that cause them to become 0 for sure.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When you compute &lt;code&gt;c+=a&lt;/code&gt;, leaving behind a copy of the original value of &lt;code&gt;c&lt;/code&gt; tends to be bad. It destroys coherence. So you must look at your adder circuit (or whatever), and think hard about if there's a way to use your output bits to get rid of your input bits. For example, after computing &lt;code&gt;c+a&lt;/code&gt; you could do a temporary out-of-place subtraction into a register r, xor r into the register storing the unwanted copy of &lt;code&gt;c&lt;/code&gt;, then revert the temporary subtraction.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(A notable exception to &quot;if you keep your output, don't keep so much of your input&quot; is Shor's algorithm. Shor's algorithm decoheres its input &lt;em&gt;on purpose&lt;/em&gt;, but in a very particular way that helps with period finding.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Step 6: Be efficient&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In step 5 I said you could uncompute the input of an inplace addition by doing an out of place addition followed by a temporary out-of-place subtraction. This is a bit silly. The overall adding process is going to span 4n qubits (n to hold &lt;code&gt;a&lt;/code&gt;, n to hold &lt;code&gt;c&lt;/code&gt;, n to hold &lt;code&gt;c+a&lt;/code&gt;, n to hold &lt;code&gt;(c+a)-a&lt;/code&gt;). If you are more clever, &lt;a href=&quot;https://dl.acm.org/citation.cfm?id=2011672&quot; rel=&quot;noreferrer&quot;&gt;you can fit everything into &lt;code&gt;2n&lt;/code&gt; qubits&lt;/a&gt; or (slightly easier) &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0410184&quot; rel=&quot;noreferrer&quot;&gt;into &lt;code&gt;2n+1&lt;/code&gt; qubits&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/ZcZqL.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/ZcZqL.png&quot; alt=&quot;cuccaro adder&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-04-10T18:03:32.747" LastActivityDate="2018-04-10T18:03:32.747" CommentCount="0" />
  <row Id="1666" PostTypeId="2" ParentId="1664" CreationDate="2018-04-10T18:12:59.743" Score="3" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;wouldn't its structure-exploitation-strategy be usable also in the classical scenario?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Not necessarily. For example, Shor's algorithm exploits the structure of factoring in a way that classical computers can't. Specifically, Shor's algorithm looks for periods in the multiplicative subgroup of N-1 in a way that requires a quantum Fourier transform to be efficient.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Sometimes quantum algorithms do translate back into the classical domain. For example, you can use phase estimation to apply fractional QFTs in an efficient way. &lt;a href=&quot;http://algassert.com/post/1710&quot; rel=&quot;nofollow noreferrer&quot;&gt;Translate this circuit directly into its classical equivalent, and you get an O(N log(N)) algorithm for fractional FFTs&lt;/a&gt;. But there's certainly no guarantees that what works well in the quantum context will work well in the classical context.&lt;/p&gt;&#xA;" OwnerUserId="119" LastActivityDate="2018-04-10T18:12:59.743" CommentCount="0" />
  <row Id="1667" PostTypeId="1" AcceptedAnswerId="1672" CreationDate="2018-04-10T18:24:33.557" Score="5" ViewCount="169" Body="&lt;blockquote&gt;&#xA;  &lt;ol start=&quot;9&quot;&gt;&#xA;  &lt;li&gt;Show that the average value of the observable $X_1Z_2$ in a two-qubit system measured in the state $(|00\rangle + |11\rangle)/\sqrt{2}$ is zero. &lt;/li&gt;&#xA;  &lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;How would we approach this question? I understand that $X_1$ means $\sigma_1$ acting on the first qubit, and $Z_2$ means $\sigma_3$ acting on the second qubit. I also know that the average value is given by $\left&amp;lt;\psi\vert M\vert \psi\right&amp;gt;$ (the inner product of $\psi$ with $M \psi$). I know how to solve similar problems for a single qubit system, however what confuses me here is what is the vector representation of the states $\left| 00\right&amp;gt;$ and $\left| 11\right&amp;gt;$ and how is this related to the vector representation of $\left| 0\right&amp;gt;$ and $\left| 1\right&amp;gt;$? Also, what is the matrix form of $M$ in this case? Is it the tensor product of $\sigma_1$ applied to the first qubit and $\sigma_3$ applied to the second qubit? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://www.physics.ohio-state.edu/~stroud/p880k20ps2.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Source of the question&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="1919" LastEditorUserId="26" LastEditDate="2018-04-11T19:26:29.693" LastActivityDate="2018-04-11T19:26:29.693" Title="Compute average value of two-qubit system" Tags="&lt;qubit&gt;&lt;qubit-state&gt;&lt;notation&gt;" AnswerCount="2" CommentCount="4" FavoriteCount="1" />
  <row Id="1668" PostTypeId="2" ParentId="1663" CreationDate="2018-04-10T20:18:16.233" Score="4" Body="&lt;p&gt;&lt;strong&gt;EPR pairs are&lt;/strong&gt; a particular case of &lt;strong&gt;entangled pairs of qubits&lt;/strong&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;From Wikipedia: &quot;&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_entanglement&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum entanglement&lt;/a&gt; is a physical phenomenon which occurs when pairs or groups of particles are generated or interact in ways such that the quantum state of each particle cannot be described independently of the state of the other.&lt;/em&gt;&quot; More to the point regarding your question, &lt;strong&gt;entanglement is a crucially important resource for quantum computing&lt;/strong&gt;, see &lt;a href=&quot;https://en.wikipedia.org/wiki/Bennett&amp;#39;s_laws&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bennet's laws&lt;/a&gt; on the inequivalences between bits, qubits and &lt;strong&gt;ebits&lt;/strong&gt; (or entanglement bits).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Elementary cases of use of EPR pairs in quantum computing would be &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_teleportation&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum teleportation&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Superdense_coding&quot; rel=&quot;nofollow noreferrer&quot;&gt;Superdense coding&lt;/a&gt;, and upon those pieces people have built more sophisticated applications. For the gory details of the original proposal for quantum teleportation, please check Bennet's &lt;a href=&quot;https://researcher.watson.ibm.com/researcher/files/us-bennetc/BBCJPW.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Teleporting an unknown quantum state via dual classical and Einstein-Podolsky-Rosen Channels&lt;/a&gt; (Phys.Rev.Lett., 1993, 70, 1895-1899).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For a more sophisticated application, please check this answer on &lt;a href=&quot;https://physics.stackexchange.com/questions/270032/whats-the-intuition-behind-the-choi-jamiolkowski-isomorphism&quot;&gt;the intuition behind the Choi-Jamiolkowski isomorphism&lt;/a&gt;, which also heavily relies on maximally entangled qubit pairs. In turn, the application of this isomorphism was suggested to me, here, a couple of days ago, as an answer to &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1634/can-one-interrogate-black-boxes-for-quantum-coherence&quot;&gt;how to obtain information on what quantum logic a quantum black box is implementing&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="1847" LastEditDate="2018-04-10T20:25:42.807" LastActivityDate="2018-04-10T20:25:42.807" CommentCount="1" />
  <row Id="1669" PostTypeId="2" ParentId="1648" CreationDate="2018-04-10T22:48:09.040" Score="6" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;Is Quantum Biocomputing ahead of us?&quot;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There has been some work done on &lt;a href=&quot;https://en.wikipedia.org/wiki/Biological_computing&quot; rel=&quot;nofollow noreferrer&quot;&gt;biocomputing&lt;/a&gt;, &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Quantum_computing&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum computing&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Spin_chemistry&quot; rel=&quot;nofollow noreferrer&quot;&gt;spin chemistry&lt;/a&gt;, and &lt;a href=&quot;https://en.wikipedia.org/wiki/Magnetochemistry&quot; rel=&quot;nofollow noreferrer&quot;&gt;magnetochemical&lt;/a&gt; reactions. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Correlated radical pairs — pairs of transient radicals created simultaneously, such that the 2 electron spins, one on each radical, are correlated — on photoactive magnetoreceptive proteins such as &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptochrome#Magnetoreception&quot; rel=&quot;nofollow noreferrer&quot;&gt;Cryptochromes&lt;/a&gt; does not constitute quantum computation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;See: &quot;&lt;a href=&quot;http://jeb.biologists.org/content/207/7/1193&quot; rel=&quot;nofollow noreferrer&quot;&gt;Light-dependent magnetoreception in birds: analysis of the behaviour under red light after pre-exposure to red light&lt;/a&gt;&quot; by W. Wiltschko, Gesson, Noll, and R. Wiltschko in the Journal of Experimental Biology, 2004.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;See the article &quot;&lt;a href=&quot;http://quantbiolab.com/research/vision-based-animal-magnetoreception&quot; rel=&quot;nofollow noreferrer&quot;&gt;Vision-based animal magnetoreception&lt;/a&gt;&quot; at the QuantBioLab website, Quantum Biology and Computational Physics research group, University of Southern Denmark (SDU):&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/H5O5j.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/H5O5j.jpg&quot; alt=&quot;Forward reaction MFeffect&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Figure 6. Shown here is a semi-classical description of the magnetic field effect on the radical pairs between FADH and tryptophan in cryptochrome. The unpaired electron spins (S$_1$ and S$_2$) precess about a local magnetic field produced by the addition of the external magnetic field $B$ with contributions I$_1$ and I$_2$ from the nuclear spins on the two radicals. The spin precession continuously alters the relative spin orientation, causing the singlet (anti-parallel) to triplet (parallel) interconversion which underlies the magnetic field effect. Electron back-transfer from a tryptophan to FADH quenches cryptochrome's active state. However, this back-transfer can only take place when the electron spins are in the singlet state, and this spin-dependence allows the external magnetic field, $B$, to affect cryptochrome activation. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/TQTmV.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/TQTmV.jpg&quot; alt=&quot;Retina Components&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Figure 7. Schematic illustration of a bird's eye and its important components. The retina (a) converts images from the eye's optical system into electrical signals sent along the ganglion cells forming the optic nerve to the brain. (b) An enlarged retina segment is shown schematically. (c) The retina consists of several cell layers. The primary signals arising in the rod and cone outer segments are passed to the horizontal, the bipolar, the amacrine, and the ganglion cells. (d) The primary phototransduction signal is generated in the receptor protein rhodopsin shown schematically at a much reduced density. The rhodopsin containing membranes form disks with a thickness of ~20 nm, being ~15–20 nm apart from each other. The putatively magnetic-field-sensitive protein cryptochrome may be localized in a specifically oriented fashion between the disks of the outer segment of the photoreceptor cell, as schematically shown in panel d or the cryptochromes (e) may be attached to the oriented, quasi-cylindrical membrane of the inner segment of the photoreceptor cell (f).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;In mathematical terms, the vision-based compass in birds is characterized by a filter function, which models the magnetic field-mediated visual signal modulation recorded on the bird's retina (see Fig. 8).&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/KROxn.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/KROxn.jpg&quot; alt=&quot;Filer Function&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Figure 8. Panoramic view at Frankfurt am Main, Germany. The image shows the landscape perspective recorded from a bird flight altitude of 200 m above ground with the cardinal directions indicated. The visual field is modified through the magnetic filter function; the patterns are shown for a bird looking at eight cardinal directions (N, NE, E, SE, S, SW, W, and NW). The geomagnetic field inclination angle is 66°, being a characteristic value for the region. &lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;A bio&lt;a href=&quot;https://en.wikipedia.org/wiki/Mechanical_computer&quot; rel=&quot;nofollow noreferrer&quot;&gt;mechanical computer&lt;/a&gt; has been created. &lt;a href=&quot;http://bio4comp.org/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bio4Comp&lt;/a&gt;, an EU-funded research project, have created biomolecular machines each only a few billionths of a meter (nanometers) in size. The actin-myosin and microtubule-kinesin motility systems can solve problems by moving through a nanofabricated network of channels designed to represent a mathematical algorithm; an approach we termed “network-based biocomputation”. Whenever the biomolecules reach a junction in the network, they either add a number to the sum they are calculating or leave it out. That way, each biomolecule acts as a tiny computer with processor and memory. While an individual biomolecule is much slower than a current computer, they are self-assembling so that they can be used in large numbers, quickly adding up their computing power. An example of how this works is shown in the video on their website.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/0UiCq.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/0UiCq.jpg&quot; alt=&quot;WP4 SEM channels (full with scalebar corrected)&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;ul&gt;&#xA;  &lt;li&gt;&lt;p&gt;Are these tools already solving problems you (quantum computing researchers) have?&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Is there any specific issue these tools 'must' be solving somehow that you are struggling with at your labs?&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Could we use them (although this will imply a paradigm shift towards biotechnology)?&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&quot;The first step in solving mathematical problems with network-based biocomputation is to encode the problem into network format so that molecular motors exploring the network can solve the problem. We have already found network encodings for several NP-complete problems, which are particularly hard to solve with electronic computers. For example, &lt;strong&gt;we have encoded subset sum, exact cover, boolean satisfiability and travelling salesman&lt;/strong&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Within the Bio4Comp project, we will focus on optimizing these encodings so that they can be efficiently solved with biological agents and be more readily scaled up. Analogous to optimized computer algorithms, optimized networks can greatly reduce the computing power (and thus the number of motor proteins) required for finding the correct solution.&quot; - Source: &lt;a href=&quot;http://bio4comp.org/research.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bio4Comp Research&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Another interesting paper which supports my answer that radical pairs don't constitute a quantum computer, but is merely a quantum biochemical reaction demonstrating spin chemistry, is &quot;&lt;a href=&quot;https://arxiv.org/abs/1011.5495&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum probe and design for a chemical compass with magnetic nanostructures&lt;/a&gt;&quot; by Jianming Cai (2018).&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;Introduction.&lt;/strong&gt; — Recently, there has been increasing interest in quantum biology namely investigating quantum effects in chemical and biological systems, e.g., light harvesting system, avian compass and olfactory sense. The main motivation is to understand how quantum coherence (entanglement) may be exploited for the accomplishment of biological functions. As a key step towards this goal, it is desirable to find tools that can detect quantum effects under ambient conditions. The ultimate goal of practical interest in studying quantum biology is to learn from nature and design highly efficient devices that can mimic biological systems in order to complete important tasks, e.g. collecting solar energy and detecting weak magnetic field.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;As an example of quantum biology, the radical pair mechanism is an intriguing hypothesis to explain the ability of some species to respond to weak magnetic fields, e.g. birds, fruit flies, and plants. A magnetochemical compass could find applications in remote magnetometry, in a magnetic mapping of microscopic or topographically complex materials, and in imaging through scattering media. It was demonstrated that a synthetic donor-bridge-acceptor compass composed of a linked carotenoid (C), porphyrin (P), and fullerene (F) can work at low temperature (193 K). It is surprising that such a triad molecule is the only known example that has been experimentally demonstrated to be sensitive to the geomagnetic field (yet not at room temperature). It is currently not known how one might construct a biomimetic or synthetic chemical compass that functions at ambient temperature.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;...&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;strong&gt;Summary.&lt;/strong&gt; — We have demonstrated that a gradient field can lead to a significant enhancement of the performance of a chemical compass. The gradient field also provides us with a powerful tool to investigate &lt;strong&gt;quantum dynamics of radical pair reactions in spin chemistry&lt;/strong&gt;. In particular, it can distinguish whether the initial &lt;strong&gt;radical pair state is in the entangled singlet state or in the classically correlated state, even in the scenarios where such a goal could not be achieved before&lt;/strong&gt;. These phenomena persist upon addition of partial orientational averaging and addition of realistic magnetic noise. The effects predicted there may be detectable in a hybrid system compass composed of magnetic nanoparticles and radical pairs in an oriented liquid crystalline host. Our work offers a simple method to design/simulate a biologically inspired weak magnetic field sensor based on the radical pair mechanism with a high sensitivity that may work at room temperature.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="278" LastEditorUserId="58" LastEditDate="2018-04-11T11:02:39.970" LastActivityDate="2018-04-11T11:02:39.970" CommentCount="0" />
  <row Id="1670" PostTypeId="2" ParentId="1667" CreationDate="2018-04-11T02:37:18.283" Score="1" Body="&lt;p&gt;Notationally, $|00\rangle = |0\rangle \otimes |0\rangle$. A basic property of tensor products is that inner products split like so: $$(\langle 0|_A \otimes \langle 0|_B) O_A\otimes O_B (|0\rangle_A \otimes |0\rangle_B) = \langle0|O_A|0\rangle \cdot \langle0|O_B|0\rangle.$$&lt;/p&gt;&#xA;" OwnerUserId="483" LastActivityDate="2018-04-11T02:37:18.283" CommentCount="0" />
  <row Id="1671" PostTypeId="2" ParentId="1648" CreationDate="2018-04-11T04:18:32.137" Score="3" Body="&lt;p&gt;Much has been written about &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_biology&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Biology&lt;/a&gt;. A somewhat old -and yet, solid- take is that of Phillip Ball, &lt;a href=&quot;https://www.philipball.co.uk/images/stories/docs/pdf/474272.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;The dawn of Quantum Biology&lt;/a&gt; (Nature 2011, 474, 271-274). For now, let's not review that and instead focus on your questions.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;On the first question:&lt;/strong&gt;(&lt;em&gt;is it solving our problems?&lt;/em&gt;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A system (or process) described by &lt;strong&gt;Quantum Biology is non-trivially quantum-mechanic&lt;/strong&gt;, and therefore interesting, but to the best of my knowledge it is also &lt;strong&gt;not multi-qubit&lt;/strong&gt;, so not really what quantum computing is about. In particular: currently known quantum biological processes do not present scalability, and neither do they present quantum logical gates (or not in the way we understand them at least), much less so quantum algorithms. So, as an answer, that's mainly a no: these tools are not solving our problems.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;On the second question:&lt;/strong&gt;(&lt;em&gt;is it solving a specific issue we're struggling with?&lt;/em&gt;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Reliable quantum coherence on the solid state, in complex structured systems and at high temperature&lt;/strong&gt; is something we all would like to see solved, and, at least to some point, this is what Quantum Biology is about. So, as far as the current understanding of the field goes, this is indeed a specific issue that people in labs are working on and which seems solved in Biology (since molecules are complex nanostructures). Whenever we are able in our labs to reliably achieve quantum coherence in the solid state, in complex structured systems and at high temperature, we will jump much closer to usefulness and cheapness. So, as an answer, that is a yes.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;On the third question:&lt;/strong&gt;(&lt;em&gt;could we use biomolecules as quantum hardware?&lt;/em&gt;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;They are not in the main league yet, to say the least. Even as an optimistic speculation, I'd say that they &lt;strong&gt;will not be competing with the big players&lt;/strong&gt; any time soon, but I do believe that, as research advances past &lt;a href=&quot;https://en.wikipedia.org/wiki/DNA_origami&quot; rel=&quot;nofollow noreferrer&quot;&gt;DNA origami&lt;/a&gt; (and related strategies) in Molecular Biology and Synthetic Biology, at some point &lt;strong&gt;biomolecular qubits will play a role within the subset of molecular spin qubits&lt;/strong&gt;. In particular, the keys to relevance would be to combine the (seemingly proven) coherence in unusual conditions (warm, wet), with the unmatched ability of biomolecules for extremely complex self-organisation into functional structures. Since (coherent, organized) molecular spin qubits are my field of research, let me link to a couple of relevant papers. First, a first reaction on the first magnetic molecule that was competitive in terms of coherence with regular solid-state candidates, and thus how&#xA;&lt;a href=&quot;https://pubs.acs.org/doi/full/10.1021/acscentsci.5b00384&quot; rel=&quot;nofollow noreferrer&quot;&gt;magnetic molecules are back in the race toward the quantum computer&lt;/a&gt;. And also, this proposal (disclosure: I'm an author) on the arXiv on why and how one could use &lt;a href=&quot;https://arxiv.org/pdf/1708.09440.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;peptides as versatile scaffolds for quantum computing&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="1847" LastEditDate="2018-04-21T09:38:03.360" LastActivityDate="2018-04-21T09:38:03.360" CommentCount="0" />
  <row Id="1672" PostTypeId="2" ParentId="1667" CreationDate="2018-04-11T06:43:50.143" Score="8" Body="&lt;p&gt;I suggest two different ways of trying to solve this, which will give you experience of different bits of the formulation of Quantum Information Theory. I'll give examples that are closely related to the question you asked, but are not what you asked so that you still get the value of answering the question yourself.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Long-hand Method&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Represent the kets as vectors, the Pauli matrices as matrices, explicitly perform the tensor products, and multiply everything out. So, we represent&#xA;$$&#xA;|0\rangle\equiv\left(\begin{array}{c} 1 \\ 0 \end{array}\right)\qquad|1\rangle\equiv\left(\begin{array}{c} 0 \\ 1 \end{array}\right)&#xA;$$&#xA;To calculate the tensor product, such as $|01\rangle$, we do&#xA;$$&#xA;|01\rangle=|0\rangle\otimes|1\rangle\equiv\left(\begin{array}{c}1\times\left(\begin{array}{c} 0 \\ 1 \end{array}\right)\\ 0\times \left(\begin{array}{c} 0 \\ 1 \end{array}\right) \end{array}\right)=\left(\begin{array}{c} 0 \\ 1 \\ 0 \\ 0 \end{array}\right)&#xA;$$&#xA;Remember that $\langle 01|$ is just the Hermitian conjugate of this,&#xA;$$&#xA;\langle 01|=\left(\begin{array}{cccc} 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \end{array}\right)&#xA;$$&#xA;Then you do something similar for the operators. For example, $$X_1X_2=\sigma_1\otimes\sigma_1=\left(\begin{array}{cc} 0\times \left(\begin{array}{cc} 0 &amp;amp; 1 \\ 1 &amp;amp; 0 \end{array}\right) &amp;amp; 1\times \left(\begin{array}{cc} 0 &amp;amp; 1 \\ 1 &amp;amp; 0 \end{array}\right) \\ 1\times \left(\begin{array}{cc} 0 &amp;amp; 1 \\ 1 &amp;amp; 0 \end{array}\right) &amp;amp; 0\times \left(\begin{array}{cc} 0 &amp;amp; 1 \\ 1 &amp;amp; 0 \end{array}\right) \end{array}\right)=\left(\begin{array}{cccc} 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\ 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \end{array}\right).&#xA;$$&#xA;Once you have all of this, you simply multiply it out:&#xA;$$&#xA;\langle 01|X_1X_2|01\rangle=\left(\begin{array}{cccc} 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \end{array}\right)\left(\begin{array}{cccc} 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\ 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \end{array}\right)\left(\begin{array}{c} 0 \\ 1 \\ 0 \\ 0 \end{array}\right)=0.&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Shorter Method&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;(With experience, this method lets you perform this calculation just by looking at it! Of course, when giving an answer, I don't recommend that; you should always justify your answer.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Remember to think of each term $|01\rangle$ as $|0\rangle\otimes|1\rangle$. So, when you also write $X_1X_2=\sigma_1\otimes\sigma_1$, you see that&#xA;$$&#xA;(\sigma_1\otimes\sigma_1)|0\rangle\otimes|1\rangle=(\sigma_1|0\rangle)\otimes(\sigma_1|1\rangle)&#xA;$$&#xA;i.e. when everything is just tensor products, individual terms match up. Now, hopefully you know the action of $\sigma_1$ and $\sigma_3$ on the basis states:&#xA;$$&#xA;\sigma_1|0\rangle=|1\rangle\qquad \sigma_1|1\rangle=|0\rangle \qquad \sigma_3|0\rangle=|0\rangle \qquad \sigma_3|1\rangle=-|1\rangle&#xA;$$&#xA;Thus,&#xA;$$&#xA;(\sigma_1|0\rangle)\otimes(\sigma_1|1\rangle)=|1\rangle\otimes |0\rangle=|10\rangle&#xA;$$&#xA;One can then easily observe that a state such as $(|01\rangle+|10\rangle)/\sqrt{2}$ is acted on by $X_1X_2$ to give&#xA;$$&#xA;X_1X_2(|01\rangle+|10\rangle)/\sqrt{2}=(|01\rangle+|10\rangle)/\sqrt{2},\tag{1}&#xA;$$&#xA;the same state. So it is clear that the inner product of the state with itself is 1:&#xA;$$&#xA;(\langle 01|+\langle 10|)X_1X_2(|01\rangle+|10\rangle)/2=1.&#xA;$$&#xA;On the other hand, had the outcome in Eq. (1) been a different one of the four Bell states, because we know the Bell states form an orthonormal basis, the expectation value would be 0.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-04-11T06:43:50.143" CommentCount="0" />
  <row Id="1673" PostTypeId="2" ParentId="1602" CreationDate="2018-04-11T08:48:57.407" Score="2" Body="&lt;p&gt;The preferred basis problem is essentially something from the many worlds interpretation: If we are to interpret a superposition as representing many universes, what basis should we choose? Since this comes from the foundations of QM, this aspect of your question is perhaps better suited to the physics stack exchange.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Is there a preferred basis for a qudit or does it depend upon the&#xA;  underlying technology used to implement the qudits.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;For qudits (and qubits) the only distinction between bases is in the physical implementation. At the abstract mathematical level, all are equivalent.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This not only means that you are free to choose your computational basis. You also have some freedom in how to generalize the Pauli matrices. For a $d$ level qudit, for example, you could choose to label your basis states with the elements of a group with order $d$. Your can then define generalizations of Pauli $X$ that implement the group multiplication, and generalization of $Z$ that depend on the representations. See &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9707021&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt; for some examples.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;How you choose to do this might depend on the physics of the qudits (perhaps the interactions naturally implement such operations) or it might depend on what you want to do with the qudits (such as create exotic topological error correcting codes). But other than concerns like these, nothing is forcing you to make any particular decisions.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Usually we choose the basis that is easiest for us to measure. Superconducting qubits/qudits for examples are made from the lowest $d$ levels of an anharmonic oscillator. These energy eigenstates are what we typically measure, and that is the reason they are used as the computational basis.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For Fibonacci anyons, we have to deal with a Hilbert space that isn’t really built for being carved into qubits. Typically we take a subspace for which measurements aren’t too convoluted. But then we also need to worry about braiding leaking the state out of the subspace. This gives us a whole bunch of practical concerns to think about when choosing our basis. But nevertheless, it is only these practical concerns that lead to a preferred choice, and different authors may very well choose different conventions.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-04-11T08:48:57.407" CommentCount="0" />
  <row Id="1674" PostTypeId="1" AcceptedAnswerId="1682" CreationDate="2018-04-11T09:30:04.060" Score="9" ViewCount="156" Body="&lt;p&gt;The D-Wave system, as I understand it, allows us to program Ising models and to find their ground states. In this form, it is not universal for quantum computation: it can not simulate a circuit model quantum computer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What would be the simplest thing that could be done to make it universal? What are the reasons why such a thing has not been implemented?&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="1837" LastEditDate="2018-04-11T11:39:28.510" LastActivityDate="2018-04-13T05:31:12.180" Title="What would be the simplest addition that would make the D-Wave architecture universal?" Tags="&lt;d-wave&gt;&lt;circuit-model&gt;&lt;universal-gates&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="2" />
  <row Id="1675" PostTypeId="2" ParentId="70" CreationDate="2018-04-11T09:48:56.377" Score="3" Body="&lt;p&gt;As the &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/71/1837&quot;&gt;other answer&lt;/a&gt; conveyed (and to which I am just trying to provide some clarification), post-selection is about just looking at a subset of possible measurement outcomes. To my mind, this falls into two different cases, as below. Yes, they are different aspects of the same thing, but they are used very differently by two different communities.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Experimental Post-selection&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;You do some experiments, but you only gather data when certain conditions are fulfilled. Generally it's used to compensate for heralded experimental imperfections (i.e. something is triggered that tells us we've had a undesired result before proceeding with another part of the experiment). For example, you might be using a pair of photons as information or entanglement carriers, but sometimes those photons get lost on the way. If you only do things when both photons are detected, you are post-selecting on their successful arrival. &lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Theoretical Post-selection&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;This is a thought experiment of &quot;&lt;em&gt;how much more powerful could my computer be if I could choose the outcomes of measurements?&lt;/em&gt;&quot; and is not a practical proposition.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As a simple example, think about quantum teleportation. In the normal scenario, Alice and Bob share a Bell pair, and Alice has a qubit in an unknown state that she wants to teleport to Bob. She performs a Bell measurement on her two qubits, and sends her measurement outcome to Bob. If Bob is far away from Alice, the information on the measurement result takes a finite time to get there, and it's after that time that he can be thought of as having received the qubit (because he has to compensate for effects of the different results on the qubit he holds).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, if Alice can post-select on the measurement result as always being one particular result, and Bob knows that she's going to select that one, then Alice doesn't need to send the measurement result to Bob. He can use the qubit he holds immediately. Even stronger, he can use it before Alice has made the measurement, secure in the knowledge that she will! So, not only are you achieving faster-than-light communication, you're actually communicating backwards in time! You can start to imagine how immensely powerful that could be for a computer (compute for an arbitrarily long time and then send the answer back in time to the moment the question was asked).&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-04-11T09:48:56.377" CommentCount="5" />
  <row Id="1676" PostTypeId="2" ParentId="1663" CreationDate="2018-04-11T09:51:00.620" Score="2" Body="&lt;p&gt;If you were to try and imagine the simplest form of correlation, you might think of two bits that were randomly either both $0$, or both $1$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Bell states are just this, but quantum. We have bits instead of qubits, and the randomness is due to superposition.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Since they are most conceptually simple form of entanglement, and the easiest to describe using information theoretic language, they are our first choice for anything entanglement related. If you need to explain non-locality, do it with a Bell pair. If you want to teleport something, it’s simplest both mathematically and practically if you use a Bell pair. If you want to measure how much entanglement you have why not see how many Bell pairs you could turn it into?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Typically, we use four canonical forms of the Bell pairs. They represent all the ways that we can choose to have correlations or anticorrelations between the $|0\rangle / |1\rangle$ states of the computational basis and the $|+\rangle / |-\rangle$ states of the $X$ basis.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;These four states form a complete basis for two qubits. So any states, entangled or not, can be expressed as a superposition of Bell states. This can sometimes make our maths easier, which is another reason we like to use them.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-04-11T09:51:00.620" CommentCount="0" />
  <row Id="1677" PostTypeId="1" CreationDate="2018-04-11T10:12:04.333" Score="6" ViewCount="153" Body="&lt;p&gt;We usually talk about the power of a quantum computer by examining the separation between sets of gates that we know we can efficiently simulate on a classical computer (i.e. problems in the class BPP), and universal gate sets which, by definition, can implement any quantum algorithm, including BQP-complete algorithms. So, assuming a separation between &lt;a href=&quot;https://en.wikipedia.org/wiki/BPP_%28complexity%29&quot; rel=&quot;noreferrer&quot;&gt;BPP&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/BQP&quot; rel=&quot;noreferrer&quot;&gt;BQP&lt;/a&gt;, there is a separation in the power of the algorithms that can be implemented with these gate sets, and the separation between these gate sets can be as simple as the availability of one gate (two classic examples are the Clifford gates + the $\pi/8$ phase gate, and Toffoli+Hadamard). In effect, you need a universal gate set in order to gain a computational speed-up. However, this is specifically about algorithms with polynomial running times.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;What are the requirements that distinguish the power of a quantum computer which is intended solely to provide a polynomial speed-up on a problem outside BPP?&lt;/strong&gt; For example, a device built solely for the purpose of implementing a Grover's search. Presumably the D-Wave machines fall into this category.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To be clear, I require a speed-up that changes the scaling relation. If there's a classical algorithm that requires time $O(2^n)$, then obviously there are many different ways of physically implementing it which have different running times, but all will be $O(2^n)$. I'm interested in identifying what it is in a quantum computer that permits a &lt;em&gt;better&lt;/em&gt; scaling (but not a reduction to polynomial time running).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Asked another way: think about the D-wave machine (although I am not aiming to be limited to just talking about this case), which we believe is doing something coherent, and for a given problem size, seems to be quite speedy, but we don't know how it scales. Can we know &lt;em&gt;a priori&lt;/em&gt;, from details of its architecture, that it at least has the potential to provide a speed-up over classical? If it were universal for quantum computation, then it certainly would have that potential, but universality probably isn't necessary in this context.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Part of what I'm struggling to get my head around, even in terms of defining the question properly, is that we don't have to have a universal gate set because it doesn't necessarily matter if the gate set can be efficiently simulated on a classical computer, just so long as the overhead in performing the simulation is similar or worse than the speedup itself.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1847" LastEditDate="2018-04-27T08:32:34.907" LastActivityDate="2018-05-16T00:56:35.650" Title="Requirements for Achieving a Quantum Speedup" Tags="&lt;quantum-algorithms&gt;&lt;quantum-speedup&gt;&lt;d-wave&gt;&lt;universal-gates&gt;" AnswerCount="1" CommentCount="1" FavoriteCount="1" />
  <row Id="1678" PostTypeId="1" AcceptedAnswerId="1681" CreationDate="2018-04-11T10:30:55.527" Score="9" ViewCount="368" Body="&lt;p&gt;I'm looking for a quantum algorithm which I can use to demonstrate the syntax of different quantum-languages. My question is similar to &lt;a href=&quot;https://physics.stackexchange.com/questions/3390/can-anybody-provide-a-simple-example-of-a-quantum-computer-algorithm&quot;&gt;this&lt;/a&gt;, however, for me, &quot;good&quot; means:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;What it does could be described in 1-2 paragraphs, and should be easy to understand.&lt;/li&gt;&#xA;&lt;li&gt;Should use more elements of the &quot;quantum-programming-world&quot; (I mean that the algorithm should use some classical constants, measurements, conditions, qregisters, operators etc., as many as possible).&lt;/li&gt;&#xA;&lt;li&gt;The algorithm should be small (at most 15-25 pseudocode-lines long).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Useful algorithms are often too long/hard, but &lt;a href=&quot;https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm&quot; rel=&quot;noreferrer&quot;&gt;Deutsch's algorithm&lt;/a&gt; doesn't use that many elements. Can someone suggest me a good-for-demo algorithm?&lt;/p&gt;&#xA;" OwnerUserId="1930" LastEditorUserId="1847" LastEditDate="2018-04-27T16:50:53.323" LastActivityDate="2018-08-07T21:13:32.310" Title="A sample quantum algorithm, useful for demonstrating languages" Tags="&lt;quantum-algorithms&gt;&lt;resource-request&gt;&lt;quantum-programming&gt;" AnswerCount="3" CommentCount="4" FavoriteCount="2" />
  <row Id="1679" PostTypeId="1" CreationDate="2018-04-11T10:37:54.783" Score="12" ViewCount="224" Body="&lt;p&gt;As per Wikipedia, &lt;a href=&quot;https://en.wikipedia.org/wiki/Blockchain&quot; rel=&quot;noreferrer&quot;&gt;&lt;em&gt;blockchains&lt;/em&gt;&lt;/a&gt; are a way to maintain &quot;a continuously growing list of records, called blocks, which are linked and secured using cryptography [... and] inherently resistant to modification of the data.&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Blockchains are in current practical use, for example in the cryptocurrency &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptocurrency&quot; rel=&quot;noreferrer&quot;&gt;bitcoin&lt;/a&gt;. These implementations must make use of some particular approach to cryptography, which will involve assumptions intended to underwrite their security.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Are the current implementations of blockchain resistant to attacks using quantum computation?&lt;/p&gt;&#xA;" OwnerUserId="1931" LastEditorUserId="124" LastEditDate="2018-05-17T10:23:39.947" LastActivityDate="2018-07-20T02:01:48.350" Title="Does quantum computing threaten blockchain?" Tags="&lt;post-quantum-crypto&gt;" AnswerCount="3" CommentCount="5" FavoriteCount="1" />
  <row Id="1680" PostTypeId="1" AcceptedAnswerId="1697" CreationDate="2018-04-11T11:02:45.863" Score="9" ViewCount="158" Body="&lt;p&gt;I wish to learn more about computational complexity classes in the context of quantum computing. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The medium is not so important; it could be a book, online lecture notes or the like. What matters the most are the contents. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The material should cover the basics of quantum computational complexity classes and discuss the similarities, differences and relationships between them and perhaps also with classical computational complexity classes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I would prefer a rigorous treatment over an intuitive one. The author's style doesn't matter.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As for prerequisites, I know next to nothing about the topic, so maybe more self-contained material would be better. That being said, I probably would not read a 1000 page book unless it was phenomenally good, anything in the range of 1-500 pages might work. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;As for availability, I would of course prefer material that is not behind a paywall of some sort and can be found online, but this is not a strict requirement.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What do you recommend? &lt;/p&gt;&#xA;" OwnerUserId="144" LastEditorUserId="144" LastEditDate="2018-04-12T10:19:42.853" LastActivityDate="2018-04-13T10:19:41.260" Title="Good introductory material on quantum computational complexity classes" Tags="&lt;complexity-theory&gt;&lt;resource-request&gt;" AnswerCount="2" CommentCount="5" FavoriteCount="2" />
  <row Id="1681" PostTypeId="2" ParentId="1678" CreationDate="2018-04-11T13:03:35.010" Score="3" Body="&lt;p&gt;I suggest looking at eigenvalue/eigenvector estimating protocols. There's a lot of flexibility to make the problem as easy or as hard as you want.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Start by picking two parameters, $n$ and $k$. You want to design an $n$-qubit unitary, $U$ that has eigenvalues of the form $e^{-2\pi iq/2^k}$ for integers $q$. Make sure that at least one of those eigenvalues is unique, and call it $\omega$. Also make sure that a simple product state, say $|0\rangle^{\otimes n}$, has non-zero overlap with the eigenvector of eigenvalue $\omega$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The aim would be to implement a phase estimation algorithm on this, being told the value $k$, and being tasked with outputting a vector $|\psi\rangle$ that is the eigenvector corresponding to eigenvalue $\omega$. In general this will comprise a circuit of $n+k$ qubits (unless you need ancillas to implement controlled-$U$).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This works as follows:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;ul&gt;&#xA;  &lt;li&gt;&lt;p&gt;set up two registers, one of $k$ qubits, and the other of $n$ qubits. (&lt;strong&gt;use of quantum registers&lt;/strong&gt;)&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;every qubit is initialized in the state $|0\rangle$. (&lt;strong&gt;initialisation of quantum registers&lt;/strong&gt;)&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;apply a Hadamard to each qubit in the first register (&lt;strong&gt;single-qubit gates&lt;/strong&gt;)&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;from qubit $r$ in the first register, apply controlled-$U^{2^{r}}$, targeting the second register (&lt;strong&gt;multi-qubit controlled gates&lt;/strong&gt;)&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;apply the inverse Fourier transform on the first register, and measure every qubit of the first register in the standard basis. These can be combined, implementing the &lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.76.3228&quot; rel=&quot;nofollow noreferrer&quot;&gt;semi-classical Fourier transform&lt;/a&gt;. (&lt;strong&gt;measurement&lt;/strong&gt; and &lt;strong&gt;feed-forward of classical data&lt;/strong&gt;)&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;for the correct measurement result, the second register is in the desired state $|\psi\rangle$.&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;For simplicity, you could pick $n=2$, $k=1$, so you need a $4\times 4$ unitary matrix with eigenvalues $\pm 1$. I'd use something like $$(U_1\otimes U_2)C(U_1^\dagger\otimes U_2^\dagger),$$&#xA;where $C$ denotes the controlled-NOT. There is just one eigenvector with eigenvalue -1, which is $|\psi\rangle=(U_1\otimes U_2)|1\rangle\otimes(|0\rangle-|1\rangle)/\sqrt{2}$, and you can mess about with the choices of $U_1$ and $U_2$ to explore the implementation of $U$ using decomposition in terms of a universal gate set (I'd probably set this as a preliminary problem). Then, controlled-$U$ is easily implemented just by replacing the controlled-NOT with a controlled-controlled-NOT (Toffoli) gate. Finally, the inverse Fourier transform is just a Hadamard gate.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For something a little more complex, put $k=3$, and replace $C$ with the square-root of swap gate,&#xA;$$&#xA;\left(&#xA;\begin{array}{cccc}&#xA; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; \frac{1}{\sqrt{2}} &amp;amp; \frac{i}{\sqrt{2}} &amp;amp; 0 \\&#xA; 0 &amp;amp; \frac{i}{\sqrt{2}} &amp;amp; \frac{1}{\sqrt{2}} &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\&#xA;\end{array}&#xA;\right)&#xA;$$&#xA;with $\omega=e^{\pm i\pi/4}$ and $|\psi\rangle=(U_1\otimes U_2)(|01\rangle\pm|10\rangle)/\sqrt{2}$.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-04-12T07:11:15.467" LastActivityDate="2018-04-12T07:11:15.467" CommentCount="0" />
  <row Id="1682" PostTypeId="2" ParentId="1674" CreationDate="2018-04-11T14:49:04.643" Score="5" Body="&lt;p&gt;XX couplers are necessary to make an quantum annealing universal.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/0704.1287&quot; rel=&quot;noreferrer&quot;&gt;https://arxiv.org/abs/0704.1287&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As for fabricating them, I’m not too familiar with the hardware issues. Perhaps someone else can comment on that. &lt;/p&gt;&#xA;" OwnerUserId="54" LastActivityDate="2018-04-11T14:49:04.643" CommentCount="0" />
  <row Id="1683" PostTypeId="2" ParentId="1642" CreationDate="2018-04-11T15:21:13.240" Score="2" Body="&lt;p&gt;The answer arguably depends on the problem you wish to solve with your computation. More specifically, are you wanting to optimize near-term applications in the &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1885/what-is-meant-by-noisy-intermediate-scale-quantum-nisq-technology&quot;&gt;NISQ&lt;/a&gt; era, or are you wanting to build a fully scalable, fault-tolerant and universe quantum computer?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For the latter, you need to think about error correction. Pretty much everything that will happen in a fault-tolerant quantum computer will be part of error correction. So whether we want to run Shor's algorithm or simulate a quantum system, we nevertheless mostly need to optimize for error correction.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Typically, error correcting codes require Clifford gates. For the surface codes, CNOTs (both ways around), and preparation and measurement in the $Z$ and $X$ basis are usually used. But your exact choice of code, and how to implement that code, will affect the precise details of the gate set. But it will typically be a subset of the multi qubit Clifford group, made using single and two qubit generators.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So for fault-tolerant QC, the best option is to figure out good ways to implement the Clifford group.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="1847" LastEditDate="2018-04-23T11:26:58.473" LastActivityDate="2018-04-23T11:26:58.473" CommentCount="1" />
  <row Id="1684" PostTypeId="2" ParentId="1529" CreationDate="2018-04-12T06:05:08.093" Score="2" Body="&lt;p&gt;In one sense, the &lt;em&gt;Xmon qubit is a transmon qubit&lt;/em&gt;, in that they both operate in the $E_J&amp;gt;&amp;gt;E_c$ regime of the CPB Hamiltonian and take advantage of the exponentially suppressed charge noise vs. polynomial decrease in anharmonicity effect discussed in (Koch, 2007). You could work out the dynamics of a superconducting qubit-resonator system without ever knowing whether the equations were describing an Xmon or a transmon, so functionally its hard to differentiate the Xmon.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;On the other hand, there are a lot of important design differences introduced in the Xmon: The qubit is grounded (mentioned above), the qubit is no longer embedded in the resonator, its conveniently tunable, the lifetime is enhanced (although the &lt;a href=&quot;https://github.com/QISKit/ibmqx-backend-information/tree/master/backends/ibmqx3&quot; rel=&quot;nofollow noreferrer&quot;&gt;ibmqx3&lt;/a&gt; chip that IBM uses for its quantum experience has qubits with $T_1\approx40 \space \mu s$ which matches the original Xmon lifetime). Also, the Xmon's shape is a great match for a surface code architecture that requires a tight-packed grid of qubits. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Practically, there are a lot of other transmon designs that offer some of the same benefits of the Xmon. So &quot;transmon vs. Xmon&quot; isn't the general question to ask; just go with the design that's got the best lifetimes and maybe tunability.&lt;/p&gt;&#xA;" OwnerUserId="1939" LastActivityDate="2018-04-12T06:05:08.093" CommentCount="0" />
  <row Id="1685" PostTypeId="2" ParentId="1678" CreationDate="2018-04-12T13:35:21.007" Score="3" Body="&lt;p&gt;Sounds like you want a quantum &quot;Hello World&quot;. The most straightforward quantum version of this would just be to write a binary encoded version of the text &lt;code&gt;Hello World&lt;/code&gt; in a register of qubits. But this would require ~100 qubits, and be longer than your upper limit for code length.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So let's write a shorter peice of text. Let's write &lt;code&gt;;)&lt;/code&gt;, we need a bit string of length 16. Specifically, using ASCII encoding&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;;)  =  00111011 00101001&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Using QISKit, you'd do this using the following code.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;from qiskit import QuantumProgram&#xA;import Qconfig&#xA;&#xA;qp = QuantumProgram()&#xA;qp.set_api(Qconfig.APItoken, Qconfig.config[&quot;url&quot;]) # set the APIToken and API url&#xA;&#xA;# set up registers and program&#xA;qr = qp.create_quantum_register('qr', 16)&#xA;cr = qp.create_classical_register('cr', 16)&#xA;qc = qp.create_circuit('smiley_writer', [qr], [cr])&#xA;&#xA;# rightmost eight (qu)bits have ')' = 00101001&#xA;qc.x(qr[0])&#xA;qc.x(qr[3])&#xA;qc.x(qr[5])&#xA;&#xA;# second eight (qu)bits have 00111011&#xA;# these differ only on the rightmost two bits&#xA;qc.x(qr[9])&#xA;qc.x(qr[8])&#xA;qc.x(qr[11])&#xA;qc.x(qr[12])&#xA;qc.x(qr[13])&#xA;&#xA;# measure&#xA;for j in range(16):&#xA;    qc.measure(qr[j], cr[j])&#xA;&#xA;# run and get results&#xA;results = qp.execute([&quot;smiley_writer&quot;], backend='ibmqx5', shots=1024)&#xA;stats = results.get_counts(&quot;smiley_writer&quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Of course, this isn't very quantum. So you could do a superposition of two different emoticons instead. The easiest example is to superpose ;) with 8), since the bit strings for these differ only on qubits 8 and 9.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;;)  =  00111011 00101001&#xA;8)  =  00111000 00101001&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;So you can simply replace the lines&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;qc.x(qr[9])&#xA;qc.x(qr[8])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;from the above with&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;qc.h(qr[9]) # create superposition on 9&#xA;qc.cx(qr[9],qr[8]) # spread it to 8 with a cnot&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;The Hadamard creates a superposition of &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;, and the cnot makes it into a superposition of &lt;code&gt;00&lt;/code&gt; and &lt;code&gt;11&lt;/code&gt; on two qubits. This is the only required superposition for &lt;code&gt;;)&lt;/code&gt; and &lt;code&gt;8)&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you want to see an actual implementation of this, it can be found on the &lt;a href=&quot;https://github.com/QISKit/qiskit-tutorial/blob/master/hello_world/quantum_emoticon.ipynb&quot; rel=&quot;nofollow noreferrer&quot;&gt;QISKit tutorial&lt;/a&gt; (full disclosure: it was written by me).&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-04-21T15:29:54.370" LastActivityDate="2018-04-21T15:29:54.370" CommentCount="2" />
  <row Id="1686" PostTypeId="2" ParentId="1680" CreationDate="2018-04-12T17:03:45.557" Score="2" Body="&lt;p&gt;I can recommend the &lt;a href=&quot;http://homepages.cwi.nl/~rdewolf/qcnotes.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Lecture notes&lt;/a&gt; of Ronald de Wolf, used for a semester course taught by him on Quantum Computing in the context of the Dutch 'Mastermath' program.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Chapter 10 &quot;Quantum Complexity Theory&quot;, covers the 'classical' complexity classes briefly, but gives enough background to talk about the 'quantum' complexity classes and compare them with the classical. It doesn't cover everything, but refers to other material for further reading.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Chapter 12 &quot;Quantum Communication Complexity&quot; is also relevant and is more technical, mainly since to the theory of communication complexity has interesting applications within quantum computation.&lt;/p&gt;&#xA;" OwnerUserId="253" LastActivityDate="2018-04-12T17:03:45.557" CommentCount="0" />
  <row Id="1687" PostTypeId="1" AcceptedAnswerId="1688" CreationDate="2018-04-12T19:23:47.013" Score="9" ViewCount="252" Body="&lt;p&gt;I am pretty intrigued by the record time that a qubit has survived.&lt;/p&gt;&#xA;" OwnerUserId="1931" LastEditorUserId="23" LastEditDate="2018-04-17T18:13:43.190" LastActivityDate="2018-05-03T23:27:01.880" Title="What is the longest time a qubit has survived with 0.9999 fidelity?" Tags="&lt;qubit&gt;&lt;fidelity&gt;" AnswerCount="2" CommentCount="4" />
  <row Id="1688" PostTypeId="2" ParentId="1687" CreationDate="2018-04-12T21:11:28.283" Score="8" Body="&lt;p&gt;Well, for the longest coherence time ever, I'm finding this Science from 2013 entitled &lt;a href=&quot;http://science.sciencemag.org/content/342/6160/830&quot; rel=&quot;noreferrer&quot;&gt;Room-Temperature Quantum Bit Storage Exceeding 39 Minutes Using Ionized Donors in Silicon-28&lt;/a&gt;, which indicates qubits that lasted for over 39 minutes; these, however, only had an 81% fidelity rate. (This is for qubits used in computation, not memory storage. For memory storage, see M. Stern's link.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But you're looking for qubits with a high fidelity rate. In that case, I found a Nature Nanotechnology from 2014 entitled &lt;a href=&quot;https://www.nature.com/articles/nnano.2014.211.epdf?referrer_access_token=eAPRpCk-XWOowPey97ATOdRgN0jAjWel9jnR3ZoTv0MSiU3zyoWmVaZbUhBS9Y2y0Ydzrooe7TM7a2pPhbGI0gUh3iiDzDUwEOCB1W-Ol1olQL-WtemqfKxyGGHJlpm_iydV0dIwcLUfrijSMynofUUA2I4DPvmBnExrFpi006xfteNV_dc5xzqmPH4MpLzEqtP-NFjPfWaIDlAPto5Ihs0w55NEK75U6G3PTxxAlkU%3D&amp;amp;tracking_referrer=www.abc.net.au&quot; rel=&quot;noreferrer&quot;&gt;Storing quantum information for 30 seconds&#xA;in a nanoelectronic device&lt;/a&gt;(&lt;a href=&quot;https://arxiv.org/abs/1402.7140&quot; rel=&quot;noreferrer&quot;&gt;alternate link to arXiv&lt;/a&gt;) which was coherent for 30 seconds - but had a greater than 99.99% fidelity rate, which is exactly what you're looking for. Most other papers I'm finding with a 99.99% fidelity rate or greater measure their coherence times in nano or microseconds.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I will keep looking.&lt;/p&gt;&#xA;" OwnerUserId="91" LastEditorUserId="1847" LastEditDate="2018-04-13T09:19:41.703" LastActivityDate="2018-04-13T09:19:41.703" CommentCount="3" />
  <row Id="1689" PostTypeId="2" ParentId="1367" CreationDate="2018-04-12T21:26:05.753" Score="3" Body="&lt;p&gt;&lt;a href=&quot;https://github.com/rigetticomputing/pyquil/&quot; rel=&quot;nofollow noreferrer&quot;&gt;pyQuil&lt;/a&gt; is an open source quantum programming library in Python. The documentation includes a hands on introduction to quantum computing where you learn by programming. It doesn't assume any physics background.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here are some links to the main topics:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;http://pyquil.readthedocs.io/en/latest/intro.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Intro to quantum computing with pyQuil&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1608.03355&quot; rel=&quot;nofollow noreferrer&quot;&gt;Whitepaper&lt;/a&gt; on the underlying Quil instruction set (assumes only linear algebra and complex numbers)&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;http://pyquil.readthedocs.io/en/latest/noise.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Understanding noise and errors in quantum processors&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;http://grove-docs.readthedocs.io/en/latest/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Examples of algorithms&lt;/a&gt; implemented using pyQuil. These are in another open source library called grove.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="299" LastActivityDate="2018-04-12T21:26:05.753" CommentCount="0" />
  <row Id="1690" PostTypeId="1" AcceptedAnswerId="1693" CreationDate="2018-04-13T04:40:30.140" Score="4" ViewCount="34" Body="&lt;p&gt;On 1993, Seth Lloyd published in Science a proposal for &lt;a href=&quot;http://science.sciencemag.org/content/261/5128/1569&quot; rel=&quot;nofollow noreferrer&quot;&gt;A Potentially Realizable Quantum Computer&lt;/a&gt;. In a nutshell, this consists in a long chain of weakly coupled qubits which are operated with (almost) no need for the operator to differentially address the different memory positions (i.e. no spatial addressing is required), and at the same time it does not require every qubit to present a different energy. Instead, all qubits are equivalent, with the exceptions of&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;the two extremes of the chain are distinguishable from the bulk (and this feature is used to introduce new information) and&lt;/li&gt;&#xA;&lt;li&gt;a qubit is sensitive to its immediate neighbours, so at any given time you effect the same simultaneous operation on all qubits with certain  surroundings, while leaving those with differing ones unperturbed (this feature allows operating in a manner of cellular automata)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;My question is: &lt;strong&gt;have few-qubit versions of Lloyd's proposal been proposed, or implemented?&lt;/strong&gt; (If yes: under what architecture(s), and if not, what would be required to do it?)&lt;/p&gt;&#xA;" OwnerUserId="1847" LastActivityDate="2018-04-13T07:25:33.377" Title="Any few-qubit versions of Lloyd's &quot;weakly-coupled-array&quot; quantum computing?" Tags="&lt;quantum-computer&gt;&lt;architecture&gt;&lt;experimental-results&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="1691" PostTypeId="2" ParentId="1674" CreationDate="2018-04-13T05:31:12.180" Score="1" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;What would be the simplest thing that could be done to make it universal?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;See US Patent &lt;a href=&quot;https://patents.google.com/patent/US9162881&quot; rel=&quot;nofollow noreferrer&quot;&gt;US9162881B2&lt;/a&gt; &quot;Physical realizations of a universal adiabatic quantum computer&quot; &lt;strong&gt;or&lt;/strong&gt; US Application &lt;a href=&quot;https://patents.google.com/patent/US20150111754&quot; rel=&quot;nofollow noreferrer&quot;&gt;US20150111754A1&lt;/a&gt; &quot;Universal adiabatic quantum computing with superconducting qubits&quot; which is quoted here:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Definition: Basis&lt;/strong&gt; Throughout this specification and the appended claims, the terms “basis” and “bases” are used to denote a set or sets, respectively, of linearly independent vectors that may be combined to completely describe a given vector space. For example, the basis of standard spatial Cartesian coordinates comprises three vectors, the x-axis, the y-axis, and the z-axis. Those of skill in mathematical physics will appreciate that bases may be defined for operator spaces, such as those used to describe Hamiltonians.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Definition: Effective Qubit&lt;/strong&gt; Throughout this specification and the appended claims, the terms “effective qubit” and “effective qubits” are used to denote a quantum system that may be represented as a two-level system. Those of skill in the relevant art will appreciate that two specific levels may be isolated from a multi-level quantum system and used as an effective qubit. Furthermore, the terms “effective qubit” and “effective qubits” are used to denote a quantum system comprising any number of devices that may be used to represent a single two-level system. For example, a plurality of individual qubits may be coupled together in such a way that the entire set, or a portion thereof, of coupled qubits represents a single two-level system.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;[0061]&#xA;A Universal Quantum Computer (UQC) is a quantum computer which is capable of efficiently simulating any other quantum computer. In some embodiments, a Universal Adiabatic Quantum Computer (UAQC) would be able to simulate any quantum computer via adiabatic quantum computation and/or via quantum annealing. In some embodiments, a UAQC would be able to simulate a physical quantum system via adiabatic quantum computation and/or via quantum annealing.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[0062]&#xA;It has been established that local lattice spin Hamiltonians can be used for universal adiabatic quantum computation. However, the 2-local model Hamiltonians used are general and hence do not limit the types of interactions required between spins to be known interactions that can be realized in a quantum processor. The 2-local Ising model with 1-local transverse field has been realized using different of technologies.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[0063]&#xA;This quantum spin model is thought unlikely to be universal for adiabatic quantum computation. See discussion in S. Bravyi et al., 2006 arXiv:quant-ph/0606140v4 or Quant. Inf. Comp. 8, 0361(2008). However, it has been shown that &lt;strong&gt;adiabatic quantum computation can be rendered universal&lt;/strong&gt; and belongs to the Quantum Merlin Arthur complexity class, a quantum analog of the NP complexity class, &lt;strong&gt;by having tunable 2-local diagonal and off-diagonal couplings in addition to tunable 1-local diagonal and off-diagonal biases&lt;/strong&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[0064]&#xA;Diagonal and off-diagonal terms can be defined with reference to the computational basis. The state of a qubit can be one of two basis states or a linear superposition of the two basis states. The two states form a computational basis.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sub&gt;&lt;strong&gt;Note: Refer to the Patent for complete details.&lt;/strong&gt;&lt;/sub&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;What are the reasons why such a thing has not been implemented?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Definition: Universal Adiabatic Quantum Computation&lt;/strong&gt; The concept of “universality” is understood in computer science to describe the scope or range of function of a computing system. A “universal computer” is generally considered to represent a computing system that can emulate any other computing system or, in other terms, a computing system that can be used for the same purposes as any other computing system. For the purposes of the present systems, methods and apparatus, the term “universal adiabatic quantum computer” is intended to describe an adiabatic quantum computing system that can simulate any unitary evolution.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;From: &quot;&lt;a href=&quot;https://arxiv.org/abs/1610.02208&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Information Processing with Superconducting Circuits: a Review&lt;/a&gt;&quot; by G. Wendin (8 Oct 2017), on page 77:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The D-Wave Systems machines are built top-down - scaling up is based on flux qubits and circuits with short coherence time. The technology is based on classical Nb RSFQ circuits combined with Nb rf-SQUID qubits, and forms the basis of the current D-Wave processors. &lt;strong&gt;The architecture is based on a cross-bar network of communication buses allowing (limited) coupling&lt;/strong&gt; of distant qubits. The qubits are operated by varying the dc-bias, changing the qubit energies and qubit qubit couplings. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;As a result, the coherence and entanglement properties have to be investigated by performing various types of experiments on the machines and their components: Physics experiments on the hardware, and ”benchmarking” of the performance by running a range of QA schemes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;During the last three years, the topic has rapidly evolved, and by now a certain common understanding and consensus has been reached. Based on the discussion in some recent papers, the situation can be summed up in the following way:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• The behaviour of the D-Wave machines is consistent with quantum annealing.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• No scaling advantage (quantum speedup) has so far been seen.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• QA is efficient in quickly finding good solutions as long as barriers are narrow, but ultimately gets stuck once broad barriers are encountered&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• The Google D-Wave 2X results showing million-times speedup are for native instances that perfectly fit the hardware graph of the device.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• For generic problems that do not map well onto the hardware of a QA, performance will suffer significantly.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• Even more efficient classical optimisation algorithms exist for these problems, which outperform the current D-Wave 2X device for most problem instances. However, the race is on.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• With improved engineering, especially faster annealing and readout, the time to perform a quantum annealing run can be reduced by a factor 100x over the current generation QA devices.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• However, misspecification of the cost function due to calibration inaccuracies is a challenge that may hamper the performance of analogue QA devices.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• Another challenge is the embedding of problems into the native hardware&#xA;architecture with limited connectivity.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• There is the open question of quantum speedup in analogue QA.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• QA error correction has been demonstrated and may pave a path toward large scale noise-protected AQO devices.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• Typically, classically computationally hard problems also seem to be hard problems for QA devices.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• Improved machine calibration, noise reduction, optimisation of the QA schedule, larger system sizes and tailored spin-glass problems may be needed for demonstrating quantum speedup. However what is hard may not be easy to judge.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;• It remains to see what the newest D-Wave 2000Q system can do with 2000 qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sub&gt;&lt;strong&gt;Note: Refer to the paper for complete details.&lt;/strong&gt;&lt;/sub&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Patent is somewhat more cryptic in it's explanation:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The simulated coupling described in FIG. 9 and FIG. 10 allows multiple types of coupling to be realized by fewer actual coupler types. This can provide greater versatility in a quantum processor where the architecture is best-suited for specific types of couplers. For instance, a superconducting quantum processor that, for whatever reason, is best-suited to implement only ZZ-couplers and XX-couplers may incorporate simulated coupling through mediator qubits to realize the effects of simulated XZ and ZX coupling.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Those of skill in the art will appreciate that, for the purposes of realizing the qubit-coupling architectures taught in the present systems, methods and apparatus, the various embodiments of XX-, ZZ-, XZ-, and ZX-couplers described herein represent non-limiting examples of coupling devices. All of the coupling devices described in the present systems, methods and apparatus may be modified to accommodate the requirements of the specific system in which they are being implemented, or to provide a specific functionality that is advantageous in a particular application.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The present systems, methods and apparatus describe the physical realization of universal adiabatic quantum computation by the implementation of at least two different coupling mechanisms in one processor architecture. Each coupling mechanism provides coupling between a first and a second basis (for example, coupling between X and X, X and Z, or Z and Z), thereby defining a “coupled basis” (for example, XX, XZ, or ZZ). &lt;strong&gt;In accordance with the present systems, methods and apparatus, qubit-coupling architectures that each include at least two different coupled bases, where at least two different coupled bases do not commute, are used to realize the Hamiltonians for universal adiabatic quantum computation. For example, the various embodiments described herein teach that universal adiabatic quantum computation may be physically realized by the simultaneous application of off-diagonal couplers in a qubit-coupling architectures&lt;/strong&gt;. Those of skill in the art will appreciate that this concept may extend to couplers that include the Y-basis, such as XY-, YX-, YY-, ZY-, and YZ-couplers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This specification and the appended claims describe physical implementations of realizable Hamiltonians for universal adiabatic quantum computers by demonstrating universal qubit-coupling architectures. There is a common element to the embodiments of universal coupling schemes described herein, and that is the implementation of at least two different sets of coupling devices between qubits, where the respective bases coupled by the two different sets of coupling devices do not commute. Those of skill in the art will appreciate that such non-commuting couplers may be realized in a variety of different embodiments and implementations and all such embodiments cannot practically be disclosed in this specification. Thus, only two physical embodiments, the XX-ZZ coupling architecture and the XZ-ZX coupling architecture, are detailed herein with the recognition that anyone of skill in the relevant art will acknowledge the extension to any quantum processor architecture implementing non-commuting couplers. Furthermore, those of skill in the art will appreciate that &lt;strong&gt;ertain quantum algorithms or hardware constraints may impose minimum requirements on the number of effective qubits in the quantum processor and/or the number of couplers&lt;/strong&gt;. The present systems, methods and apparatus describe the use of XX and ZZ couplers to simulate XZ and ZX couplers, as well as the use of XZ and ZX couplers to simulate XX and ZZ couplers, thereby proving that a pair of non-commuting couplers in a quantum processor may be used to simulate other coupler schemes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[&lt;strong&gt;My comment&lt;/strong&gt;: Basically, there's only so much room; and improvments are planned.]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the Application it's slightly less cryptic:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[0129] Readout is likely more challenging in AQC than in GMQC. Within the latter paradigm, all qubits are isolated at the end of a computation. Consequently, one can independently read each qubit in a GMQC processor. In contrast, AQC terminates with the target Hamiltonian being asserted. When the Hamiltonian contains off-diagonal elements, read out for AQC can present a challenge. &lt;strong&gt;If the readout process requires the qubit register wavefunction to collapse, then that state will no longer be an eigenstate of the target Hamiltonian. Therefore, it is desirable to devise a method to simultaneously project the states of all qubits in an AQC processor in the presence of finite biases and couplings&lt;/strong&gt;.&lt;/p&gt;&#xA;" OwnerUserId="278" LastActivityDate="2018-04-13T05:31:12.180" CommentCount="0" />
  <row Id="1693" PostTypeId="2" ParentId="1690" CreationDate="2018-04-13T07:25:33.377" Score="3" Body="&lt;p&gt;This sort of architecture has certainly been studied &lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.93.220502&quot; rel=&quot;nofollow noreferrer&quot;&gt;more&lt;/a&gt;, often under the banner of &quot;Global Control&quot;, significantly reducing some of the &lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.88.017904&quot; rel=&quot;nofollow noreferrer&quot;&gt;requirements&lt;/a&gt; (in particular, only requiring an ABABAB... repeating structure instead of ABCABC...). I am not aware of any of these ideas having been implemented. I assume this is partly because there are large overheads in the length of time required to implement something, which makes it more difficult to fit inside the decoherence time of a system.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I was involved in some studies at some point, detailing how you can make larger versions &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0308113&quot; rel=&quot;nofollow noreferrer&quot;&gt;fault tolerant&lt;/a&gt;, but also suggesting implementations in optical lattices (&lt;a href=&quot;http://iopscience.iop.org/article/10.1088/1367-2630/6/1/126/meta&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.73.022310&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;). These were at least partly motivated by this &lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.67.051603&quot; rel=&quot;nofollow noreferrer&quot;&gt;experimental paper&lt;/a&gt;. At a similar time, &lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.70.012306&quot; rel=&quot;nofollow noreferrer&quot;&gt;Zoller&lt;/a&gt; was also looking at this idea.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-04-13T07:25:33.377" CommentCount="0" />
  <row Id="1694" PostTypeId="2" ParentId="20" CreationDate="2018-04-13T07:43:38.933" Score="2" Body="&lt;p&gt;Short answer for the superconducting -&gt; formula example: no, we will not be able to do that. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Longer answer (and more optimistic)&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;We need a one-to-one correspondence between the Hamiltonian of the system we can control in the actual experiment and the theoretical one, in terms of system size (degrees of freedom that we care about) and in terms of parameters.&lt;/li&gt;&#xA;&lt;li&gt;As you describe, we are currently in the situation where we would like to know how a theoretical system evolves (the solution to a known set of equations with a known set of parameters). We map the theoretical system on the experimental one, measure and effectively know the solution to the theoretical equations.&lt;/li&gt;&#xA;&lt;li&gt;The reverse would be: we know the evolution we want to obtain (the theoretical system) and we want to find the experimental system that fits. We would then do an iterative optimization process: controllably change parameters in the experimental system, measure, quantify the fidelity of the final quantum state or of the whole quantum process, and systematically tweak the parameters to optimize this. I do think this is totally doable: it's simply an extension of the forward process It's almost the same experiment, only performed more times.&lt;/li&gt;&#xA;&lt;li&gt;Why we can't apply this to the superconducting -&gt; formula case? First, because of the size requirement: if we want to relate an emerging property to the details of its composition, we probably would need an all-atomic model. Second, because we cannot continuously control the experimental variables in chemical compounds with quantum accuracy.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="1847" LastActivityDate="2018-04-13T07:43:38.933" CommentCount="0" />
  <row Id="1696" PostTypeId="1" AcceptedAnswerId="1698" CreationDate="2018-04-13T09:14:15.857" Score="6" ViewCount="116" Body="&lt;p&gt;Capacitors, Inductors and Resistors are well-known circuit components. Since the proposal of Leon Chua in 1971, the Memristor joined them as a fundamental component.&#xA;I am wondering whether these elements would be somehow imitated by the means of quantum technologies and what would be the requirements to achieve them.&lt;/p&gt;&#xA;" OwnerUserId="1955" LastEditorUserId="26" LastEditDate="2018-04-13T17:49:57.113" LastActivityDate="2018-04-14T16:19:48.497" Title="Do the 'fundamental circuit elements' have a correspondence in quantum technologies?" Tags="&lt;quantum-computer&gt;&lt;circuit-model&gt;" AnswerCount="3" CommentCount="1" />
  <row Id="1697" PostTypeId="2" ParentId="1680" CreationDate="2018-04-13T10:19:41.260" Score="5" Body="&lt;p&gt;I think John Watrous' survey is a great place to start (Professor Watrous recommended it to me a long long time ago and I have been hooked ever since!):&lt;/p&gt;&#xA;&#xA;&lt;p&gt;J. Watrous. Quantum computational complexity. Encyclopedia of Complexity and System Science, Springer, 2009. arXiv:&lt;a href=&quot;https://arxiv.org/abs/0804.3401&quot; rel=&quot;noreferrer&quot;&gt;0804.3401 [quant-ph]&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To the best of my knowledge, it has the highest complexity classes to page ratio.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I also really like Scott Aaronson's 2016 Barbados Lecture Notes:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;S. Aaronson (with A. Bouland and L. Schaeffer). The Complexity of Quantum States and Transformations: From Quantum Money to Black Holes. ECCC &lt;a href=&quot;https://eccc.weizmann.ac.il/report/2016/109/&quot; rel=&quot;noreferrer&quot;&gt;TR16-109&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="1813" LastActivityDate="2018-04-13T10:19:41.260" CommentCount="0" />
  <row Id="1698" PostTypeId="2" ParentId="1696" CreationDate="2018-04-13T12:41:53.450" Score="5" Body="&lt;p&gt;When you ask,&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;I am wondering whether these elements would be somehow imitated by the means of quantum technologies &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;there are different levels on which you can interpret this question. You might mean to ask whether people will realise quantum capacitors, inductors, or resistors, or you might mean to ask whether people will realise components which, in quantum computers, fulfil the same functional roles as capacitors, inductors, or resistors in order to realise digital information processing &amp;mdash; as opposed, for instance to analogue computers to model differential systems of equations.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It must be remembered that quantum technologies are at an early phase, where this is no single way which we can be confident will form the basis of a scalable quantum computer. But we can consider whether there are any cases where there may be interesting analogues.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Many quantum technologies do not represent anything like an electrical circuit, as such. &lt;a href=&quot;https://physics.aps.org/articles/v7/119&quot; rel=&quot;noreferrer&quot;&gt;Ion traps&lt;/a&gt; store bits of information on individual ions, which are moved in a limited and carefully controlled way. There is no natural notion of electrical conduction, resistors, or capacitors in this setting. &lt;a href=&quot;https://physics.stackexchange.com/a/252038/4976&quot;&gt;Quantum dots&lt;/a&gt; are even less like electrical circuits, in that the locations of the physical systems storing the data are fixed.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Flux_qubit&quot; rel=&quot;noreferrer&quot;&gt;Flux qubits&lt;/a&gt;, on the other hand, explicitly include circuits which carry a current (albeit a very small one). The resistance in such circuits is effectively zero, as they are superconducting; but they do involve &lt;a href=&quot;https://en.wikipedia.org/wiki/Josephson_effect&quot; rel=&quot;noreferrer&quot;&gt;Josephson junctions&lt;/a&gt;, which are often considered a non-linear type of inductor.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;This is different from whether or not there is anything in a given platform which is &lt;em&gt;doing the same job&lt;/em&gt; as a resistor, capacitor, or inductor: which may be substantially different on the level of physics, but which are somehow performing a similar role in mediating how a system performs information processing. However, there is a big difference between the way that classical semiconductor electronics realises information processing &amp;mdash; with physical gates, which transform information-carrying input signals to produce output signals &amp;mdash; and the way every current quantum technology realises information processing, which is to perform &lt;em&gt;controlled changes of the dynamics of systems&lt;/em&gt; prepared in some input state, to realise an output state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(The one possible exception are photonic quantum systems, in which the information is carried in light signals rather than in the states of more-or-less static pieces of matter. Perhaps you might argue that an optical memory is analogous to a capacitor somehow, or that a wave plate is analogous to an inductor, but these don't seem to be meaningful functional analogues for how an optical system might be used to perform quantum information processing.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In summary: there is no single answer to your question, because of the different things you might mean by it and because there is no single  platform to refer to in order to provide a definitive answer. But most of the platforms don't have anything which represents these basic electrical components, or which play the same role. Quantum technologies are simply expected to operate differently than classical computing technology.&lt;/p&gt;&#xA;" OwnerUserId="124" LastActivityDate="2018-04-13T12:41:53.450" CommentCount="0" />
  <row Id="1699" PostTypeId="2" ParentId="1367" CreationDate="2018-04-13T14:50:05.847" Score="2" Body="&lt;p&gt;If you want to go beyond learning how to write quantum circuits in the various quantum programming frameworks such as &lt;a href=&quot;https://www.microsoft.com/en-us/quantum/development-kit&quot; rel=&quot;nofollow noreferrer&quot;&gt;Q#&lt;/a&gt;, &lt;a href=&quot;https://github.com/rigetticomputing/pyquil&quot; rel=&quot;nofollow noreferrer&quot;&gt;pyQuil&lt;/a&gt; and &lt;a href=&quot;https://github.com/qiskit&quot; rel=&quot;nofollow noreferrer&quot;&gt;QISKit&lt;/a&gt;, I highly recommend &lt;a href=&quot;https://arxiv.org/pdf/1804.03719.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;this recent paper&lt;/a&gt; with the title &lt;em&gt;Quantum Algorithm Implementations for Beginners&lt;/em&gt; from the Los Alamos National Laboratory. It's a great resource for understanding how to compile and implement various quantum algorithms as well as their oracles and specific subroutines as quantum circuits with the IBM Q Experience. I'd recommend you to implement them in any of the aforementioned programming frameworks and learn the nitty-gritty details as you go.&lt;/p&gt;&#xA;" OwnerUserId="1234" LastActivityDate="2018-04-13T14:50:05.847" CommentCount="0" />
  <row Id="1700" PostTypeId="1" CreationDate="2018-04-13T16:14:55.530" Score="7" ViewCount="98" Body="&lt;p&gt;&lt;strong&gt;The context&lt;/strong&gt;: We are in the solid state. After a photon absortion by a system with a singlet ground state, the system undergoes the spin-conserving fission of one spin singlet exciton into two spin triplet excitons (for context, see &lt;a href=&quot;https://www.nature.com/articles/ncomms15953&quot; rel=&quot;noreferrer&quot;&gt;The entangled triplet pair state in acene and heteroacene materials&lt;/a&gt;). These spin triplet pair propagates in the solid, still entangled. The quantum-computing-related goal of all this operation would be to transfer the entanglement of the two flying qubits to two positions that are fixed in space and are also well protected from decoherence (low-energy excitations of nuclear spins in a paramagnetic ion, for example).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;The problem at hand&lt;/strong&gt; (1), and the question: What would be the requirements to favour said quantum information transfer between the flying qubits and the stationary qubits?&#xA;(I know flying vs stationary qubit scenarios have been explored, but I have no experience in that field).&lt;/p&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="1847" LastEditDate="2018-04-19T14:52:39.243" LastActivityDate="2018-04-19T14:52:39.243" Title="Entanglement transfer of spin-entangled triplet-pair states between flying qubits and stationary qubits" Tags="&lt;architecture&gt;&lt;quantum-entanglement&gt;&lt;quantum-memory&gt;&lt;solid-state&gt;" AnswerCount="0" CommentCount="2" FavoriteCount="1" />
  <row Id="1701" PostTypeId="1" CreationDate="2018-04-13T16:17:00.647" Score="9" ViewCount="116" Body="&lt;p&gt;&lt;strong&gt;The context&lt;/strong&gt;: We are in the solid state. After a photon absortion by a system with a singlet ground state, the system undergoes the spin-conserving fission of one spin singlet exciton into two spin triplet excitons (for context, see &lt;a href=&quot;https://www.nature.com/articles/ncomms15953&quot; rel=&quot;noreferrer&quot;&gt;The entangled triplet pair state in acene and heteroacene materials&lt;/a&gt;). These spin triplet pair propagates in the solid, still entangled. The quantum-computing-related goal of all this operation would be to transfer the entanglement of the two flying qubits to two positions that are fixed in space and are also well protected from decoherence (low-energy excitations of nuclear spins in a paramagnetic ion, for example).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;The problem at hand&lt;/strong&gt; (2), and the question: Eventually, the entanglement between the two triplets is lost, and moreover inevitably the triplets find a way to relax back to the singlet ground state, emitting energy in form of photons. I would like to calculate how these processes are affected by vibrations. I assume the independent relaxation of each of the two triplets can be calculated mostly considering local vibrations, e.g. following a procedure similar to the one we employed here (&lt;a href=&quot;https://pubs.acs.org/doi/abs/10.1021/acs.jpclett.7b00479&quot; rel=&quot;noreferrer&quot;&gt;Determining key local vibrations in the relaxation of molecular spin qubits and single-molecule magnets&lt;/a&gt;). Would the calculation of the loss of entanglement be necessarily related to delocalized vibrational modes that simultaneously involve the local environment of both triplets?&lt;/p&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="1847" LastEditDate="2018-04-20T06:58:47.930" LastActivityDate="2018-04-28T09:02:02.400" Title="Decoherence of spin-entangled triplet-pair states in the solid state: local vs delocalized vibrations" Tags="&lt;architecture&gt;&lt;quantum-entanglement&gt;&lt;quantum-decoherence&gt;&lt;solid-state&gt;" AnswerCount="1" CommentCount="4" FavoriteCount="1" />
  <row Id="1703" PostTypeId="2" ParentId="1696" CreationDate="2018-04-14T14:08:41.957" Score="2" Body="&lt;p&gt;These elements do not necessarily have a correspondence in quantum computers, just as they do not necessarily occur in classical computers (an electronic computer might use some of them, but a mechanical or photonic computer does not necessarily have any equivalent of them).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What has an equivalence are the fundamental gates that form a classical computer. For example, there are only two classical single-bit gates, the direct connection and the NOT gate. A quantum computer has single qubit rotation gates (for example $X$, $Y$, $Z$, $H$, $T$) of which $X$ is a direct equivalent.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-04-14T14:08:41.957" CommentCount="0" />
  <row Id="1704" PostTypeId="2" ParentId="1678" CreationDate="2018-04-14T14:22:58.270" Score="1" Body="&lt;p&gt;I would propose the (perfect) 1-bit random number generator. It is almost trivially easy:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You start with a single qubit in the usual initial state $\left|0\right&amp;gt;$. Then you apply the Hadamard gate $H$ which produces the equal superposition of $\left|0\right&amp;gt;$ and $\left|1\right&amp;gt;$. Finally, you measure this qubit to get either 0 or 1, each with 50% probability.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-04-14T14:22:58.270" CommentCount="0" />
  <row Id="1705" PostTypeId="2" ParentId="1677" CreationDate="2018-04-14T14:31:07.003" Score="-3" Body="&lt;p&gt;I am not sure if the answer to this question, in the sense of not just necessary but also sufficient conditions, is actually known.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, simply using handwaving arguments, you can identify a few actual requirements (necessary conditions):&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Initialization. Without initializing your system, the result will be arbitrary. In fact, you might include all of the five &lt;a href=&quot;https://en.wikipedia.org/wiki/DiVincenzo%27s_criteria&quot; rel=&quot;nofollow noreferrer&quot;&gt;DiVincenzo criteria&lt;/a&gt; for quantum computing in the first place.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Superpositions&lt;/strong&gt; or quantum parallelism. Without superposition, you cannot process &quot;more&quot; information than possible classically.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interference&lt;/strong&gt;. Without interference, you cannot make use of the &quot;extra&quot; information gained from superposition.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Measurement. Without measurement, you cannot get a (classical) result from the computation.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-04-14T14:31:07.003" CommentCount="0" />
  <row Id="1706" PostTypeId="2" ParentId="1696" CreationDate="2018-04-14T16:19:48.497" Score="2" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;I am wondering whether these elements would be somehow imitated by the means of quantum technologies and what would be the requirements to achieve them&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I don't think we would want to achieve quantum equivalents of resistors, capacitors, inductors etc (at least as of now). There are two parts to any circuit: 1) Logical implementation 2) Physical implementation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You need the 'bits' represented as voltages/currents/spins to implement the logic, for which we have the quantum equivalent of qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And when you physically implement a circuit, the concepts of resistance, capacitance etc comes into picture because of the sheer nature of the materials that we are trying to implement the circuit with. There are resistances, capacitances which act as noise in a circuit due to the wires, etc and also resistors and capacitors which we add to the circuit to vary the above said voltages/currents (for eg, a transistor is a variable resistor).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This analogy applies to quantum circuitry when you are implementing qubits. It boils down to the fact that after you have achieved the required logical implementation, in which form do you need your output? Based on this you may need to apply resistances and capacitances to the circuitry to change the voltages/currents.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So in the future if we need to change the qubits in such a way as it somehow mimics the classical resistive action, then we will need a technique to achieve a mechanism which performs the resistive action on qubits (I don't even comprehend what such action would even be for a qubit), then that technique will be called as a quantum resistor. Until then we will resort to classical resistors and capacitors to manipulate the classical signals, after the qubits have done their job.&lt;/p&gt;&#xA;" OwnerUserId="419" LastActivityDate="2018-04-14T16:19:48.497" CommentCount="0" />
  <row Id="1707" PostTypeId="5" CreationDate="2018-04-15T00:16:57.453" Score="0" Body="&lt;p&gt;There are a number of different distance measures used in quantum computing:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Fidelity_of_quantum_states&quot; rel=&quot;nofollow noreferrer&quot;&gt;Fidelity&lt;/a&gt;: For two states (density matrices $\rho$ and $\sigma$) the &lt;em&gt;fidelity&lt;/em&gt; is defined as either $$F = \text{Tr}\sqrt{\sqrt \rho\sigma\sqrt\rho}\quad\text{ or }\quad F' = F^2$$ and measures how close the two states are. when $F=1$, the two states are equal. When comparing two quantum channels, $\rho$ and $\sigma$ get replaced by $\mathcal E\left(\rho\right)$ and $\mathcal E'\left(\rho\right)$ (for some different $\rho$). The maximum, minimum and average fidelities can then be considered, where the maximum and minimum are taken over states and the average is uses the 'Haar measure over pure states' $d\psi$, which is the integral $$\int F\left(\mathcal E\left(\left|\psi\rangle\langle\psi\right|\right), \mathcal E'\left(\left|\psi\rangle\langle\psi\right|\right)\right) d\psi,$$ where $\left|\psi\rangle\langle\psi\right|$ is a pure state.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Fidelity can then be used to define the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bures_metric#Bures_distance&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bures distance&lt;/a&gt;, $D_B = \sqrt{2\left(1-F\right)}$.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Defining $M = \rho-\sigma$ when comparing states or $M = \mathcal E\left(\rho\right) - \mathcal E'\left(\rho\right)$ when comparing channels gives:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Schatten_norm&quot; rel=&quot;nofollow noreferrer&quot;&gt;Schatten norm&lt;/a&gt;: $$\lVert M\rVert_p = \left[\text{Tr}\left(\sqrt{M^\dagger M}^p\right)\right]^{1/p}.$$ Commonly used values of $p$ are $1$ (trace norm), $2$ (Frobenius norm) and $\infty$ (infinity norm).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;The trace &lt;em&gt;distance&lt;/em&gt; is half the trace norm.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Operator_norm&quot; rel=&quot;nofollow noreferrer&quot;&gt;Operator norm&lt;/a&gt;: $$\lVert M\rVert_p = \sup_\psi\frac{\lVert M\left|\psi\right&amp;gt;\rVert_p}{\lVert\left|\psi\right&amp;gt;\rVert_p},$$ where, for a state $\left|\phi\right&amp;gt;$, the vector $p$-norm is $\lVert\left|\phi\right&amp;gt;\rVert_p = \left(\sum_{i=1}^n\lvert\left|\phi\right&amp;gt;_i\rvert^p\right)^{1/p}$ where $\left|\phi\right&amp;gt;_i$ is the $i^{th}$ element of $\phi$. A common case is $p=2$, known as the $L_2$ or &lt;em&gt;Euclidean&lt;/em&gt; norm, which is the maximum singular value of $M$.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;For a channel $\mathcal E:\mathcal H\rightarrow \mathcal H$ for a Hilbert space $\mathcal H$, defining a density matrix $\rho \in \mathcal H\otimes\mathcal K$, for an 'ancillary' Hilbert space $\mathcal K$ with $\dim\mathcal K\geq\dim\mathcal H$:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Diamond norm: $$\lVert\mathcal E - \mathcal E'\rVert_\Diamond = \sup_\rho\left\lVert\left(\mathcal E\otimes \mathcal I_{\mathcal K}\right)\rho - \left(\mathcal E'\otimes \mathcal I_{\mathcal K}\right)\rho\right\rVert_1$$ where the trace norm is used and $\mathcal I_{\mathcal K}$ is the identity operator on $\mathcal K$. Methods of calculating the diamond norm can be found in e.g. &lt;a href=&quot;https://arxiv.org/abs/1004.4110v1&quot; rel=&quot;nofollow noreferrer&quot;&gt;this paper by Benenti and Strini&lt;/a&gt;.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="23" LastEditorUserId="23" LastEditDate="2018-04-15T00:16:57.453" LastActivityDate="2018-04-15T00:16:57.453" CommentCount="0" />
  <row Id="1708" PostTypeId="4" CreationDate="2018-04-15T00:16:57.453" Score="0" Body="A distance measure can be used to find how 'far apart' two different quantum states or channels are. This tag is for general questions about different distance measures or when comparing different states or channels. For a specific measure, consider also using a specific tag for that measure." OwnerUserId="23" LastEditorUserId="23" LastEditDate="2018-04-15T00:16:57.453" LastActivityDate="2018-04-15T00:16:57.453" CommentCount="0" />
  <row Id="1709" PostTypeId="2" ParentId="1429" CreationDate="2018-04-15T04:12:00.540" Score="2" Body="&lt;p&gt;Another approach to topological quantum computing could be that of topological insulators, and the use of the 1/2 integer quantum Hall effect. These insulators have potential to be less error prone. Topological insulators, are both insulators, and conductors, at the same time, and being less error prone, have potential to provide a robust, quantum computing environment. Such Topological Insulator devices could be used in a topological quantum computer, by being a connector in between a classical system, and a quantum computer. &lt;a href=&quot;https://spectrum.ieee.org/nanoclast/semiconductors/materials/toplogical-insulators-take-step-closer-to-computing-uses&quot; rel=&quot;nofollow noreferrer&quot;&gt; IEEE Reference &lt;/a&gt;. &lt;/p&gt;&#xA;" OwnerUserId="429" LastActivityDate="2018-04-15T04:12:00.540" CommentCount="0" />
  <row Id="1710" PostTypeId="1" AcceptedAnswerId="1718" CreationDate="2018-04-15T06:45:54.140" Score="6" ViewCount="301" Body="&lt;p&gt;&lt;strong&gt;Problem Statement:&lt;/strong&gt; We are given a $2-1$ function $f:\{0,1\}^{n}\to\{0,1\}^{n}$ such that: there is a secret string $s\in\{0,1\}^{n}$ such that: $f(x)=f(x\oplus s)$. Challenge: find $s$.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;Simon's algorithm&lt;/strong&gt; says:&lt;/p&gt;&#xA;  &#xA;  &lt;ol&gt;&#xA;  &lt;li&gt;&lt;p&gt;Set up a random superposition $$\frac{1}{\sqrt{2}}|r\rangle + \frac{1}{\sqrt{2}}|r\oplus s\rangle$$&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Fourier sample to get a random $y$: $$y.s=0\ (\text{mod 2})$$&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Repeat steps $n-1$ times to generate $n-1$ linear equations in $s$.&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;/ol&gt;&#xA;  &#xA;  &lt;p&gt;Solve for $s$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I don't understand steps (1) and (2). &lt;em&gt;Why&lt;/em&gt; and &lt;em&gt;how&lt;/em&gt; exactly do we set up the random superposition? How does it help? Also, in step (2), what does the dot operator (in $y.s$) stand for? Bit-wise multiplication?&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-05-01T07:10:01.507" LastActivityDate="2018-05-01T07:10:01.507" Title="How exactly does Simon's algorithm solve the Simon's problem?" Tags="&lt;quantum-algorithms&gt;&lt;circuit-model&gt;&lt;simons-algorithm&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="1711" PostTypeId="5" CreationDate="2018-04-15T06:54:15.173" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T06:54:15.173" LastActivityDate="2018-04-15T06:54:15.173" CommentCount="0" />
  <row Id="1712" PostTypeId="4" CreationDate="2018-04-15T06:54:15.173" Score="0" Body="For questions regarding complexity analysis of quantum algorithms and comparisons with complexities of classical algorithms " OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T07:42:29.963" LastActivityDate="2018-04-15T07:42:29.963" CommentCount="0" />
  <row Id="1713" PostTypeId="5" CreationDate="2018-04-15T06:58:07.093" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T06:58:07.093" LastActivityDate="2018-04-15T06:58:07.093" CommentCount="0" />
  <row Id="1714" PostTypeId="4" CreationDate="2018-04-15T06:58:07.093" Score="0" Body="Refers to the state of an isolated quantum system. A quantum state provides a probability distribution for the value of each observable, i.e. for the outcome of each possible measurement on the system. A mixture of quantum states is again a quantum state." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T07:42:41.043" LastActivityDate="2018-04-15T07:42:41.043" CommentCount="0" />
  <row Id="1715" PostTypeId="1" AcceptedAnswerId="1720" CreationDate="2018-04-15T09:37:38.783" Score="5" ViewCount="101" Body="&lt;p&gt;In my constant thrill to know more about Quantum Computing I wanna know what is this relation. Additionally: Can one use squeezed light to effect multi-qubit operations on single photon qubits, or are these completely independent approaches? &lt;/p&gt;&#xA;" OwnerUserId="1931" LastEditorUserId="1847" LastEditDate="2018-04-15T14:09:40.227" LastActivityDate="2018-04-15T14:09:40.227" Title="What is the relation between single photon qubits and squeezed light qubits?" Tags="&lt;architecture&gt;&lt;qubit&gt;&lt;quantum-gate&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="1716" PostTypeId="1" CreationDate="2018-04-15T09:47:10.927" Score="6" ViewCount="102" Body="&lt;p&gt;In his &lt;a href=&quot;http://homepages.cwi.nl/~rdewolf/oratie-final.pdf&quot; rel=&quot;noreferrer&quot;&gt;inaugural lecture&lt;/a&gt;, Ronald de Wolf states&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;People are working with quantum objects, but trying to make them behave as classical as possible. (...) Instead of suppressing them to make systems behave as classically as possible, why not try to&#xA;  benefit from them?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;While he goes on to state that looking at fully exploiting the quantum effects is more interesting, I do wonder if and how the 'naturally occurring' quantum effects on extremely small transistors could be used to get better classical (or perhaps some classical/quantum hybrid) computation. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Obviously, the design of those transistors needs to use quantum mechanics, but not necessarily quantum information or quantum computation theory. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Has there been any promising research or results in this direction? Or are the good reasons why this wouldn't work?&lt;/p&gt;&#xA;" OwnerUserId="253" LastActivityDate="2018-04-22T15:03:14.547" Title="Can the theory of quantum computation assist in the miniaturization of transistors?" Tags="&lt;quantum-computer&gt;&lt;classical-computing&gt;" AnswerCount="3" CommentCount="0" />
  <row Id="1717" PostTypeId="1" CreationDate="2018-04-15T10:50:59.103" Score="5" ViewCount="63" Body="&lt;p&gt;Pairs of entangled qubits (or Bell pairs, or EPR pairs) are a fundamental resource for quantum computing, in the sense that any computational platform that cannot generate entanglement will also be unable to provide a computational advantage.[1] In two recent questions, &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1701/decoherence-of-spin-entangled-triplet-pair-states-in-the-solid-state-local-vs-d&quot;&gt;Decoherence of spin-entangled triplet-pair states in the solid state: local vs delocalized vibrations&lt;/a&gt; and &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1700/entanglement-transfer-of-spin-entangled-triplet-pair-states-between-flying-qubit&quot;&gt;Entanglement transfer of spin-entangled triplet-pair states between flying qubits and stationary qubits&lt;/a&gt;, I asked about a physical scenario with the goal of &lt;strong&gt;generating entangled qubits pairs in the solid state&lt;/strong&gt;. I know of this result of 2013, &lt;a href=&quot;https://arxiv.org/abs/1212.6136&quot; rel=&quot;nofollow noreferrer&quot;&gt;Heralded entanglement between solid-state qubits separated by 3 meters&lt;/a&gt;, which used photons and NV-centers in diamond, so this can be achieved in practice. Hoewever, I am not up-to-date on what is currently the best option. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is: &lt;strong&gt;What is the current technological status for the generation of entangled qubit pairs in the solid state?&lt;/strong&gt; In particular, which options are currently fastest and/or most reliable?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;[1] Thanks to Niel de Beaudrap who pointed that out in a comment.&lt;/em&gt;&lt;/p&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="1847" LastEditDate="2018-04-15T17:51:41.703" LastActivityDate="2018-04-16T14:57:33.863" Title="What are the current solutions to generate entangled qubits in the solid state?" Tags="&lt;architecture&gt;&lt;quantum-entanglement&gt;&lt;experimental-results&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="1" />
  <row Id="1718" PostTypeId="2" ParentId="1710" CreationDate="2018-04-15T11:03:42.410" Score="4" Body="&lt;p&gt;$$&#xA;\newcommand{\bra}[1]{\left&amp;lt;#1\right|}\newcommand{\ket}[1]{\left|#1\right&amp;gt;}\newcommand{\bk}[2]{\left&amp;lt;#1\middle|#2\right&amp;gt;}\newcommand{\bke}[3]{\left&amp;lt;#1\middle|#2\middle|#3\right&amp;gt;}\newcommand{\proj}[1]{\left|#1\right\rangle\left\langle#1\right|}&#xA;$$&#xA;Much of the functionality here is the same as the Bernstien-Vazirani algorithm, if that helps. The following is more or less copy and pasted from some lecture notes I prepared at some point. It explains it in a slightly different way to the direction you're coming at it from, but hopefully gets you going in the right direction.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The circuit is, in principle, the same as for the Bernstein-Vazirani Algorithm, except that since the output of the function evaluation is $n$ bits, the second register, which is used for the reversible function evaluation, is also $n$ bits,&#xA;&lt;a href=&quot;https://i.stack.imgur.com/kuLFN.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/kuLFN.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&#xA;This function evaluation is represented by the controlled-controlled...-controlled-U gate, acting as $\ket{x}\ket{y}\mapsto\ket{x}\ket{y\oplus f(x)}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We start with the first set of Hadamards producing an equally weighted superposition of all strings of $n$ bits,&#xA;$$&#xA;\ket{0}\ket{0}\rightarrow\frac{1}{\sqrt{2^n}}\sum_{x\in\{0,1\}^n}\ket{x}\ket{0}.&#xA;$$&#xA;This is followed by the function evaluation,&#xA;$$&#xA;\rightarrow\frac{1}{\sqrt{2^n}}\sum_{x\in\{0,1\}^n}\ket{x}\ket{f(x)}.&#xA;$$&#xA;At this point, you &lt;em&gt;could&lt;/em&gt; measure the second register. This will return a random value of $f(r)$, so that the overall state of the system is in&#xA;$$&#xA;\frac{1}{\sqrt{2}}(\ket{r}+\ket{r\oplus s})\ket{f(r)}.&#xA;$$&#xA;So, the point is that you don't have to actively prepare different values of $r$; they will be selected for you by the measurement. We'll have to make a bit of an argument later on about how likely it is that we get new information each time we make such a measurement, but it'll all work out.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Actually, I don't usually think about performing the measurement at this point; it's unnecessary (but would allow you to avoid the density matrix formalism in the following calculation). Instead, calculate the action of the final set of Hadamards, yielding the final output state&#xA;$$&#xA;\frac{1}{2^n}\sum_{x,z}(-1)^{x\cdot z}\ket{z}\ket{f(x)}.&#xA;$$&#xA;Here,&#xA;$$&#xA;x\cdot z= x_1z_1\oplus x_2z_2\oplus x_3z_3 \oplus\ldots \oplus x_nz_n,&#xA;$$&#xA;where $x_k$ is the $k^{th}$ bit of $x$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now we collect unique values of $f(x)$,&#xA;$$&#xA;\frac{1}{2^n}\sum_{z,f(x)}\left((-1)^{x\cdot z}+(-1)^{(x\oplus s)\cdot z}\right)\ket{z}\ket{f(x)}.&#xA;$$&#xA;One can therefore verify that the output of the algorithm is&#xA;$$&#xA;\frac{1}{2^{n-1}}\sum_{z: s\cdot z=0}(-1)^{x\cdot z}\ket{z}\sum_{f(x)}\ket{f(x)}.&#xA;$$&#xA;The state of the first register clearly contains the information about $s$, but we need to extract it. Measuring the second register is not necessary (we could do it, but it doesn't help). Instead, let's trace out the second register, so we get&#xA;$$&#xA;\rho=\frac{1}{2^{2n-2}}\sum_{z: s\cdot z=0}\sum_{y: s\cdot y=0}\sum_x(-1)^{x\cdot(y\oplus z)}\ket{y}\bra{z}.&#xA;$$&#xA;By performing the sum over $x$, we are left with&#xA;$$&#xA;\rho=\frac{1}{2^{n-1}}\sum_{s\cdot z=0}\proj{z}.&#xA;$$&#xA;Measurement of the first register yields a binary string $z$ where $s\cdot z=0$. If we had $n-1$ such examples which are linearly independent, we would be able to determine $s$. This requires repeated application of the algorithm to find enough strings (this is the 'Fourier Sampling' part).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We must now justify that a linear number of applications is sufficient to find enough strings with high probability. In the absolute worst case, when we have found $n-2$ vectors, we must find the one remaining bit of information when there are still $2^{n-1}$ strings $s\cdot z=0$ to sample. These must constitute $1-2^{n-2}/2^{n-1}=\frac12$ of the space. Hence, the average number of trials to find one of these vectors is given by&#xA;$$&#xA;\frac{1}{2}\sum_{n=0}^\infty\frac{n+1}{2^n},&#xA;$$&#xA;which is readily evaluated using the following identities,&#xA;\begin{eqnarray}&#xA;\sum_{n=0}^\infty r^n&amp;amp;=&amp;amp;\frac{1}{1-r}	\nonumber\\&#xA;\frac{d}{dr}r\sum_{n=0}^\infty r^n&amp;amp;=&amp;amp;\sum_{n=0}^\infty (n+1)r^n.	\nonumber&#xA;\end{eqnarray}&#xA;On average, we always find another linearly independent vector by making $2$ samples, i.e. within $2n$ steps, we have a high probability of determining $s$. It is this final part of the argument, requiring some classical post-processing that differentiates Simon's algorithm from the Bernstein-Vazirani algorithm. Essentially, the difference comes from not knowing the eigenvectors of $U$ in advance. If we did, we could prepare the second register in a fixed state. Instead, it is prepared in a superposition of different eigenstates (which coincides with a nice state to prepare) and we have to rely on a certain amount of randomness to sample the elements we need.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-04-15T11:03:42.410" CommentCount="0" />
  <row Id="1719" PostTypeId="2" ParentId="1488" CreationDate="2018-04-15T12:45:51.220" Score="3" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Is there a reliable resource/website that calculates which key sizes are currently at risk, based on how fast the newest quantum computers are?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;As other answers have conveyed, if a given algorithm is susceptible to attack by quantum computers, it's not really a question of going to a larger key length; it wouldn't take much technological advancement to bring that larger key length under threat (and you never really know what the current state of the art is). We've seen from the history of classical computers (e.g. Moore's Law) that once you pass some basic threshold, exponential improvements are possible.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What other answers haven't mentioned is timeliness. Yes, you could ask &quot;based on our current state of technology, is a particular algorithm &amp;amp; key length combination secure?&quot;, but that is only an instantaneous security. Sometimes that's good enough. If you want to agree a clandestine meeting with someone tomorrow, and so long as nobody finds out about it until after the fact, that's fine, you can use any algorithm that gave a yes answer to the question. However, what if that information is to remain secret for longer? Perhaps you're emailing someone the identity of an under-cover agent they are to meet. It's not good enough that the identity of that individual is protected now, but it must also be protected going into the future. Any data like that, you essentially have to assume that if it has been encrypted with an algorithm that is potentially susceptible to attack by a quantum computer, it will be read at some point, and is therefore compromised. Actually, if you're super-paranoid, you should assume this about all crypto algorithms anyway because even if the theory says they're perfectly secure, their practical implementation may be faulty and susceptible to cracking.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Or possibly, will new algorithms be created which try to prevent quantum computers from being able to crack them easily?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;To replace these potentially breakable systems, you need new methods, which generally come under the banner of post-quantum crypto. Some of these exist already, but there are varying levels of confidence about how well they will actually hold up to attack. Much like with factoring numbers on a classical computer, where the difficulty was essentially based on &quot;lots of people have tried, and nobody's succeeded in doing it efficiently, so we guess it isn't possible&quot;, the argument is similar, but not so many people have tried, and not for so long, as to have a huge weight of confidence yet, although the aim is to back it up with a bit more rigour from CS, making connections to complexity classes, and particularly the assumption P$\neq$NP.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-04-15T12:45:51.220" CommentCount="0" />
  <row Id="1720" PostTypeId="2" ParentId="1715" CreationDate="2018-04-15T13:09:23.203" Score="4" Body="&lt;p&gt;By photon qubits, I'm assuming that you meant single-photon qubit systems. &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Can one use squeezed light to effect multi-qubit operations on photon qubits, or are these completely independent approaches?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There are two protocols in quantum communication namely, discrete-varibale (dv) and continuous variable (cv). Squeezed light qubits are a part of cv quantum communication protocols because continuous-variable entanglement can be efficiently produced using squeezed light. Whereas single-photon qubits are part of the dv protocols. So to answer your question, they are both different approaches.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The main difference between these protocols is explained in this review paper &quot;&lt;a href=&quot;https://arxiv.org/pdf/quant-ph/0410100.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum information with continuous variables&lt;/a&gt;&quot;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;A valuable feature of quantum optical implementations based upon continuous variables, related to their high efficiency, is their 'unconditionalness'. Quantum resources such as entangled states emerge from the nonlinear optical interaction of a laser with a crystal  in an unconditional fashion. This 'unconditionalness' is hard to obtain in dv qubit-based implementations based on single-photon states.&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To expand on the answer, &lt;a href=&quot;http://www.qi.aei-hannover.de/information-press/what-is-squeezed-light&quot; rel=&quot;nofollow noreferrer&quot;&gt;Splitting squeezed light on beam splitter results in two output beams in an entangled state&lt;/a&gt;. The quality of this entanglement produced leads to imperfect communication, where the degree of imperfection depends on the amount of squeezing of the laser light involved.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, in a realistic quantum key distribution scenario, the cv states accumulate noise and emerge at the receiver as contaminated versions of the sender’s input states. The dv quantum information encoded in single-photon states is reliably conveyed for each photon that is not absorbed during transmission.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I hope that this cleared your question.&lt;/p&gt;&#xA;" OwnerUserId="419" LastActivityDate="2018-04-15T13:09:23.203" CommentCount="2" />
  <row Id="1721" PostTypeId="5" CreationDate="2018-04-15T13:46:46.433" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T13:46:46.433" LastActivityDate="2018-04-15T13:46:46.433" CommentCount="0" />
  <row Id="1722" PostTypeId="4" CreationDate="2018-04-15T13:46:46.433" Score="0" Body="Quantum supremacy or &quot;quantum advantage&quot; is the potential ability of quantum computing devices to solve problems that classical computers practically cannot." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T14:07:31.043" LastActivityDate="2018-04-15T14:07:31.043" CommentCount="0" />
  <row Id="1723" PostTypeId="5" CreationDate="2018-04-15T13:48:02.170" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T13:48:02.170" LastActivityDate="2018-04-15T13:48:02.170" CommentCount="0" />
  <row Id="1724" PostTypeId="4" CreationDate="2018-04-15T13:48:02.170" Score="0" Body="Trapped ion quantum computing is one proposed approach to a large-scale quantum computing. Ions, or charged atomic particles, can be confined and suspended in free space using electromagnetic fields. Qubits are stored in stable electronic states of each ion, and quantum information can be transferred through the collective quantized motion of the ions in a shared trap (interacting through the Coulomb force)." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T14:06:40.983" LastActivityDate="2018-04-15T14:06:40.983" CommentCount="0" />
  <row Id="1725" PostTypeId="5" CreationDate="2018-04-15T13:49:55.657" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T13:49:55.657" LastActivityDate="2018-04-15T13:49:55.657" CommentCount="0" />
  <row Id="1726" PostTypeId="4" CreationDate="2018-04-15T13:49:55.657" Score="0" Body="Quantum Software Development Kit for writing quantum computing experiments, programs, and applications." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T14:07:27.610" LastActivityDate="2018-04-15T14:07:27.610" CommentCount="0" />
  <row Id="1727" PostTypeId="5" CreationDate="2018-04-15T13:52:22.077" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T13:52:22.077" LastActivityDate="2018-04-15T13:52:22.077" CommentCount="0" />
  <row Id="1728" PostTypeId="4" CreationDate="2018-04-15T13:52:22.077" Score="0" Body="For questions related to microscopic systems made of a large number of interacting particles as relevant to quantum computing, or simulation of such systems using a quantum computer." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T14:10:00.980" LastActivityDate="2018-04-15T14:10:00.980" CommentCount="0" />
  <row Id="1729" PostTypeId="5" CreationDate="2018-04-15T13:54:36.870" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T13:54:36.870" LastActivityDate="2018-04-15T13:54:36.870" CommentCount="0" />
  <row Id="1730" PostTypeId="4" CreationDate="2018-04-15T13:54:36.870" Score="0" Body="Bayesian learning is a method of statistical inference in which Bayes' theorem is used to update the probability for a hypothesis as more evidence or information becomes available. Use this tag for questions regarding bayesian learning using quantum computers and/or quantum algorithms." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T14:06:50.903" LastActivityDate="2018-04-15T14:06:50.903" CommentCount="0" />
  <row Id="1731" PostTypeId="5" CreationDate="2018-04-15T13:57:09.247" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T13:57:09.247" LastActivityDate="2018-04-15T13:57:09.247" CommentCount="0" />
  <row Id="1732" PostTypeId="4" CreationDate="2018-04-15T13:57:09.247" Score="0" Body="In its simplest terms, quantum control is essentially the design of Hamiltonians to reach a desired final state of a quantum system from a specified initial state in a certain time duration.&#xD;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T16:00:45.237" LastActivityDate="2018-04-15T16:00:45.237" CommentCount="0" />
  <row Id="1733" PostTypeId="5" CreationDate="2018-04-15T13:57:49.833" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T13:57:49.833" LastActivityDate="2018-04-15T13:57:49.833" CommentCount="0" />
  <row Id="1734" PostTypeId="4" CreationDate="2018-04-15T13:57:49.833" Score="0" Body="A quantum channel is a communication channel which can transmit quantum information, as well as classical information. An example of quantum information is the state of a qubit" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T14:07:00.280" LastActivityDate="2018-04-15T14:07:00.280" CommentCount="0" />
  <row Id="1735" PostTypeId="5" CreationDate="2018-04-15T13:59:16.093" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T13:59:16.093" LastActivityDate="2018-04-15T13:59:16.093" CommentCount="0" />
  <row Id="1736" PostTypeId="4" CreationDate="2018-04-15T13:59:16.093" Score="0" Body="For questions related to usage of quantum computers for biological computing and/or their comparison with biological computers. " OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T14:09:45.220" LastActivityDate="2018-04-15T14:09:45.220" CommentCount="0" />
  <row Id="1737" PostTypeId="5" CreationDate="2018-04-15T14:00:07.267" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:00:07.267" LastActivityDate="2018-04-15T14:00:07.267" CommentCount="0" />
  <row Id="1738" PostTypeId="4" CreationDate="2018-04-15T14:00:07.267" Score="0" Body="Adiabatic quantum computation (AQC) is a form of quantum computing which relies on the adiabatic theorem to do calculations and is closely related to and may be regarded as a subclass of, quantum annealing." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T14:08:59.377" LastActivityDate="2018-04-15T14:08:59.377" CommentCount="0" />
  <row Id="1739" PostTypeId="5" CreationDate="2018-04-15T14:01:07.827" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:01:07.827" LastActivityDate="2018-04-15T14:01:07.827" CommentCount="0" />
  <row Id="1740" PostTypeId="4" CreationDate="2018-04-15T14:01:07.827" Score="0" Body="For questions regarding approximating results using quantum computers and/or quantum algorithms." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T14:07:34.850" LastActivityDate="2018-04-15T14:07:34.850" CommentCount="0" />
  <row Id="1741" PostTypeId="5" CreationDate="2018-04-15T14:01:44.353" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:01:44.353" LastActivityDate="2018-04-15T14:01:44.353" CommentCount="0" />
  <row Id="1742" PostTypeId="4" CreationDate="2018-04-15T14:01:44.353" Score="0" Body="Quantum cryptography is the science of exploiting quantum mechanical properties to perform cryptographic tasks." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T14:07:20.687" LastActivityDate="2018-04-15T14:07:20.687" CommentCount="0" />
  <row Id="1743" PostTypeId="5" CreationDate="2018-04-15T14:04:06.787" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:04:06.787" LastActivityDate="2018-04-15T14:04:06.787" CommentCount="0" />
  <row Id="1744" PostTypeId="4" CreationDate="2018-04-15T14:04:06.787" Score="0" Body="For questions regarding solving physics problems using quantum computers or applications of quantum computing in physics." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T14:08:50.477" LastActivityDate="2018-04-15T14:08:50.477" CommentCount="0" />
  <row Id="1745" PostTypeId="5" CreationDate="2018-04-15T14:06:30.060" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:06:30.060" LastActivityDate="2018-04-15T14:06:30.060" CommentCount="0" />
  <row Id="1746" PostTypeId="4" CreationDate="2018-04-15T14:06:30.060" Score="0" Body="For questions regarding the famous Simon's algorithm which solves Simon's problem exponentially faster than any deterministic or probabilistic classical algorithm, requiring exponentially less computational power than the best classical probabilistic algorithm." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T14:07:14.707" LastActivityDate="2018-04-15T14:07:14.707" CommentCount="0" />
  <row Id="1747" PostTypeId="5" CreationDate="2018-04-15T14:07:35.463" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:07:35.463" LastActivityDate="2018-04-15T14:07:35.463" CommentCount="0" />
  <row Id="1748" PostTypeId="4" CreationDate="2018-04-15T14:07:35.463" Score="0" Body="In Bell test experiments, the term quantum correlation has come to mean the expectation value of the product of the outcomes on the two sides. In other words, the expected change in physical characteristics as one quantum system passes through an interaction site. " OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T14:09:09.820" LastActivityDate="2018-04-15T14:09:09.820" CommentCount="0" />
  <row Id="1749" PostTypeId="5" CreationDate="2018-04-15T14:08:37.793" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:08:37.793" LastActivityDate="2018-04-15T14:08:37.793" CommentCount="0" />
  <row Id="1750" PostTypeId="4" CreationDate="2018-04-15T14:08:37.793" Score="0" Body="Continuous-variable quantum computing is a type of quantum computing that makes use of physical observables, like the strength of an electromagnetic field, whose numerical values belong to continuous intervals." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T14:09:04.497" LastActivityDate="2018-04-15T14:09:04.497" CommentCount="0" />
  <row Id="1751" PostTypeId="5" CreationDate="2018-04-15T14:09:14.637" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:09:14.637" LastActivityDate="2018-04-15T14:09:14.637" CommentCount="0" />
  <row Id="1752" PostTypeId="4" CreationDate="2018-04-15T14:09:14.637" Score="0" Body="Quantum error correction (QEC) is used in quantum computing to protect quantum information from errors due to decoherence and other quantum noise. Quantum error correction is essential if one is to achieve fault-tolerant quantum computation that can deal not only with noise on stored quantum information, but also with faulty quantum gates, faulty quantum preparation, and faulty measurements." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T14:10:06.983" LastActivityDate="2018-04-15T14:10:06.983" CommentCount="0" />
  <row Id="1753" PostTypeId="5" CreationDate="2018-04-15T14:09:56.007" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:09:56.007" LastActivityDate="2018-04-15T14:09:56.007" CommentCount="0" />
  <row Id="1754" PostTypeId="4" CreationDate="2018-04-15T14:09:56.007" Score="0" Body="In quantum mechanics, the quantum eraser experiment is an interferometer experiment that demonstrates several fundamental aspects of quantum mechanics, including quantum entanglement and complementarity" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T14:10:12.007" LastActivityDate="2018-04-15T14:10:12.007" CommentCount="0" />
  <row Id="1755" PostTypeId="5" CreationDate="2018-04-15T14:10:51.823" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:10:51.823" LastActivityDate="2018-04-15T14:10:51.823" CommentCount="0" />
  <row Id="1756" PostTypeId="4" CreationDate="2018-04-15T14:10:51.823" Score="0" Body="For questions regarding usage of Majorana particles for quantum computation. A Majorana fermion, also referred to as a Majorana particle, is a fermion that is its own antiparticle. They were hypothesized by Ettore Majorana in 1937. The term is sometimes used in opposition to a Dirac fermion, which describes fermions that are not their own antiparticles." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T15:03:20.817" LastActivityDate="2018-04-15T15:03:20.817" CommentCount="0" />
  <row Id="1757" PostTypeId="5" CreationDate="2018-04-15T14:12:35.847" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:12:35.847" LastActivityDate="2018-04-15T14:12:35.847" CommentCount="0" />
  <row Id="1758" PostTypeId="4" CreationDate="2018-04-15T14:12:35.847" Score="0" Body="For questions regarding quantum computing on the Alibaba Cloud. Alibaba Cloud, a subsidiary of Alibaba Group, is a global cloud computing company headquartered in Hangzhou. Alibaba Cloud provides a suite of cloud computing services that covers elastic computing, object storage, relational database, big data analysis, and artificial intelligence in fifteen geographical regions around the globe. " OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T15:03:28.890" LastActivityDate="2018-04-15T15:03:28.890" CommentCount="0" />
  <row Id="1759" PostTypeId="5" CreationDate="2018-04-15T14:15:12.760" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:15:12.760" LastActivityDate="2018-04-15T14:15:12.760" CommentCount="0" />
  <row Id="1760" PostTypeId="4" CreationDate="2018-04-15T14:15:12.760" Score="0" Body="For questions regarding quantum computation by State Injection" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T15:05:23.930" LastActivityDate="2018-04-15T15:05:23.930" CommentCount="0" />
  <row Id="1761" PostTypeId="5" CreationDate="2018-04-15T14:16:03.020" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:16:03.020" LastActivityDate="2018-04-15T14:16:03.020" CommentCount="0" />
  <row Id="1762" PostTypeId="4" CreationDate="2018-04-15T14:16:03.020" Score="0" Body="Entanglement distillation is the transformation of N copies of an arbitrary entangled state into some number of approximately pure Bell pairs, using only local operations and classical communication (LOCC)." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T15:04:59.990" LastActivityDate="2018-04-15T15:04:59.990" CommentCount="0" />
  <row Id="1763" PostTypeId="5" CreationDate="2018-04-15T14:17:31.800" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:17:31.800" LastActivityDate="2018-04-15T14:17:31.800" CommentCount="0" />
  <row Id="1764" PostTypeId="4" CreationDate="2018-04-15T14:17:31.800" Score="0" Body="The randomized benchmarking method yields estimates of the computationally relevant errors without relying on accurate state preparation and measurement. Since it involves long sequences of randomly chosen gates, it also verifies that error behavior is stable when used in long computations." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T15:03:09.443" LastActivityDate="2018-04-15T15:03:09.443" CommentCount="0" />
  <row Id="1765" PostTypeId="5" CreationDate="2018-04-15T14:18:36.227" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:18:36.227" LastActivityDate="2018-04-15T14:18:36.227" CommentCount="0" />
  <row Id="1766" PostTypeId="4" CreationDate="2018-04-15T14:18:36.227" Score="0" Body="In quantum information theory, fidelity is a measure of the &quot;closeness&quot; of two quantum states. It expresses the probability that one state will pass a test to identify as the other. The fidelity is not a metric on the space of density matrices, but it can be used to define the Bures metric on this space." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T15:04:54.197" LastActivityDate="2018-04-15T15:04:54.197" CommentCount="0" />
  <row Id="1767" PostTypeId="5" CreationDate="2018-04-15T14:19:08.320" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:19:08.320" LastActivityDate="2018-04-15T14:19:08.320" CommentCount="0" />
  <row Id="1768" PostTypeId="4" CreationDate="2018-04-15T14:19:08.320" Score="0" Body="Bremermann's limit, named after Hans-Joachim Bremermann, is the maximum computational speed of a self-contained system in the material universe. " OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T15:03:59.457" LastActivityDate="2018-04-15T15:03:59.457" CommentCount="0" />
  <row Id="1769" PostTypeId="5" CreationDate="2018-04-15T14:20:19.163" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:20:19.163" LastActivityDate="2018-04-15T14:20:19.163" CommentCount="0" />
  <row Id="1770" PostTypeId="4" CreationDate="2018-04-15T14:20:19.163" Score="0" Body="For questions regarding scalability as relevant to quantum computation. Scalability is the capability of a system, network, or process to handle a growing amount of work, or its potential to be enlarged to accommodate that growth." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T15:05:09.443" LastActivityDate="2018-04-15T15:05:09.443" CommentCount="0" />
  <row Id="1771" PostTypeId="5" CreationDate="2018-04-15T14:21:14.670" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:21:14.670" LastActivityDate="2018-04-15T14:21:14.670" CommentCount="0" />
  <row Id="1772" PostTypeId="4" CreationDate="2018-04-15T14:21:14.670" Score="0" Body="For questions regarding quantum Fourier sampling. It's a method of efficiently approximating the distribution, sampled after a quantum Fourier transform over a system of qubits. " OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T15:04:49.977" LastActivityDate="2018-04-15T15:04:49.977" CommentCount="0" />
  <row Id="1773" PostTypeId="5" CreationDate="2018-04-15T14:24:02.417" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:24:02.417" LastActivityDate="2018-04-15T14:24:02.417" CommentCount="0" />
  <row Id="1774" PostTypeId="4" CreationDate="2018-04-15T14:24:02.417" Score="0" Body="Use this tag for questions about possible applications of quantum computing in improving neural network models and/or quantum neural networks.  Artificial neural networks (ANNs) or connectionist systems are computing systems vaguely inspired by the biological neural networks that constitute animal brains. Such systems &quot;learn&quot; (i.e. progressively improve performance on) tasks by considering examples, generally without task-specific programming (Wikipedia). " OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-15T13:23:39.963" LastActivityDate="2018-07-15T13:23:39.963" CommentCount="0" />
  <row Id="1775" PostTypeId="5" CreationDate="2018-04-15T14:24:32.450" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:24:32.450" LastActivityDate="2018-04-15T14:24:32.450" CommentCount="0" />
  <row Id="1776" PostTypeId="4" CreationDate="2018-04-15T14:24:32.450" Score="0" Body="Deep learning (also known as deep structured learning or hierarchical learning) is part of a broader family of machine learning methods based on learning data representations, as opposed to task-specific algorithms. Learning can be supervised, semi-supervised or unsupervised." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T15:05:18.077" LastActivityDate="2018-04-15T15:05:18.077" CommentCount="0" />
  <row Id="1777" PostTypeId="5" CreationDate="2018-04-15T14:25:04.120" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:25:04.120" LastActivityDate="2018-04-15T14:25:04.120" CommentCount="0" />
  <row Id="1778" PostTypeId="4" CreationDate="2018-04-15T14:25:04.120" Score="0" Body="Topological quantum computing is a theoretical quantum computing model that employs two-dimensional quasiparticles called anyons, whose world lines pass around one another to form braids in a three-dimensional spacetime (i.e., one temporal plus two spatial dimensions)." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T15:05:05.337" LastActivityDate="2018-04-15T15:05:05.337" CommentCount="0" />
  <row Id="1779" PostTypeId="5" CreationDate="2018-04-15T14:25:57.800" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:25:57.800" LastActivityDate="2018-04-15T14:25:57.800" CommentCount="0" />
  <row Id="1780" PostTypeId="4" CreationDate="2018-04-15T14:25:57.800" Score="0" Body="For questions regarding representation of classical data in quantum computers" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T15:04:29.797" LastActivityDate="2018-04-15T15:04:29.797" CommentCount="0" />
  <row Id="1781" PostTypeId="5" CreationDate="2018-04-15T14:27:15.817" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:27:15.817" LastActivityDate="2018-04-15T14:27:15.817" CommentCount="0" />
  <row Id="1782" PostTypeId="4" CreationDate="2018-04-15T14:27:15.817" Score="0" Body="Shor's algorithm, named after American mathematician Peter Shor, is a quantum algorithm for integer factorization, formulated in 1994. Informally, it solves the following problem: given an integer N, find its prime factors." OwnerUserId="26" LastEditorUserId="55" LastEditDate="2018-07-05T16:12:08.963" LastActivityDate="2018-07-05T16:12:08.963" CommentCount="0" />
  <row Id="1783" PostTypeId="5" CreationDate="2018-04-15T14:39:26.953" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T14:39:26.953" LastActivityDate="2018-04-15T14:39:26.953" CommentCount="0" />
  <row Id="1784" PostTypeId="4" CreationDate="2018-04-15T14:39:26.953" Score="0" Body="In quantum computing theory post-selection refers to giving a quantum computer the power to choose the outcomes of certain measurements, which greatly increases its computational power. In this case the, perhaps exponentially many, extra runs required to obtain the output are ignored. &#xD;&#xA;The important point is that an interference pattern is not produced immediately." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-15T15:04:41.993" LastActivityDate="2018-04-15T15:04:41.993" CommentCount="0" />
  <row Id="1785" PostTypeId="5" CreationDate="2018-04-15T15:07:21.500" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T15:07:21.500" LastActivityDate="2018-04-15T15:07:21.500" CommentCount="0" />
  <row Id="1786" PostTypeId="4" CreationDate="2018-04-15T15:07:21.500" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-15T15:07:21.500" LastActivityDate="2018-04-15T15:07:21.500" CommentCount="0" />
  <row Id="1788" PostTypeId="2" ParentId="1426" CreationDate="2018-04-15T18:52:38.237" Score="3" Body="&lt;p&gt;While I’m not an experimentalist, and have not studied these systems in any great depth, my (crude) understanding is the following:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In ion traps you (more or less) have to trap the ions in lines. However, this isn’t a limitation in terms of the ease of communication because what you’re probably thinking about is when a linear system has nearest neighbour interactions, I.e. each qubit can only interact with its immediate neighbours. In ion traps, this isn’t really true because you can access a common vibrating mode of all the ions in order to make arbitrary pairs interact directly. So actually, that’s really good.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The problem is that number of qubits that you can store. The more atoms you put in the trap, the closer together their energy levels are, and the harder they become to individually address in order to control them and implement gates. This tends to limit the number of qubits you have in a single trapping area. To get around this (and with the added bonus of parallelism, necessary for error correction), people want to make multiple distinct trapping regions interact, either with flying qubits, or by shuttling the atoms between different trapping regions. This second approach seems to be very much in progress. &lt;a href=&quot;https://deepblue.lib.umich.edu/bitstream/handle/2027.42/62880/nature00784.pdf%3Bsequence=1&quot; rel=&quot;nofollow noreferrer&quot;&gt;This&lt;/a&gt; is the theory proposal, but I have certainly seen papers that have demonstrated the &lt;a href=&quot;http://iopscience.iop.org/article/10.1088/1367-2630/12/3/033031/meta&quot; rel=&quot;nofollow noreferrer&quot;&gt;basic components&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-04-15T18:52:38.237" CommentCount="0" />
  <row Id="1789" PostTypeId="1" AcceptedAnswerId="1791" CreationDate="2018-04-15T22:16:34.560" Score="5" ViewCount="117" Body="&lt;p&gt;I´ve solved the Exercise 7.1.1 (Bernstein–Vazirani problem) of the book &quot;An introduction to quantum computing&quot; (Mosca et altri). The problem is the following: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Show how to find $a \in Z_2^n$ given one application of a black box that maps $|x\rangle|b\rangle \to |x\rangle |b \oplus x · a\rangle$ for some $b\in \{0, 1\}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I´d say we can do it like this:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;First i go from $|0|0\rangle \to \sum_{i \in \{0,1\}^n}|i\rangle| + \rangle$ using QFT and Hadamard&lt;/li&gt;&#xA;&lt;li&gt;Then I apply the oracle: &#xA;$$ \sum_{i \in \{0,1\}^n}(-1)^{(i,a)} |i\rangle| + \rangle $$&lt;/li&gt;&#xA;&lt;li&gt;Then I read the pase with an Hadamard (since we are in $Z_2^n$ our QFT is an Hadamard)&#xA;$$ |a\rangle |+ \rangle $$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;I think is correct. Do you agree?&lt;/p&gt;&#xA;" OwnerUserId="1644" LastActivityDate="2018-04-16T12:48:34.713" Title="Bernstein–Vazirani problem in book as exercise" Tags="&lt;quantum-algorithms&gt;" AnswerCount="1" CommentCount="1" />
  <row Id="1790" PostTypeId="2" ParentId="1426" CreationDate="2018-04-16T04:23:33.707" Score="4" Body="&lt;p&gt;You may want to check out this Schaetz et al, Reports on Progress in Physics of 2012 &quot;&lt;a href=&quot;http://iopscience.iop.org/article/10.1088/0034-4885/75/2/024401/meta&quot; rel=&quot;nofollow noreferrer&quot;&gt;Experimental quantum simulations of many-body physics with trapped ions&lt;/a&gt;&quot; (&lt;a href=&quot;https://pdfs.semanticscholar.org/7297/c133331f43b1d4be00388cdb4e424a4668b4.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;alternate link in semanticscholar&lt;/a&gt;). In sum: &lt;strong&gt;yes, the arrangement of the ions is one key limitation to scalability, but no, configurations are not currently limited to a single line of atoms&lt;/strong&gt;. On that paper, check Figure 3 for experimental fluorescence images of laser-cooled ions in a common confining potential of a linear RF trap, including a single ion, a single line, a zig-zag chain and a three-dimensional construct. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;From Figure 3 in the paper above by Schaetz et al: &quot;&lt;em&gt;Structural phase transitions can be induced between one-, two- and three-dimensional crystals, for example by reducing the ratio of radial to axial trapping frequencies.&lt;/em&gt;&quot; I am sure more recent review papers should exist, but this is the first one I found that was satisfactory. Admittedly, current results are more about direct simulation rather than universal computation, e.g. from figure 13 in the same paper: &quot;&lt;em&gt;Changing the experimental parameters non-adiabatically during a structural phase transition from a linear chain of ions to a zigzag structure, the order within the crystal breaks up in domains, framed by topologically protected defects that are suited to simulate solitons.&lt;/em&gt;&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;On the same topic, and also from 2012, another paper worth checking out would be &lt;a href=&quot;https://arxiv.org/abs/1204.5789&quot; rel=&quot;nofollow noreferrer&quot;&gt;Engineered two-dimensional Ising interactions in a trapped-ion quantum simulator with hundreds of spins (arXiv version)&lt;/a&gt; (&lt;a href=&quot;http://www.nature.com/articles/nature10981&quot; rel=&quot;nofollow noreferrer&quot;&gt;Nature version&lt;/a&gt;. You have the experimental picture as Figure 1; it is a Penning trap in this case rather than a Paul trap. Indeed, it is not universal quantum computing but rather the specialized application of quantum simulation, but still it is undeniably experimental progress towards &lt;em&gt;holding ions in place in a 2-D trap&lt;/em&gt; and thus advancing towards scalability.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am myself no expert in traps, but this is what I got on scalability in a recent (2017) conference:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Experimentalists play around with the potentials and achieve interesting combinations, with central zones that are quasi-crystalline (chains, ladders, ribbons etc) and exotic tips (e.g. ribbons or ladders that finish in a single atom). &lt;/li&gt;&#xA;&lt;li&gt;The majority of the popular ions have a configuration of the type [noble-gas]$s^1$ (like Ca$^+$), preferredly with no nuclear spin but this is for convenience and simplicity. Accessing hyperfine states and/or a more complex spin level structure (like Yb$^+$=[Xe]f$^{14}$s$^2$) opens the door to a richer Hilbert space per ion.&lt;/li&gt;&#xA;&lt;li&gt;Collective vibrations are used as the basis of interqubit communication. As in the previous point, the breathing mode is uniquely stable and thus convenient to use, but other vibrations are also accessible and would allow more interesting interqubit communication schemes. &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="1847" LastEditDate="2018-04-19T05:37:50.093" LastActivityDate="2018-04-19T05:37:50.093" CommentCount="0" />
  <row Id="1791" PostTypeId="2" ParentId="1789" CreationDate="2018-04-16T07:01:48.590" Score="4" Body="&lt;p&gt;This is not correct: you need to use the state $|-\rangle=(|0\rangle-|1\rangle)/\sqrt{2}$ instead of $|+\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The important thing is that you've missed showing how the black box map that you've stated gives the oracle output that you've stated. To see this, apply the map on&#xA;$$&#xA;|x\rangle|+\rangle\mapsto|x\rangle(|0\oplus x\cdot a\rangle+|1\oplus x\cdot a\rangle)/\sqrt{2}=|x\rangle(|0\rangle+|1\rangle)/\sqrt{2}.&#xA;$$&#xA;When the $|+\rangle$ state is there, you get no phase. Meanwhile, with the $|-\rangle$ state,&#xA;$$&#xA;|x\rangle|-\rangle\mapsto|x\rangle(|0\oplus x\cdot a\rangle-|1\oplus x\cdot a\rangle)/\sqrt{2}=\left\{\begin{array}{cc} |x\rangle(|0\rangle-|1\rangle)/\sqrt{2} &amp;amp; x\cdot a=0 \\ |x\rangle(|1\rangle-|0\rangle)/\sqrt{2} &amp;amp; x\cdot a=1\end{array}\right..&#xA;$$&#xA;This can simply be written as $(-1)^{x\cdot a}|x\rangle|-\rangle$.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-04-16T12:48:34.713" LastActivityDate="2018-04-16T12:48:34.713" CommentCount="1" />
  <row Id="1792" PostTypeId="1" AcceptedAnswerId="1827" CreationDate="2018-04-16T09:25:48.237" Score="11" ViewCount="858" Body="&lt;p&gt;I read that a qubit can be encoded in a &lt;a href=&quot;https://en.wikipedia.org/wiki/Fock_state&quot; rel=&quot;noreferrer&quot;&gt;Fock state&lt;/a&gt;, such as the presence or absence of a photon. How do you perform single qubit rotations on Fock states? &lt;/p&gt;&#xA;" OwnerUserId="1931" LastEditorUserId="23" LastEditDate="2018-04-17T18:09:46.430" LastActivityDate="2018-04-18T20:37:01.407" Title="How do you rotate a Fock state qubit?" Tags="&lt;qubit&gt;&lt;quantum-gate&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="1793" PostTypeId="2" ParentId="1792" CreationDate="2018-04-16T10:28:55.760" Score="7" Body="&lt;p&gt;The short answer is that you can't. There's something called a &quot;particle number superselection rule&quot; which postulates that you can't create a superposition of different numbers of particles. So, if you prepare a Fock state, you can perform phase gates, and bit flips, but you cannot perform arbitrary rotations that create superpositions of different particle number.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;The longer answer is that sometimes you can make superpositions, if you have the right reference frame available. There's a good discussion of this stuff &lt;a href=&quot;https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.79.555&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;. This is the reason why states such as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Coherent_states&quot; rel=&quot;noreferrer&quot;&gt;coherent states&lt;/a&gt;, which are a superposition of different numbers of photons, can be created (and they get used for quantum computation, but that's an entirely different question). But I believe that this can't work with small photon numbers (e.g. the presence or absence of a single photon). The only thing you can do in that context is create a superposition of a single photon being in one of two places.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-04-16T10:28:55.760" CommentCount="0" />
  <row Id="1794" PostTypeId="1" AcceptedAnswerId="1795" CreationDate="2018-04-16T10:56:52.610" Score="10" ViewCount="511" Body="&lt;p&gt;In a lecture, recorded on &lt;a href=&quot;https://www.youtube.com/watch?v=L5gSZsezhoQ&quot; rel=&quot;noreferrer&quot;&gt;Youtube&lt;/a&gt;, Gil Kalai presents a 'deduction' for why topological quantum computers will not work. The interesting part is that he claims this is a stronger argument than the argument against fault tolerant computing in general.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If I understand his argument correctly, he states that &lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;A (hypothetical) quantum computer &lt;em&gt;without quantum error correction&lt;/em&gt; can simulate the system of anyons representing the qubit in a topological quantum computer.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Therefore, any quantum computer based on these anyons must have at least as much noise as a quantum computer without quantum error correction. As we know that our noisy quantum computer is insufficient for universal quantum computation, topological quantum computers based on anyons cannot provide universal quantum computation either.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;I think step 2 is sound, but I have some doubts on step 1 and why it implies 2. In particular:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Why can a quantum computer without error correction simulate the system of anyons?&lt;/li&gt;&#xA;&lt;li&gt;If it can simulate the system of anyons, is it possible that it can only do so with low probability and hence cannot simulate the topological quantum computer with the same fault tolerance as the system of anyons?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="253" LastEditorUserId="253" LastEditDate="2018-04-16T14:11:32.330" LastActivityDate="2018-04-16T14:11:32.330" Title="Is Gil Kalai's argument against topological quantum computers sound?" Tags="&lt;quantum-computer&gt;&lt;topological-quantum-computing&gt;&lt;quantum-error-correction&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="2" />
  <row Id="1795" PostTypeId="2" ParentId="1794" CreationDate="2018-04-16T11:48:35.727" Score="6" Body="&lt;p&gt;A topological quantum computer could be made by using an exotic phase of matter in which anyons arise as localized effects (such as quasiparticles or defects). In this case, errors typically cost energy, and so the probability is suppressed for small temperatures (though it will never be zero).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A topological quantum computer could also be made (or one could also say &lt;em&gt;simulated&lt;/em&gt;) by a standard gate model quantum computer, such as one based on qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In either case, we are using a noisy medium to engineer a system of anyons. And so we will get a noisy system of anyons. The effects of the noise will cause our anyons to wander around, as well as causing pair creations of additional anyons, etc. If these effects are not accounted for, it will cause errors in any topological quantum computation that we intend to do. So in this sense, his arguments are correct.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The important point to note, therefore, is that we must not fail to account for the errors. We must look at the system, keep track of where all anyons are, try to identify which ones we are using, and identify how to clear away the ones that have been created in error. This means that we must do error correction within the topological quantum computer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The promise of TQC is mainly that there should be ways to engineer topological phases that will have &lt;em&gt;less&lt;/em&gt; noise. They should therefore require &lt;em&gt;less&lt;/em&gt; error correction. But they will definitely need some.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For a gate model quantum computer &lt;em&gt;simulating&lt;/em&gt; a topological quantum computer, the benefits are that topological error correction is quite straightforward and has high thresholds. The surface codes are examples of this. But we don't usually think of this as a gate model QC simulating a topological QC. We just think of it as a good example of a quantum error correcting code.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-04-16T12:07:22.070" LastActivityDate="2018-04-16T12:07:22.070" CommentCount="4" />
  <row Id="1796" PostTypeId="1" AcceptedAnswerId="1814" CreationDate="2018-04-16T13:18:45.773" Score="8" ViewCount="210" Body="&lt;p&gt;Since the original experimental contribution using the  &lt;a href=&quot;https://www.nature.com/articles/414883a&quot; rel=&quot;nofollow noreferrer&quot;&gt;Shor's factoring algorithim&lt;/a&gt; to factorize the integer 15 some experiments have been performed in order to calculate the largest factorized number. But most of the experiments are particularly designed for a specific number ($N$) and not a general approach which could be used for any $&amp;lt;N$ integer. &lt;a href=&quot;https://phys.org/news/2014-11-largest-factored-quantum-device.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Example.&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am wondering which is, at the moment, the largest number that has been experimentally factorized in a general procedure by a quantum algorithm.&lt;/p&gt;&#xA;" OwnerUserId="1955" LastEditorUserId="91" LastEditDate="2018-05-20T15:47:37.840" LastActivityDate="2018-05-20T20:23:51.553" Title="Which is the highest number factorized by QC in a non-specific experiment?" Tags="&lt;quantum-algorithms&gt;&lt;experimental-results&gt;" AnswerCount="3" CommentCount="8" />
  <row Id="1797" PostTypeId="2" ParentId="1717" CreationDate="2018-04-16T14:16:41.577" Score="3" Body="&lt;p&gt;&lt;strong&gt;Superconducting qubits&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are several possible approaches. In the most popular scheme the qubits are always coupled, but off resonant and thus the energy conservation prevents the exchange of excitation. With external magnetic flux the qubits can be tuned temporarily into a resonance. The qubits will pick up a phase, which will depend on the state of the other qubit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For first works see &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0303002&quot; rel=&quot;nofollow noreferrer&quot;&gt;Strauch2003&lt;/a&gt; or &lt;a href=&quot;https://arxiv.org/abs/0903.2030&quot; rel=&quot;nofollow noreferrer&quot;&gt;DiCarlo2009&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;These days cPhase gates are done routinely &amp;lt; 300 ns and fidelity &gt;99%. &lt;a href=&quot;https://arxiv.org/abs/1511.03316&quot; rel=&quot;nofollow noreferrer&quot;&gt;Barends2016&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1502.06778&quot; rel=&quot;nofollow noreferrer&quot;&gt;Salathe2015&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1604.03076&quot; rel=&quot;nofollow noreferrer&quot;&gt;McKay2016&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As superconducting qubits work in microwave regime and are thus operated at cryogenic temperature it is not straight forward to do a two qubit gate between distant qubits. A gate between qubits on different chips in the same cryostat has been demonstrated (eg. &lt;a href=&quot;https://arxiv.org/abs/1712.08593&quot; rel=&quot;nofollow noreferrer&quot;&gt;Kurpiers2017a&lt;/a&gt;), but in order to conduct a gate between different cryostats either a microwave-to-optical and optical-to-microwave converter is needed or alternatively a low loss cryogenic microwave link needs to be built.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Quantum dots&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are different degrees of freedom in multi-quantum-dot systems which can be used as a qubti. Thus there are different exact mechanisms. Typically either direct exchange interaction or tunable perturbation of a non-computational state is used.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Single-quantum-dot spin qubits: &lt;a href=&quot;https://arxiv.org/abs/1708.04214&quot; rel=&quot;nofollow noreferrer&quot;&gt;Watson2018&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Double-quantum-dot spin qubits: &lt;a href=&quot;https://www.nature.com/articles/s41534-016-0003-1&quot; rel=&quot;nofollow noreferrer&quot;&gt;Nichol2017&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Between a spin and a photon: &lt;a href=&quot;https://arxiv.org/abs/1710.03265&quot; rel=&quot;nofollow noreferrer&quot;&gt;Mi2018&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="1989" LastEditorUserId="1989" LastEditDate="2018-04-16T14:57:33.863" LastActivityDate="2018-04-16T14:57:33.863" CommentCount="0" />
  <row Id="1799" PostTypeId="1" AcceptedAnswerId="1800" CreationDate="2018-04-16T21:26:17.250" Score="7" ViewCount="195" Body="&lt;p&gt;I understand the notation for classical error correcting codes. E.g., &quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hamming(7,4)&quot; rel=&quot;nofollow noreferrer&quot;&gt;Hamming(7,4)&lt;/a&gt;&quot; stands for a Hamming code that uses 7 bits to encode blocks of 4 bits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What does the notation for quantum error correcting codes mean? E.g., there is &lt;a href=&quot;https://arxiv.org/abs/1705.08957&quot; rel=&quot;nofollow noreferrer&quot;&gt;a paper&lt;/a&gt; that deals with a [[4,2,2]]-code. What are these three numbers? What do double brackets stand for?&lt;/p&gt;&#xA;" OwnerUserId="528" LastEditorUserId="26" LastEditDate="2018-05-07T13:19:20.393" LastActivityDate="2018-05-07T13:19:20.393" Title="What does quantum error correction code notation stand for?" Tags="&lt;notation&gt;&lt;quantum-error-correction&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="1800" PostTypeId="2" ParentId="1799" CreationDate="2018-04-16T23:04:09.650" Score="4" Body="&lt;p&gt;An $[\![n,k,d]\!]$ code is a quantum error correction code which encodes $ k$ qubits in an $ n$-qubit state, in such a way that any operation which maps some encoded state to another encoded state must act on at least $d$ qubits. (So, for example, any encoded state which has been subjected to an error consisting of at most $\lfloor (d-1)/2 \rfloor $ Pauli operations can in principle be recovered perfectly).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This notation generalises the notation $ [n,k,d]$ for classical error correction codes, in which $ k$-bit &quot;plaintext&quot; strings are encoded in $n$-bit &quot;codeword&quot; strings, in such a way that at least $d $ bits must be flipped to transform between any two codewords representing different plaintexts. (In this context and in the quantum case, $ d $ is referred to as the &lt;em&gt;code distance&lt;/em&gt;.) The double-brackets are used simply to denote that the code being referred to is a quantum error correction code rather than a classical code. &lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-04-17T08:21:54.377" LastActivityDate="2018-04-17T08:21:54.377" CommentCount="1" />
  <row Id="1801" PostTypeId="2" ParentId="1799" CreationDate="2018-04-16T23:51:38.320" Score="4" Body="&lt;p&gt;Taking an $\left[\left[n, k, d\right]\right]$ code:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The classical equivalent to this is an $\left[n, k, d\right]$ code, which is a code referring to the number of bits, $n$, encoding $k$ bits. The third number, $d$, is the minimum Hamming distance taken between any two codewords. This is equal to the minimum Hamming weight (i.e. number of non-zero bits) of non-zero codewords.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As per the classical case, &lt;strong&gt;in the quantum case&lt;/strong&gt;, the first two numbers are referring to the numbers of qubits, $n$, that encode $k$ qubits. $d$ is still used to refer to distance, but the definition of &lt;em&gt;distance&lt;/em&gt; has to be changed.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &lt;em&gt;weight&lt;/em&gt;, $t$, of a Pauli operator $E_a$, is the number of qubits that a (single-qubit) Pauli operator $\left(X, Y \text{ or } Z\right)$ acts on. As an example, arbitrarily taking $E_1 = X\otimes I\otimes I\otimes Z\otimes I$, $E_1$ has a weight $t=2$. The distance is then the minimum weight that the overlap of a Pauli operator (in the space of possible errors) acting on a codeword, with a &lt;em&gt;different&lt;/em&gt; codeword is non-zero, or the minimum weight such that $\left&amp;lt;j\vert E_a\vert i\right&amp;gt;\neq C_a\delta_{ji}$ for some (real) $C_a$ for all codewords $i$ and $j$. That is, the distance is the minimum number of errors that can occur on a codeword that causes it to be mapped to a different codeword.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For more details, see e.g. Chapter 7 of &lt;a href=&quot;http://www.theory.caltech.edu/%7Epreskill/ph219/index.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Preskill's quantum computation notes&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="23" LastActivityDate="2018-04-16T23:51:38.320" CommentCount="1" />
  <row Id="1802" PostTypeId="1" AcceptedAnswerId="1811" CreationDate="2018-04-17T01:17:41.923" Score="8" ViewCount="77" Body="&lt;p&gt;I want to simulate large stabilizer circuits (H/S/CNOT/MEASURE/feedforward) with a small number of T gates mixed in. How can I do this in a way that scales exponentially only in the number of T gates? Are there existing implementations?&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-04-17T07:26:41.773" LastActivityDate="2018-04-17T08:53:49.653" Title="Simulating Clifford + few-T circuits" Tags="&lt;simulation&gt;" AnswerCount="1" CommentCount="2" />
  <row Id="1803" PostTypeId="1" AcceptedAnswerId="1805" CreationDate="2018-04-17T02:37:03.897" Score="22" ViewCount="2300" Body="&lt;p&gt;Plain and simple. Does &lt;a href=&quot;https://en.wikipedia.org/wiki/Moore&amp;#39;s_law&quot; rel=&quot;noreferrer&quot;&gt;Moore's law&lt;/a&gt; apply to quantum computing, or is it similar but with the numbers adjusted (ex. triples every 2 years). Also, if Moore's law doesn't apply, why do qubits change it?&lt;/p&gt;&#xA;" OwnerUserId="1348" LastEditorUserId="1847" LastEditDate="2018-04-19T10:01:43.267" LastActivityDate="2018-05-12T23:26:39.113" Title="Does Moore's law apply to quantum computing?" Tags="&lt;quantum-computer&gt;&lt;classical-computing&gt;&lt;history&gt;&lt;scalability&gt;" AnswerCount="4" CommentCount="2" FavoriteCount="5" />
  <row Id="1804" PostTypeId="2" ParentId="1803" CreationDate="2018-04-17T06:22:28.217" Score="5" Body="&lt;p&gt;The first thing to understand about Moore’s law is that it is not a law in the absolute sense, mathematically provable, or even postulated (like a law of physics). Really, it was just a rule of thumb that said the number of transistors in a processor would double every x years. This can be seen in the way that the value x has changed over time. Originally, it was x=1, then it became x=2, then what it was applied to (processor speed) changed. It has proved to be a useful rule of thumb, partly because it was the rule of thumb that was used to set targets for new generations of processor.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, there is absolutely no reason why Moore’s law should apply to quantum computers, but it would not be unreasonable to guess that, past some basic threshold, qubit numbers will double every y years. For most implementations of quantum computation, we don’t yet have enough data points to start extrapolating an estimate for the value y. Some might argue that it’s not even clear yet whether we’re in the “vacuum tube” or “transistor” era of quantum computing (Moore’s law didn’t start until the transistor era).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We might start to try and extrapolate for some systems. For example, D-wave has a history of doubling its processor sizes. This started as y=1, and currently has about y=2. Of course, this is not a universal quantum computing device. The next best thing we might look at is the IBM quantum processor. In a year, the computer available on the IBM quantum experience went from 5 qubits to 16, although I don’t think it’s reasonable to extrapolate based on this.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-04-17T06:22:28.217" CommentCount="0" />
  <row Id="1805" PostTypeId="2" ParentId="1803" CreationDate="2018-04-17T06:24:32.837" Score="16" Body="&lt;p&gt;If you take as definition &quot;&lt;em&gt;the number of transistors in a dense integrated circuit doubles about every two years&lt;/em&gt;&quot;, it definitely does not apply: as answered here in &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1696/do-the-fundamental-circuit-elements-have-a-correspondence-in-quantum-technolog&quot;&gt;Do the 'fundamental circuit elements' have a correspondence in quantum technologies?&lt;/a&gt; there exist no transistors-as-fundamental-components (nor do exist fundamental-parallel-to-transistors) in a quantum computer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you take a more general definition &quot;&lt;em&gt;chip performance doubles aproximately every 18 months&lt;/em&gt;&quot;, the question makes more sense, and the answer is still that &lt;strong&gt;it does not apply&lt;/strong&gt;, mainly because Moore's law is not one of fundamental Physics. Rather, in the early stages, it was an observation of a stablished industry. Later, as pointed out in a comment,[1] it has been described as functioning as an &quot;&lt;em&gt;evolving target&lt;/em&gt;&quot; and as a &quot;&lt;em&gt;self-fulfilling prophecy&lt;/em&gt;&quot; for that same industry. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The key is that &lt;strong&gt;we do not have a stablished industry producing quantum computers.&lt;/strong&gt; We are not in the quantum equivalent from 1965. Arguably we will move faster, but in many aspects we are rather in the XVII-XVIII centuries. For a perspective, check this &lt;a href=&quot;https://en.wikipedia.org/wiki/Timeline_of_computing_hardware_before_1950&quot; rel=&quot;noreferrer&quot;&gt;timeline of computing hardware before 1950&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For a more productive answer, there are a few fundamental differences and a few possible parallels between classical and quantum hardware, in the context of Moore's law:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;For many architectures, in a certain sense we already work with the smallest possible component. While we might develop ion traps (of a fixed size) fitting more ions, but we cannot develop smaller ions: they are of atomic size.&lt;/li&gt;&#xA;&lt;li&gt;Even when we are able to come up with tricks, such as &lt;a href=&quot;https://arxiv.org/abs/1610.03994&quot; rel=&quot;noreferrer&quot;&gt;Three addressable spin qubits in a molecular single-ion magnet&lt;/a&gt;, they are still fundamentally limited by quantum mechanics. We need control over 8 energy levels to control 3 qubits ($2^n$), which is doable, but not scalable.&lt;/li&gt;&#xA;&lt;li&gt;Precisely because the scalability issue is one of the hardest problem we have with quantum computers -not just having a larger number of qubits, buy also being able to entangle them- it's dangerous to extrapolate from current progress. See for illustration the history of &lt;a href=&quot;https://en.wikipedia.org/wiki/Nuclear_magnetic_resonance_quantum_computer&quot; rel=&quot;noreferrer&quot;&gt;NMR quantum computers&lt;/a&gt;, which stalled after a very early string of successes. In theory, increasing the number of qubits in the device was trivial. In practice, every time you want to be able to control 1 more qubit you need to double the resolution of your machine, which becomes very unfeasible very quickly.&lt;/li&gt;&#xA;&lt;li&gt;If and when there exists an industry that relies on an evolving technology which is able to produce some kind of integrated quantum chips, then yes, at that point we will be able to draw a real parallel to Moore's law. For a taste of how far we are from that point, see &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2017/are-there-any-estimates-on-how-complexity-of-quantum-engineering-scales-with-siz&quot;&gt;Are there any estimates on how complexity of quantum engineering scales with size?&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;[1] &lt;em&gt;Thanks to Sebastian Mach for that insight and &lt;a href=&quot;https://en.wikipedia.org/wiki/Moore&amp;#39;s_law#As_an_evolving_target_for_industry&quot; rel=&quot;noreferrer&quot;&gt;wikipedia link&lt;/a&gt;. For more details on that see &lt;a href=&quot;https://books.google.es/books?id=1khslZ-jbgEC&amp;amp;pg=PA206&amp;amp;redir_esc=y#v=onepage&amp;amp;q&amp;amp;f=false&quot; rel=&quot;noreferrer&quot;&gt;Getting New Technologies Together: Studies in Making Sociotechnical Order&#xA;edited by Cornelis Disco, Barend van der Meulen, p. 206&lt;/a&gt; and &lt;a href=&quot;https://www.theinquirer.net/inquirer/news/1014782/gordon-moore-aloha-moore-law&quot; rel=&quot;noreferrer&quot;&gt;Gordon Moore says aloha to Moore's Law&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="1847" LastEditDate="2018-05-10T18:54:03.470" LastActivityDate="2018-05-10T18:54:03.470" CommentCount="14" />
  <row Id="1806" PostTypeId="1" AcceptedAnswerId="1810" CreationDate="2018-04-17T07:44:02.087" Score="17" ViewCount="2575" Body="&lt;p&gt;Quantum state teleportation is the quantum information protocol where a qubit is transferred between two parties using an initial shared entangled state, Bell measurement, classical communication and local rotation. Apparently, there is also something called quantum gate teleportation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What is quantum gate teleportation and what is it used for?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am particularly interested in possible applications in simulating quantum circuits.&lt;/p&gt;&#xA;" OwnerUserId="144" LastEditorUserId="144" LastEditDate="2018-04-17T08:35:36.943" LastActivityDate="2018-04-17T11:26:03.857" Title="What is quantum gate teleportation?" Tags="&lt;quantum-gate&gt;&lt;circuit-model&gt;&lt;quantum-information&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="8" />
  <row Id="1807" PostTypeId="1" AcceptedAnswerId="1816" CreationDate="2018-04-17T08:15:49.980" Score="8" ViewCount="83" Body="&lt;p&gt;I read that a qubit can be encoded in a &lt;a href=&quot;https://en.wikipedia.org/wiki/Polarization_%28waves%29&quot; rel=&quot;nofollow noreferrer&quot;&gt;polarization state&lt;/a&gt; (horizontal or vertical polarization of a photon). How do you perform two-qubit operations on a polarization qubit?&lt;/p&gt;&#xA;" OwnerUserId="1931" LastEditorUserId="55" LastEditDate="2018-04-17T18:32:48.670" LastActivityDate="2018-04-17T18:32:48.670" Title="How do you apply a CNOT on polarization qubits?" Tags="&lt;quantum-computer&gt;&lt;qubit&gt;&lt;quantum-gate&gt;&lt;optical-quantum-computing&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="1808" PostTypeId="1" CreationDate="2018-04-04T18:57:56.557" Score="7" ViewCount="123" Body="&lt;p&gt;For an integer, $N$, to be factorised, with $a$ (uniformly) chosen at random between $1$ and $N$, with $r$ the order of $a\mod N$ (that is, the smallest $r$ with $a^r\equiv 1\mod N$):&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Why is that in Shor's algorithm we have to discard the scenario in which $a^{r/2} =-1 \mod N$? Also, why shouldn't we discard the scenario when $a^{r/2} = 1 \mod N$?&lt;/p&gt;&#xA;" OwnerDisplayName="user2508039" LastEditorUserId="23" LastEditDate="2018-04-17T09:40:18.167" LastActivityDate="2018-06-24T20:34:19.160" Title="Shor's algorithm caveats when $a^{r/2} =-1 \mod N$" Tags="&lt;quantum-algorithms&gt;&lt;shors-algorithm&gt;" AnswerCount="3" CommentCount="2" />
  <row Id="1809" PostTypeId="2" ParentId="1806" CreationDate="2018-04-17T08:35:51.683" Score="6" Body="&lt;p&gt;Gate teleportation is in principle a method that allows the creation of different gates from an available set of gates, by teleporting qubits through entangled states. An example of the use of this method, is the creation of the T gate from a Clifford set of gates in order to make the set universal. The construction in this particular case is done with the use of special T ancillae. The standard reference can be found in &lt;a href=&quot;https://arxiv.org/pdf/quant-ph/9908010.pdf&quot; rel=&quot;noreferrer&quot;&gt;https://arxiv.org/pdf/quant-ph/9908010.pdf&lt;/a&gt; .&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For simulating quantum circuits you can use the gate teleportation to move gates around the circuit with the use of ancillae qubit (number of ancillae depended on the number of gates).&lt;/p&gt;&#xA;" OwnerUserId="2000" LastActivityDate="2018-04-17T08:35:51.683" CommentCount="0" />
  <row Id="1810" PostTypeId="2" ParentId="1806" CreationDate="2018-04-17T08:52:23.860" Score="14" Body="&lt;p&gt;Quantum gate teleportation is the act of being able to apply a quantum gate on the unknown state while it is being teleported. This is one of the ways in which &lt;a href=&quot;https://en.wikipedia.org/wiki/One-way_quantum_computer&quot; rel=&quot;noreferrer&quot;&gt;measurement-based computation&lt;/a&gt; can be described using graph states.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Usually, teleportation works by having an unknown quantum state $|\psi\rangle$ held by Alice, and two qubits in the Bell state $|\Psi\rangle=(|00\rangle+|11\rangle)/\sqrt{2}$ shared between Alice and Bob. Alice performs a Bell state measurement, getting one of 4 possible answers and Bob holds on his qubit, depending on the measurement result of Alice, one of the 4 states $|\psi\rangle,X|\psi\rangle,Z|\psi\rangle,ZX|\psi\rangle.$ So, once Bob learns what result Alice got, he can compensate by applying the appropriate Paulis.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let $U$ be a 1-qubit unitary. Assume Alice and Bob share $(\mathbb{I}\otimes U)|\Psi\rangle$ instead of $|\Psi\rangle$. If they repeat the teleportation protocol, Bob now has one of $U|\psi\rangle,UX|\psi\rangle,UZ|\psi\rangle,UZX|\psi\rangle$, which we can rewrite as $|\psi\rangle,(UXU^\dagger)U|\psi\rangle,(UZU^\dagger)U|\psi\rangle,(UZXU^\dagger)U|\psi\rangle.$ The compensations that Bob has to make for a given measurement result are given by the bracketed terms. Often, these are no worse than the compensations you would have to make for normal teleportation (i.e. just the Pauli rotations). For example, if $U$ is the Hadamard rotation, then the corrections are just $(\mathbb{I},Z,X,XZ)$ respectively. So, you can apply the Hadamard during teleportation just be changing the state that you teleport through (There is a strong connection here to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Channel-state_duality&quot; rel=&quot;noreferrer&quot;&gt;Choi-Jamiołkowski isomorphism&lt;/a&gt;). You can do the same for Pauli gates, and the phase gate $\sqrt{Z}=S$. Moreover, if you repeat this protocol to build up a more complicated computation, it is often sufficient to keep a record of what these corrections are, and to apply them later.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Even if you don't only need the Pauli gates (as is the case for $T=\sqrt{S}$), the compensations may be easier than implementing the gate directly. This is the basis of the construction of the fault-tolerant T gate.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In fact, you can do something similar to apply a controlled-NOT between a pair of qubits as well. This time, the state you need is $|\Psi\rangle_{A_1B_1}|\Psi\rangle_{A_1B_1}$, and a controlled-NOT applied between $B_1$ and $B_2$. This time, there are 16 possible compensating rotations, but all of them are just about how Pauli operations propagate through the action of a controlled-NOT and, again, that just gives Pauli operations out.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-04-17T11:26:03.857" LastActivityDate="2018-04-17T11:26:03.857" CommentCount="2" />
  <row Id="1811" PostTypeId="2" ParentId="1802" CreationDate="2018-04-17T08:53:49.653" Score="5" Body="&lt;p&gt;Taking your comment to Kiro to its logical conclusion, the answer is 'yes'. The basic idea is to decompose the T&amp;nbsp;gate 'magic' state $\tfrac{1}{\sqrt 2}\bigl(\lvert 0 \rangle + \mathrm{e}^{i \pi / 4} \lvert 1 \rangle \bigr)$ as a linear combination of stabiliser states. (If you do this for several magic states, this produces an exponentially large linear combination.) Representing the T-gate states involved as density operators, together with any other stabiliser states introduced as inputs or as auxiliary work-space, we can use this expansion to compute the probability of any particular Pauli measurement outcome, such as a&amp;nbsp;standard basis measurement on a single qubit, after performing a stabiliser circuit and gate teleportations of the T&amp;nbsp;gates.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The basic idea behind this can be improved by noting that there is more than one way to expand the T-gate state as a linear combination &amp;mdash; particularly if you consider decompositions of &lt;em&gt;several&lt;/em&gt; T-gate states at once, rather than expanding each T-gate state independently, and if furthermore you are happy with an approximate simulation rather than an exact one (see e.g.&amp;nbsp;[&lt;a href=&quot;https://arxiv.org/abs/1601.07601&quot; rel=&quot;noreferrer&quot;&gt;Bravyi+Gossett 2016&lt;/a&gt;] and [&lt;a href=&quot;https://arxiv.org/abs/1609.07488&quot; rel=&quot;noreferrer&quot;&gt;Campbell+Howard 2017&lt;/a&gt;]).&lt;/p&gt;&#xA;" OwnerUserId="124" LastActivityDate="2018-04-17T08:53:49.653" CommentCount="0" />
  <row Id="1812" PostTypeId="2" ParentId="1808" CreationDate="2018-04-17T09:07:36.533" Score="1" Body="&lt;p&gt;There is no scenario of $a^{r/2}\equiv 1\text{ mod }N$ because you have already assumed that $r$ is the smallest value such that $a^r\equiv1\text{ mod }N$, and $r/2$ is smaller than $r$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As you why you have to discount $a^{r/2}\equiv -1\text{ mod }N$, the point is that you've found something that satisfies $(a^r-1)=kN$ for some integer $k$. This factors as $(a^{r/2}-1)(a^{r/2}+1)=kN$  if $r$ is even. Either, one of the terms $(a^{r/2}\pm 1)$ is divisible by $N$, or each contains different factors of $N$. We want them to contain different factors so that we can computer $\text{gcd}(a^{r/2}\pm1,N)$ to find a factor. So, we specifically want that $a^{r/2}\pm 1\neq 0 \text{ mod }N$. One case has been eliminated as stated above by requiring $r$ to be as small as possible. The other we have to explicitly discount.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-04-17T18:02:01.293" LastActivityDate="2018-04-17T18:02:01.293" CommentCount="0" />
  <row Id="1813" PostTypeId="2" ParentId="1808" CreationDate="2018-04-17T09:25:00.190" Score="1" Body="&lt;p&gt;The requirement that $a^r\equiv 1\mod N$ is equivalent  to requiring that $a^r - 1\equiv 0\mod N$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We want a number, $b$, such that the greatest common denominator of $b$ and $N$ is a proper factor of $N$ (i.e. is a factor $\neq 1, N$).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We also have that $a^r-1 = \left(a^{r/2}-1\right)\left(a^{r/2}+1\right)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, we take $b = a^{r/2}-1$. We know that $r$ is the &lt;em&gt;smallest&lt;/em&gt; number such that $a^r = 1\mod N$, showing that $a^{r/2}\neq 1\mod N$ and so $\gcd\left(a^{r/2}-1, N\right)\neq N$ (as otherwise, $N$ would divide $b$).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;By &lt;a href=&quot;https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bézout's identity&lt;/a&gt;, if $\gcd\left(a^{r/2}-1, N\right)=1, \exists\, x_1, x_2\in\mathbb Z \text{ s.t. } \left(a^{r/2}-1\right)x_1+Nx_2 = 1$, or $\left(a^r-1\right)x_1+N\left(a^{r/2}+1\right)x_2 = a^{r/2}+1$. As $N$ divides $a^r-1$, this gives that $N$ divides $a^{r/2}+1$, or $a^{r/2} = -1\mod N$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This gives that the requirement $a^{r/2}\neq -1\mod N$ (alongside the constraint on $r$) is enough to determine that the greatest common denominator of $a^{r/2} - 1$ and $N$ is a proper factor of $N$.&lt;/p&gt;&#xA;" OwnerUserId="23" LastEditorUserId="23" LastEditDate="2018-04-17T10:27:49.283" LastActivityDate="2018-04-17T10:27:49.283" CommentCount="0" />
  <row Id="1814" PostTypeId="2" ParentId="1796" CreationDate="2018-04-17T09:25:54.283" Score="5" Body="&lt;p&gt;The answer is $N = 200\,099$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Shor's algorithm is not the only way to factorize integers. In fact, it is also possible to factorize integers with an optimization approach. This approach even allows for integers with more than two prime-factors to be composed. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;See this paper from D-Wave, &lt;a href=&quot;https://arxiv.org/pdf/1604.05796.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Prime factorization using quantum annealing and&#xA;computational algebraic geometry&lt;/a&gt;, in which the explain their approach and show the results of factoring multiple composite numbers, among which $N=200\,099$. &lt;/p&gt;&#xA;" OwnerUserId="2005" LastEditorUserId="1847" LastEditDate="2018-04-17T17:01:41.293" LastActivityDate="2018-04-17T17:01:41.293" CommentCount="3" />
  <row Id="1815" PostTypeId="1" AcceptedAnswerId="1821" CreationDate="2018-04-17T09:27:11.620" Score="11" ViewCount="206" Body="&lt;p&gt;Let us assume that we have quantum and classical computers such that, experimentally, each elementary logical operation of mathematical factorization is equally time-costing in classical and in quantum factorization:&#xA;Which is the lowest integer value for which the quantum proceeding is faster than the classical one?&lt;/p&gt;&#xA;" OwnerUserId="1955" LastEditorUserId="23" LastEditDate="2018-04-17T18:01:36.347" LastActivityDate="2018-04-24T13:27:21.743" Title="What is the minimum integer value to make quantum factorization to be worthwhile?" Tags="&lt;quantum-computer&gt;&lt;quantum-algorithms&gt;&lt;quantum-speedup&gt;" AnswerCount="2" CommentCount="5" FavoriteCount="2" />
  <row Id="1816" PostTypeId="2" ParentId="1807" CreationDate="2018-04-17T12:08:19.987" Score="7" Body="&lt;p&gt;A standard reference for linear optical quantum computing is Kok et al. 2009 (&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0512071&quot; rel=&quot;nofollow noreferrer&quot;&gt;quant-ph/0512071&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If one qubit is encoded in the polarization degree of freedom of a single photon, and the second qubit in the &lt;em&gt;path&lt;/em&gt; degree of freedom of &lt;em&gt;the same&lt;/em&gt; photon, then a CNOT gate is trivially implemented by a &lt;em&gt;polarizing beamsplitter&lt;/em&gt;.&#xA;This is a kind of beamsplitter that only changes the path of the photon if its polarization is in some polarization state (say, $|V\rangle$), and leaves the photon in its path otherwise.&#xA;This is therefore effectively a CNOT gate where the control qubit is the polarization and the target qubit is the path.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Of course, you cannot use the same idea to implement a gate between more than two qubits.&#xA;Generally speaking, as long as you are working on degrees of freedom of a single photon (position, time/frequency, polarization, orbital angular momentum), it is still &quot;easily&quot; doable to implement transformations between them,&#xA;but this is a limited approach because it is not really scalable to cram too much information into a single photon.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A very different story is the use of polarization qubits of many different photons.&#xA;The main problem with this is that photons &lt;em&gt;do not&lt;/em&gt; naturally interact with each other, so that two-qubit gates between such qubits are nontrivial.&#xA;Indeed, it is easy to show that with linear optics alone it is &lt;em&gt;impossible&lt;/em&gt; to implement arbitrary two-qubit gates in a deterministic way.&#xA;For example, consider the case where one has two single photons, each one in a different spatial mode, and both in the initial polarization state $|H\rangle$.&#xA;Using the standard second quantization notation, the set of transformations that can be implemented between these two photons within linear optics are given by&#xA;$$a_H^\dagger b_H^\dagger \to\left(\sum_{k=H,V}\alpha_k c_k^\dagger +\beta_k d_k^\dagger\right)\left(\sum_{k=H,V}\gamma_k c_k^\dagger +\delta_k d_k^\dagger\right),$$&#xA;where $\alpha_k,\beta_k,\gamma_k,\delta_k$ are parameters characterising the linear transformation that is being implemented, $a_H^\dagger,b_H^\dagger$ are the creation operators of the input photons in the spatial modes $a$ and $b$ with polarization $H$, and $c$ and $d$ denote the two output modes of the photons.&#xA;It can be seen that, for example, no set of values of $\alpha_k,\beta_k,\gamma_k,\delta_k$ can implement the transformation &#xA;$$a_H^\dagger b_H^\dagger\to c_H^\dagger d_V^\dagger + c_V^\dagger d_H^\dagger,$$&#xA;meaning that it is not possible to generate deterministically, within linear optics, to transform $|00\rangle$ into the Bell state $|01\rangle+|10\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What the above tells us is that linear optics quantum computing with single photons &lt;em&gt;requires&lt;/em&gt; some kind of nonlinearity.&#xA;One, therefore, needs to either use nonlinear elements such as Kerr media, or exploit the nonlinearity induced by the measurement process. Unfortunately, it is very hard to find materials implementing strong enough Kerr interactions (I don't think there is, to date, any viable known way to do this, but I may stand corrected).&#xA;On the other hand, linear optical quantum computation using measurements is possible via the &lt;a href=&quot;https://en.wikipedia.org/wiki/KLM_protocol&quot; rel=&quot;nofollow noreferrer&quot;&gt;Knill, Laflamme, and Milburn (KLM) protocol&lt;/a&gt;.&#xA;This protocol exploits photon bunching, gate teleportation, and projective measurements to obtain effective interactions between different polarization qubits.&#xA;I will not go into the details of how this works here, as this may be worth a question of its own, but the circuit to implement a CZ gate using the KLM protocol can be found in Fig. 10 of Kok et al. 2009.&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-04-17T14:48:39.297" LastActivityDate="2018-04-17T14:48:39.297" CommentCount="1" />
  <row Id="1817" PostTypeId="1" AcceptedAnswerId="1820" CreationDate="2018-04-17T13:42:56.093" Score="8" ViewCount="406" Body="&lt;p&gt;When it comes to error correction, we take our stabilizers to be members of the Pauli group. Why is the Pauli group used for this and not, say, the group of all unitary matrices?&lt;/p&gt;&#xA;" OwnerUserId="2015" LastEditorUserId="26" LastEditDate="2018-05-07T13:19:09.810" LastActivityDate="2018-05-07T13:19:09.810" Title="Why is the Pauli group used for stabilizers?" Tags="&lt;quantum-error-correction&gt;&lt;stabilizer-code&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="1818" PostTypeId="2" ParentId="1803" CreationDate="2018-04-17T14:32:03.010" Score="6" Body="&lt;p&gt;&lt;strong&gt;&lt;em&gt;tl;dr&lt;/em&gt;-&lt;/strong&gt; Moore's law won't necessarily apply to the quantum computing industry.  A deciding factor may be if the manufacturing processes can be iteratively improved to exponentially increase something analogous to transistor count or roughly proportional to performance.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Background:  Moore's law and why it worked&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;It's important to note that Moore's law was about the numbers of transistors in high-density integrated circuits, &lt;em&gt;not&lt;/em&gt; the performance or speed of electronics despite common approximate restatements of Moore's law.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;Moore's law&lt;/strong&gt; is the observation that the number of &lt;a href=&quot;https://en.wikipedia.org/wiki/Transistor&quot; rel=&quot;noreferrer&quot;&gt;transistors&lt;/a&gt; in a dense &lt;a href=&quot;https://en.wikipedia.org/wiki/Integrated_circuit&quot; rel=&quot;noreferrer&quot;&gt;integrated circuit&lt;/a&gt; doubles about every two years.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&amp;ndash;&lt;a href=&quot;https://en.wikipedia.org/wiki/Moore%27s_law&quot; rel=&quot;noreferrer&quot;&gt;&quot;Moore's law&quot;&lt;/a&gt;, Wikipedia&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Underlying Moore's law was the simple fact that, for a given integrated circuit size, the number of transistors we could cram into it was roughly proportional to the volume of an individual transistor,$$&#xA;n_{\text{transistors}}~{\approx}~\frac{V_{\text{integrated circuit}}}{V_{\text{transistor}}}.&#xA;$$So, Moore's law was sorta like:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The volume of a transistor halved about every two years.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Then the question becomes, why were transistors able to shrink so rapidly?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This was largely because transistors are basically made of microscopically fabricated wires in an integrated circuit, and as manufacturing technology progressed, we were able to make smaller-and-smaller wires:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&lt;a href=&quot;https://en.wikipedia.org/wiki/File:Comparison_semiconductor_process_nodes.svg&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/c/c7/Comparison_semiconductor_process_nodes.svg&quot; width=&quot;550&quot;&gt;&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The process of making crazy-small wires in an integrated circuit took a lot of research know-how, so folks in industry basically set out to iteratively improve their fabrication processes at such a rate to maintain Moore's law.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, Moore's law is now basically over.  Our fabrication processes are nearing the atomic scale such that the physics of the situation are changing, so we can't just keep shrinking further.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Can Moore's law work for quantum components?&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;As noted above, Moore's law is basically ending now.  Computers will likely pick up speed due to other advances, but we aren't really planning to make sub-atomic transistors at this time.  So despite industry's strong desire to maintain it, it seems unlikely.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we assume similar behavior in a future quantum-computing industry, then we might assume that something like Moore's law might arise if industry finds itself in a similar position, where it can iteratively improve the components' manufacturing process to exponentially increase their count (or some similar metric).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;At this time, it's unclear what basic industrial metric quantum computer manufacturers might iteratively improve over the course of decades to recreate a trend like Moore's law, largely because it's unclear what sort of quantum computing architectural technologies might find widespread deployment like modern integrated circuits have.&lt;/p&gt;&#xA;" OwnerUserId="15" LastActivityDate="2018-04-17T14:32:03.010" CommentCount="0" />
  <row Id="1819" PostTypeId="2" ParentId="1817" CreationDate="2018-04-17T15:58:35.250" Score="4" Body="&lt;p&gt;Any operator from the Pauli group has two eigenspaces of equal size. So we known that by adding stabilizer generator from this group, we reduce the size of the stabilizer space by half. This means that the stabilizer space would fit one less logical qubit. This makes it easy to know when we have enough stabilizers: to store $k$ logical qubits in $n$ physical qubits, we just need $n-k$ independent stabilizer generators.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Also, the Pauli group is made up of Hermitian operators. Since the point of a stabilizer is to be measured, it is useful for them to be Hermitian, since they can be directly interpreted as observables.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Furthermore, the the operators that map between stabilizer states (mutual eigenstates of stabilizer operators) will themselves be elements of the Pauli group. This is related to the point raised in your comment: Pauli group elements form a complete basis to describe multi-qubit operation. So once we measure the stabilizers, and the noise is effectively reduced to a mapping between stabilizer states, it is pretty much as if the noise just applied a bunch of simple Paulis. Correction can be then done by a simple Pauli frame rotation. This doesn't even require us to directly apply any gate to the code. We can just say &quot;It looks like a $\sigma_x$ hit this qubit, so from now on I'll interpret its $|0\rangle$ as $|1\rangle$, and vice-versa&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Paulis aren't required, but they have nice properties. So that's why they are the focus&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-04-17T18:12:14.527" LastActivityDate="2018-04-17T18:12:14.527" CommentCount="0" />
  <row Id="1820" PostTypeId="2" ParentId="1817" CreationDate="2018-04-17T16:13:33.520" Score="4" Body="&lt;p&gt;There are some fairly simple reasons &amp;mdash; beyond the merely historical &amp;mdash; to use Pauli matrices instead of arbitrary unitary matrices. These reasons may not uniquely single out the Pauli group of operators, but they do significantly limit the scope of what is productive to consider.&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;A stabiliser operator $S$, first and foremost, must have a +1 eigenvalue; otherwise there isn't any state $\lvert \psi \rangle$ which it 'stabilises', in the sense that $S \lvert \psi \rangle = \lvert \psi \rangle$. So we must restrict ourselves to sets of operators which have +1 eigenvalues.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Secondly, we must consider how the stabiliser operators may be used operationally. If we know that there is a symmetry of the system that should hold, but we don't have any way to determine whether or not that symmetry holds in practise (that is, whether some error has occurred), then we're out of luck. What we would like to be able to do then is to be able to perform phase estimation to test whether or not the eigenvalue of a given state $\lvert \psi \rangle$ with respect to some allegedly-stabilising operator $S$ is in fact +1, to determine whether $\lvert \psi \rangle$ deviates from the properties that hold of it.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This motivates considering operators $S$ which, yes, are unitary, but&#xA;also where the eigenvalues differ significantly from one another, in&#xA;order for phase estimation to easily distinguish a state with significant error from one with insignificant error. This motivates considering a set of $n$-qubit operators which have at most $1/\mathrm{poly}(n)$ eigenvalues.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Part of the whole problem is that we would like to detect and correct for operations which may be involved in complicated quantum transformations. If the phase estimation involved in eigenvalue estimation of a stabilising operator $S$ is itself complicated, we're not helping the situation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What would be good is for each of the stabilising operators $S$ we consider to have very simple structure: for instance, we may be especially interested in the case that they are tensor products of 1- or 2-qubit operations. It seems sensible to approach the subject by considering each operator $S$ to be a tensor product of single qubit operations.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;In order to consider tensor product operations on $k \leqslant n$ qubits, which have at most $1/\mathrm{poly}(k)$ distinct eigenvalues, including +1 &amp;mdash; and without imposing awkward constraints on which single-qubit operators act on which qubits &amp;mdash; we are more or less forces to consider single-qubit unitary operators whose eigenvalues range within some finite set $E \subseteq \mathbb C$ (independent of $k$ or $n$) which includes +1.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We may reduce this to the case $E = \{+1,-1\}$ by observing that estimating the eigenvalues of a tensor product operator $S = S_1 \otimes S_2 \otimes \cdots \otimes S_k$, where each $S_j$ has one +1 eigenvalue and one eigenvalue which is not +1, is the same as doing an artificially shortened version of eigenvalue estimation for an operator $P_j$ which has eigenvalues $\pm 1$. Furthermore, in order to consider several operators $S$ which manage to have a useful common +1 eigenspace, it helps for each operator S to have as large a +1 eigenspace as possible; then it helps for it to be as easy as possible for the eigenvalues of each $S_j$ to multiply to +1. This again motivates the case for the eigenvalues of $S_j$ to be $\pm 1$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Nothing forces us to consider the &lt;em&gt;group&lt;/em&gt; of operators generated by such a set, but the products of our stabiliser operators will also be stabiliser operators, and we have enough constraints on our operators that we can at least reasonably contemplate the group generated by our stabiliser operators.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We have operators $S = S_1 \otimes \cdots \otimes S_n$ and $S' =&#xA;    S'_1 \otimes \cdots \otimes S'_n$ whose tensor factors are all&#xA;either $\mathbb 1$ or non-trivial reflections on single-qubit&#xA;states; their products $S_j S'_j$ will be rotations by an angle&#xA;$\theta$ determined by the angles between the eigenbases of $S_j$&#xA;and $S'_j$. If we want to obtain a nice clean theory, we might want&#xA;these products of stabiliser operators to themselves be easy to&#xA;measure: this motivates having $S_j S'_j$ to be proportional to an operator with eigenvalues $\pm 1$ (actually $S_j S'_j$ will have eigenvalues $\pm i$), in which case $S_j$ and $S'_j$ anticommute.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Thus, the above combination of theoretical and practical constraints suffice to yield something which is isomorphic to the Pauli group. Furthermore, as the Pauli operators have a theory which is fairly easily understood, it has led to a fruitful theory of quantum error correction. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;A fair question would be which of the above moves were more arbitrary than the others.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;It would not astonish me if there was a productive theory of error correction in which the constraints were tensor product operators, whose tensor factors had eigenvalues $\pm 1$, but where the possible operators &lt;em&gt;did not necessarily&lt;/em&gt; anticommute (step&amp;nbsp;5 above).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;More sophisticated (and more difficult) would be a powerful and&#xA;useful theory of error correction in which the stabilising operators&#xA;which one measures included operators which are not tensor product&#xA;operators (step&amp;nbsp;3 &amp;mdash; which would motivate not worrying too&#xA;much about having group structure in the group of stabilisers which&#xA;you intend to measure).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;From a purely mathematical perspective, there is nothing obvious to &lt;em&gt;prevent&lt;/em&gt; or &lt;em&gt;discourage&lt;/em&gt; such a line of investigation &amp;mdash; aside, of course from the fact that it is likely to be hard and also likely to be unnecessary &amp;mdash; and in this sense, it would be perfectly fine to consider theories of quantum error correction extending well beyond the Pauli group.&lt;/p&gt;&#xA;" OwnerUserId="124" LastActivityDate="2018-04-17T16:13:33.520" CommentCount="0" />
  <row Id="1821" PostTypeId="2" ParentId="1815" CreationDate="2018-04-17T18:38:42.757" Score="7" Body="&lt;p&gt;The quantum part of Shor's algorithm is, essentially, a single modular exponentiation done under superposition followed by a Fourier transform and then a measurement. The modular exponentiation is by far the most expensive part.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;em&gt;Let us assume that [...] each elementary logical operation of mathematical factorization is equally time-costing in classical and in quantum factorization&lt;/em&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;If we assume that the modular exponentiation takes exactly as long on a quantum computer as it would on a classical computer, then the transition where the quantum computation became better would happen at a very low number. Computing modular exponentiations is very fast, classically, because you can use repeated squaring. I would wildly estimate the crossover to happen even before you even get to 30 bit numbers (numbers over a billion).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;But quantum computers are not going to do math nearly as fast as classical computers&lt;/strong&gt;. For example, on my laptop, I can do a 1000-bit modular exponentiation in python in a fraction of a second. But on foreseeable quantum computers, it would take hours or days. The issue is the massive (&lt;em&gt;massive&lt;/em&gt;) difference in the cost of an AND gate.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;On a classical machine, performing an AND is so inconsequential that we don't even really think about it when programming. It's way more likely for you to think in terms of counting 64-bit additions than in terms of counting AND gates, when determining the cost of your algorithm. But on an error corrected quantum computer, performing an AND (usually temporarily, via a Toffoli) tends to be expensive. For example, you can do it by distilling four high-quality $|T\rangle$ states. I won't go into the numbers... suffice it to say that on early error corrected machines you would be very happy to get a million T states per second.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So suppose we get a million T states per second, and we want to convert this into a rate of 64-bit additions to compare with the classical machine. A 64-bit addition requires 64 AND gates, each requiring 4 T gates. 1 million divided by 4 divided by 64 gives... about 4KHz. For contrast a classical machine will easily do a billion additions per second. &lt;em&gt;Quantum adders are a million times slower than classical adders&lt;/em&gt; (again, wildly estimating, and keep in mind this number should improve over time).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Another factor worth considering is the differing costs of quantum and classical computers. If you have a hundred million dollars, and you're choosing between one quantum computer and a thousand classical computers, that factor of 1000 has to be accounted for. In this sense, we could say quantum adders are a &lt;em&gt;billion&lt;/em&gt; times less efficient than classical adders (in FLOPS/$).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A constant factor penalty of &lt;em&gt;a billion&lt;/em&gt; is normally an immediate deal breaker. And for quantum algorithms with a mere quadratic advantage (like Grover), I contend that it is in fact a deal breaker. But Shor's algorithm gets exponentially better relative to the classical strategy as you increase the number of bits in the number to factor. How many bits before we eat away that &quot;measly&quot; 10^9 constant with our exponential growth in advantage?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Consider that &lt;a href=&quot;https://en.wikipedia.org/wiki/RSA-200#RSA-640&quot; rel=&quot;nofollow noreferrer&quot;&gt;RSA-640 was factored&lt;/a&gt; in 2005 using ~33 CPU years. A quantum computer should be able to do that number in under a day. If you have a thousand classical computers working on the problem, they'd finish in about two weeks. So it seems like quantum is winning by 640 bits, but only by an order of magnitude or three. So maybe the cutoff would occur somewhere around 500 bits?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Anyways, I know this is not a hard and fast answer. But hopefully I've conveyed some sense of the quantities I would think about when comparing classical and quantum. Really no one knows the constant factors involved yet, so I'd be surprised if anyone could give you a proper estimate better than &quot;somewhere in the hundreds of bits&quot;.&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-04-17T20:49:16.637" LastActivityDate="2018-04-17T20:49:16.637" CommentCount="3" />
  <row Id="1822" PostTypeId="1" AcceptedAnswerId="1828" CreationDate="2018-04-17T18:44:52.797" Score="6" ViewCount="310" Body="&lt;p&gt;I keep reading (e.g. Nielsen and Chuang, 2010; pg456 and 465) the following three phases; &quot;code space&quot;, &quot;code word&quot; and &quot;stabilizer code&quot; - but am having a difficult time finding definitions of them and more importantly how they differ from one another.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is therefore; how are these three terms defined and how are they related?&lt;/p&gt;&#xA;" OwnerUserId="2015" LastEditorUserId="26" LastEditDate="2018-05-07T13:18:47.137" LastActivityDate="2018-06-02T06:21:11.300" Title="What is the difference between &quot;code space&quot;, &quot;code word&quot; and &quot;stabilizer code&quot;?" Tags="&lt;terminology&gt;&lt;quantum-error-correction&gt;&lt;stabilizer-code&gt;" AnswerCount="3" CommentCount="0" />
  <row Id="1823" PostTypeId="2" ParentId="1822" CreationDate="2018-04-17T19:07:54.510" Score="3" Body="&lt;p&gt;A code word (for a quantum code) is a quantum state that is typically associated with a state in the logical basis. So, you’ll have some state $|\psi_0\rangle$ that corresponds to the 0 state of the qubit to be encoded (you don’t have to use qubits, but you probably are), and you’ll have another that’s $|\psi_1\rangle$ that corresponds to the 1 state of the qubit to be encoded.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The code space is the space spanned by the code words, i.e. the entire space $\alpha|\psi_0\rangle+\beta|\psi_1\rangle$ for all possible $\alpha$ and $\beta$ (normalised).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A stabilizer code is one possible formalism for telling you how to work out the code words and therefore the code space. For an [[n,k,d]] code, you are given n-k stabilizer operators $S$ ($S^2=\mathbb{I}$) that mutually commute, and act on n qubits. Any state $|\psi\rangle$ in the code space satisfies $S|\psi\rangle=|\psi\rangle$. You will further have operators $Z_m$ and $X_m$ for $m=1,\ldots k$ that all commute with the stabilizers $S$ but pairwise anticommute, $\{Z_m,X_m\}=0$, for matching subscripts. These define the Logical Pauli operators for the code, and the code words are therefore the states that satisfy $Z_m|\psi\rangle=\pm|\psi\rangle$.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-04-17T19:15:22.333" LastActivityDate="2018-04-17T19:15:22.333" CommentCount="0" />
  <row Id="1824" PostTypeId="2" ParentId="1822" CreationDate="2018-04-17T19:10:44.123" Score="3" Body="&lt;p&gt;In a quantum error correcting code, you store a number of &lt;em&gt;logical&lt;/em&gt; qubits, $k$, in a state of many physical qubits, $n$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A code word is a state of the physical qubits that is associated with a specific logical state. So, for example, however you store the $|0\rangle$ state for one of your logical qubits is a code word.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The code space is the Hilbert space spanned by all possible code words. For a stabilizer code, this term is synonymous with the stabilizer space. Any state within this code space is a code word&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A stabilizer code is a quantum error correcting code described by the stabilizer formalism. The stabilizer space is defined as the mutual $+1$ eigenspace of $n-k$ mutually commuting and independent tensor products of Pauli operators.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-04-18T05:36:11.957" LastActivityDate="2018-04-18T05:36:11.957" CommentCount="0" />
  <row Id="1825" PostTypeId="1" AcceptedAnswerId="1831" CreationDate="2018-04-17T19:39:44.590" Score="3" ViewCount="57" Body="&lt;p&gt;I'm currently busy learning about the basics of quantum information theory. Does anyone know how the measurement described in the wiki link &lt;a href=&quot;https://en.wikipedia.org/wiki/LOCC&quot; rel=&quot;nofollow noreferrer&quot;&gt;LOCC&lt;/a&gt; is a measurement on the product space $\mathbb{C}^2 \otimes \mathbb{C}^n$ as stated? &lt;/p&gt;&#xA;" OwnerUserId="2032" LastActivityDate="2018-04-18T07:29:23.660" Title="Local operations and classical communication (LOCC) on quantum system" Tags="&lt;quantum-entanglement&gt;&lt;quantum-information&gt;" AnswerCount="1" CommentCount="1" FavoriteCount="1" />
  <row Id="1826" PostTypeId="1" AcceptedAnswerId="4060" CreationDate="2018-04-16T11:17:08.780" Score="11" ViewCount="155" Body="&lt;p&gt;In Cabello's paper &lt;em&gt;Quantum key distribution without alternative measurements&lt;/em&gt;, the author said &quot;the number of useful random bits shared by Alice and Bob by transmitted qubit, before checking for eavesdropping, is 0.5 bits by transmitted qubit, both in BB84 and B92 (and 0.25 in E91)&quot; (see &lt;a href=&quot;https://arxiv.org/pdf/quant-ph/9911025.pdf&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;, page 2).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In E91 protocol, Alice and Bob each chooses independently and randomly from three measurement bases, so there are 9 situations and only 2 of them can yeild correct bits. Does that mean the efficiency of E91 is $\frac 2 9$ ? Why does the useful random bits is 0.25 bits by transmitted qubits in E91? &lt;/p&gt;&#xA;" OwnerUserId="2047" OwnerDisplayName="Shireen" LastEditorUserId="2293" LastEditDate="2018-07-08T09:13:18.277" LastActivityDate="2018-08-21T09:31:13.243" Title="Why is the efficiency of Ekert 91 Protocol 25%?" Tags="&lt;quantum-information&gt;" AnswerCount="3" CommentCount="7" FavoriteCount="1" />
  <row Id="1827" PostTypeId="2" ParentId="1792" CreationDate="2018-04-17T20:40:41.790" Score="2" Body="&lt;p&gt;Superpositions in Fock space--and rotations in Fock space--are absolutely ubiquitous. &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;It is important to note that &lt;em&gt;all&lt;/em&gt; classical states of the electromagnetic field are superpositions of many different photon-number eigenstates.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;The entire discipline of &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_field_theory&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum field theory&lt;/a&gt; (approximately) concerns which rotations within certain physically-motivated Fock spaces are allowed, and with what amplitudes they actually occur.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;The experimental paradigms of &lt;a href=&quot;https://en.wikipedia.org/wiki/Circuit_quantum_electrodynamics&quot; rel=&quot;nofollow noreferrer&quot;&gt;circuit&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Cavity_quantum_electrodynamics&quot; rel=&quot;nofollow noreferrer&quot;&gt;cavity QED&lt;/a&gt;--which validate exquisitely the predictions of that now 70-year-old theory--explicitly deals with operations on photon number states (in particular &quot;the presence or absence of a single photon&quot; as DaftWullie put it), and are cornerstones of atomic, molecular and optical physics. Circuit QED is the essential theory underpinning superconducting flux qubits, which devices have been shown to display coherent quantum effects beyond any reasonable or unreasonable doubt. &lt;a href=&quot;https://en.wikipedia.org/wiki/Serge_Haroche&quot; rel=&quot;nofollow noreferrer&quot;&gt;Serge Haroche&lt;/a&gt; was awarded the 2012 Nobel Prize in physics for his work on cavity QED, in which he went on happily creating, controlling and measuring superpositions of small numbers of microwave photons. Lots of experimentalists do this every day.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;It has long been suggested that a single harmonic mode be used to represent one or more qubits in a practical quantum computer, in which logical states are encoded as superpositions of states of different occupation number. For a few ideas on how to do this as well a few reasons why it might not be the best idea, see Nielsen and Chuang, section 7.2.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;There's no shortage of literature on ways to perform these kinds of operations. In fact, a nontrivial fraction of modern physics is concerned with exactly that. I can't imagine where or how you would get the opposite idea.&lt;/p&gt;&#xA;" OwnerUserId="2034" LastEditorUserId="2034" LastEditDate="2018-04-17T20:46:08.857" LastActivityDate="2018-04-17T20:46:08.857" CommentCount="1" />
  <row Id="1828" PostTypeId="2" ParentId="1822" CreationDate="2018-04-17T23:12:29.187" Score="5" Body="&lt;p&gt;&lt;strong&gt;Code spaces and code-words&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A quantum error correcting code is often identified with the code-space (Nielsen &amp;amp; Chuang certainly seem to do so). The &lt;em&gt;code space&lt;/em&gt; $\mathcal C$ of e.g.&amp;nbsp;an $n$-qubit quantum error correction code is a vector subspace $\mathcal C \subseteq \mathcal H_2^{\otimes n}$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;A &lt;em&gt;code word&lt;/em&gt; (terminology which was borrowed from the classical theory of error correction) is a state $\lvert \psi \rangle \in \mathcal C$ for some code-space: that is, it is a state which encodes some data.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Quantum error correction codes&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In practice, we demand some non-trivial properties to hold of a quantum error correction code, such as:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;That $\mathop{\mathrm{dim}} \mathcal C \geqslant 2$, so that there is a non-zero amount of information being encoded;&lt;/li&gt;&#xA;&lt;li&gt;That there are a set $\mathcal E = \{ E_1, E_2, \ldots \}$ of at least two operators including the operator $E_1 = \mathbb 1$, such&#xA;that &amp;mdash; if $P$ is the orthogonal projector onto $\mathcal C$ &amp;mdash; we have $$P E_j E_k P = \alpha_{j,k} P$$&#xA;for some scalars $\alpha_{j,k}$ (known as the &lt;em&gt;Knill&amp;ndash;Laflamme conditions&lt;/em&gt;).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;This determines some set of error operators against which you can in principle protect a state $\lvert \psi \rangle \in \mathcal C$, in that if the Knill&amp;ndash;Laflamme conditions hold of a set of operators $\mathcal E$, and some operator $E \in \mathcal E$ acts on your state, it is possible in principle to detect the fact that $E$ has occurred (as opposed to some other operator in $\mathcal E$) and undo the error, without disrupting the data stored in the original state $\lvert \psi \rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A &lt;em&gt;quantum error correction code&lt;/em&gt; is a code-space $\mathcal C$, &lt;em&gt;together with&lt;/em&gt; a set of error operators $\mathcal E$ which satisfy the Knill&amp;ndash;Laflamme conditions &amp;mdash; that is, a quantum error correcting code must specify which errors it is meant to protect against.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Why it is common to identify quantum error correcting codes with their code-spaces&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You cannot determine a unique set $\mathcal E$ of operators which satisfy the Knill&amp;ndash;Laflamme conditions from the code-space $\mathcal C$ alone. However, it is most common to consider which &lt;em&gt;low-weight&lt;/em&gt; operators (ones which act only on a small number of qubits) can be simultaneosuly corrected by a code, and to an extent this &lt;em&gt;can&lt;/em&gt; be derived from the code-space alone. The &lt;em&gt;code distance&lt;/em&gt; of a code space $\mathcal C$ is the smallest number of qubits that you have to act on, to transform one &quot;code-word&quot; $\lvert \psi \rangle \in \mathcal C$ into a distinct codeword $\lvert \psi' \rangle \in \mathcal C$. If we then describe a code-space as being a $[\![n,k,d]\!]$ code, this then says that $\mathcal C \subseteq \mathcal H_2^{\otimes n}$ has dimension $2^k$, and that the set $\mathcal E$ that we consider is the set of all Pauli operators with weight at most  $\lfloor (d{-}1)/2 \rfloor$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In some cases, describing a code as an $[\![n,k,d]\!]$ code is enough. For instance, the 5-qubit code is a $[\![5,1,3]\!]$ code, and it is possible to show that five qubits cannot encode a single qubit in such a way that &lt;em&gt;any other errors&lt;/em&gt; can be corrected in addition to all of the single-qubit errors.&#xA;However, the same is not true of the Steane $[\![7,1,3]\!]$ code, which can protect against any single-qubit Pauli error as well as &lt;em&gt;some&lt;/em&gt; (but not all) two-qubit Pauli errors. Which two-qubit Pauli errors you &lt;em&gt;should&lt;/em&gt; protect against depends on what your error model is; and if your noise is symmetric and independently distributed, it won't matter very much what you choose (so that you will likely make the conventional choice of any single $X$ error together with any single $Z$ error). It is however a &lt;em&gt;choice&lt;/em&gt;, and one which will guide how you protect your data against noise.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Stabiliser codes&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A stabiliser code is a quantum error correction code determined by a set $\mathscr  S$ of &lt;em&gt;stabiliser generators&lt;/em&gt;, which are Pauli operators which commute with one another, and which define a code-space $\mathcal C$ by the intersection of their +1-eigenspaces. (It is often useful to consider the &lt;em&gt;stabiliser group&lt;/em&gt; $\mathcal G$ formed by products of $P \in \mathscr S$.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Almost all quantum error correction codes that people consider in practise are stabiliser codes. This is one reason why you may have problems distinguishing the two terms. However, we do not require that a quantum error correction code  be a stabiliser code &amp;mdash; just as in principle we do not require a classical error correction code to be a linear code. Stabiliser codes just happen to be an extremely successful way of describing quantum error correcting codes, just as linear error correcting codes are an extremely successful way of describing classical error correcting codes. And indeed, stabiliser codes can be regarded as a natural &lt;em&gt;generalisation&lt;/em&gt; of the theory of classical linear codes to quantum error correction.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As people are often interested just in low-weight operators which are less than half the code distance, the set of stabilisers is often all people say about an stabiliser correction code. However, to specify the set of errors $\mathcal E$ against which the code can protect, it is necessary also to specify a relationship $\sigma$ between Pauli product operators $E$ and  subsets $S \subseteq \mathscr S$, such that&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$E$ anticommutes with $P \in \mathscr S$ if and only if $P \in S$ for $\sigma(E,S)$;&lt;/li&gt;&#xA;&lt;li&gt;If $E, E'$ both satisfy $\sigma(E,S)$ and $\sigma(E',S)$, then $E E' \in \mathcal G = \langle \mathscr S \rangle$.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;This defines a set $$\mathcal E = \bigl\{ E  \mathbin{\big\vert}&#xA;   \exists S \subseteq \mathscr S: \sigma(E,S) \bigr\}$$ of errors&#xA;   against which the code can protect.&#xA;The subsets $S \subseteq \mathscr S$ are called &lt;em&gt;error syndromes&lt;/em&gt;, and the relation which I've called $\sigma$ here (which you don't usually see given an explicit name) associates syndromes to one or more errors which 'cause' that syndrome, and whose effects on the code are equivalent.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;'Syndromes' represent information that can actually be obtained about an error by 'coherent measurement' &amp;mdash; that is, by measuring operators $P \in \mathscr S$ as observables (a process which is usually simulated by eigenvalue estimation). An error $E$ 'causes' a syndrome $S \subseteq \mathscr S$ if, for any code-word $\lvert \psi \rangle \in \mathcal C$, the state $E \lvert \psi \rangle$ is in the $-1$ eigenspace of all operators $P \in S$, and in the $+1$-eigenspace of all other operators in $\mathscr S$. (This property is directly related to the anticommutation of $E$ with all of the elements of $S \subseteq \mathscr S$, and only those elements.)  &lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-06-02T06:21:11.300" LastActivityDate="2018-06-02T06:21:11.300" CommentCount="5" />
  <row Id="1829" PostTypeId="2" ParentId="1716" CreationDate="2018-04-18T00:37:59.780" Score="4" Body="&lt;p&gt;It may or may not be &lt;em&gt;exactly&lt;/em&gt; what you're looking for, but there is research done on &lt;a href=&quot;https://arxiv.org/abs/1602.06004&quot; rel=&quot;nofollow noreferrer&quot;&gt;coherent charge oscillations in a silicon field-effect transistor&lt;/a&gt; (paper by Gonzalez-Zalba et. al. at Hitatchi labs).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the above paper, they coherently control a double quantum dot in a silicon-on-insulator nanowire CMOS transistor, with a $T_2$ coherence time of $\approx 100$ ps. While this is a small coherence time, as already existing CMOS technology was used, putting this (or something similar) on a classical chip would be relatively easy. Although it's probably not going to perform any advanced quantum computations in the near future, it arguably demonstrates some potential for a limited classical/quantum hybrid chip. Regardless, this is a clear example of a field-effect transistor having the potential to be used for quantum computation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The same labs also created a &lt;a href=&quot;https://arxiv.org/abs/1008.2844&quot; rel=&quot;nofollow noreferrer&quot;&gt;Spin Hall effect transistor&lt;/a&gt;, where they use spin-orbit coupling to manipulate spin to implement an AND gate. While spin-orbit coupling is a quantum mechanical process (that doesn't particularly involve quantum information or computing), manipulating spin is something that's required in various different types of quantum computer and so, I wouldn't be all that surprised if talking about such processes in terms of quantum computing/information were possible to some extent.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Overall&lt;/strong&gt;, while you may or may not count the above as definitive evidence of what you want, they are at least small steps in that direction&lt;/p&gt;&#xA;" OwnerUserId="23" LastActivityDate="2018-04-18T00:37:59.780" CommentCount="0" />
  <row Id="1830" PostTypeId="2" ParentId="105" CreationDate="2018-04-18T06:32:25.713" Score="2" Body="&lt;p&gt;To understand this question (and its possible answers) properly, we need to discuss a couple of concepts related to &lt;strong&gt;temperature&lt;/strong&gt; and its relation to quantum states. Since I think the question makes more sense in the &lt;strong&gt;solid state&lt;/strong&gt;, this answer will assume that's what we're talking about.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For starters, I find it useful to think about &lt;a href=&quot;https://en.wikipedia.org/wiki/Boltzmann_distribution&quot; rel=&quot;nofollow noreferrer&quot;&gt;Boltzmann's distribution&lt;/a&gt;: a probability distribution that gives the probability $p_i$ that a system will be in a certain state $i$ as a function of that state’s energy ${\varepsilon}_i$ and the temperature $T$ of the system:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$p_i={\frac{e^{- {\varepsilon}_i / k T}}{\sum_{j=1}^{M}{e^{- {\varepsilon}_j / k T}}}}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;where $k$ is Boltzmann's constant.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In a system that is in &lt;strong&gt;equilibrium&lt;/strong&gt;, as defined by statistical mechanics, the population of the different quantum states is governed by this equation (the system will be in a &lt;em&gt;thermal&lt;/em&gt; state). If we think of a single quantum system rather than a collection or &quot;&lt;em&gt;ensemble&lt;/em&gt;&quot;, this distribution of populations would correspond to a series of weights in a &lt;a href=&quot;https://en.wikipedia.org/wiki/Density_matrix&quot; rel=&quot;nofollow noreferrer&quot;&gt;mixed state&lt;/a&gt;.&#xA;In any case, &lt;strong&gt;these are not the conditions one needs for quantum computing&lt;/strong&gt;, where at any given time we want to have a good control the wavefunction. However, note that these probabilities have an exponential dependence on ${\varepsilon}_i$. This will be important further down.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Additionally, we need to consider &lt;a href=&quot;https://en.wikipedia.org/wiki/Phonon&quot; rel=&quot;nofollow noreferrer&quot;&gt;phonons&lt;/a&gt;, the collective excitations in periodic, elastic arrangements of atoms or molecules in condensed matter. These are often the carriers of energy to and from our qubits into the part of the solid where we do not have an exquisite quantum control and thich therefore is thermalized: the so-called &lt;em&gt;thermal bath&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Why must quantum computers operate under such extreme temperature conditions?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;We can never fully control the quantum state of a solid chunk of matter. At the same time, &lt;strong&gt;we do need full control over the quantum state of our quantum computer&lt;/strong&gt;, meaning &lt;em&gt;the subset of quantum states where our information resides&lt;/em&gt;. These will live in pure states (including quantum superpositions), surrounded by a disordered -thermalized- environment.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Think about the Boltzmann distribution described above, and about the exponential term. In practice, its equation means that we can assume  $p_i=0$ when the relation between temperature and the energy of the states we're interested in (which often means the states corresponding to our qubits) is such that ${\varepsilon}_i&amp;lt;&amp;lt;kT$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Kinetics are often hard to model, but you know that &lt;strong&gt;inevitably your system will tend to thermalize&lt;/strong&gt;. So, you need to keep your quantum computer, for as long as possible, in a state such that the only excitations that occur are those corresponding to the quantum states and quantum operations that are part of your computation. If the temperature of the solid where the quantum system is residing is low, you only need to worry about your qubits uncontrollably relaxing to a lower-energy state (which is bad enough). If the temperature is high, you also need to worry about your qubits being uncontrollably excited to higher-energy states. Inevitably, this also includes states that are outside your computational basis, meaning states that, for your qubit state, are neither $|0&amp;gt;$ nor $|1&amp;gt;$, nor any complex combination thereof: harder-to-correct errors.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you now think about the phonons, recall that they are excitations, which cost energy, and thus are more abundant at high temperature. With rising temperatures, there is a rising number of available phonons, and they will present rising energies, sometimes allowing for interaction with different kinds of excitations (accelerating the kinetics toward thermalization): eventually, those that are detrimental to our quantum computer.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Is the need for extremely low temperatures the same for all quantum computers, or does it vary by architecture?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;It does vary, and dramatically so. Within the solid state, it depends on the energies of the states that constitute our qubits. Outside the solid state, as pointed out above and in a follow-up question (&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/117/why-do-optical-quantum-computers-not-have-to-be-kept-near-absolute-zero-while-su&quot;&gt;Why do optical quantum computers not have to be kept near absolute zero while superconducting quantum computers do?&lt;/a&gt;), it's a whole another story.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;What happens if they overheat?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;See above. In a nutshell: you lose your quantum information faster.&lt;/p&gt;&#xA;" OwnerUserId="1847" LastActivityDate="2018-04-18T06:32:25.713" CommentCount="0" />
  <row Id="1831" PostTypeId="2" ParentId="1825" CreationDate="2018-04-18T07:29:23.660" Score="4" Body="&lt;p&gt;I assume the question refers to how LOCC is used to distinguish the two states&#xA;$$&#xA;(|00\rangle+|11\rangle)/\sqrt{2}\qquad(|01\rangle+|10\rangle)/\sqrt{2}&#xA;$$&#xA;when Alice and Bob each hold one qubit, and are separated by a great distance.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are many different measurement operators that could achieve the same task. If Alice just held both qubits herself, she could simply implement a measurement in the Bell basis, described by measurement operators&#xA;$$&#xA;M_0=\frac12(|00\rangle+|11\rangle)(\langle00|+\langle11|)\qquad M_1=\frac12(|00\rangle-|11\rangle)(\langle00|-\langle11|)\qquad M_2=\frac12(|01\rangle+|10\rangle)(\langle01|+\langle10|)\qquad M_3=\frac12(|01\rangle-|10\rangle)(\langle01|-\langle10|)&#xA;$$&#xA;However, these measurements don't have a tensor product structure, and so cannot be implemented by LOCC. The results $M_0$ and $M_2$ distinguish the two states given.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As an alternative, Alice and Bob do as described at the original link; both make $Z$ basis measurements. So, their measurement operators are described by&#xA;$$&#xA;M_0'=|0\rangle\langle0|\otimes |0\rangle\langle0|\qquad &#xA;M_1'=|0\rangle\langle0|\otimes |1\rangle\langle1|\qquad &#xA;M_2'=|1\rangle\langle1|\otimes |0\rangle\langle0|\qquad &#xA;M_3'=|1\rangle\langle1|\otimes |1\rangle\langle1|&#xA;$$&#xA;If they get either answers $M_0'$ or $M_3'$, they had the first state, while if they get $M_1'$ or $M_2'$ they had the second state. Note that while Alice and Bob each act locally, on their qubit (as you can tell from the tensor product structure), they only know which overall result they got by comparing their measurement results, which requires classical communication.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now a brief comment about the dimension of the Hilbert space. I have specifically talked about two qubits, $\mathbb{C}^2\otimes\mathbb{C}^2$. The first set of measurement operators, $\{M_k\}$, cannot be described under this tensor product structure; they are operators on $\mathbb{C}^4$, while the $\{M_k'\}$ operators can be described under $\mathbb{C}^2\otimes\mathbb{C}^2$. As for why the original source was talking about $\mathbb{C}^2\otimes\mathbb{C}^n$, for that specific example it seemed to be an unnecessary complication. Yes, you can always restrict to a qubit inside a larger Hilbert space, but there's no reason not to just take $n=2$ as far as I can see.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-04-18T07:29:23.660" CommentCount="6" />
  <row Id="1832" PostTypeId="1" AcceptedAnswerId="1834" CreationDate="2018-04-18T11:22:54.807" Score="9" ViewCount="592" Body="&lt;p&gt;The complexity class &lt;a href=&quot;https://en.wikipedia.org/wiki/BQP&quot; rel=&quot;noreferrer&quot;&gt;BQP&lt;/a&gt; (bounded-error quantum polynomial time) seems to be defined only considering the time factor. Is this always meaningful? Do algorithms exist where computational time scales polynomially with the input size but other resources such as memory scale exponentially?&lt;/p&gt;&#xA;" OwnerUserId="1931" LastEditorUserId="23" LastEditDate="2018-04-18T11:56:34.303" LastActivityDate="2018-04-18T11:58:13.493" Title="Is BQP only about time? Is this meaningful?" Tags="&lt;quantum-algorithms&gt;&lt;complexity-theory&gt;&lt;bqp&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="2" />
  <row Id="1833" PostTypeId="2" ParentId="1832" CreationDate="2018-04-18T11:35:07.250" Score="3" Body="&lt;p&gt;Not for memory, at least, as every memory access requires $O(1)$ 'time'. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the term time complexity, 'time' is a bit misleading, as we &lt;em&gt;actually&lt;/em&gt; count the number of elementary operations required to perform an algorithm. Under the additional assumption that these operations can be performed in '$O(1)$ time', we can say that our algorithm has a 'time complexity'. But what we are actually mean is that we have a 'operation complexity' which we express in time.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I think it is clearer that counting elementary operations is a fundamental and important measure of the number of resources required by an algorithm, as we can always decide how many resources each elementary operation requires.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;While in the definition of BQP and for quantum algorithms we consider &lt;em&gt;circuit complexity&lt;/em&gt; instead of 'operation complexity', circuit complexity can again defined in terms of operations on Turing machines, so the same reasoning applies.&lt;/p&gt;&#xA;" OwnerUserId="253" LastEditorUserId="253" LastEditDate="2018-04-18T11:58:13.493" LastActivityDate="2018-04-18T11:58:13.493" CommentCount="0" />
  <row Id="1834" PostTypeId="2" ParentId="1832" CreationDate="2018-04-18T11:41:59.833" Score="9" Body="&lt;p&gt;&lt;strong&gt;BQP&lt;/strong&gt; is defined considering &lt;em&gt;circuit size&lt;/em&gt;, which is to say the total number of gates. This means that it incorporates:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Number of qubits &amp;mdash; because we can ignore any qubits which are not acted on by a gate. This will be polynomially bounded relative to the input size, and often a modest polynomial (e.g.&amp;nbsp;Shor's algorithm only involves a number of qubits which is a constant factor times the input size).&lt;/li&gt;&#xA;&lt;li&gt;Circuit depth (or 'time') &amp;mdash; because the longest the computation could take is if we perform one gate after another, without performing any operations in parallel.&lt;/li&gt;&#xA;&lt;li&gt;Communication with control systems &amp;mdash; because the gates being performed are taken from some finite gate set, and even if we allow intermediate measurements, the amount of communication required to indicate the result of the measurement and the amount of computation required to determine what is done next is usually a constant for each operation.&lt;/li&gt;&#xA;&lt;li&gt;Interactions between quantum systems &amp;mdash; even if we consider an architecture which does not have all-to-all interactions or anything close to it, we can simulate having that connectivity by performing explicit SWAP operations, which can themselves be decomposed into a constant number of two-qubit operations. This might give us a noticeable polynomial overhead which impacts how practical an algorithm is for a given architecture, but it does not hide an exponential amount of work. &lt;/li&gt;&#xA;&lt;li&gt;Energy &amp;mdash; again because the circuits are decomposed into a finite gate-set, there is no obvious way to obtain an apparent speed-up by &quot;doing the gates faster&quot; or by hiding work in an exotic interaction, if our bound is in terms of the number of operations performed from a fairly basic set of operations. This consideration is more important in adiabatic quantum computing: we can't try to avoid small gaps just by amplifying the entire energy landscape as much as we like &amp;mdash; meaning that we must take longer to do the computation instead, corresponding in the circuit picture to a circuit with more gates.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;In effect, counting the number of gates from a constant-sized set captures many things which you might worry about as practical resources: it leaves very little space to hide anything which is secretly very expensive.&lt;/p&gt;&#xA;" OwnerUserId="124" LastActivityDate="2018-04-18T11:41:59.833" CommentCount="1" />
  <row Id="1835" PostTypeId="2" ParentId="1815" CreationDate="2018-04-18T14:42:56.847" Score="6" Body="&lt;p&gt;As I mentioned in the comments, a very precise answer will likely depend on a lot of technical choices which are somewhat arbitrary. It is likely to be more important to obtain an order-of-magnitude estimate, and to account for as much as possible in making it.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This answer is intended not as a definitive answer, but as a step in the right direction by reference to the existing literature (though admittedly over a decade old by now), specifically:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Van&amp;nbsp;Meter, Itoh, and Ladd.&#xA;&lt;em&gt;Architecture-Dependent Execution Time of Shor's Algorithm&lt;/em&gt;. Proc.&amp;nbsp;Mesoscopic Superconductivity&amp;nbsp;+ Spintronics 2006; [&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0507023&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv:quant-ph/0507023&lt;/a&gt;]&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Van Meter, Itoh, and Ladd attempt to compare the performance of Shor's algorithm with available computing technology performing the Number Field Sieve (the best known classical algorithm for factorisation). I have not had the time to plumb through the details of the paper &amp;mdash; a superior answer could likely be obtained by doing so &amp;mdash; but Figure&amp;nbsp;1 of that article allows us to make a reasonable numerical estimation:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/zt7uF.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/zt7uF.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here, the steep curves represent the computing time of classical computing networks. The curve labeled 'NFS, 104 PCs, 2003' seems to indicate computations (and the projected computing time) of one hundred and four personal computers circa 2003, as reported by RSA Security Inc. in 2004 [&lt;a href=&quot;http://www.rsasecurity.com/rsalabs/node.asp?id=2096]&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://www.rsasecurity.com/rsalabs/node.asp?id=2096]&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We will carry out a Fermi calculation. Let us assume that the curve corresponds to a computation on 104 essentially identical computers, and let us presume that $n$ computers carrying out number field sieve can carry out $n \cdot v$ computations per second of Number Field Sieve, where $v$ is the number of operations per second which a single computer can carry out. A quick web search suggests the speed of a good commercially available PC circa 2003 was about 2GHz. Assuming that the computers were performing one logical operation per clock cycle, the classical computation in 2003 was effectively operating at about $2 \times 10^{11}$ operations per second. A hypothetical benchmarking of Shor's algorithm would have to be made against a quantum computer performing at a comparable clock speed.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Unfortunately the lowest curve for quantum algorithms represents a clock-rate of $10^9$, so the point at which a hypothetical realisation of Shor's algorithm would surpass this performance is not on the graph shown. However, there is some interesting information which is shown.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Despite a operations-per-second advantage of a factor of 200 or more, the plot does indicate when this 200GHz classical NFS implementation is surpassed by a 1GHz quantum computer performing Shor's algorithm (at about 200 digit numbers) and by a 1MHz quantum computer (at about 330 digit numbers).&lt;/li&gt;&#xA;&lt;li&gt;We also have a curve projecting the performance &quot;in 2018&quot;, representing 1000 times the classical computation power: the intercepts with the 1GHz and 1MHz quantum computers are at 350 bit numbers and 530 bit numbers.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;The increase in the crossing points against quantum computations, from the computation in 2003 to the projected one in 2018, representing a clock-speed boost of 1000, is a factor of about 5/3. From this we can estimate that the computational advantage to the size of numbers that can be quickly solved by a classical computer, due to a speed increase of a factor of 200, is roughly 7/6. Then we can estimate that the crossing point of a single 1GHz classical computer performing NFS, with a 1GHz quantum computer performing Shor's algorithm, is at about 170 bit numbers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The bottom line &amp;mdash; a precise answer will depend on many technical assumptions which can change the precise result significantly, so it is better to seek a rough estimate. But this question has been researched at least once before, and making some number of assumptions and extrapolations on performance based on classical performance in 2003, it seems that Shor's algorithms will outperform the best known classical algorithm on an operation-by-operation basis for numbers around 170 bits.&lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="119" LastEditDate="2018-04-18T19:49:58.667" LastActivityDate="2018-04-18T19:49:58.667" CommentCount="2" />
  <row Id="1836" PostTypeId="1" AcceptedAnswerId="1837" CreationDate="2018-04-18T16:22:20.833" Score="7" ViewCount="236" Body="&lt;p&gt;The following question is related to this one: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1404/will-deep-learning-neural-networks-run-on-quantum-computers&quot;&gt;Will deep learning neural networks run on quantum computers?&lt;/a&gt;. I found it complementary and necessary because the previous answers are not completely related with my concerns.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Primarily, my question is related to hardware-based neural networks. As proposed by &lt;a href=&quot;https://www.nature.com/articles/nature14441&quot; rel=&quot;noreferrer&quot;&gt;Precioso et al. in 'Training and operation of an integrated neuromorphic network based on metal-oxide memristors'&lt;/a&gt; the use of solid-state or even molecular memristors can be a hardware proposal to implement efficient and non-volatile neural networks.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thus, the question is: Is there a quantum logic operation which can be used to improve the algorithms present in neural networks? Can quantum logic add any possible strategy in order to increase the efficiency of such networks?&lt;/p&gt;&#xA;" OwnerUserId="1955" LastActivityDate="2018-04-18T21:02:57.660" Title="Can quantum computing provide advantages related to Hardware-Neural Networks?" Tags="&lt;quantum-computer&gt;&lt;quantum-algorithms&gt;&lt;architecture&gt;&lt;neural-network&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="1837" PostTypeId="2" ParentId="1836" CreationDate="2018-04-18T17:18:17.603" Score="6" Body="&lt;p&gt;Again, this is still an open question.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are two lines of work that come to mind when you talk of &quot;hardware-based neural networks&quot; which try/claim to use photonics as a mean to speed-up processing, and make direct reference to speeding up machine learning tasks. &#xA;Shen et al. 2016 (&lt;a href=&quot;https://arxiv.org/abs/1610.02365&quot; rel=&quot;nofollow noreferrer&quot;&gt;1610.02365&lt;/a&gt;) propose a method to implement &quot;fully-optical neural networks&quot; which they claim to provide advantages in terms of computational speed and power efficiency.&#xA;A similar in principle (but not in method) idea is the one pursued by the &lt;a href=&quot;http://www.lighton.io/our-technology&quot; rel=&quot;nofollow noreferrer&quot;&gt;LightOn&lt;/a&gt; startup (see the papers referenced in their website). Very roughly speaking, the idea is here to exploit the natural dynamics of complex media, and therefore the natural dynamics of scattered light, to again get better processing speed and power consumption performances (note that I'm just stating the claims made in the papers here, as the details and validity of performances and advantages can be hard to judge in this case).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Note that, in both cases, only classical light is used&lt;/em&gt;&lt;/strong&gt;. In other words, there is arguably nothing &quot;quantum&quot; about these works, so you may not consider them totally relevant here. &#xA;However, both platforms could naturally be used (and have been used for different experiments) with single photons, and therefore can be used for processing of quantum information.&#xA;However, building a &quot;quantum neural network&quot; is &lt;em&gt;not&lt;/em&gt; just a matter of building a neural network-like evolution for a quantum system, as that would likely provide no advantage at all.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Talking instead of &quot;&lt;em&gt;quantum logic operation which can be used to improve the algorithms present in neural networks&lt;/em&gt;&quot;, this is the idea behind a good chunk of research being done on quantum (assisted) machine learning, some references for which can be found in the question you linked as well as in &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1268/55&quot;&gt;this other one&lt;/a&gt;.&#xA;A notable example is &lt;a href=&quot;https://arxiv.org/abs/0811.3171&quot; rel=&quot;nofollow noreferrer&quot;&gt;HHL09&lt;/a&gt;, which provides a way to speed-up the problem of inverting a linear system, which is an important part of many machine-learning algorithms.&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-04-18T21:02:57.660" LastActivityDate="2018-04-18T21:02:57.660" CommentCount="0" />
  <row Id="1839" PostTypeId="2" ParentId="1716" CreationDate="2018-04-19T10:18:09.857" Score="3" Body="&lt;p&gt;In order to benefit from the use of quantum objects to perform classical computation, one possibility is proposed by &lt;a href=&quot;https://en.wikipedia.org/wiki/Spintronics&quot; rel=&quot;nofollow noreferrer&quot;&gt;Spintronics&lt;/a&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Since the discovery of the giant magnetorresistence by Fert et al. (in &lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.61.2472&quot; rel=&quot;nofollow noreferrer&quot;&gt;Giant Magnetoresistance of (001)Fe/(001)Cr Magnetic Superlattices&lt;/a&gt;) a new field has been developed in which the spin has been used instead of the classical charge. This new electronics relies on the use of the quantum properties of the spin to to encode information, an approach that permits the manipulation (write/read) of information using lower energies compared to those involved in conventional electronics. Spintronics proposes new materials to the data storage and data processing industries but also aims at offering novel possibilities to quantum technologies. &lt;a href=&quot;http://science.sciencemag.org/content/294/5546/1488.full&quot; rel=&quot;nofollow noreferrer&quot;&gt;See: Spintronics, A Spin-Based Electronics Vision for the Future.&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Molecular spintronics, developed in the past decade,deals with the possibility of transferring the spintronic properties displayed by the purely inorganic compounds to systems made out of discrete molecules. Motivated by the fact that organic molecules are mostly formed by light atoms, which bear weak spin−orbit coupling and present low-contact nuclear hyperfine interaction, molecular spintronics hold promises for enhanced quantum coherence and the preservation of the spin during the operation time.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Regarding classical/quantum hybrid  computation, recently the group of W. Wernsdorfer et al have reported the fist quantum algorithm implemented in a single-molecule device by means of spintronics in &lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.119.187702&quot; rel=&quot;nofollow noreferrer&quot;&gt;Operating Quantum States in Single Magnetic Molecules: Implementation of Grover’s Quantum Algorithm.&lt;/a&gt; I am not aware that any advance in this approach has been performed by the inorganic (non-molecular) counterpart in Spintronics.&lt;/p&gt;&#xA;" OwnerUserId="1955" LastEditorUserId="1955" LastEditDate="2018-04-19T10:42:00.423" LastActivityDate="2018-04-19T10:42:00.423" CommentCount="0" />
  <row Id="1840" PostTypeId="1" AcceptedAnswerId="1848" CreationDate="2018-04-19T11:06:14.907" Score="8" ViewCount="108" Body="&lt;p&gt;Considering two entangled flying qubits, as far as I know, there is no physical limit for separating them without losing quantum information. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;See: &lt;a href=&quot;https://physics.stackexchange.com/questions/170454/is-there-any-theoretical-limit-to-the-distance-at-which-particles-can-remain-ent&quot;&gt;Is there any theoretical limit to the distance at which particles can remain entangled?&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Question&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;What is the actual record in such distance using photons?  I have found a previous record in 143 km (&lt;a href=&quot;https://phys.org/news/2012-09-km-physicists-quantum-teleportation-distance.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Physicists break quantum teleportation distance&lt;/a&gt;) &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;What about using solid-state based qubits? &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Can this suppose a limitation when constructing a solid-state quantum computer?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="1955" LastEditorUserId="119" LastEditDate="2018-04-20T08:39:10.990" LastActivityDate="2018-04-20T08:39:10.990" Title="What is the maximum separation between two entangled qubits that has been achieved experimentally?" Tags="&lt;quantum-entanglement&gt;&lt;quantum-decoherence&gt;" AnswerCount="2" CommentCount="1" FavoriteCount="2" />
  <row Id="1841" PostTypeId="1" AcceptedAnswerId="1843" CreationDate="2018-04-19T13:36:02.280" Score="8" ViewCount="465" Body="&lt;p&gt;Suppose I transform a state as follows:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;I start with the state $\lvert 0\rangle \otimes \lvert0\rangle \otimes \lvert0\rangle \otimes \lvert 0 \rangle$.&lt;/li&gt;&#xA;&lt;li&gt;I entangle the 1st and 2nd qubits (with an H gate and C-NOT).&lt;/li&gt;&#xA;&lt;li&gt;I then then entangle the 3rd and 4th qubits the same way.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;If I try to apply H gate and C-NOT to the 2nd and 3rd qubits afterwords, will the whole system become entangled? What happens to the 1st and 4th qubits in that case?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(&lt;a href=&quot;https://physics.stackexchange.com/questions/400699/what-happens-if-two-separate-entangled-qubits-are-passed-through-a-cnot-gate&quot;&gt;Cross-posted from Physics.SE&lt;/a&gt;) &lt;/p&gt;&#xA;" OwnerUserId="2060" LastEditorUserId="124" LastEditDate="2018-04-19T14:02:47.607" LastActivityDate="2018-04-19T15:22:15.577" Title="What happens if two separately entangled qubits are passed through a C-NOT gate?" Tags="&lt;quantum-computer&gt;&lt;qubit&gt;&lt;quantum-gate&gt;&lt;quantum-entanglement&gt;" AnswerCount="1" CommentCount="5" FavoriteCount="1" />
  <row Id="1842" PostTypeId="1" AcceptedAnswerId="1849" CreationDate="2018-04-19T13:53:43.727" Score="5" ViewCount="64" Body="&lt;p&gt;I've read the &quot;&lt;em&gt;trend&lt;/em&gt;&quot; article entitled &lt;a href=&quot;https://physics.aps.org/articles/v2/34&quot; rel=&quot;nofollow noreferrer&quot;&gt;Is a room-temperature, solid-state quantum computer mere fantasy?&lt;/a&gt; from almost 10 years ago, and was wondering if things have really changed: What is the current consensus on the viability of a room-temperature solid-state quantum computer?&lt;/p&gt;&#xA;" OwnerUserId="1931" LastEditorUserId="1847" LastEditDate="2018-04-19T14:35:45.350" LastActivityDate="2018-04-21T02:44:47.083" Title="What is the most optimistic perspective of room-temperature solid-state QC?" Tags="&lt;quantum-computer&gt;&lt;architecture&gt;&lt;solid-state&gt;" AnswerCount="1" CommentCount="1" />
  <row Id="1843" PostTypeId="2" ParentId="1841" CreationDate="2018-04-19T14:01:53.557" Score="7" Body="&lt;p&gt;$\newcommand{\bra}[1]{\left&amp;lt;#1\right|}\newcommand{\ket}[1]{\left|#1\right&amp;gt;}\newcommand{\bk}[2]{\left&amp;lt;#1\middle|#2\right&amp;gt;}\newcommand{\bke}[3]{\left&amp;lt;#1\middle|#2\middle|#3\right&amp;gt;}&#xA;%&#xA;$So, first you're entangling qubits 1 and 2, and qubits 3 and 4, so overall you have the quantum state&#xA;$$&#xA;\left(\ket{00}+\ket{11}\right)\otimes\left(\ket{00}+\ket{11}\right)/2&#xA;$$&#xA;Then you apply a Hadamard on qubit 2,&#xA;$$&#xA;(\ket{0}(\ket{0}+\ket{1})+\ket{1}(\ket{0}-\ket{1}))\otimes(\ket{00}+\ket{11})/(2\sqrt{2})&#xA;$$&#xA;before applying a controlled-NOT from qubit 2 (control) to qubit 3 (target), right? This gives you&#xA;$$&#xA;(\ket{0}\otimes(\ket{0}\otimes(\ket{00}+\ket{11})+\ket{1}\otimes(\ket{10}+\ket{01}))+\ket{1}\otimes(\ket{0}\otimes(\ket{00}+\ket{11})-\ket{1}\otimes(\ket{10}+\ket{01})))/(2\sqrt{2})&#xA;$$&#xA;Let's rearrange this slightly as&#xA;$$&#xA;\ket{\Psi}=((\ket{0}-\ket{1})\ket{1}(\ket{10}+\ket{01})+(\ket{0}+\ket{1})\ket{0}(\ket{00}+\ket{11}))/(2\sqrt{2})&#xA;$$&#xA;Note that we need the full state of the whole system. You cannot really talk about the states of qubits 1 and 4 separately due to the entanglement.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The question of &quot;is it still entangled&quot; is straightforwardly &quot;yes&quot;, but that is a actually a triviality of a much more complex issue. It is entangled in the sense that it is not a product state $\ket{\psi_1}\otimes\ket{\psi_2}\otimes\ket{\psi_3}\otimes\ket{\psi_4}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One simple way to see that this state is entangled is to pick a bipartition, i.e. a split of the qubits into two parties. For instance, let's take qubit 1 as one party (A), and all the others as party B. If we work out the reduced state of party A, a product state (unentangled) would have to give a pure state. Meanwhile, if the reduced state is not pure, i.e. has a rank greater than 1, the state is definitely entangled. For example, in this case&#xA;$$&#xA;\rho_A=\text{Tr}(\ket{\Psi}\bra{\Psi})=\frac{\mathbb{I}}{2},&#xA;$$&#xA;has rank 2. Actually, it doesn't matter what you did between qubits 2 and 3, as $\rho_A$ is independent of that unitary; it cannot remove the entanglement created with qubit 1 (just possibly spread it between qubits 2 and 3). The fact that you have to look at different bipartitions to see which qubits are entangled with which already starts to indicate some of the complexity. For pure states, it is sufficient to look at each of the bipartitions of 1 qubit with the rest. If each of these reduced density matrices is rank 1, your whole state is separable.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Related to your question, you might like to look up issues of &quot;monogamy of entanglement&quot; -- the more entangled qubit 1 is with qubit 2, the less entangled qubit 1 is with qubit 3 (for example), and that can be quantified in a number of different ways. Equally, you can ask questions about &quot;what sort of entanglement is there?&quot;. One approach is to look at what types of entanglement can be converted into different types (often termed &quot;SLOCC equivalence classes&quot;). For example, with 3 qubits, people make the distinction between W-state entanglement, which looks like $\ket{001}+\ket{010}+\ket{100}$ and GHZ-entanglement that looks like $\ket{000}+\ket{111}$, as well as bipartite entanglement between different pairs of qubits, and a separable state on the other. It gets really messy for 4 qubits!&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-04-19T15:22:15.577" LastActivityDate="2018-04-19T15:22:15.577" CommentCount="0" />
  <row Id="1844" PostTypeId="2" ParentId="1840" CreationDate="2018-04-19T15:14:29.357" Score="5" Body="&lt;p&gt;I believe the current record is held by the Jian-Wei Pan group in China, who are able to generate entanglement via a satellite. The journal article is &lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.119.200501&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;, while there's plenty of media coverage that is a bit more accessible, e.g. &lt;a href=&quot;https://www.newscientist.com/article/2134843-chinese-satellite-beats-distance-record-for-quantum-entanglement/&quot; rel=&quot;noreferrer&quot;&gt;New Scientist&lt;/a&gt;. This claims a distance of &lt;strong&gt;1203km&lt;/strong&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-04-19T15:14:29.357" CommentCount="0" />
  <row Id="1845" PostTypeId="1" AcceptedAnswerId="1846" CreationDate="2018-04-19T16:50:05.380" Score="7" ViewCount="91" Body="&lt;p&gt;Consider the 9 qubit &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_error_correction#The_Shor_code&quot; rel=&quot;noreferrer&quot;&gt;Shor code&lt;/a&gt;. This can detect and correct arbitrary single qubit errors, but if there are 2 or more single qubit errors before a correction round, the correction will fail. (In the sense that it won't reproduce the original logical state.) Hence the probability of failure of the Shor code is the probability of there being 2 or more single qubit errors. If we assume that single qubit errors occur independently with probability $p$, then we can calculate this probability as&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;P(\mathrm{failure}) = 1 - \left[(1-p)^{9} + 9p(1-p)^{8}\right].&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We can write this probability as a series in $p$ as&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;P(\mathrm{failure}) = \sum_{m=2}^{9} (-1)^{m} (m-1) \binom{9}{m} p^{m}.&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is about the intuition for the coefficients of each term in this sum.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The $\binom{9}{m} p^{m}$ part seems natural. We can interpret it as the probability that $m$ single qubit errors occur multiplied by the number of groups of $m$ qubits these errors could act on. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; What I am confused by is the $(-1)^{m} (m-1)$ part of the coefficient. Why should some of the higher order terms lead to a &lt;em&gt;suppression&lt;/em&gt; of the failure probability, and why should the weighting of these terms beyond the binomial coefficient increase with order? Is there some intuition for these coefficients?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Note 1:&lt;/strong&gt; I realise that the $m=2$ case is the most important, since we typically assume $p \ll 1$. Indeed, most treatments truncate the series at $m=2$, where $(-1)^{m} (m-1) = 1$, so even if the higher-order terms do have an effect, that effect should be fairly negligible.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Note 2:&lt;/strong&gt; Though I have specified the Shor code for concreteness, this behaviour is not specific to the Shor code. For example, if we restrict ourselves to bit-flip errors, then the failure probability of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_error_correction#The_bit_flip_code&quot; rel=&quot;noreferrer&quot;&gt;bit-flip code&lt;/a&gt; will exhibit similar coefficients.&lt;/p&gt;&#xA;" OwnerUserId="2061" LastEditorUserId="26" LastEditDate="2018-05-07T13:18:27.270" LastActivityDate="2018-05-07T13:18:27.270" Title="Intuition for Shor code failure probability" Tags="&lt;quantum-error-correction&gt;" AnswerCount="1" CommentCount="1" />
  <row Id="1846" PostTypeId="2" ParentId="1845" CreationDate="2018-04-19T19:12:42.477" Score="4" Body="&lt;p&gt;When given set of Pauli errors acts on a stabilizer code, they will either be corrected, or the attempt at correction will lead to a logical error. There will be no more complicated cases, such as a superposition of the two.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This makes calculation of the failure probability rather straightforward (though not necessarily practical for large codes). You just take the probability of every uncorrectable set of errors, and sum them up.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Even though this is a simple sum of positive terms, there are ways it could be written with the occasional minus sign. For example, you could sum the probabilities for all correctable sets of errors, and then subtract that from $1$. Such subtractions do not imply a suppression of the failure probability. They just show that you previous terms overestimated the failure probability.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Minus signs most often come because the probability for a lack of error on a qubit can be written as $1-p$. If we expand out products in which this is a factor, we will get negative terms. But that is simply because we chose to write the expression as a polynomial in the single probability $p$, rather than using both $p$ and $1-p$ for their respective events.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is what is happening in your case. The factor $p^m$ is an overestimate for the probability of errors on $m$ qubits, because it doesn’t account for what the other qubits are doing, and the corresponding contributions to the total probability. Hence some subtractions also need to be made.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-04-19T19:12:42.477" CommentCount="3" />
  <row Id="1847" PostTypeId="2" ParentId="75" CreationDate="2018-04-19T19:44:43.293" Score="1" Body="&lt;p&gt;In the dim and distant past (I.e. I don’t remember the details any more), I tried to calculate an upper bound on a fault tolerant threshold. I suspect the assumptions that I made to get there wouldn’t apply to every possible scenario, but I came up with an &lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.77.052319&quot; rel=&quot;nofollow noreferrer&quot;&gt;answer&lt;/a&gt; of 5.3% (&lt;a href=&quot;https://arxiv.org/abs/0705.4360&quot; rel=&quot;nofollow noreferrer&quot;&gt;non-paywall version&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The idea was roughly to make use of a &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9604024&quot; rel=&quot;nofollow noreferrer&quot;&gt;well-known connection&lt;/a&gt; between error correction codes and distillation of multiple noisy Bell states into a single, less noisy Bell state. In essence, if you have multiple noisy Bell states, one strategy for making a single high quality Bell state is to teleport the codewords of an error correction code through them. It's a two-way relationship; if you come up with a better distillation strategy, that defines a better error correcting code and vice-versa. So, I wondered what would happen if you allowed a concatenated scheme of distillation of noisy Bell pairs, but allowed some errors to occur when applying the various operations. This would map directly to fault tolerance via concatenated error correcting codes. But the different perspective allowed me to estimate a threshold beyond which the noise accumulation would simply be too high, and thus the error correction scheme would fail. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Different works have made different assumptions. For example, &lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.71.042328&quot; rel=&quot;nofollow noreferrer&quot;&gt;this one&lt;/a&gt; restricts to specific gate sets, and derives an upper bound to the fault-tolerant threshold of 15% in a specific case (but then the question arises as to why you wouldn't pick the scheme with the highest upper bound, rather than the lowest!).&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-05-04T19:39:05.400" LastActivityDate="2018-05-04T19:39:05.400" CommentCount="5" />
  <row Id="1848" PostTypeId="2" ParentId="1840" CreationDate="2018-04-20T04:26:54.810" Score="4" Body="&lt;p&gt;Photons travel fast, and there's often the option to transfer their entanglement to solid state. Of course, the advantage of transferring entanglement to a solid state qubit is that one is able to operate with it (one- and two-qubit gates, for example) with ease and efficiency, whereas it is very hard to effect two-qubit quantum gates on photons themselves, for more on that see the answer to &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1807/how-do-you-apply-a-cnot-on-polarization-qubits&quot;&gt;How do you apply a CNOT on polarization qubits?&lt;/a&gt; So, let us divide the answer into optical-solid-state hybrid approaches, purely optical approaches and purely solid-state approaches:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;The optical-solid-state hybrid approach results in records such as this one from 2012: &lt;a href=&quot;https://arxiv.org/abs/1212.6136&quot; rel=&quot;nofollow noreferrer&quot;&gt;Heralded entanglement between solid-state qubits separated by 3 meters&lt;/a&gt;. For the solid-state part they employed &lt;a href=&quot;https://en.wikipedia.org/wiki/Nitrogen-vacancy_center&quot; rel=&quot;nofollow noreferrer&quot;&gt;Nitrogen-Vacancy centers&lt;/a&gt;, which are diamond defects with remarkable quantum coherence, even at high temperature (although this particular experiment is performed at low temperature). In this case, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Fidelity_of_quantum_states&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum fidelity&lt;/a&gt; of the final entangled state is well above the classical limit of 0.5 but at the same time well below 0.9, meaning it's enough to demonstrate quantum effects, but not great in a practical sense. Apparently, imperfect  photon  indistinguishability is the main limitation to fidelity in this experiment, followed by errors  in  the  microwave  pulses that are used to rotate the readout bases of the two solid-state qubits. As a more recent update on where things could be headed towards with the hybrid approach, there's this &lt;a href=&quot;https://arxiv.org/pdf/1712.00854.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Demonstration  of  Entanglement  Purification  and  Swapping Protocol to Design Quantum Repeater in IBM Quantum Computer&lt;/a&gt;. As far as I read it, it's not a complete demonstration, since it does not actually implement the photon-solid transfer but rather &quot;&lt;em&gt;design a quantum circuit which could in principle equivalently perform the main operations of a quantum repeater&lt;/em&gt;&quot;. For a perspective on the whole field of combining quantum communications with quantum computing, see Nature Photonic's &lt;a href=&quot;https://www.nature.com/articles/s41566-017-0032-0&quot; rel=&quot;nofollow noreferrer&quot;&gt;Towards a global quantum network&lt;/a&gt;(&lt;a href=&quot;https://arxiv.org/pdf/1710.11585.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv version&lt;/a&gt;).&lt;/li&gt;&#xA;&lt;li&gt;The purely optical record, as reported in his answer by @DaftWullie, is claimed by the Jian-Wei Pan group in China, who report entanglement over 1203 km via a satellite (&lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.119.200501&quot; rel=&quot;nofollow noreferrer&quot;&gt;Satellite-to-Ground Entanglement-Based Quantum Key Distribution&lt;/a&gt;). Because of the nature of photons, this is more useful for purely quantum communication purposes rather than for actual quantum computing.&lt;/li&gt;&#xA;&lt;li&gt;On the purely solid-state approach, I found this letter to Nature Nanotechnology of 2012, &lt;a href=&quot;https://www.nature.com/articles/nnano.2012.28&quot; rel=&quot;nofollow noreferrer&quot;&gt;Electrical control of a solid-state flying qubit&lt;/a&gt; (&lt;a href=&quot;https://arxiv.org/pdf/1709.08873.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv version&lt;/a&gt;) Yamamoto and coworkers reported the transport and manipulation of qubits over distances of 6 microns within 40 ps, in an Aharonov-Bohm rings (based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Aharonov%E2%80%93Bohm_effect&quot; rel=&quot;nofollow noreferrer&quot;&gt;Aharonov–Bohm_effect&lt;/a&gt;), connected to two-channel wires that have a tunable tunnel coupling between channels. They claim to be the first &quot;&lt;em&gt;demonstrations of scalable ‘flying qubit’ architectures—systems in which it is possible to perform quantum operations on qubits while they are being coherently transferred—in solid-state systems&quot;&lt;/em&gt;. According to Yamamoto et al., &quot;&lt;em&gt;These architectures allow for control over qubit separation and for non-local entanglement, which makes them more amenable to integration and scaling than static qubit approaches.&lt;/em&gt;&quot; &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;All that being said, probably the best practical answer to the question, at least for now, is currently working quantum computers: since it is claimed that &lt;a href=&quot;https://arxiv.org/abs/1801.03782&quot; rel=&quot;nofollow noreferrer&quot;&gt;16-qubit IBM universal quantum computer can be fully entangled&lt;/a&gt;, it seems that &lt;strong&gt;the maximum distance of entanglement in solid-state devices will not be a practical limitation for quantum computing&lt;/strong&gt; (even without employing flying qubits). I suspect that scaling and protecting that entanglement, however, will not be trivial.&lt;/p&gt;&#xA;" OwnerUserId="1847" LastActivityDate="2018-04-20T04:26:54.810" CommentCount="0" />
  <row Id="1849" PostTypeId="2" ParentId="1842" CreationDate="2018-04-21T02:44:47.083" Score="2" Body="&lt;p&gt;Articles on technology from 10 years ago are often outdated, to some extent the same can be said of last year's information. Occasionally something will stand for decades, or fall into decline only to be revisited later.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The most optimistic perspective is: someone is working on it.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here are some more recent articles on room temperature QC:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;a href=&quot;https://www.beilstein-journals.org/bjnano/articles/9/100&quot; rel=&quot;nofollow noreferrer&quot;&gt;Room-temperature single-photon emitters in titanium dioxide optical defects&lt;/a&gt;&quot; by Chung, Leung, To, Djurišić and Tomljenovic-Hanic (04 Apr 2018).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;a href=&quot;https://arxiv.org/abs/1712.07293&quot; rel=&quot;nofollow noreferrer&quot;&gt;Room temperature high-fidelity non-adiabatic holonomic quantum computation on solid-state spins in Nitrogen-Vacancy centers&lt;/a&gt;&quot; by Yan, Chen, and Lu (20 Dec 2017).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;a href=&quot;https://arxiv.org/abs/1612.08567&quot; rel=&quot;nofollow noreferrer&quot;&gt;Scalable quantum computation based on quantum actuated nuclear-spin decoherence-free qubits&lt;/a&gt;&quot;, by Rong, Dong, Geng, Shi, Li, Duan, and Du (27 Dec 2016).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;a href=&quot;https://arxiv.org/abs/1407.0180&quot; rel=&quot;nofollow noreferrer&quot;&gt;Coherent control of single spins in silicon carbide at room temperature&lt;/a&gt;&quot; by Widmann, Lee, Rendler, and 15 others (31 Oct 2014).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Lots of people are working on the idea, how soon it becomes available remains to be seen. Use of solid-state could be on the way out ...&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;a href=&quot;https://phys.org/news/2018-03-transistor-closer.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Practical spin wave transistor one step closer&lt;/a&gt;&quot; physics.Org article, March 1, 2018, and University of Groningen &quot;&lt;a href=&quot;https://www.rug.nl/research/portal/publications/magnon-spintronics-in-noncollinear-magnetic-insulatormetal-heterostructures(6ec15eb7-2d85-4c48-b953-ac23aff19e07).html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Magnon spintronics in non-collinear magnetic insulator/metal heterostructures&lt;/a&gt;&quot; (Feb 2017).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/wFzZm.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/wFzZm.png&quot; alt=&quot;Magnon Circuit&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="278" LastActivityDate="2018-04-21T02:44:47.083" CommentCount="0" />
  <row Id="1850" PostTypeId="1" CreationDate="2018-04-21T06:05:36.383" Score="7" ViewCount="328" Body="&lt;p&gt;It is &lt;a href=&quot;https://www.nationalreview.com/2018/02/quantum-computing-blockchain-technology-threat/&quot; rel=&quot;noreferrer&quot;&gt;popularly stated&lt;/a&gt; that quantum computing could destroy and disrupt blockchain technology completely. How is quantum computing a threat to blockchain technology?&lt;/p&gt;&#xA;" OwnerUserId="2074" LastEditorUserId="91" LastEditDate="2018-04-22T17:00:07.097" LastActivityDate="2018-04-22T17:00:07.097" Title="Quantum computing and blockchain technology" Tags="&lt;quantum-computer&gt;" AnswerCount="2" CommentCount="2" FavoriteCount="2" />
  <row Id="1851" PostTypeId="1" AcceptedAnswerId="1853" CreationDate="2018-04-21T09:14:33.290" Score="6" ViewCount="55" Body="&lt;p&gt;QMA(Quantum Merlin Arthur), is the quantum analog of NP, and QMA(k) is the class with $k$ verifiers. These are important classes when studying Quantum Complexity theory. QMA(k) is QMA with $k$ unentangled provers($k$ Merlins), or BQP verfiers. These classes enable us to formally study the complexity of Entanglement. For instance the class QMA(2) could help us to study the separability of quantum states, and resources required for telling whether these states are separable or far from separable. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;A natural question arises - What are the upper bounds for these classes (QMA, QMA(k))- do these classes have nontrivial upper bounds(could they have upper bounds such as PSPACE?&lt;/p&gt;&#xA;" OwnerUserId="429" LastEditorUserId="429" LastEditDate="2018-04-21T09:51:00.063" LastActivityDate="2018-04-21T09:51:00.063" Title="Upper Bounds for QMA Quantum Merlin Arthur, and QMA(k)" Tags="&lt;quantum-entanglement&gt;&lt;complexity-theory&gt;&lt;qma&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="1852" PostTypeId="2" ParentId="1850" CreationDate="2018-04-21T09:31:41.077" Score="4" Body="&lt;p&gt;My crude understanding of blockchain (derived mainly from the &lt;a href=&quot;https://en.wikipedia.org/wiki/Blockchain&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wikipedia article&lt;/a&gt;) is that it gets its security from two sources:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Individual communications are performed using a public key cryptography scheme&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Information is stored in a decentralised manner across many different computers, meaning that there are many different copies of the same information.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;The level of security provided by these two items differs, I suspect. Public key cryptography has an exponential form of security against classical attacks: it's based on a mathematical problem, and you add one bit to the problem size, and the difficulty (roughly) doubles. It's really easy to add a few bits, and put the problem completely out of anybody's reach. Meanwhile, for the decentralised part, I imagine that adding one extra computer to the network doesn't significantly increase the resources required to monitor all the communications; for a network of $N$ nodes, there are only $\binom{N}{2}$ communication links to monitor (a polynomial in $N$, not exponential). So, while adding a few more computers to the network might make monitoring a daunting task for an individual, state-level interference is unlikely to be eliminated. Thus, the security is heavily dependent upon the security of the public key cryptosystem being used.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The point is that quantum computers will be good at breaking existing public key cryptography systems such as RSA. RSA, for example, is secured by the assumption that it is difficult to find the prime factors of a large number (the person who is allowed to decript a message proves that they can by giving the factors of a particular number). To the best of our knowledge, this is true for classical computers, but Shor's algorithm makes this an easy task for a quantum computer. This means that, in principle, individual communications can be read an manipulated by a quantum computer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Researchers are working on replacement public key cryptography systems that will be resiliant to attack by a quantum computer (called post-quantum cryptography) but these are not yet in place. &lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-04-21T09:51:57.807" LastActivityDate="2018-04-21T09:51:57.807" CommentCount="0" />
  <row Id="1853" PostTypeId="2" ParentId="1851" CreationDate="2018-04-21T09:38:08.770" Score="2" Body="&lt;p&gt;You probably want to check out the &lt;a href=&quot;https://complexityzoo.uwaterloo.ca/Complexity_Zoo&quot; rel=&quot;nofollow noreferrer&quot;&gt;complexity zoo&lt;/a&gt; for known results. For example, the listing on &lt;a href=&quot;https://complexityzoo.uwaterloo.ca/Complexity_Zoo:Q#qma2&quot; rel=&quot;nofollow noreferrer&quot;&gt;QMA(2)&lt;/a&gt; states:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;It was shown in &lt;a href=&quot;http://arxiv.org/0804.0802&quot; rel=&quot;nofollow noreferrer&quot;&gt;ABD+08&lt;/a&gt; that a conjecture they call the Strong Amplification Conjecture implies that QMA(2) is contained in PSPACE.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;It was shown in &lt;a href=&quot;https://arxiv.org/abs/1001.0017&quot; rel=&quot;nofollow noreferrer&quot;&gt;HM13&lt;/a&gt; that QMA(k) = QMA(2) for k &gt;= 2. However we still do not know if QMA(2) = QMA. The best known upper bound is NEXP. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-04-21T09:38:08.770" CommentCount="1" />
  <row Id="1854" PostTypeId="1" AcceptedAnswerId="1984" CreationDate="2018-04-21T10:26:07.993" Score="11" ViewCount="139" Body="&lt;p&gt;This question is related to &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1716/can-the-theory-of-quantum-computation-assist-in-the-miniaturization-of-transisto&quot;&gt;Can the theory of quantum computation assist in the miniaturization of transistors?&lt;/a&gt; and &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1648/is-quantum-biocomputing-ahead-of-us&quot;&gt;Is Quantum Biocomputing ahead of us?&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;About 10 years ago, several papers discussed the &lt;a href=&quot;https://aip.scitation.org/doi/10.1063/1.3002335&quot; rel=&quot;nofollow noreferrer&quot;&gt;environment-assisted quantum walks in photosynthetic energy transfer&lt;/a&gt; (Mohseni, Rebentrost, Lloyd, Aspuru-Guzik, The Journal of Chemical Physics, 2008) and the &lt;a href=&quot;http://iopscience.iop.org/article/10.1088/1367-2630/10/11/113019/meta&quot; rel=&quot;nofollow noreferrer&quot;&gt;dephasing-assisted transport: quantum networks and biomolecules&lt;/a&gt; (Plenio, Huelga, New Journal of Physics 2008). One major idea there seems to be that the &quot;environment&quot; (quantum decoherence) assists or &lt;em&gt;optimizes&lt;/em&gt; the transport of a signal that is also fundamentally quantum coherent in nature.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is: beyond the theoretical interpretation of processes happening in natural systems, have physical processes of this kind already been explored in artificial systems, either as quantum computation (perhaps as quantum-enhanced mixed classical-quantum transistors) or in a quantum simulator? Or, if this has not happened yet, could one in principle do it?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Edit after obtaining an answer: Note the lax sense of&lt;/em&gt; optimize &lt;em&gt;above. In a biological rather than mathematical context,&lt;/em&gt; optimization &lt;em&gt;needs not be absolute but can refer to any significant improvement, like enzimes have been&lt;/em&gt; optimized &lt;em&gt;via evolution to increase the speed of reactions&lt;/em&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="141" LastEditDate="2018-08-07T03:45:10.363" LastActivityDate="2018-08-27T23:40:40.370" Title="Quantum simulation of environment-assisted quantum walks in photosynthetic energy transfer" Tags="&lt;architecture&gt;&lt;experimental-results&gt;&lt;quantum-decoherence&gt;&lt;quantum-walks&gt;&lt;quantum-biology&gt;" AnswerCount="1" CommentCount="6" FavoriteCount="5" />
  <row Id="1855" PostTypeId="1" AcceptedAnswerId="1856" CreationDate="2018-04-21T11:24:29.037" Score="7" ViewCount="684" Body="&lt;p&gt;I am getting confused about the meaning of the term &quot;ancilla&quot; qubit. It's use seems to vary a lot in different situations. I have read (in numerous places) that an ancilla is a constant input - but in nearly all of the algorithms I know (Simion's, Grover's, Deutsch etc) all the qubits are of constant input and therefore would be considered ancilla. Given that this does not seem to be the case - what is the general meaning of an &quot;ancilla&quot; qubit in quantum computers?&lt;/p&gt;&#xA;" OwnerUserId="2015" LastActivityDate="2018-04-22T06:17:33.763" Title="What counts as an &quot;ancilla&quot; qubit?" Tags="&lt;qubit&gt;&lt;terminology&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="2" />
  <row Id="1856" PostTypeId="2" ParentId="1855" CreationDate="2018-04-21T11:58:51.950" Score="5" Body="&lt;p&gt;The general meaning of &lt;em&gt;ancilla&lt;/em&gt; in &lt;a href=&quot;https://en.wikipedia.org/wiki/Ancilla_bit&quot; rel=&quot;nofollow noreferrer&quot;&gt;ancilla qubit&lt;/a&gt; is &lt;em&gt;auxiliary&lt;/em&gt;. In particular, when people write about &quot;constant input&quot; what they mean is that, for a given algorithm -which has a purpose, such as finding the prime factors of an input number, or &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1289/how-does-a-quantum-computer-do-basic-math-at-the-hardware-level-&quot;&gt;effecting a simple arithmetic operation between two input numbers&lt;/a&gt; the value of the &lt;em&gt;ancilla&lt;/em&gt; qubits will be independent of the value of the input.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Probably your confusion arises because some algorithms study a function, employing a constant input, rather than study an input, using a constant function. Maybe in these cases the term &lt;em&gt;ancilla&lt;/em&gt; qubit makes less sense, since, as you point out, all input qubits are constant and act as &lt;em&gt;ancillae&lt;/em&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="1847" LastEditDate="2018-04-22T06:17:33.763" LastActivityDate="2018-04-22T06:17:33.763" CommentCount="1" />
  <row Id="1857" PostTypeId="2" ParentId="1855" CreationDate="2018-04-21T11:59:03.060" Score="5" Body="&lt;p&gt;When translating a classical circuit into a quantum circuit, you often need to introduce extra qubits simply because quantum computers only implement reversible logic. Such extra qubits are ancilla (or ancillary qubits).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One way to spot which qubits are ancilla is to look for those qubits that typically need to be &quot;uncomputed&quot; when using the quantum circuit as a quantum oracle in another quantum algorithm.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-04-21T11:59:03.060" CommentCount="1" />
  <row Id="1858" PostTypeId="1" AcceptedAnswerId="1866" CreationDate="2018-04-21T14:08:23.203" Score="6" ViewCount="76" Body="&lt;p&gt;On p490 of Nielsen and Chuang, 2010 the authors say that the preparation of the 'cat' state ($|000\ldots 0\rangle+|111\ldots 1\rangle$) is not Fault Tolerant.  Below is my mock up of the diagram they draw for the preparation ($H$ and $C$-not-not *) and one part of the verification (the next two C-nots):&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/dWIlm.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/dWIlm.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;They then explain that this is not fault tolerant because a $Z$ error in the 'extra qubit' (i.e. that at the bottom of the diagram) propagates into two Z-errors in the ancilla qubits (the top three).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;They they go onto say that this will not affect the Encoded data (I have not shown this in my diagram). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are a couple of things that confuse me here. Firstly I cannot see how we get two $Z$-errors on the axillary qubits, Secondly even if we did get two $Z$-errors, surely this is a good thing as it will take our cat state back to the cat state? More the the crux of the issue - I cannot see what criterion they are using for fault tolerance here (I know what it means in the general case - i.e. unrecoverable error with probability no greater then $Cp^2$)  and how there example violates it - Please can someone explain this to me.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sub&gt;*Not technical name - I couldn't find what it was actually called.&lt;/sub&gt;&lt;/p&gt;&#xA;" OwnerUserId="2015" LastEditorUserId="2015" LastEditDate="2018-04-22T09:20:46.607" LastActivityDate="2018-04-22T09:20:46.607" Title="Why or how is 'cat' state preparation via a C-not-not operation not fault tolerant?" Tags="&lt;fault-tolerance&gt;" AnswerCount="2" CommentCount="1" />
  <row Id="1859" PostTypeId="2" ParentId="1858" CreationDate="2018-04-21T16:19:32.197" Score="4" Body="&lt;p&gt;First a matter of terminology. I don't have my copy of Nielsen &amp;amp; Chuang to hand, but I would have thought that the bottom, extra qubit, is the one that is the ancilla. I am also not entirely convinced that the errors you're talking about can be correct. You seem to be talking about $Z$ errors, but giving results that correspond to $X$ errors. (If a $Z$-gate happens on the ancilla, it makes no difference, up to a global phase, because that qubit is always in a basis state and, as you state, 2 $Z$-errors on your original state give back the original state, so no harm done.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What the ancilla qubit is doing here is comparing qubits 2 and 3; if they are in the same state (as they should be), you get a 0 answer. If they are in a different state, you get a 1 answer. Thus, if you get a 1 answer, you know something has gone wrong on one of your 3 main qubits, and needs correction. Let's say you've already tested to see that qubits 1 and 2 are the same, and they are. So, having found that qubits 2 and 3 are different, it must be that qubit 3 has the error (assuming the error occurred on one of the main qubits). So, you apply a bit-flip gate to qubit 3.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, let me show you what &lt;em&gt;could&lt;/em&gt; go wrong. Here, $X$ represents a bit-flip error.&#xA;&lt;a href=&quot;https://i.stack.imgur.com/n7B48.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/n7B48.png&quot; alt=&quot;EC circuit with error&quot;&gt;&lt;/a&gt;&#xA;This is the full syndrome circuit, where $|\psi\rangle$ is the cat state you produced before (also called a GHZ state).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here, qubit 3 has the error, but you detect it on qubit 1. So, you correct it on qubit 1, and thus your state has 2 errors in it.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What does this have to do with fault-tolerance? Proofs of fault-tolerance are usually based around the idea of tracking the errors in each error correcting code (of which there are many, one for each logical qubit that you want). You can prove that provided each logical gate that you apply (preceded and followed by a round of error correction) only causes single errors on each logical qubit, then there is a threshold error probability below which these errors can be corrected away through the use of concatenated error correcting codes. So, the point is that the structure we've just talked about doesn't obey this. There is a place where a single error actually causes 2 errors on the error correcting code. Thus, the usual argument for fault tolerance does not apply. (Technically, this does not show that there aren't other arguments that could be made, it's just that the standard route doesn't work.)&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-04-21T16:19:32.197" CommentCount="3" />
  <row Id="1860" PostTypeId="1" AcceptedAnswerId="1865" CreationDate="2018-04-21T20:07:52.027" Score="9" ViewCount="351" Body="&lt;p&gt;I understand that a qudit is a quantum $d$-state system. If $d=4$, is this exactly the same as a two-qubit system, which also presents $4$ quantum states? The Hilbert space is the same, right? Are there any theoretical or practical differences?&lt;/p&gt;&#xA;" OwnerUserId="1931" LastEditorUserId="26" LastEditDate="2018-05-05T20:26:04.283" LastActivityDate="2018-05-05T20:26:04.283" Title="What is the difference between a qudit system with d=4 and a two-qubit system?" Tags="&lt;qubit&gt;&lt;qubit-state&gt;&lt;qudit&gt;" AnswerCount="5" CommentCount="0" FavoriteCount="3" />
  <row Id="1861" PostTypeId="1" AcceptedAnswerId="1862" CreationDate="2018-04-21T20:29:23.433" Score="7" ViewCount="149" Body="&lt;p&gt;I have no background in quantum physics, and no understanding of most formulas used in this context. I'm not looking for an in depth answer, i'd just like to vaguely understand the concept.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The way i heard it, a superposition is [real/a neccessary assumption/a concept not even wrong/whatever] and will end as soon as the object in superposition is observed. I always took that &quot;observed&quot; part to mean &quot;interacted with in a way that allows to make a decision on the state&quot; and i further supposed there was no cheating a la &quot;oh but i entangled A and B and now i just observed A, so B will be alright&quot; and suchlike . &lt;/p&gt;&#xA;&#xA;&lt;p&gt;So now we have quantum computation, which seems to rely on the superpositions of objects somehow covering a whole lot of bases at once and then [something something] which produces an answer - my question is about the i/o process: How can i input something so a superposition is achieved that encompasses the information i input, without automatically destroying the relevant superposition? How can i be sure my input was put in without looking? how can i look without destroying the very thing i wanted?&lt;/p&gt;&#xA;" OwnerUserId="2080" LastEditorUserId="55" LastEditDate="2018-05-07T10:57:15.550" LastActivityDate="2018-05-07T10:57:15.550" Title="Is it true that observing a quantum state will end the superposition of states? How can I not observe?" Tags="&lt;noise&gt;&lt;measurement&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="1862" PostTypeId="2" ParentId="1861" CreationDate="2018-04-21T21:26:24.077" Score="4" Body="&lt;p&gt;I'm going to go for an intuitive answer here, as requested. Let's s go in steps:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Your input is (often?) classical, so up to that point we're good. &lt;/li&gt;&#xA;&lt;li&gt;Then you start doing quantum operations and achieve, for example, quantum superpositions between different states. Here you're right, you cannot look to check if you're doing OK, and that indeed is a problem, or rather the origin for different problems. For more on that you could give a try to the tags &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/tagged/quantum-entanglement&quot;&gt;quantum entanglement&lt;/a&gt; (what you want, often), &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/tagged/quantum-decoherence&quot;&gt;quantum decoherence&lt;/a&gt; (what happens in the way) and &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/tagged/quantum-error-correction&quot;&gt;quantum error correction&lt;/a&gt; (ways to fix the situation without observing, or to observe just-enough but not-in-a-destructive-way).&lt;/li&gt;&#xA;&lt;li&gt;The last point, quantum error correction, is indeed a &lt;em&gt;trick&lt;/em&gt; that is allowed. Here the key is observing, not the values of the qubits, but rather the relation between these values. With enough redundance and smart schemes, one can deduce what went wrong and where, and fix it without observing the values that are involved in the calculation. (Hopefully the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_error_correction#The_bit_flip_code&quot; rel=&quot;nofollow noreferrer&quot;&gt;3-qubit bit flip code&lt;/a&gt; can be understood without understanding quantum mechanics, since C-not operations have basic truth tables?) In this way we sacrifice part of the quantum information while preserving the part that we care about.&lt;/li&gt;&#xA;&lt;li&gt;In the end we also get a classical output. We lose a lot, but that's just how reality works. You can always repeat the calculation to extract information gradually, aim for &lt;em&gt;quantum state tomography&lt;/em&gt;.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Finally, since others said it better than I could, consider this quotations (emphases mine).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;First, by &lt;a href=&quot;https://www.scottaaronson.com/democritus/lec14.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Scott Aaronson,  &quot;PHYS771 Lecture 14: Skepticism of Quantum Computing&quot;&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Q: OK, so you have the Threshold Theorem, but then you have to do some error correction, right? Your computation becomes longer, right? &lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Scott: Yeah, but by a factor of polylog(n). This isn't challenging the Church-Turing Thesis, but yeah, that's true.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Q: I'm not sure if you'd have to perform another error correction as you proceed.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Scott: &lt;strong&gt;The entire content of the Threshold Theorem is that you're correcting errors faster than they're created&lt;/strong&gt;. That's the whole point, and the whole non-trivial thing that the theorem shows. That's the problem it solves.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;And secondly, the abstract from &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9712048&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv:quant-ph/9712048 &quot;Fault-tolerant quantum computation&quot; by John Preskill&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The discovery of quantum error correction has greatly improved the long-term prospects for quantum computing technology. Encoded quantum information can be protected from errors that arise due to uncontrolled interactions with the environment, or due to imperfect implementations of quantum logical operations. &lt;strong&gt;Recovery from errors can work effectively even if occasional mistakes occur during the recovery procedure.&lt;/strong&gt; Furthermore, encoded quantum information can be processed without serious propagation of errors. &lt;strong&gt;In principle, an arbitrarily long quantum computation can be performed reliably, provided that the average probability of error per gate is less than a certain critical value, the accuracy threshold.&lt;/strong&gt; It may be possible to incorporate intrinsic fault tolerance into the design of quantum computing hardware, perhaps by invoking topological Aharonov-Bohm interactions to process quantum information. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="1847" LastEditDate="2018-04-22T05:23:02.253" LastActivityDate="2018-04-22T05:23:02.253" CommentCount="4" />
  <row Id="1863" PostTypeId="2" ParentId="1850" CreationDate="2018-04-22T01:37:04.493" Score="4" Body="&lt;p&gt;This answer assumes that you do not have a technical background in cryptography or quantum physics.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Most current implementations of the blockchain rely on two math concepts: (1) Public key encryption. (2) Hash keys.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quantum computers can break the public key encryption part, through a famous method known as Shor's algorithm (For technical details: see page 8 of: &lt;a href=&quot;https://arxiv.org/pdf/1710.10377.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/pdf/1710.10377.pdf&lt;/a&gt;).  This is a powerful threat.  But since the digital security of the modern world is built on public key encryption, this would be a broader problem (as opposed to a blockchain specific one).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quantum computers can also break the hash key component, through a method known as Grover search. But this part is relatively resistant to the attack (For technical details: see page 4 of the above link).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are other ways to build a blockchain to protect against the above attack:  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Some would be based on math ideas.  This is known as post-quantum blockchains.  Since quantum computers have already shown to break math-based cryptography systems and researchers are working on new algorithms of this future computer (see: &lt;a href=&quot;https://www.nature.com/news/first-quantum-computers-need-smart-software-1.22590&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://www.nature.com/news/first-quantum-computers-need-smart-software-1.22590&lt;/a&gt;), it casts a doubt on the long-term durability of such a cryptographic system.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A research group based a blockchain on a cryptographic system that uses quantum physics (For technical details see: &lt;a href=&quot;https://arxiv.org/abs/1705.09258&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/1705.09258&lt;/a&gt;); this uses the properties of quantum particles as opposed to math ideas.  It's known as quantum cryptography and it is resistant to attacks from a quantum computer.  The weakness in that blockchain system is that it makes technical assumptions that may not be viable in the real world.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Another research group made the blockchain itself into a quantum system (For technical details, see: &lt;a href=&quot;https://arxiv.org/abs/1804.05979&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/1804.05979&lt;/a&gt;).  This uses a property of quantum particles known as entanglement in time. The weakness is that the research only presents a conceptual design.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In summary, quantum computers pose a threat to the current implementations of the blockchain; future implementations may not suffer.  Furthermore, it would be incorrect to single out just blockchains for such a threat; quantum computers pose a threat to other systems protected by current digital security methods.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Hope that helps.&lt;/p&gt;&#xA;" OwnerUserId="2084" LastActivityDate="2018-04-22T01:37:04.493" CommentCount="1" />
  <row Id="1864" PostTypeId="2" ParentId="1860" CreationDate="2018-04-22T03:30:06.123" Score="6" Body="&lt;p&gt;Yes the Hilbert space is the same, but you have to choose the isomorphism $\phi : \; \; (\mathbb{C}^2)^{\otimes 2} \simeq \mathbb{C}^4$. But the different setup will mean some unitaries that will be easy to implement in one setup will be hard in the other. For example, as 2 qubits gates something like $\sigma_z \otimes 1$ will be easy. But if you write that as a 4 by 4 unitary through that isomorphism $\phi$ instead that might not be as easy to implement. You should say both the Hilbert space and the easy operations that you wish to write your program in terms of.&lt;/p&gt;&#xA;" OwnerUserId="434" LastActivityDate="2018-04-22T03:30:06.123" CommentCount="1" />
  <row Id="1865" PostTypeId="2" ParentId="1860" CreationDate="2018-04-22T07:46:59.517" Score="7" Body="&lt;p&gt;For qubits, we usually base all of our operators on the Pauli matrices. Our basic gate set consists of the Pauli matrices themselves, Clifford gates like $H$ and $S$ that map between Pauli matrices, controlled operations like the CNOT that implement a Pauli on one qubit depending on the Pauli eigenstate of another, etc.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For any larger $d$-dimensional quantum system, we have to find the basic set of operators that will play the same role.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One approach is the generalize the Pauli matrices. We choose a group whose order is $d$, and define operators based in that group. &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9707021&quot; rel=&quot;nofollow noreferrer&quot;&gt;This&lt;/a&gt; is my go-to text on how to do this, though it is actually focused more on generalizing stabilizer codes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We could also look to the spin operators for inspiration. The Pauli matrices describe a spin-$1/2$ system. So for higher dimensional systems, we could look at the operators for higher spin. They don’t have the same sort of nice properties, though. So this doesn’t seem to be a popular approach.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Either way, the Hilbert space is the same and universal QC based on them is the same thing. The only difference is our basic gate set. So the numbers of gates required for a given task may have a difference in terms of constants and coefficients. And the maths might be nicer for one than the other. But the complexity will be the same.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-04-22T15:59:54.320" LastActivityDate="2018-04-22T15:59:54.320" CommentCount="1" />
  <row Id="1866" PostTypeId="2" ParentId="1858" CreationDate="2018-04-22T08:42:50.523" Score="3" Body="&lt;p&gt;First of all, the two conditions for fault tolerant measurements are:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;A single error gives no more than one error per block of qubits&lt;/li&gt;&#xA;&lt;li&gt;The measurement result needs to be correct with probability $1-\mathcal O\left(p^2\right)$&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;The preparation step creates the state $\frac{1}{\sqrt{2}}\left(\left|000\right&amp;gt;+\left|111\right&amp;gt;\right)$ (the three qubit 'cat state', also known as the three qubit &lt;a href=&quot;https://en.wikipedia.org/wiki/Greenberger%E2%80%93Horne%E2%80%93Zeilinger_state&quot; rel=&quot;nofollow noreferrer&quot;&gt;GHZ state&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The 'ancilla verification' step is then applying two CNOTs on extra qubits (starting in the state $\left|0\right&amp;gt;$) to check the parities $Z_iZ_j$ to see if a bit flip has occurred.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, assuming no errors, checking $Z_2Z_3$:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;The state after preparation, before verification is $\frac{1}{\sqrt{2}}\left(\left|000\right&amp;gt;+\left|111\right&amp;gt;\right)\left|0\right&amp;gt;$&lt;/li&gt;&#xA;&lt;li&gt;After the first CNOT on the extra qubit: $\frac{1}{\sqrt{2}}\left(\left|000\right&amp;gt;\left|0\right&amp;gt;+\left|111\right&amp;gt;\left|1\right&amp;gt;\right)$&lt;/li&gt;&#xA;&lt;li&gt;After the second CNOT: $\frac{1}{\sqrt{2}}\left(\left|000\right&amp;gt;+\left|111\right&amp;gt;\right)\left|0\right&amp;gt;$&lt;/li&gt;&#xA;&lt;li&gt;The extra qubit is now measured and returns $0$, showing no bit flip has occurred. There is a possibility, with probability $\mathcal O\left(p^2\right)$ of two bit flips occurring, where the probability of a single error is $p$.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Instead of the above, let's have a $Z$ error after the first CNOT. The state after this error (and before the second CNOT) is $\frac{1}{\sqrt{2}}\left(\left|000\right&amp;gt;\left|0\right&amp;gt;-\left|111\right&amp;gt;\left|1\right&amp;gt;\right)$. Applying the second CNOT then gives $\frac{1}{\sqrt{2}}\left(\left|000\right&amp;gt;-\left|111\right&amp;gt;\right)\left|0\right&amp;gt;$, which is the same as before, only now with a $Z$ error on the second ancilla qubit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A controlled-$M$ operation on the encoded data (in the state $\left|\psi\right&amp;gt; = \alpha\left|0_L\right&amp;gt; + \beta\left|1_L\right&amp;gt;$), putting the system in the state $\frac{1}{\sqrt{2}}I_1Z_2I_3\left(\left|000\right&amp;gt;\left|\psi\right&amp;gt;+\left|111\right&amp;gt;M\left|\psi\right&amp;gt;\right) = \frac{1}{\sqrt{2}}\left(\left|000\right&amp;gt;\left|\psi\right&amp;gt;-\left|111\right&amp;gt;M\left|\psi\right&amp;gt;\right)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The decoding operation (C-NOT-NOT, followed by $H_1$ on the ancilla qubits) is then performed. The decoding C-NOT-NOT gives the state $$\frac{1}{\sqrt{2}}\left(\left|000\right&amp;gt;\left|\psi\right&amp;gt;-\left|100\right&amp;gt;M\left|\psi\right&amp;gt;\right) = \frac{1}{\sqrt{2}}Z_1Z_2I_3\left(\left|000\right&amp;gt;\left|\psi\right&amp;gt;+\left|100\right&amp;gt;M\left|\psi\right&amp;gt;\right)$$ and the $Z$ error is now on the &lt;em&gt;first&lt;/em&gt; qubit, directly affecting the measurement result.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;While it isn't necessarily clear that this is the case, it can be shown that $Z$ errors propagate 'backwards' through CNOT gates by starting with the state $\left|++\right&amp;gt; = \frac{1}{2}\left(\left|0\right&amp;gt;+\left|1\right&amp;gt;\right)\left(\left|0\right&amp;gt;+\left|1\right&amp;gt;\right)$ and applying a CNOT to return the same state. However, a $Z$ error on the second qubit returns the state $\left|--\right&amp;gt; = ZZ\left|++\right&amp;gt;$, showing the $Z$ error has propagated backwards.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In &lt;em&gt;this&lt;/em&gt; sense, a single &lt;em&gt;uncorrectable&lt;/em&gt; $Z$ error on an extra qubit eventually ends up causing $Z$ errors on multiple ancilla qubits (at a point where multiple $Z$ errors don't cancel) before the measurement and so, this part of the procedure is &lt;em&gt;not&lt;/em&gt; fault tolerant as an error on multiple qubits happens with probability $p$ and the probability of a successful measurement outcome is $1-p$, so the whole process has to be repeated multiple times to achieve a better measurement outcome.&lt;/p&gt;&#xA;" OwnerUserId="23" LastEditorUserId="23" LastEditDate="2018-04-22T09:09:30.267" LastActivityDate="2018-04-22T09:09:30.267" CommentCount="3" />
  <row Id="1867" PostTypeId="1" AcceptedAnswerId="1927" CreationDate="2018-04-22T09:14:27.913" Score="6" ViewCount="62" Body="&lt;p&gt;This question is inspired by &quot;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1860/what-is-the-difference-between-a-qudit-system-with-d-4-and-a-two-qubit-system&quot;&gt;What is the difference between a qudit system with d=4 and a two-qubit system?&lt;/a&gt;&quot;, as an experimental follow-up.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Consider for illustration these two particular cases:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1711.07216.pdf&quot; rel=&quot;noreferrer&quot;&gt;Molecular Spin Qudits for Quantum Algorithms&lt;/a&gt;, where in one important example a single d=4 qudit arises from a nuclear spin quadruplet I=3/2&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://www.nature.com/articles/ncomms11377&quot; rel=&quot;noreferrer&quot;&gt;A modular design of molecular qubits to implement universal quantum gates&lt;/a&gt;, where in one important example a two-qubit system arises from an electronic spin quadruplet S=3/2 (which in turn arises from a ferromagnetic coupling between two ideal electronic spin doublets)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;In general I'm referring to experimental cases where in practice there is an always-on-but-sometimes-weak coupling between two two-state systems, producing a ground quadruplet.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is: in experiments such as these, are 2·qubit and d=4 qudit (a) strictly distinguishable beasts, or (b) theoretical idealizations which are more or less adequate depending on practical considerations? &lt;/p&gt;&#xA;" OwnerUserId="1847" LastActivityDate="2018-04-26T01:24:07.957" Title="Is qubit/qudit terms, where is the experimental limit between an S=3/2 and 2·S=1/2?" Tags="&lt;experimental-results&gt;&lt;terminology&gt;&lt;qudit&gt;" AnswerCount="1" CommentCount="3" FavoriteCount="1" />
  <row Id="1868" PostTypeId="2" ParentId="1716" CreationDate="2018-04-22T15:03:14.547" Score="1" Body="&lt;p&gt;Miniaturizing switching or transistor technology needs to go hand in hand with quantum (transport and computing) theory.&#xA;I think that many challenging aspects (like for instance isotopically purifying silicon and donor implementation for &lt;a href=&quot;http://scholar.google.fr/scholar_url?url=http://docs.lib.purdue.edu/cgi/viewcontent.cgi%3Farticle%3D1853%26context%3Dnanopub&amp;amp;hl=de&amp;amp;sa=X&amp;amp;scisig=AAGBfm2QTZisLMSAiX5NRLQwYIbxoY5BZA&amp;amp;nossl=1&amp;amp;oi=scholarr&amp;amp;ved=0ahUKEwjHuYmaj87aAhXJOBQKHbf1CKkQgAMIMCgAMAA&quot; rel=&quot;nofollow noreferrer&quot;&gt;single atom transistors&lt;/a&gt;) are classical material science problems.&#xA;There is a recent review article on the strategies to develop beyond current CMOS transistor technology:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.nature.com/articles/s41567-018-0101-4&quot; rel=&quot;nofollow noreferrer&quot;&gt;Beyond CMOS computing with spin and polarization&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Moreover, there is a lot of research on building qubits transistor-like:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.nature.com/articles/ncomms13575&quot; rel=&quot;nofollow noreferrer&quot;&gt;A CMOS spin qubit&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And a comment on recent advances in silicon quantum technology which is important for  quantum computing applications (&lt;a href=&quot;https://arxiv.org/ftp/arxiv/papers/1708/1708.03530.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;CNOT gate&lt;/a&gt;, &lt;a href=&quot;https://qutech.nl/wp-content/uploads/2016/01/science.aar4054.full_.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;strong coupling&lt;/a&gt;) from this year 2018:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://science.sciencemag.org/content/359/6374/393&quot; rel=&quot;nofollow noreferrer&quot;&gt;Toward a silicon-based quantum computer&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;" OwnerUserId="2094" LastActivityDate="2018-04-22T15:03:14.547" CommentCount="1" />
  <row Id="1869" PostTypeId="1" CreationDate="2018-04-22T15:26:58.737" Score="4" ViewCount="122" Body="&lt;p&gt;$\newcommand{\qr}[1]{|#1\rangle}$Question.  Can you check whether this is correct?  Also, given the analysis below, what is the domain of and co-domain of $f(\qr{x})$?  I think it is $V^4 \to W^4 : f$ because &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\qr{00} = \qr{0}\otimes\qr{0} = \left[\begin{matrix}1\\0\\0\\0\end{matrix}\right].$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Analysis.  Let&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\qr{x} = a_{00}\qr{00} + a_{01}\qr{01} + a_{10}\qr{10} + a_{11}\qr{11}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;and let $U_f$ implement some constant or balanced function $f(x)$. Then I claim the following holds given the linear function nature of $U_f$.&#xA;\begin{align*}&#xA;  f(\qr{x}) &amp;amp;= U_f\qr{x}\\&#xA;  &amp;amp;= U_f(a_{00}\qr{00} + a_{01}\qr{01} + a_{10}\qr{10} + a_{11}\qr{11})\\&#xA;  &amp;amp;= U_f(a_{00}\qr{00}) + U_f(a_{01}\qr{01}) + U_f(a_{10}\qr{10}) + U_f(a_{11}\qr{11})\\&#xA;  &amp;amp;= a_{00}U_f(\qr{00}) + a_{01}U_f(\qr{01}) + a_{10}U_f(\qr{10}) + a_{11}U_f(\qr{11}),&#xA;\end{align*}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now if $f$ is constant --- with $f(\qr{x}) = \qr{00}$ for all $\qr{x}$ ---, then we would have&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{align*}&#xA;  f(\qr{x}) &amp;amp;= a_{00}U_f(\qr{00}) + a_{01}U_f(\qr{01}) + a_{10}U_f(\qr{10}) + a_{11}U_f(\qr{11})\\&#xA;  &amp;amp;= a_{00}\qr{00} + a_{01}\qr{00} + a_{10}\qr{00} + a_{11}\qr{00}\\&#xA;  &amp;amp;= (a_{00} + a_{01} + a_{10} + a_{11})\qr{00}.&#xA;\end{align*}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If, on the other hand, $f$ is balanced then with probability $1/2$, we have&#xA;\begin{align*}&#xA;  f(\qr{x}) &amp;amp;= a_{00}U_f(\qr{00}) + a_{01}U_f(\qr{01}) + a_{10}U_f(\qr{10}) + a_{11}U_f(\qr{11})\\&#xA;  &amp;amp;= (a_{00} + a_{01} + a_{10} + a_{11})\qr{00}&#xA;\end{align*}&#xA;and with probability $1/2$ as well&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{align*}&#xA;  f(\qr{x}) &amp;amp;= a_{00}U_f(\qr{00}) + a_{01}U_f(\qr{01}) + a_{10}U_f(\qr{10}) + a_{11}U_f(\qr{11})\\&#xA;  &amp;amp;= (a_{00} + a_{01} + a_{10} + a_{11})\qr{11}.&#xA;\end{align*}&lt;/p&gt;&#xA;" OwnerUserId="1589" LastActivityDate="2018-08-01T10:09:15.733" Title="What can I deduce about $f(x)$ if $f$ is balanced or constant?" Tags="&lt;quantum-algorithms&gt;&lt;qubit&gt;&lt;quantum-gate&gt;&lt;notation&gt;" AnswerCount="2" CommentCount="8" FavoriteCount="1" />
  <row Id="1870" PostTypeId="1" CreationDate="2018-04-22T15:43:42.417" Score="13" ViewCount="503" Body="&lt;p&gt;In the Wikipedia article about &lt;a href=&quot;https://en.wikipedia.org/wiki/Bell_state#Bell_state_correlations&quot; rel=&quot;noreferrer&quot;&gt;Bell states&lt;/a&gt; it is written:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Independent measurements made on two qubits that are entangled in Bell states positively correlate perfectly, if each qubit is measured in the &lt;em&gt;relevant basis&lt;/em&gt;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;What does it even mean to perform a measurement in a certain basis? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can answer by using the example of the Bell states of the Wikipedia article.&lt;/p&gt;&#xA;" OwnerUserId="72" LastEditorUserId="1847" LastEditDate="2018-04-22T17:13:28.893" LastActivityDate="2018-04-23T11:20:20.010" Title="What does &quot;measurement in a certain basis&quot; mean?" Tags="&lt;measurement&gt;&lt;quantum-information&gt;&lt;terminology&gt;" AnswerCount="3" CommentCount="1" FavoriteCount="3" />
  <row Id="1871" PostTypeId="2" ParentId="1870" CreationDate="2018-04-22T16:12:11.267" Score="3" Body="&lt;p&gt;Qubits are essentially quantum objects from which you can extract a bit. But there are different ways that this can be done, and the answer you get depends on the measurement you choose.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you qubit is an electron spin, the measurement basis corresponds to measuring spin in a particular direction. We use that picture more generally in the form of the Bloch sphere. Measurement in this case corresponds to taking pair of opposing points on the sphere and making the qubit choose between then. Each possible pair of opposing points is referred to as a different measurement basis.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Often with qubits, practical reasons in implementation mean that we can only actually measure in a single basis, known as the $Z$ or computational basis. To simulate the others we can precede our measurement with a certain single qubit rotation. The rotation we choose determines the basis we end up measuring in.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For a given Bell state, and for a given measurement basis on one of the qubits, there exists a measurement basis for the second with with results will be perfectly correlated. This seems to be what the article is getting at.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For the Bell states, measuring both qubits in the $Z$ basis will either end up with perfect correlation or perfect anti correlation, depending on which Bell state it is. If you get an anti correlation, you can change basis on one qubit by applying an $X$ rotation before the measurement. This new basis will get perfect correlations with the $Z$ basis measurement results for the other qubit.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-04-22T16:54:03.307" LastActivityDate="2018-04-22T16:54:03.307" CommentCount="0" />
  <row Id="1872" PostTypeId="2" ParentId="1870" CreationDate="2018-04-22T16:37:27.460" Score="4" Body="&lt;p&gt;If you think of a electronic spin $S=1/2$, imagine measuring it on the z-axis to obtain $S_z=+1/2$ (or $S_z=-1/2$). This (the z projection of the spin magnetic moment) is a possible basis for the measurement. Or you could measure the spin on the x-axis, and they you will obtain $S_x=+1/2$ (or $S_x=-1/2$). This is a different basis. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The measurements on Bell pairs will correlate with each other when measured on non-orthogonal basis (if you measure one particle on z and the other on x, the results will be perfectly uncorrelated; if you measure both on z or both on x, the results will be perfectly correlated).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Other examples of measurement bases would be polarization with photons: vertical vs horizontal is the linear polarization basis, whereas clockwise vs anticlockwise is the circular polarization basis.&lt;/p&gt;&#xA;" OwnerUserId="1847" LastActivityDate="2018-04-22T16:37:27.460" CommentCount="3" />
  <row Id="1873" PostTypeId="5" CreationDate="2018-04-22T17:15:29.917" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-22T17:15:29.917" LastActivityDate="2018-04-22T17:15:29.917" CommentCount="0" />
  <row Id="1874" PostTypeId="4" CreationDate="2018-04-22T17:15:29.917" Score="0" Body="For questions regarding design, development or theory of solid-state devices as relevant to quantum computers. May also be used for questions regarding solid state physics or chemistry, if they are relevant to quantum computing. " OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-05-03T07:26:18.707" LastActivityDate="2018-05-03T07:26:18.707" CommentCount="0" />
  <row Id="1875" PostTypeId="1" AcceptedAnswerId="1876" CreationDate="2018-04-22T17:24:34.220" Score="10" ViewCount="193" Body="&lt;p&gt;I am currently reading &quot;Quantum Computation and Quantum Information&quot; by Nielsen and Chuang. In the section about Quantum Simulation, they give an illustrative example (section 4.7.3), which I don't quite understand:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Suppose we have the Hamiltonian &#xA;  $$ H = Z_1 ⊗ Z_2 ⊗ \cdots ⊗ Z_n,\tag{4.113}$$&#xA;  which acts on an $n$ qubit system. Despite this being an interaction involving all of the system, indeed, it can be simulated efficiently. What we desire is a simple quantum circuit which implements $e^{-iH\Delta t}$, for arbitrary values of $\Delta t$. A circuit doing precisely this, for $n = 3$, is shown in Figure 4.19. The main insight is that although the Hamiltonian involves all the qubits in the system, it does so in a &lt;em&gt;classical&lt;/em&gt; manner: the phase shift applied to the system is $e^{-i\Delta t}$ if the &lt;em&gt;parity&lt;/em&gt; of the $n$ qubits in the computational basis is even; otherwise, the phase shift should be $e^{i\Delta t}$. Thus, simple simulation of $H$ is possible by first classically computing the parity (storing the result in an ancilla qubit), then applying the appropriate phase shift conditioned on the parity, then uncomputing the parity (to erase the ancilla).&lt;a href=&quot;https://i.stack.imgur.com/OwE2r.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/OwE2r.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&#xA;  Furthermore, extending the same procedure allows us to ismulate more complicated extended Hamiltonians. Speciffically, we can efficiently simulate any Hamiltonian of the form $$H = \bigotimes_{k=1}^n\sigma_{c\left(k\right)}^k,$$ where $\sigma_{c(k)}^k$ is a Pauli matrix (or the identity) acting on the $k$th qubit, with $c(k) \in \{0, 1, 2, 3\}$ specifying one of $\{I, X, Y, Z\}$. The qubits upon which the identity operation is performed can be disregarded, and $X$ or $Y$ terms can be transformed by single qubit gates to $Z$ operations. This leaves us with Hamiltonian of the form of (4.113), which is simulated as described above.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;How can we obtain gate $e^{-i\Delta t Z}$ from elementary gates (for example from Toffoli gates)?&lt;/p&gt;&#xA;" OwnerUserId="2098" LastEditorUserId="55" LastEditDate="2018-08-03T14:20:02.150" LastActivityDate="2018-08-03T14:20:02.150" Title="Obtaining gate $e^{-i\Delta t Z}$ from elementary gates" Tags="&lt;quantum-gate&gt;&lt;simulation&gt;&lt;gate-synthesis&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="2" />
  <row Id="1876" PostTypeId="2" ParentId="1875" CreationDate="2018-04-22T17:42:27.720" Score="6" Body="&lt;p&gt;One way order to perform Z rotations by arbitrary angles is to approximate them with a sequence of Hadamard and T gates. If you need the approximation to have maximum error $\epsilon$, there are known constructions that do this using roughly $3 \lg \frac{1}{\epsilon}$ T gates. See &lt;a href=&quot;https://arxiv.org/abs/1403.2975&quot; rel=&quot;noreferrer&quot;&gt;&quot;Optimal ancilla-free Clifford+T approximation of z-rotations&quot; by Ross et al&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The best published way to approximate arbitrary Z rotations, &lt;a href=&quot;https://arxiv.org/abs/1404.5320&quot; rel=&quot;noreferrer&quot;&gt;repeat-until-success circuits&lt;/a&gt;, takes a slightly more complicated approach but achieves an average of roughly $9 + 1.2 \lg \frac{1}{\epsilon}$ T gates.&lt;/p&gt;&#xA;" OwnerUserId="119" LastActivityDate="2018-04-22T17:42:27.720" CommentCount="1" />
  <row Id="1877" PostTypeId="1" AcceptedAnswerId="1879" CreationDate="2018-04-22T18:06:45.973" Score="6" ViewCount="119" Body="&lt;p&gt;I am currently reading &quot;Quantum Computation and Quantum Information&quot; by Nielsen and Chuang. In the section about Quantum Simulation, they give an illustrative example (section 4.7.3), which I don't quite understand:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Suppose we have the Hamiltonian &#xA;  $$ H = Z_1 ⊗ Z_2 ⊗ \cdots ⊗ Z_n, \tag{4.113}$$&#xA;  which acts on an $n$ qubit system. Despite this being an interaction involving all of the system, indeed, it can be simulated efficiently. What we desire is a simple quantum circuit which implements $e^{-iH\Delta t}$, for arbitrary values of $\Delta t$. A circuit doing precisely this, for $n = 3$, is shown in Figure 4.19. The main insight is that although the Hamiltonian involves all the qubits in the system, it does so in a &lt;em&gt;classical&lt;/em&gt; manner: the phase shift applied to the system is $e^{-i\Delta t}$ if the &lt;em&gt;parity&lt;/em&gt; of the $n$ qubits in the computational basis is even; otherwise, the phase shift should be $e^{i\Delta t}$. Thus, simple simulation of $H$ is possible by first classically computing the parity (storing the result in an ancilla qubit), then applying the appropriate phase shift conditioned on the parity, then uncomputing the parity (to erase the ancilla).&lt;a href=&quot;https://i.stack.imgur.com/OwE2r.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/OwE2r.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&#xA;  Furthermore, extending the same procedure allows us to ismulate more complicated extended Hamiltonians. Speciffically, we can efficiently simulate any Hamiltonian of the form $$H = \bigotimes_{k=1}^n\sigma_{c\left(k\right)}^k,$$ where $\sigma_{c(k)}^k$ is a Pauli matrix (or the identity) acting on the $k$th qubit, with $c(k) \in \{0, 1, 2, 3\}$ specifying one of $\{I, X, Y, Z\}$. The qubits upon which the identity operation is performed can be disregarded, and $X$ or $Y$ terms can be transformed by single qubit gates to $Z$ operations. This leaves us with Hamiltonian of the form of (4.113), which is simulated as described above.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;What do we mean by the &lt;em&gt;parity&lt;/em&gt; of the qubits here? Is it the number of qubits in the state $\lvert 1 \rangle$, and can it be even or odd?&lt;/p&gt;&#xA;" OwnerUserId="2098" LastEditorUserId="55" LastEditDate="2018-04-23T08:09:18.023" LastActivityDate="2018-04-23T08:09:18.023" Title="What do we mean by parity of qubits?" Tags="&lt;simulation&gt;&lt;terminology&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="1878" PostTypeId="2" ParentId="1877" CreationDate="2018-04-22T20:29:52.420" Score="0" Body="&lt;p&gt;Yes. This is just checked on the computational basis of all n-bit strings and you can see it does the right thing there. It is acting by $(e^{\pm i \Delta t})$ for the respective parities of basis vectors so it is the circuit you wanted by checking on the basis.&lt;/p&gt;&#xA;" OwnerUserId="434" LastActivityDate="2018-04-22T20:29:52.420" CommentCount="0" />
  <row Id="1879" PostTypeId="2" ParentId="1877" CreationDate="2018-04-22T20:32:02.493" Score="4" Body="&lt;p&gt;In the computational $\left(Z\right)$ basis, the parity of a (classical) bit string is $0$ if the number of $1$s in the string is even (i.e. 'even parity'), or $1$ if the number of $1$s in the string is odd (i.e. 'odd parity').&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The parity can be measured by applying CNOT gates from each qubit that you want to measure (the control qubits) to an ancilla qubit (the target, initially in state $\left|0\right&amp;gt;$). Measuring the parity of a (classical) input state $\left|x_1x_2\ldots x_n\right&amp;gt;$, gives the output of the ancilla as $\left|\bigoplus_{k=1}^nx_k\right&amp;gt;$, which is $\left|0\right&amp;gt;$ for even parity and $\left|1\right&amp;gt;$ for odd parity, as above.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The same process can be applied to quantum input states. As an example, calculating the parity of $\frac {1}{\sqrt{2}}\left(\left|00\right&amp;gt;+\left|11\right&amp;gt;\right)$, applying the CNOT gates gives the state of the overall system (including ancilla) as $\frac {1}{\sqrt{2}}\left(\left|00\right&amp;gt;+\left|11\right&amp;gt;\right)\left|0\right&amp;gt;$, which returns $0$, showing the input qubits have even parity. The converse of this is taking the input state as $\frac {1}{\sqrt{2}}\left(\left|01\right&amp;gt;+\left|10\right&amp;gt;\right)$, which gives the total state, after CNOTs, as $\frac {1}{\sqrt{2}}\left(\left|01\right&amp;gt;+\left|10\right&amp;gt;\right)\left|1\right&amp;gt;$, showing the input state has odd parity.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This shows that the parity of a quantum state is analogous to the parity of a classical state.&lt;/p&gt;&#xA;" OwnerUserId="23" LastActivityDate="2018-04-22T20:32:02.493" CommentCount="0" />
  <row Id="1880" PostTypeId="1" CreationDate="2018-04-23T05:54:38.400" Score="5" ViewCount="62" Body="&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Nitrogen-vacancy_center&quot; rel=&quot;noreferrer&quot;&gt;Nitrogen-Vacancy centers&lt;/a&gt; (NVs) have astonishing quantum properties, which make them interesting as potential hardware both for quantum computing in particular and for quantum technologies in general. In part this results from the center being protected by the diamond structure, which is at the same time very rigid and practically free from nuclear spins.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, their properties change in unpractical ways with their proximity to the surface:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;The closer they are to the surface, the better they interact with whatever is just beyond the surface. This is very important for quantum metrology but also in general for input/output in a quantum computing context, see for example &lt;a href=&quot;http://advances.sciencemag.org/content/3/8/e1701116&quot; rel=&quot;noreferrer&quot;&gt;A molecular quantum spin network controlled by a single qubit&lt;/a&gt; (&lt;a href=&quot;https://arxiv.org/abs/1703.08248&quot; rel=&quot;noreferrer&quot;&gt;arXiv version&lt;/a&gt;).&lt;/li&gt;&#xA;&lt;li&gt;However, the closer the are to the surface, the more they are affected by all kinds of noise also just beyond the surface. This results from the fact that while the bulk is perfect diamond the surface is full of defects/impurities/rubbish.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;My question is practical and is about &lt;strong&gt;cleaning and/or chemically modifying the diamond surface in order to passivate it&lt;/strong&gt;: up to which point has this been experimentally demonstrated? What is the current state of the art, how much can quantum coherence on NV centers be improved by a detailed control of the diamond surface?&lt;/p&gt;&#xA;" OwnerUserId="1847" LastActivityDate="2018-07-27T17:24:48.173" Title="Passive improving of nanodiamond surfaces for NV centers?" Tags="&lt;architecture&gt;&lt;experimental-results&gt;&lt;quantum-decoherence&gt;&lt;solid-state&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="1881" PostTypeId="1" CreationDate="2018-04-23T07:40:11.190" Score="6" ViewCount="95" Body="&lt;p&gt;In Kaye, Laflamme and Mosca (2007) pg106 they write the following (in the context of Simon's algorithm):&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;...where $S=\{\mathbf{0},\mathbf{s}\}$ is a $2$-dimensional vector space spanned by $\mathbf{s}$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;this is not the only place I have seen this vector space referred to as &quot;2-dimensional&quot;. But surely the fact that it is only spanned by one vector, $\mathbf{s}$, means (by definition) that it is only &quot;1-dimensional&quot;?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Am I missing something here or is the use of the term &quot;dimension&quot; different in this area?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;More Context&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As mentioned above the context is Simon's Algorithm. I.e. there exists a oracle $f:\{0,1\}^n\rightarrow \{0,1\}^n$ such that $f(x)=f(y)$ if and only if $x=y\oplus \mathbf{s}$ where $\mathbf{s}\in \{0,1\}^n$ and $\oplus$ is addition in $\Bbb{Z}_2^n$ (i.e. bit-wise). The aim of the algorithm is to find $\mathbf{s}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;After applying a relevant circuit the output is a uniform distribution of $\mathbf{z}\in \{0,1\}^n$ such that $\mathbf{z}\cdot\mathbf{s}=z_1s_1+z_2s_2\cdots+ z_ns_n=0$. The statement I have quoted above is refering to the fact that since $\mathbf{0}$ and $\mathbf{s}$ are are solution to this problem you only need $n-1$  linearly independent vectors $\mathbf{z}$ to find $\mathbf{s}$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The term is also used in the same context at the end of Pg 4 of this &lt;a href=&quot;https://courses.cs.washington.edu/courses/cse599d/06wi/lecturenotes8.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;pdf&lt;/a&gt; (&lt;a href=&quot;https://web.archive.org/web/20180420040038/https://courses.cs.washington.edu/courses/cse599d/06wi/lecturenotes8.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wayback Machine version&lt;/a&gt;).&lt;/p&gt;&#xA;" OwnerUserId="2015" LastEditorUserId="2015" LastEditDate="2018-04-24T05:37:26.020" LastActivityDate="2018-04-24T06:35:55.513" Title="Use of the term &quot;dimension&quot; for qubits?" Tags="&lt;qubit&gt;&lt;terminology&gt;&lt;simons-algorithm&gt;" AnswerCount="1" CommentCount="4" />
  <row Id="1882" PostTypeId="2" ParentId="1869" CreationDate="2018-04-23T08:17:58.013" Score="2" Body="&lt;p&gt;$f$ being balanced does not mean that it gives one output with probability $0.5$ and the other output with probability $0.5$.&#xA;Instead, it means that half of the inputs are sent to one output and the other half to a different output.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I don't know what you are referring to in the notes you link, but $f$ is there defined as $f:\{0,1\}^n\mapsto\{0,1\}$, and if it is balanced then it will act for example as&#xA;$f(00)=f(01)=0$, $f(10)=f(11)=1$.&#xA;This is totally different from what you wrote, as you will get something like&#xA;$$|x\rangle\mapsto|f(x)\rangle=(a_{00}+a_{01})|0\rangle+(a_{10}+a_{11})|1\rangle.$$&lt;/p&gt;&#xA;" OwnerUserId="55" LastActivityDate="2018-04-23T08:17:58.013" CommentCount="3" />
  <row Id="1883" PostTypeId="2" ParentId="1861" CreationDate="2018-04-23T08:36:12.950" Score="1" Body="&lt;p&gt;The whole point is that you do &lt;em&gt;not&lt;/em&gt; want, nor need, to &quot;&lt;em&gt;look&lt;/em&gt;&quot; how the computation is going.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can ensure that the input is what it should be by a variety of means. The simplest case being that you may simply trust that your apparatus, which you previously characterized very well, will produce what you ask it to produce.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;After that, you will know whether the input will evolve into a superposition of different states simply because you generally know what the evolution of the system looks like. Again, because you know what your computer is going to do: you built it for that purpose.&#xA;You will know that (for example) a specific sequence of entangling gates will be performed on the input, so that the state will evolve into a given superposition of states in the computational basis.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The crucial point here is that &lt;em&gt;you do not, and cannot, look at the state during the computation&lt;/em&gt;.&#xA;In other words, you have to think of the whole quantum algorithm/circuit as a black box: you built it so you (more or less) trust what it does, but after that you can just put an input and look at the resulting output.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Looking at the output does indeed destroy the coherence of the state (that is, roughly speaking, its being in a superposition of different states), but this is not a problem because quantum algorithms are designed in such a way that the measurements performed on the output give the answer to the problem.&lt;/p&gt;&#xA;" OwnerUserId="55" LastActivityDate="2018-04-23T08:36:12.950" CommentCount="0" />
  <row Id="1884" PostTypeId="2" ParentId="1860" CreationDate="2018-04-23T08:44:37.240" Score="2" Body="&lt;p&gt;I would argue that the spaces are exactly the same: the only difference between a &quot;&lt;em&gt;pair of qubits&lt;/em&gt;&quot; and a single &quot;&lt;em&gt;four-dimensional qudit&lt;/em&gt;&quot; is that when you say you have &quot;&lt;em&gt;two qubits&lt;/em&gt;&quot; you are implicitly making some assumptions on the kind of operations you can perform on it.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In particular, it only makes sense to talk of two qubits if they can be treated as two different systems, or, in other words, if it possible to act locally on them. Similarly, the kinds of operations that one can assume to be able to perform on two qubits are different than those on qudits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;From a practical point of view, the difference is that one tends to consider different operations as &quot;easily available&quot; when talking of sets of qubits rather than (sets of) qudits.&lt;/p&gt;&#xA;" OwnerUserId="55" LastActivityDate="2018-04-23T08:44:37.240" CommentCount="0" />
  <row Id="1885" PostTypeId="1" AcceptedAnswerId="1888" CreationDate="2018-04-23T10:17:42.513" Score="11" ViewCount="618" Body="&lt;p&gt;Preskill introduced recently this term, see for example &lt;a href=&quot;https://arxiv.org/abs/1801.00862&quot; rel=&quot;noreferrer&quot;&gt;Quantum Computing in the NISQ era and beyond (arXiv)&lt;/a&gt;. I think the term (and the concept behind it) is of sufficient importance that it deserves to be explained here in a pedagogical manner. Probably it actually merits more than one question, but the first one needs to be:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;What are Noisy Intermediate-Scale Quantum (NISQ) technologies?&lt;/strong&gt;&lt;/p&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="26" LastEditDate="2018-05-03T13:19:05.723" LastActivityDate="2018-05-03T13:19:05.723" Title="What is meant by &quot;Noisy Intermediate-Scale Quantum&quot; (NISQ) technology?" Tags="&lt;quantum-computer&gt;&lt;terminology&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="2" />
  <row Id="1886" PostTypeId="2" ParentId="1870" CreationDate="2018-04-23T11:20:20.010" Score="2" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;What does it even mean to perform a measurement in a certain basis?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;It is very close to a measurement of a certain observable. In quantum mechanics, when we talk about measuring an observable, we usually are primarily interested in an eigenvalue as an outcome of the measurement. In quantum information, we don't care about the eigenvalues; we are solely interested in a state after the measurement, and this state can be interpreted as an eigenvector of an observable being measured.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Mathematically, for any &quot;measurement in a certain basis&quot; there exists many observables that correspond to the same measurement (not all of them have physical meaning); all these observables have the same eigenvectors (which form the measurement basis) but may differ in eigenvalues. Eigenvalues don't matter provided they are different, so the measurement distinguishes between the eigenvectors (measurement basis states).&lt;/p&gt;&#xA;" OwnerUserId="2105" LastActivityDate="2018-04-23T11:20:20.010" CommentCount="0" />
  <row Id="1887" PostTypeId="1" AcceptedAnswerId="1936" CreationDate="2018-04-23T13:05:09.393" Score="5" ViewCount="94" Body="&lt;p&gt;My question is a continuation from the previous question:&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1648/is-quantum-biocomputing-ahead-of-us&quot;&gt;Is Quantum Biocomputing ahead of us?&lt;/a&gt;. Considering that there exist many biological processes with a quantum nature present (Photosynthesis, Electron transport chain, etc). And, since this biological quantum processes are quite optimal in terms of efficiency and yield:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am wondering if these could be mimicked by engineers/scientists to improve the actual possibilities in quantum computation. Let me explain a bit deeper my question: Nature is extremely efficient. Especially intracellular processes are well optimized in both time and space this, with their high yield, can be studied in order to check the properties/structural features that contribute to such efficiency. Please note that I am not suggesting or asking about the possibility of using directly biological molecules or processes but to try to extract what makes them ultra-efficient and used such knowledge in the design of particular architectures.&#xA;My question is related to this, is that an actual field of research? are we now dealing with the 'natural quantum processes imitation'?&lt;/p&gt;&#xA;" OwnerUserId="1955" LastEditorUserId="141" LastEditDate="2018-08-07T03:45:00.117" LastActivityDate="2018-08-07T03:45:00.117" Title="Can biological quantum processes be used to guide optimized quantum algorithms?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-computer&gt;&lt;biocomputing&gt;&lt;quantum-biology&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="1888" PostTypeId="2" ParentId="1885" CreationDate="2018-04-23T13:05:18.190" Score="5" Body="&lt;p&gt;When we talk about quantum computers, we usually mean fault-tolerant devices. These will be able to run Shor's algorithm for factoring, as well as all the other algorithms that have been developed over the years. But the power comes at a cost: to solve a factoring problem that is not feasible for a classical computer, we will require &lt;a href=&quot;https://arxiv.org/abs/1605.07197&quot; rel=&quot;noreferrer&quot;&gt;millions of qubits&lt;/a&gt;. This overhead is required for error correction, since most algorithms we know are extremely sensitive to noise.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Even so, programs run on devices beyond 50 qubits in size quickly become extremely difficult to simulate on classical computers. This opens the possibility that devices of this sort of size might be used to perform the first demonstration of a quantum computer doing something that is infeasible for a classical one. It will likely be a highly abstract task, and not useful for any practical purpose, but it will nevertheless be a proof-of-principle.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Once this is done, we'll be in a strange era. We'll know that devices can do things that classical computers can't, but they won't be big enough to provide fault-tolerant implementations of the algorithms know about. Preskill coined the term '&lt;a href=&quot;https://arxiv.org/abs/1801.00862&quot; rel=&quot;noreferrer&quot;&gt;Noisy Intermediate-Scale Quantum&lt;/a&gt;' to describe this era. Noisy because we don't have enough qubits to spare for error correction, and so we'll need to directly use the imperfect qubits at the physical layer. And 'Intermediate-Scale' because of their small (but not too small) qubit number.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So what applications might devices in NISQ era have? And how will we design the quantum software to implement them? These are questions that are far from being fully answered, and will likely require quite different techniques than fault-tolerant quantum computing.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-04-23T13:05:18.190" CommentCount="0" />
  <row Id="1889" PostTypeId="1" CreationDate="2018-04-23T14:22:21.420" Score="6" ViewCount="186" Body="&lt;p&gt;The representation of bits in different technological areas: &lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Normal digital bits are mere abstractions of the underlying electric current through wires. Different standards, like CMOS or TTL, assign different thresholds to such signals: &quot;if the voltage goes above this level, then the bit is 1; if it goes below this level, then the bit is 0; discard in any other case&quot;.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;In genetics, we usually consider a signal as a 1 if it is &quot;enough&quot; to trigger the target response; 0 otherwise. In this scenario, the thresholding is qualitative. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;From the point of view of quantum information, qubits also abstractions, but in practice measurements will need standards to be comparable.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Question: From the point of view of quantum engineering, is there any standard technique/method to identify their value e.g. based on &lt;strong&gt;&lt;a href=&quot;https://www.nature.com/articles/lsa2016144&quot; rel=&quot;nofollow noreferrer&quot;&gt;detection thresholds&lt;/a&gt;&lt;/strong&gt; or fidelity verification like &lt;a href=&quot;https://www.nature.com/articles/35057215&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bell inequalities violation&lt;/a&gt;? Are there units for that hidden signals?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;The best possible answer would probably contain specific details for different architectures (e.g. superconductors vs photons) or contexts (e.g. quantum computing vs quantum communications).&lt;/em&gt;&lt;/p&gt;&#xA;" OwnerUserId="1894" LastEditorUserId="1847" LastEditDate="2018-04-27T16:51:03.783" LastActivityDate="2018-07-13T15:34:33.587" Title="Are there measuring standards (and units) for the identification of qubits?" Tags="&lt;qubit&gt;&lt;qubit-state&gt;&lt;technical-standards&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="2" />
  <row Id="1890" PostTypeId="1" AcceptedAnswerId="1891" CreationDate="2018-04-23T14:33:21.520" Score="9" ViewCount="1077" Body="&lt;p&gt;In general, a qubit is mathematically represented as a quantum state of the form $\lvert \psi\rangle = \alpha \lvert 0\rangle + \beta \lvert 1\rangle$, using the  basis $\{ \lvert 0\rangle,  \lvert 1\rangle \}$. It seems to me that a qubit is just a term used in quantum computing and information to denote a quantum state (i.e. a vector) of a system. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is there any fundamental difference between a qubit and a quantum state? What's more to a qubit than the quantum state it represents?&lt;/p&gt;&#xA;" OwnerUserId="72" LastEditorUserId="1847" LastEditDate="2018-04-24T07:34:22.280" LastActivityDate="2018-04-24T07:34:22.280" Title="What is the difference between a qubit and a quantum state?" Tags="&lt;qubit&gt;&lt;terminology&gt;&lt;quantum-state&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="1891" PostTypeId="2" ParentId="1890" CreationDate="2018-04-23T15:07:36.033" Score="11" Body="&lt;p&gt;There are a few things to distinguish here, which are often conflated by experts because we're using these terms quickly and informally to convey intuitions rather than in the way that would be most transparent to novices.&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;A &quot;qubit&quot; can refer to a small system, which &lt;em&gt;has&lt;/em&gt; a quantum mechanical state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The states of a quantum mechanical system form a vector space. Most&#xA;of these states can only be distinguished from each other only&#xA;imperfectly, in that there is a chance of mistaking one state for the&#xA;other, no matter how cleverly you try to distinguish them. One may then ask the question, of a set of states, whether they are all perfectly distinguishable from one another.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A &quot;qubit&quot; is an example of a quantum mechanical system, for which the largest number of perfectly distinguishable states is two. (There are many different sets of perfectly distinguishable states; but each such set contains only two elements.) These may be&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;the polarisation of a photon ($\lvert \mathrm H \rangle$ versus $\lvert \mathrm V \rangle$, or $\lvert \circlearrowleft \rangle$ versus $\lvert \circlearrowright \rangle$);&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;or the spin of an electron ($\lvert \uparrow \rangle$ versus $\lvert&#xA;   \downarrow \rangle$, or $\lvert \rightarrow \rangle$ versus $\lvert&#xA;   \leftarrow \rangle$);&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;or two energy levels $\lvert E_1 \rangle$ and $\lvert E_2 \rangle$ of an electron in an ion, which may occupy many different energy levels but which is being controlled in such a way that the electron stays within the subspace defined by these energy levels when it isn't being acted on.&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Common to these systems is that one can describe their states in terms of two states, which we might label as $\lvert 0 \rangle$ and $\lvert 1 \rangle$, and consider the other states of the system (which are vectors in the vector space spanned by $\lvert 0 \rangle$ and $\lvert 1 \rangle$) using linear combinations taking the form $\alpha \lvert 0 \rangle + \beta \lvert 1 \rangle$, where $\lvert \alpha \rvert^2 + \lvert \beta \rvert^2 = 1$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;A &quot;qubit&quot; can also refer to the quantum mechanical state &lt;em&gt;of&lt;/em&gt; a physical system of the sort we've described above. That is, we may call  some state of the form $\alpha \lvert 0 \rangle + \beta \lvert 1 \rangle$ &quot;a qubit&quot;. In this case we are not considering what physical system is storing that state; we are interested only in the form of the state.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&quot;A qubit&quot; can also refer to &lt;em&gt;an amount of information&lt;/em&gt; which is equivalent to a state such as $\alpha \lvert 0 \rangle + \beta \lvert 1 \rangle$. For instance, if we know two states $\lvert \psi_0 \rangle$ and $\lvert \psi_1 \rangle$ of some complicated quantum system, and we have some physical system whose state $\lvert \Psi \rangle$ is in some superposition $\alpha \lvert \psi_0 \rangle + \beta \lvert \psi_1 \rangle$, then it doesn't matter how complicated the system is or whether either of the states $\lvert \psi_j \rangle$ have any entanglement: the amount of information expressed by the possible values of $\lvert \Psi \rangle$ is one qubit, because with a clever enough noiseless procedure, you could reversibly encode that complicated quantum state into the state of a (physical system) qubit. Similarly, you can have a very large quantum system which encodes $n$ qubits of information, if you could reversibly encode the state of that complicated system as the state of $n$ qubits.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;This may seem confusing, but it's no different from what we do all the time with classical computation.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;If in a C-like language I write &lt;code&gt;int x = 5;&lt;/code&gt; you probably understand that &lt;code&gt;x&lt;/code&gt; is an integer (an integer &lt;em&gt;variable&lt;/em&gt; that is), which stores an integer &lt;code&gt;5&lt;/code&gt; (an integer &lt;em&gt;value&lt;/em&gt;).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;If I then write &lt;code&gt;x = 7;&lt;/code&gt; I don't mean that &lt;code&gt;x&lt;/code&gt; is an integer which is equal to both &lt;code&gt;5&lt;/code&gt; and &lt;code&gt;7&lt;/code&gt;, but rather that &lt;code&gt;x&lt;/code&gt; is a container of sorts and that what we are doing is changing what it contains.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;And so forth &amp;mdash; these ways in which we use the term 'qubit' are just the same as how we use the term 'bit', only it so happens that we use the term for quantum states instead of for values, and for small physical systems rather than variables or registers. (Or rather: the quantum states &lt;em&gt;are&lt;/em&gt; the values in quantum computation, and the small physical systems &lt;em&gt;are&lt;/em&gt; the variables / registers.)&lt;/p&gt;&#xA;" OwnerUserId="124" LastActivityDate="2018-04-23T15:07:36.033" CommentCount="5" />
  <row Id="1892" PostTypeId="2" ParentId="1860" CreationDate="2018-04-23T18:02:30.083" Score="2" Body="&lt;p&gt;There is also a difference if you consider experiments or implementations. To make a physical qubit, I need to use a two-level quantum system. Qudits than require a more complicated quantum system, e.g., with four levels for a d=4 qudit. The engineering justification for using the more complicated system would be that you than require fewer of the four-level systems.&lt;/p&gt;&#xA;" OwnerUserId="2139" LastActivityDate="2018-04-23T18:02:30.083" CommentCount="0" />
  <row Id="1894" PostTypeId="1" AcceptedAnswerId="1897" CreationDate="2018-04-23T20:07:53.377" Score="4" ViewCount="116" Body="&lt;p&gt;Let me start the question with two examples.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;First, I am reading Nielsen &amp;amp; Chuang section &quot;8.3.3 Bit flip and phase flip channels&quot;. There is a description of a quantum operation&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;$\rho \to \mathcal{E}(\rho) = P_0 \rho P_0 + P_1 \rho P_1$, where $P_0 = |0 \rangle \langle 0|$, $P_1 = |1 \rangle \langle 1|$, which corresponds to a measurement of the qubit in the $|0 \rangle$, $|1 \rangle$ basis, with &lt;em&gt;the result of the measurement unknown.&lt;/em&gt; [Italics is mine - A.P.]&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Second, in the edX course &quot;&lt;a href=&quot;https://www.edx.org/course/quantum-information-science-i-part-3&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Information Science I, Part 3&lt;/a&gt;&quot; there is a question that looks like this:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;After quantum measurement &amp;lt;...&gt;, &lt;em&gt;if the measurement result is known,&lt;/em&gt; &amp;lt;...&gt;. [Italics is mine - A.P.]&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;So, I do not understand what does that mean for a result of a measurement to be known/unknown? Moreover, how could that knowledge or an absense of knowledge further affect the quantum system once the measurement is performed? Would anything change in the examples if we replace &quot;known&quot; with &quot;unknown&quot; and vice versa? Is there a mathematical formalism for the &quot;is known/unknown&quot; expression?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I believe, the source of my confusion comes from the Schrödinger's cat paradox solution. My understanding is that the cat is strictly alive or dead once the &quot;measurement&quot; by a detector happens, regardless of whether we know the fact (i.e., result of the &quot;measurement&quot;) or not. That is a knowledge of an experimenter, and it has no relation to the &quot;measurement&quot;.&lt;/p&gt;&#xA;" OwnerUserId="528" LastEditorUserId="2175" LastEditDate="2018-04-24T07:44:32.007" LastActivityDate="2018-04-24T07:44:32.007" Title="What does it mean for a result of a measurement to be known/unknown?" Tags="&lt;terminology&gt;&lt;measurement&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="1895" PostTypeId="1" AcceptedAnswerId="1902" CreationDate="2018-04-23T20:55:01.630" Score="6" ViewCount="233" Body="&lt;p&gt;Suppose we have two states of a system where I tell you that there is a probability $p_1$ of being in state $1$, and probability $p_2$ of being in state $2$. The total state can be written as a vector in $L^1$ normed space:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$p=\begin{pmatrix}p_1 \\ p_2 \end{pmatrix}, ||p||=p_1+p_2=1$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we define a transition matrix for a Markov process:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$T=\begin{pmatrix}t_{11}&amp;amp;t_{12} \\ t_{21}&amp;amp;t_{22}\end{pmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then the next state would be:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$p'=Tp=\begin{pmatrix}t_{11}p_1+t_{12}p_2 \\ t_{21}p_1+t_{22}p_2\end{pmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now my understanding of density matrices and quantum mechanics is that it should contain classical probability theory in addition to strictly quantum phenomena.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Classical probabilities in the density matrix formalism are mapped as:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$p=\begin{pmatrix}p_1 \\ p_2 \end{pmatrix} \rightarrow \rho=\begin{pmatrix}p_1&amp;amp;0 \\ 0&amp;amp;p_2 \end{pmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And I want to obtain:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$p'=\begin{pmatrix}t_{11}p_1+t_{12}p_2 \\ t_{21}p_1+t_{22}p_2\end{pmatrix} \rightarrow \rho'=\begin{pmatrix}t_{11}p_1+t_{12}p_2&amp;amp;0 \\ 0&amp;amp;t_{21}p_1+t_{22}p_2\end{pmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;My attempt:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Define an operator $U$ such that:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\rho'=U\rho U^\dagger$$&#xA;$$\implies \begin{pmatrix}t_{11}p_1+t_{12}p_2&amp;amp;0 \\ 0&amp;amp;t_{21}p_1+t_{22}p_2\end{pmatrix}=\begin{pmatrix}u_{11}&amp;amp;u_{12} \\ u_{21}&amp;amp;u_{22}\end{pmatrix}\begin{pmatrix}p_1&amp;amp;0 \\ 0&amp;amp;p_2\end{pmatrix}\begin{pmatrix}u_{11}^*&amp;amp;u_{21}^* \\ u_{12}^*&amp;amp;u_{22}^*\end{pmatrix}$$ &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$=\begin{pmatrix}|u_{11}|^2p_1+|u_{12}|^2p_2&amp;amp;u_{11}u_{21}^*p_1+u_{12}u_{22}^*p_2 \\ &#xA;u_{21}u_{11}^*p_1+u_{12}^*u_{22}p_2 &amp;amp; |u_{21}|^2p_1+|u_{22}|^2p_2  \end{pmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Evidently, $|u_{ij}|^2=t_{ij}$, but the off diagonal terms aren't easily made zero, (I've wrestled with the algebra and applied all the proper normalizations of probability theory).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What would be the correct way to apply a Markov process in the density matrix formalism? It seems really basic and something that this formalism should be able to naturally handle. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Edit: Repost of : &lt;a href=&quot;https://physics.stackexchange.com/questions/401665/markov-chain-expressed-in-density-matrix-formalism?noredirect=1#comment900292_401665&quot;&gt;repost&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="2160" LastActivityDate="2018-04-24T14:30:55.063" Title="Markov Chain expressed in Density Matrix formalism" Tags="&lt;qubit&gt;&lt;quantum-entanglement&gt;" AnswerCount="3" CommentCount="5" FavoriteCount="1" />
  <row Id="1896" PostTypeId="2" ParentId="1895" CreationDate="2018-04-23T22:09:30.097" Score="4" Body="&lt;p&gt;The most general quantum evolution is a completely positive (CP) map:&#xA;$$&#xA;\rho\mapsto \mathcal E(\rho) = \sum_i M_i\rho M_i^\dagger \ .&#xA;$$&#xA;Here, &#xA;$$&#xA;M_1=\left(\begin{matrix}\sqrt{t_{11}}&amp;amp;0\\0&amp;amp;0\end{matrix}\right)\,, \&#xA;M_2=\left(\begin{matrix}0&amp;amp;0\\\sqrt{t_{21}}&amp;amp;0\end{matrix}\right)\quad&#xA;$$&#xA;$$&#xA;M_3=\left(\begin{matrix}0&amp;amp;\sqrt{t_{12}}\\0&amp;amp;0&#xA;\end{matrix}\right)\,,\ &#xA;M_4=\left(\begin{matrix}0&amp;amp;0\\0&amp;amp;\sqrt{t_{22}}&#xA;\end{matrix}\right)\ .&#xA;$$&lt;/p&gt;&#xA;" OwnerUserId="491" LastEditorUserId="491" LastEditDate="2018-04-24T11:48:27.167" LastActivityDate="2018-04-24T11:48:27.167" CommentCount="4" />
  <row Id="1897" PostTypeId="2" ParentId="1894" CreationDate="2018-04-24T01:33:13.593" Score="4" Body="&lt;p&gt;Forget about quantum mechanics for a second and consider two people predicting a coin flip. Alice flips a coin, covers it with her hand, and asks Bob to predict the result. Alice knows the coin is heads, but Bob is unsure if it is heads or tails. They will describe the state of the coin using different probability distributions.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The same situation can apply to quantum systems. Alice may know the state of the system, while Bob is unsure. When this happens, they each will describe the situation using a different &lt;a href=&quot;https://en.wikipedia.org/wiki/Density_matrix&quot; rel=&quot;nofollow noreferrer&quot;&gt;density matrix&lt;/a&gt;: &lt;em&gt;the matrix formalism that is used to describe a quantum system in a mixed state, meaning a statistical ensemble of several quantum states&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(On the other hand, if they describe the same system using different &lt;em&gt;superpositions&lt;/em&gt;, that's bad. At least one of them is objectively wrong. Similarly, if Alice says a die roll was definitely 100% five, and Bob says the die roll was definitely 100% six, at least one of them is dead wrong.)&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;em&gt;how could that knowledge or an absense of knowledge further affect the quantum system once the measurement is performed?&lt;/em&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;It doesn't affect the system, it determines your ability to accurately describe the system.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, suppose I have a qubit in the state $\frac{3}{5} |0\rangle + \frac{4}{5}|1\rangle$. I measure the state. I tell you all this, but don't tell you what the measurement outcome was.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you're asked to predict the state of the system, the best you can do is bet 36% odds on $|0\rangle$ and 64% odds on $|1\rangle$. And a succinct way to describe your knowledge about the system is the density matrix $0.36 |0\rangle \langle 0| + 0.64 |1\rangle \langle 1| = \begin{bmatrix} 0.36 &amp;amp; 0 \\ 0 &amp;amp; 0.64\end{bmatrix}$. By contrast, I know the measurement result. It happens to have been $|1\rangle$. So the density matrix describing &lt;em&gt;my&lt;/em&gt; knowledge is $|1\rangle \langle 1| = \begin{bmatrix} 0 &amp;amp; 0 \\ 0 &amp;amp; 1\end{bmatrix}$.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;em&gt;Would anything change in the examples if we replace &quot;known&quot; with &quot;unknown&quot; and vice versa?&lt;/em&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;If you perform the same operations to multiple systems in the state $|\psi\rangle$, their outputs will be identically distributed regardless of which ones you knew started in the state $|\psi\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, your ability to do useful tasks with a quantum system often depends on knowing what state that system is in. In that sense it does matter if you know the state or not. For example, it's pretty hard to do magic state distillation if you keep forgetting whether or not you already did the distillation.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;em&gt;Is there a mathematical formalism for the &quot;is known/unknown&quot; expression?&lt;/em&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Yes. Density matrices.&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-04-24T04:04:20.187" LastActivityDate="2018-04-24T04:04:20.187" CommentCount="0" />
  <row Id="1898" PostTypeId="2" ParentId="1894" CreationDate="2018-04-24T04:39:15.040" Score="2" Body="&lt;p&gt;Suppose you have a qubit in a state $|\psi\rangle=\alpha|0\rangle+\beta|1\rangle$. For simplicity let us assume $\alpha$ and $\beta$ are real.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Alternatively, the state can be described by density matrix&#xA;$$\rho=|\psi\rangle\langle\psi|=\begin{pmatrix}&#xA;\alpha^2 &amp;amp; \alpha\beta \\&#xA;\alpha\beta &amp;amp; \beta^2&#xA;\end{pmatrix}&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we measure the qubit in the standard basis but don't look an the measurement outcome, the qubit's state after measurement is&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\rho_{out}=\begin{pmatrix}&#xA;\alpha^2 &amp;amp; 0 \\&#xA;0 &amp;amp; \beta^2&#xA;\end{pmatrix}&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(measurement killed off-diagonal terms, and now it is a mixed state)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we looked at the outcome of the measurement and found that the outcome is $|0\rangle$ state, then the qubit's state after measurement is&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\rho_{out,0}=\begin{pmatrix}&#xA;1 &amp;amp; 0 \\&#xA;0 &amp;amp; 0&#xA;\end{pmatrix}&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The relation between $\rho_{out}$ and $\rho_{out,i}$ is the same as relation between unconditional and conditional probabilities studied in probability theory,&#xA;$$\rho_{out}=\alpha^2 \rho_{out,0}+\beta^2 \rho_{out,1}&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;as explained in Craig's answer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Concerning the cat - yes, the cat is strictly dead or alive after the box is opened (cat is measured), but we don't know it before we looked into the box. This is purely classical situation, well known in probability theory.&lt;/p&gt;&#xA;" OwnerUserId="2105" LastEditorUserId="2105" LastEditDate="2018-04-24T07:30:00.773" LastActivityDate="2018-04-24T07:30:00.773" CommentCount="1" />
  <row Id="1899" PostTypeId="1" CreationDate="2018-04-24T05:47:24.780" Score="8" ViewCount="107" Body="&lt;p&gt;Predicting the energy of molecules to high accuracy during the course of a chemical reaction, which in turn allows us to predict reaction rates, equilibrium geometries, transition states among others is a Quantum Chemical problem. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quantum Computing could help Quantum Chemistry by solving the Schrodinger equation for large systems. An example of a problem that is intractable but has applications to Quantum Chemistry is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Hartree%E2%80%93Fock_method&quot; rel=&quot;noreferrer&quot;&gt;Hartree-Fock method&lt;/a&gt;, a  method to approximate the wave function and energy of a quantum many-body system (in stationary state). This problem is known to be &lt;a href=&quot;https://en.wikipedia.org/wiki/NP-completeness&quot; rel=&quot;noreferrer&quot;&gt;NP-complete&lt;/a&gt; (see &lt;a href=&quot;https://aip.scitation.org/doi/abs/10.1063/1.4903453&quot; rel=&quot;noreferrer&quot;&gt;On the NP-completeness of the Hartree-Fock method for translationally invariant systems&lt;/a&gt;). Other examples of Quantum Computation to Quantum chemistry are 2-local-Hamiltonians (QMA-complete), Fermionic Local Hamiltonian (QMA-hard). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quantum Computing could give yes/no answers to questions to specific problems such as showing certain molecules have dipole moment. Also, NMR, Trapped Ions, and Superconducting qubits could be used to to simulate such chemical systems too. Noise being, a factor approaches such as &lt;a href=&quot;https://arxiv.org/abs/1801.00862&quot; rel=&quot;noreferrer&quot;&gt; NISQ &lt;/a&gt; could play a part in simulating quantum chemical systems. What Quantum Computing approaches have been successful to solving Quantum chemistry problems such as predicting reaction rates, transition rates (or even show promise)? &lt;/p&gt;&#xA;" OwnerUserId="429" LastEditorUserId="429" LastEditDate="2018-04-24T22:11:09.190" LastActivityDate="2018-05-02T05:53:49.913" Title="Quantum Chemistry and Quantum Computing" Tags="&lt;quantum-algorithms&gt;&lt;qma&gt;&lt;quantum-chemistry&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="2" />
  <row Id="1900" PostTypeId="2" ParentId="1881" CreationDate="2018-04-24T06:29:23.793" Score="1" Body="&lt;p&gt;In order to represent a '$\mathbf 0$' state as a vector in a Hilbert space, the '$\mathbf 0$' vector must in fact be non-zero. Thus, the label '$\mathbf 0$' is &lt;em&gt;just a label&lt;/em&gt; for some designated vector (of norm 1) in our computational basis. This is obviously an abuse of notation, but it is a fairly common one. The more usual (and less confusing) notation would be $\left|0\right&amp;gt;$. This notation is even used on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Qubit&quot; rel=&quot;nofollow noreferrer&quot;&gt;wiki page about qubits&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Building this up from the ground: we have $n$ 2-dimensional vector spaces $V_i$, and we designate basis elements $\left| 0_i \right&amp;gt;$ and $\left| 1_i \right&amp;gt;$ in these vector spaces. Both these elements have norm 1. We then form the $2^n$ dimensional vector space $V = \bigotimes_{i=1}^n V_i$. We can designate a computational basis $\left| b_1 b_2 \ldots b_n \right&amp;gt;$ with $b_1,\ldots,b_n \in \{0,1\}$ for $V$. Within $V$ there are two vectors of interest: $\mathbf 0 = \left|00\ldots0\right&amp;gt;$ and $\mathbf s = \left| s_1 s_2 \ldots s_n \right&amp;gt;$, with $s_1, \ldots, s_n$ the bits of $s$. The vector space $S = \mathbf{\text{span}} \{\mathbf 0, \mathbf s\} \subset V$ is trivially 2-dimensional.&lt;/p&gt;&#xA;" OwnerUserId="2182" LastEditorUserId="2182" LastEditDate="2018-04-24T06:35:55.513" LastActivityDate="2018-04-24T06:35:55.513" CommentCount="0" />
  <row Id="1901" PostTypeId="2" ParentId="1895" CreationDate="2018-04-24T07:58:48.970" Score="1" Body="&lt;p&gt;As mentioned by Norbert Schuch, the most general quantum operation (i.e. preserving quantum mechanical interpretation) is completely positive and trace-preserving map (CPTP). You can find more on this subject in the field of open quantum systems (these maps carry information on the interaction with the environment) - see the book: H-P. Breuer, F. Petruccione &quot;&lt;a href=&quot;http://isfr-quantum.ir/KhabarFile/Breuer.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;The theory of Open quantum systems&lt;/a&gt;&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One reason why it's not easy (only in special cases) to express your stochastic process as unitary transformation is that the transition matrix needs not be invertible (and if it is, it is not necessarily stochastic matrix), while unitaries are always invertible and describe the legitimate quantum transformation. &lt;/p&gt;&#xA;" OwnerUserId="563" LastEditorUserId="1847" LastEditDate="2018-04-24T10:40:39.657" LastActivityDate="2018-04-24T10:40:39.657" CommentCount="2" />
  <row Id="1902" PostTypeId="2" ParentId="1895" CreationDate="2018-04-24T08:29:59.207" Score="4" Body="&lt;p&gt;The easiest way to get rid of off diagonal elements is to measure. You could then apply some post-measurement unitaries which depend on the result, as well as some classical randomness. Clearly you need more than just a unitary to apply such a process. Instead you'll need a more general CP map, as mentioned by the other answers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am going to assume that $t_{11}+t_{12}=t_{21}+t_{22}=1$ in what follows, so that the Markov process is also trace preserving.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's say you measure in the $\{|1\rangle, |2\rangle\}$ basis, but don't look at the result. The state is then described by&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;P_1 \, \rho \, P_1 + P_2 \, \rho \, P_2.&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now let's consider a different process. Suppose you applied a random process that flipped the states with probability $t_{xy}$, and did nothing with probability $t_{xx}$. The state is then&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;t_{xx} \, \rho  + t_{xy} \, X  \,\rho \, X&#xA;$$&#xA;where here I use $X$ to denote the unitary that performs the flip.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What you want is the process that combines the two. First measure, and then apply the random flip with probabilities that depend on the results. The map you need is then&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;t_{11} \, P_1 \rho P_1 + t_{12} \, X  P_1 \, \rho P_1 \, X \,+ t_{22} \, P_2 \rho P_2  + t_{21} \, X  \, P_2 \rho P_2 \, X \, .&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This can be expressed as as the CPTP map&#xA;$$&#xA;\rho\mapsto \mathcal E(\rho) = \sum_i M_i\rho M_i^\dagger \ .&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;with $M_{11} = \sqrt{t_{11}} P_1$, $M_{12} = \sqrt{t_{12}} X P_1$, $M_{22} = \sqrt{t_{22}} P_2$ and $M_{21} = \sqrt{t_{21}} X P_2$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that this expression is not unique. The interpretation of how to do it is not unique either. Measurements are not necessarily required, but it can never be as simple as just a unitary.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To see why, note that your Markov process changes the value of $\rm{tr}(\rho^2)$. This cannot be done by a single qubit unitary, because&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ (U \rho U^{\dagger})^2 = U \rho U^{\dagger} U \rho U^{\dagger} = U \rho^2 U^{\dagger},$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;and the trace is unitary invariant. A process that changes this value requires either measurement, or interaction with an external system.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-04-24T14:30:55.063" LastActivityDate="2018-04-24T14:30:55.063" CommentCount="4" />
  <row Id="1903" PostTypeId="2" ParentId="1860" CreationDate="2018-04-24T09:15:59.253" Score="2" Body="&lt;p&gt;A fundamental difference between the two kinds of systems is that a two-qubit system can actually be in an entangled state. On the other hand, a single d=4 dimensional system does not possess entanglement, since entanglement is always defined with respect to more than one party. Consequently, for the purposes of quantum protocols that exploit entanglement as a resource, a two-qubit system and a single 4-dimensional quantum system are very different. &lt;/p&gt;&#xA;" OwnerUserId="2186" LastEditorUserId="2186" LastEditDate="2018-04-25T12:33:00.680" LastActivityDate="2018-04-25T12:33:00.680" CommentCount="2" />
  <row Id="1904" PostTypeId="2" ParentId="1889" CreationDate="2018-04-24T10:20:46.423" Score="2" Body="&lt;p&gt;It seems to me that, from the point of view of quantum engineering, we are a few years away from being at the point of fixing standards.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Standards are a good way to ensure the reproducibility of the behaviour of a piece of information technology, and the interoperability of the functionality of multiple pieces of information technology. It is clear that at some point we will require such standards. The question is: how would one begin to formulate those standards?&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Before we ensure the reproducibility of a piece of quantum technology, we should build a piece of quantum technology whose behaviour &lt;em&gt;we want&lt;/em&gt; to reproduce, rather than immediately set out to improve upon. With perhaps one exception, I expect that almost everyone in the quantum technologies game are more interested in bettering their own designs &amp;mdash; possibly involving significant revisions to any design parameters which could play the role of standards &amp;mdash; rather than setting down parameters which they expect that everyone will be happy to use.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Conceivably D-WAVE is at this stage &amp;mdash; obviously they would also like&#xA;to improve upon their existing technology (as for instance do&#xA;conventional chip manufacturers), but my understanding is that they are in the business of making $\,N&amp;gt;1\,$ computers of a given model whose behaviour is intended to achieve a certain, well, 'standard'. Whatever the computational power of their machines, it seems that they are in the business of engineering complex systems with multiple components, and doing so in a reproducible manner. So it seems very likely that they have standards for their qubits: but it is not clear that anyone apart from them will be interested in conforming to those standards (rather than building more versatile quantum computers for instance), or to what extent D-WAVE's standards are publicly available.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Another incipient exception is in the field of optics, where the inclination is very strong to use the existing materials technology of fibre optic cables: while there is no formal standard likely exists, a practical standard of using wavelengths of light which have very low attenuation in modern-day optical fibre is one that could be comfortably predicted to continue for the foreseeable future.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Given this situation for individual approaches to quantum technologies, the question of interoperation is even more premature. No-one knows what their equipment is going to be interoperating &lt;em&gt;with&lt;/em&gt; &amp;mdash; again, with the probable exception of fibre-optic cable, and perhaps the mains frequency of your electrical grid if this is somehow important to take into account.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;But ask the question again in five or ten years (more likely ten), and you may get a more interesting answer.&lt;/p&gt;&#xA;" OwnerUserId="124" LastActivityDate="2018-04-24T10:20:46.423" CommentCount="0" />
  <row Id="1905" PostTypeId="1" AcceptedAnswerId="1906" CreationDate="2018-04-24T11:54:45.100" Score="8" ViewCount="69" Body="&lt;p&gt;I have heard about Quantum chemistry as one of the main applications of quantum computers. However, I have not found concrete related articles with circuit-implementations for these applications. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Does anyone have articles on simulating molecules (such as for instance hydrogen or helium) with a circuit implementation to run it? &lt;/p&gt;&#xA;" OwnerUserId="2005" LastEditorUserId="2293" LastEditDate="2018-05-02T09:10:10.730" LastActivityDate="2018-05-02T09:10:10.730" Title="Quantum chemistry: references" Tags="&lt;resource-request&gt;&lt;quantum-chemistry&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="2" />
  <row Id="1906" PostTypeId="2" ParentId="1905" CreationDate="2018-04-24T12:30:51.750" Score="5" Body="&lt;p&gt;Have you read &lt;a href=&quot;https://www.nature.com/articles/nchem.483&quot; rel=&quot;noreferrer&quot;&gt;Towards quantum chemistry on a quantum computer&lt;/a&gt; (Nature Chemistry 2010, or here in the &lt;a href=&quot;https://arxiv.org/pdf/0905.0887&quot; rel=&quot;noreferrer&quot;&gt;arXiv version&lt;/a&gt;)? They present &quot;&lt;em&gt;a photonic implementation for the smallest problem: obtaining the energies of H$_2$ (the hydrogen molecule) in a minimal basis&lt;/em&gt;&quot;. In the figure S1 of the Supporting information there is an equivalence of the operations they implement in circuit notation. &lt;/p&gt;&#xA;" OwnerUserId="1847" LastActivityDate="2018-04-24T12:30:51.750" CommentCount="0" />
  <row Id="1907" PostTypeId="2" ParentId="1899" CreationDate="2018-04-24T12:43:10.953" Score="1" Body="&lt;p&gt;You may be referring to works like &lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.107.020501&quot; rel=&quot;nofollow noreferrer&quot;&gt;Simulation of Chemical Isomerization Reaction Dynamics on a NMR Quantum Simulator&lt;/a&gt; (&lt;a href=&quot;https://arxiv.org/pdf/1105.4228&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv version&lt;/a&gt;). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, I'd say that in general the prediction of reaction rates or transition rates will be much more difficult compared with this 3-qubit job. Note a large amount of chemistry happens either in solution or in the solid state. Only few-particle phenomena (maybe reactions among simple molecules in atmospherical chemistry or astrochemistry), which are also the cheapest to calculate also with conventional means, can be simulated with few qubits. As soon as one aspires to embed the reaction in an environment, the complexity of a realistic simulation explodes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I agree that if we are able to find particular cases of Noisy Intermediate-Scale Quantum systems in which, by chance of by design, the noise is a reasonable approximation to the real (thermal?) effect of the environment in the chemical reaction under study could indeed give us at least exciting results, maybe even useful.&lt;/p&gt;&#xA;" OwnerUserId="1847" LastActivityDate="2018-04-24T12:43:10.953" CommentCount="0" />
  <row Id="1908" PostTypeId="2" ParentId="1542" CreationDate="2018-04-24T16:00:53.090" Score="1" Body="&lt;p&gt;For a certain class of codes called &lt;em&gt;pure&lt;/em&gt;, the &lt;strong&gt;presence of entanglement is a necessary and sufficient requirement&lt;/strong&gt; for quantum error correction, i.e. to correct all errors affecting up to a certain number of subsystems.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Recall the Knill-Laflamme conditions for a quantum error correcting code  to be able to &lt;em&gt;detect&lt;/em&gt; a certain set of errors $\{E_\alpha\}$: pick any orthonormal basis $|i_\mathcal{Q}\rangle$ that spans the code-space. Then the error $E_\alpha$ can be &lt;em&gt;detected&lt;/em&gt; if and only if&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{equation}&#xA;\langle i_\mathcal{Q} | E_\alpha | j_\mathcal{Q} \rangle = \delta_{ij} C(E_\alpha). \quad\quad\quad (1)&#xA;\end{equation}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that $C(E_\alpha)$ is a constant that only depends on the specific error $E_\alpha$, but not on $i$ and $j$. (This means that the error $E_\alpha$ affects all states in the code subspace in the same way). In the case of $C(E_\alpha) \propto \operatorname{tr}(E_\alpha)$, the code if called &lt;em&gt;pure&lt;/em&gt;. Many stabilizer codes considered are of this form, not however Kitaev's toric code.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let us assume an error-model where we are only interested in on how many subsystems our errors act. If our code can &lt;em&gt;detect&lt;/em&gt; all errors $E_\alpha$ that act on at most $(d-1)$ subsystems nontrivially, the code is said to have &lt;em&gt;distance&lt;/em&gt; $d$. As a consequence, any combination of errors that affect up to $\lfloor(d-1)/2\rfloor$ subsystems can be &lt;em&gt;corrected&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What follows is that for pure codes of distance $d$, every vector lying in the code subspace must be &lt;em&gt;maximally entangled&lt;/em&gt; across  any bipartition whose smaller subsystem has at most size $(d-1)$: &#xA;to see this, note that for every error $E_\alpha \neq \mathbb{1}$ and vector $|v_\mathcal{Q} \rangle$ in the subspace (our ONB was chosen arbitrary), one has that&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{equation}&#xA; \langle E \rangle = \operatorname{tr}(E |v_\mathcal{Q} \rangle\langle v_\mathcal{Q}|) = \langle v_\mathcal{Q} |E_\alpha|v_\mathcal{Q} \rangle = \operatorname{tr}(E) = 0.&#xA;\end{equation}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thus all observables on at most $(d-1)$ parties are vanishing, and all reduced density matrices on $(d-1)$ parties must be maximally mixed. This implies that $|v_\mathcal{Q}\rangle$ is maximally entangled for any choice of $(d-1)$ parties vs. the rest. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Addendum (for the sufficiency):&#xA;As an equivalent definition to Eq. (1): All errors $E_\alpha$ acting on less than $d$ places can be &lt;em&gt;detected&lt;/em&gt;, if and only if for all $|v\rangle, |w\rangle$ in the code subspace following condition holds,&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{equation}&#xA; \langle v| E_\alpha | v\rangle = \langle w | E_\alpha| w\rangle.&#xA;\end{equation}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the case of pure codes, above expression vanishes. It follows that if one has a subspace where every state is maximally entangled for all bipartitions of (d-1) parties vs. the rest, then it is a pure code of distance $d$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;tl;dr: For a large distance $d$, a pure code consists of highly entangled states. It is a necessary and sufficient requirement for the  existence of the code.&lt;/p&gt;&#xA;" OwnerUserId="2192" LastEditorUserId="2192" LastEditDate="2018-04-27T13:29:00.520" LastActivityDate="2018-04-27T13:29:00.520" CommentCount="0" />
  <row Id="1909" PostTypeId="1" CreationDate="2018-04-24T16:35:06.120" Score="3" ViewCount="70" Body="&lt;p&gt;The following $2\times 2$ matrix &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;P = &#xA;\begin{bmatrix} &#xA;e^{i\theta} &amp;amp; 0 \\ &#xA;0 &amp;amp; e^{i\phi}&#xA;\end{bmatrix}&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;represents a quantum gate because it's a unitary matrix. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we multiply $P$ by the quantum state $\lvert \psi\rangle = \alpha \lvert 0\rangle + \beta \lvert 1\rangle$, we obtain ${\lvert \psi\rangle}_P = \alpha e^{i\theta} \lvert 0 \rangle  + \beta  e^{i\phi} \lvert 1\rangle $, which can be derived as follows&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{align}&#xA;{\lvert \psi\rangle}_P&#xA;&amp;amp;=&#xA;\begin{bmatrix} &#xA;e^{i\theta} &amp;amp; 0 \\ &#xA;0 &amp;amp; e^{i\phi}&#xA;\end{bmatrix}&#xA;\alpha \lvert 0\rangle + \beta \lvert 1\rangle &#xA;\\&#xA;&amp;amp;=&#xA;\begin{bmatrix} &#xA;e^{i\theta} &amp;amp; 0 \\ &#xA;0 &amp;amp; e^{i\phi}&#xA;\end{bmatrix}&#xA;\alpha \lvert 0\rangle + &#xA;\begin{bmatrix} &#xA;e^{i\theta} &amp;amp; 0 \\ &#xA;0 &amp;amp; e^{i\phi}&#xA;\end{bmatrix}&#xA;\beta \lvert 1\rangle &#xA;\\&#xA;&amp;amp;=&#xA;\alpha &#xA;\begin{bmatrix} &#xA;e^{i\theta} &amp;amp; 0 \\ &#xA;0 &amp;amp; e^{i\phi}&#xA;\end{bmatrix}&#xA;\begin{bmatrix} 1 \\ 0 \end{bmatrix} + &#xA;\beta &#xA;\begin{bmatrix} &#xA;e^{i\theta} &amp;amp; 0 \\ &#xA;0 &amp;amp; e^{i\phi}&#xA;\end{bmatrix}&#xA;\begin{bmatrix} 0 \\ 1 \end{bmatrix} &#xA;\\&#xA;&amp;amp;=&#xA;\alpha &#xA;\begin{bmatrix} e^{i\theta} \\ 0 \end{bmatrix} + &#xA;\beta &#xA;\begin{bmatrix} 0 \\ e^{i\phi} \end{bmatrix}&#xA;\\&#xA;&amp;amp;=&#xA;\alpha &#xA;e^{i\theta}&#xA;\begin{bmatrix} 1 \\ 0 \end{bmatrix} + &#xA;\beta &#xA;e^{i\phi} &#xA;\begin{bmatrix} 0 \\ 1 \end{bmatrix}&#xA;\\&#xA;&amp;amp;=&#xA;\alpha e^{i\theta} \lvert 0 \rangle  + \beta  e^{i\phi} \lvert 1\rangle &#xA;\end{align}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we tried to measure ${\lvert \psi\rangle}_P$, we would obtain the computational basis state $\lvert 0 \rangle$ with probability $|\alpha|^2$ and the computational basis state $\lvert 1 \rangle$ with probability $|\beta |^2$. So, there's no difference between measuring ${\lvert \psi\rangle}_P$ or $\lvert \psi\rangle$, in terms of probabilities of obtaining one rather than the other computational basis state. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The reason to obtain same probabilities is because $e^{i\theta}$ and $e^{i\phi}$ are phase vectors, so they do not affect the probabilities. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$e^{i\theta}$ and $e^{i\phi}$ represent complex numbers, as vectors, in the complex plane. This can be easily visualized from the following picture&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;https://i.stack.imgur.com/3UulI.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/3UulI.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But what's the intuitive meaning of multiplying the &quot;vectors&quot; $e^{i\phi}$ by a computational basis state? In general, what is a phase and a phase vector in this context and how does it affect the mathematics and the basis vectors? What's the relation between $\lvert \psi\rangle$ and ${\lvert \psi\rangle}_P$?&lt;/p&gt;&#xA;" OwnerUserId="72" LastEditorUserId="72" LastEditDate="2018-04-24T17:22:07.497" LastActivityDate="2018-04-24T17:22:07.497" Title="What exactly is a phase vector?" Tags="&lt;quantum-gate&gt;&lt;quantum-state&gt;&lt;unitarity&gt;" AnswerCount="1" CommentCount="1" />
  <row Id="1910" PostTypeId="2" ParentId="1909" CreationDate="2018-04-24T17:12:28.643" Score="1" Body="&lt;p&gt;There are a few different things that you may be confusing.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Why are objects of the form $e^{i\phi}$ actually called vectors in this context?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;A complex number can always be expressed as a vector in $\mathbb R^2$, because $\mathbb C$ is nothing but $\mathbb R^2$ with a particular product defined between its elements. Note that this has nothing to do with quantum mechanics or physics, it is just how complex numbers are defined.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;in general what is a phase (in the context of quantum mechanics)?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;You can think of a phase as a number that characterises how different modes interfere with each other. While as you noted adding a phase doesn't change the output probabilities in a fixed basis, it &lt;em&gt;does&lt;/em&gt; change the output probabilities as soon as you measure in a different basis.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;What is the relation between $|\psi\rangle$ and $|\psi\rangle_P$?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;They are just two different states. As noted above, while the probabilities of measuring $|0\rangle$ or $|1\rangle$ are the same for these states, as soon as you measure in a different basis you will see that they behave differently.&#xA;For example, you can easily verify that $|\psi\rangle$ and $|\psi\rangle_P$ correspond to different probabilities of measuring the outcome $|+\rangle\equiv\frac{1}{\sqrt2}(|0\rangle+|1\rangle)$.&lt;/p&gt;&#xA;" OwnerUserId="55" LastActivityDate="2018-04-24T17:12:28.643" CommentCount="1" />
  <row Id="1911" PostTypeId="1" AcceptedAnswerId="1912" CreationDate="2018-04-24T18:07:35.513" Score="3" ViewCount="61" Body="&lt;p&gt;I know that a density operator is separable if it can be written in the form:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ \rho =\sum_k a_k \rho^A_k \otimes \rho^B_k\tag{1}$$&#xA;where &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$a_k \ge 0,\quad \sum_k a_k=1\tag{2}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is will any set of $\rho_k^A \otimes \rho_k^B$ work? I.e. I am asking if the following statement is true (if so how do we prove it and if not - why not):&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;A density matrix $\rho$ is separable if and only if when written as the sum of &quot;factorized&quot; states $\rho_K^A \otimes \rho_k^B$ (independent of which factorized states are used) the relations (1) and (2) hold.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;This is clearly a stronger statement then saying it &lt;em&gt;can be&lt;/em&gt; written as (1) and (2) - and if true leads to a quick way to test entanglement.&lt;/p&gt;&#xA;" OwnerUserId="2015" LastActivityDate="2018-04-24T21:22:13.340" Title="Density operators and separable states" Tags="&lt;quantum-entanglement&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="1912" PostTypeId="2" ParentId="1911" CreationDate="2018-04-24T20:04:16.967" Score="3" Body="&lt;p&gt;The correct definition is&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;$\rho$ is separable if and only if there exist $\rho_i^A\ge0$, $\rho_i^B\ge0$, and $p_i\ge0$ such that &#xA;  $$\rho = \sum_i p_i \rho_i^A\otimes \rho_i^B\ .$$&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;All other properties (that the $\rho_i^\bullet$ have trace 1 and the $p_i$ sum to $1$) follow automatically.&lt;/p&gt;&#xA;" OwnerUserId="491" LastActivityDate="2018-04-24T20:04:16.967" CommentCount="0" />
  <row Id="1913" PostTypeId="2" ParentId="1911" CreationDate="2018-04-24T20:27:35.860" Score="1" Body="&lt;p&gt;There are fixed sets that you can use, but the question is how large that set is. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If your possible set of states is infinitely large (every possible pure state of 1 qubit), you can always do it, of course. But, worse, it has to be this large. Imagine you have a finite set $\{\rho^A_i\}$ and you want to describe a pure single-qubit state $|\psi\rangle\langle\psi|$ that is not one of the $\rho^A_i$. Clearly, there is no choice of $\{p_i\}$ such that $\sum_ip_i\rho^A_i=|\psi\rangle\langle\psi|$ because you must sum at least two terms, and hence will have a state with at least rank 2, while the pure state has rank 1.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A good way to visualise this is with the Bloch sphere. Imagine a sphere. Every possible pure state corresponds to a point on the surface. The set $\{\rho^A_i\}$ form a set of points on, or in, the sphere. The set of possible states that you can make via the term $\sum_ip_i\rho^A_i$ is given by the convex hull of the points. You can't reconstruct the surface of the sphere from a convex hull (the shape has flat sides!) unless you have infinitely many points.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-04-24T21:22:13.340" LastActivityDate="2018-04-24T21:22:13.340" CommentCount="0" />
  <row Id="1914" PostTypeId="1" AcceptedAnswerId="1919" CreationDate="2018-04-25T03:53:41.470" Score="5" ViewCount="280" Body="&lt;p&gt;Whenever I learn about quantum computing and qubits, it always talks about the superposition principle and that the qubits can be in both states 0 and 1 simultaneously, thus claiming that quantum computers have processing capability way more than modern conventional computers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But here is what I don't understand:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;How can a superposition of 0 and 1 represent any discrete information at all?&lt;/li&gt;&#xA;&lt;li&gt;What about the logic gates? &lt;/li&gt;&#xA;&lt;li&gt;How can a discrete decision be taken by leveraging this superposition principle?&lt;/li&gt;&#xA;&lt;li&gt;Combination of 0 and 1 is basically important for computing. How can this third state of qubits be leveraged to give a boost in computing?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="2201" LastEditorUserId="26" LastEditDate="2018-05-09T04:31:25.253" LastActivityDate="2018-05-09T04:37:24.943" Title="How does using a superposition of 0 and 1 improve the processing capabilities of a quantum computer compared to classical computers?" Tags="&lt;quantum-computer&gt;&lt;qubit&gt;&lt;qubit-state&gt;" AnswerCount="2" CommentCount="5" FavoriteCount="3" ClosedDate="2018-04-25T18:32:00.133" />
  <row Id="1915" PostTypeId="2" ParentId="1914" CreationDate="2018-04-25T04:53:03.663" Score="1" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;How can a superposition of 0 and 1 represent any discrete information at all?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Any algorithm, classical or quantum, inputs 0's and 1's and outputs 0's and 1's. For a quantum algorithm 0 is $|0\rangle$ and 1 is $|1\rangle$. Quantum algorithms use superpositions $|\psi\rangle = \alpha|0\rangle+\beta|1\rangle$ on intermediate computation steps only.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;What about the logic gates?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Quantum computers use a different set of gates because they are built on different physics. For example, all quantum gates are reversible, while for example classical AND gate is not reversible.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Formally, a quantum gate is a unitary transformation applied to one or several qubits.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;How can a discrete decision be taken by leveraging this superposition principle?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&quot;Discrete decision&quot; (whatever it means) is based on the output of a quantum algorithm which is nothing more than a bunch of zeros and ones, same as with &#xA;classical algorithm.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Combination of 0 and 1 is basically important for computing. How can this third state of qubits be leveraged to give a boost in computing?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Actually quantum algorithms use not only single-qubit superposition states $|\psi\rangle = \alpha|0\rangle+\beta|1\rangle$ but also multi-qubit entangled states. Anyway, quantum algorithms have additional &quot;degrees of freedom&quot; that are unavailable to classical algorithms and indeed can leverage these degrees of freedom &quot;to give a boost in computing&quot;. I doubt it is possible to explain how quantum algorithms do it without learning quantum algorithms themselves.&lt;/p&gt;&#xA;" OwnerUserId="2105" LastEditorUserId="26" LastEditDate="2018-05-09T04:37:24.943" LastActivityDate="2018-05-09T04:37:24.943" CommentCount="1" />
  <row Id="1916" PostTypeId="2" ParentId="1803" CreationDate="2018-04-25T06:13:25.380" Score="3" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Plain and simple. Does Moore's law apply to quantum computing, or is it similar but with the numbers adjusted (ex. triples every 2 years). Also, if Moore's law doesn't apply, why do qubits change it?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;A great question, with great answers; still, I will try my hand at it.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;No, most quantum computers do not have qubits created in silicon; even the few that do are not created by utilizing &lt;a href=&quot;https://en.wikipedia.org/wiki/Computational_lithography&quot; rel=&quot;nofollow noreferrer&quot;&gt;computational lithography&lt;/a&gt;. Quantum computing is in it's earliest days, it can't be compared directly to a mature technology of an entirely different kind.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Information to support that short answer:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This question was asked at physics.SE: &quot;&lt;a href=&quot;https://physics.stackexchange.com/questions/372161/reasonable-to-expect-moores-law-for-quantum-computing&quot;&gt;Reasonable to expect Moore's law for quantum computing?&lt;/a&gt;&quot;, receiving one answer; not particularly well received (400 views in 144 days, and 1 UpVote).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is termed &lt;a href=&quot;https://en.wikipedia.org/wiki/D-Wave_Systems#History&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rose&lt;/a&gt;'s Law, by some; after the CTO of D-Wave Systems. See this article: &quot;&lt;a href=&quot;https://www.fanaticalfuturist.com/2016/08/quantum-computing-roses-law-is-moores-law-on-steroids/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum computing Rose’s Law is Moore’s Law on steroids&lt;/a&gt;&quot; or the Flickr page of the Managing Director of the investment firm Draper Fisher Jurvetson, Steve Jurvetson: &quot;&lt;a href=&quot;https://www.flickr.com/photos/jurvetson/8054771535/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rose’s Law for Quantum Computers&lt;/a&gt;&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/1Itei.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/1Itei.jpg&quot; alt=&quot;Rose&amp;#39;s Law&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The chart runs a bit ahead of itself, and it applies to &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_annealing&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum annealing&lt;/a&gt; computers, it's not exactly comparable to &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_computing#Quantum_supremacy&quot; rel=&quot;nofollow noreferrer&quot;&gt;universal quantum computing&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The reason Moore's Law is not exactly comparable is because it refers to transistors and an entirely different manufacturing process, you're comparing a manufacturing process that was established at the time with one where the computer is in it's earliest days and is essentially hand built.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Wikipedia's webpage describes &lt;a href=&quot;https://en.wikipedia.org/wiki/Moore%27s_law&quot; rel=&quot;nofollow noreferrer&quot;&gt;Moore's Law&lt;/a&gt; this way:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;Moore's law is the observation that the number of transistors in a dense integrated circuit doubles about every two years. The observation is named after Gordon Moore, the co-founder of Fairchild Semiconductor and Intel, whose 1965 paper described a doubling every year in the number of components per integrated circuit, and projected this rate of growth would continue for at least another decade. In 1975, looking forward to the next decade, he revised the forecast to doubling every two years. The period is often quoted as 18 months because of Intel executive David House, who predicted that chip performance would double every 18 months (being a combination of the effect of more transistors and the transistors being faster).&quot;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://www.intel.com/pressroom/kits/events/moores_law_40th/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Gordon E. Moore&lt;/a&gt;'s graphic from 1965 looked like this:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/wZFYe.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/wZFYe.jpg&quot; alt=&quot;Original Moore&amp;#39;s Law&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The article by Max Roser and Hannah Ritchie (2018) - &quot;&lt;a href=&quot;https://ourworldindata.org/technological-progress&quot; rel=&quot;nofollow noreferrer&quot;&gt;Technological Progress&lt;/a&gt;&quot;, published online at OurWorldInData.org, explains how exponential equations have been used to describe everything from Moore's Law, computational power (both operations per second and clock speed * cores * threads), the progress of human flight or even human genome DNA sequencing.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Moore's law is an &lt;a href=&quot;https://en.wikipedia.org/wiki/Observation&quot; rel=&quot;nofollow noreferrer&quot;&gt;observation&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Forecasting&quot; rel=&quot;nofollow noreferrer&quot;&gt;projection&lt;/a&gt; of an historical trend and not a &lt;a href=&quot;https://en.wikipedia.org/wiki/Physical_law&quot; rel=&quot;nofollow noreferrer&quot;&gt;physical&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Natural_law&quot; rel=&quot;nofollow noreferrer&quot;&gt;natural law&lt;/a&gt;. Although the rate held steady from 1975 until around 2012, the rate was faster during the first decade. A nostalgic look at the early days of personal computing is given in this Ars Technica feature: &quot;&lt;a href=&quot;https://arstechnica.com/gadgets/2015/06/from-laptops-that-needed-leg-braces-to-laplets-engineering-mastery/&quot; rel=&quot;nofollow noreferrer&quot;&gt;The creation of the modern laptop: An in-depth look at lithium-ion batteries, industrial design, Moore's law, and more&lt;/a&gt;&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In this Communications of the ACM, Vol. 60 No. 1 article: &quot;&lt;a href=&quot;https://webcache.googleusercontent.com/search?q=cache:JDSZ4GENpGgJ:https://cacm.acm.org/magazines/2017/1/211094-exponential-laws-of-computing-growth/fulltext%20&amp;amp;cd=1&amp;amp;hl=en&amp;amp;ct=clnk&amp;amp;gl=ca&quot; rel=&quot;nofollow noreferrer&quot;&gt;Exponential Laws of Computing Growth&lt;/a&gt;&quot; the authors, Denning and Lewis, explain: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;The three kinds of exponential growth, as noted—doubling of components, speeds, and technology adoptions—have all been lumped under the heading of Moore's Law. Because the original Moore's Law applies only to components on chips, not to systems or families of technologies, other phenomena must be at work. We will use the term &quot;Moore's Law&quot; for the component-doubling rule Moore proposed and &quot;exponential growth&quot; for all the other performance measures that plot as straight lines on log paper. What drives the exponential growth effect? Can we continue to expect exponential growth in the computational power of our technologies?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Exponential growth depends on three levels of adoption in the computing ecosystem (see the table here). The chip level is the domain of Moore's Law, as noted. However, the faster chips cannot realize their potential unless the host computer system supports the faster speeds and unless application workloads provide sufficient parallel computational work to keep the chips busy. And the faster systems cannot reach their potential without rapid adoption by the user community. The improvement process at all three levels must be exponential; otherwise, the system or community level would be a bottleneck, and we would not observe the effects often described as Moore's Law.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;With supporting mathematical models, we will show what enables exponential doubling at each level. Information technology may be unique in being able to sustain exponential growth at all three levels. We will conclude that Moore's Law and exponential doubling have scientific bases. Moreover, the exponential doubling process is likely to continue across multiple technologies for decades to come.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Self-Fulfillment&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The continuing achievement signified by Moore's Law is critically important to the digital economy. Economist Richard G. Anderson said, &quot;Numerous studies have traced the cause of the productivity acceleration to technological innovations in the production of semiconductors that sharply reduced the prices of such components and of the products that contain them (as well as expanding the capabilities of such products).&quot;1 Robert Colwell, Director of DARPA's Microsystems Technology Office, echoes the same conclusion, which is why DARPA has invested in overcoming technology bottlenecks in post-Moore's-Law technologies.5 If and when Moore's Law ends, that end's impact on the economy will be profound.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is no wonder then that the standard explanation of the law is economic; it became a self-fulfilling prophesy of all chip companies to push the technology to meet the expected exponential growth and sustain their markets. A self-fulfilling prophecy is a prediction that causes itself to become true. For most of the past 50-plus years of computing, designers have emphasized performance. Faster is better. To achieve greater speed, chip architects increased component density by adding more registers, higher-level functions, cache memory, and multiple cores to the same chip area and the same power dissipation. Moore's Law became a design objective.&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Moore's Law had a lot of help, shaping the future and maintaining the growth was an objective of those whom stood to profit; not entirely constrained by technological limitations. If consumers wanted something sometimes it was provided and other times a &lt;em&gt;better&lt;/em&gt; idea was offered; what was popular (clock speed) sold at a premium and what, at one time, was not well understood (more cores and threads) was promoted as the way forward.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Moore's Law was well received, evolving into many things, like Kurzweil's &quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/Accelerating_change#Kurzweil&amp;#39;s_The_Law_of_Accelerating_Returns&quot; rel=&quot;nofollow noreferrer&quot;&gt;The Law of Accelerating Returns&lt;/a&gt;&quot;. Here's an updated version of Moore’s Law (based on Kurzweil’s graph):&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/vayBP.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/vayBP.png&quot; alt=&quot;Kurzweil&amp;#39;s Law&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Another fact-based chart is provided by &lt;a href=&quot;https://www.top500.org/statistics/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Top500.Org&lt;/a&gt;'s chart of the exponential growth of SuperComputer power:&#xA;&lt;a href=&quot;https://i.stack.imgur.com/4biM4.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/4biM4.png&quot; alt=&quot;Top 500 SuperComputers&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Missouri University of Science and Technology's article: &quot;&lt;a href=&quot;http://scholarsmine.mst.edu/bio_inftec_facwork/130/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Forecasting Consumer Adoption of Technological Innovation: Choosing the Appropriate Diffusion Models for New Products and Services before Launch&lt;/a&gt;&quot; explains that the Bass Model (a modification of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Logistic_function&quot; rel=&quot;nofollow noreferrer&quot;&gt;logistic curve&lt;/a&gt;) is a sound method to predict future growth (based upon past statistics).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The logistic curve features a slow start, great mid-term progress, followed by an eventual slowdown; often replaced by something new.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/mszUr.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/mszUr.png&quot; alt=&quot;Logistic Curve&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;On forecasting models the authors had this to say:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;strong&gt;MODELS&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Box and Cox and Generalized Bass models were the best models when it came to curve-fitting while the Simple Logistic model did the poorest. &lt;strong&gt;However, the results of the research showed that a curve-fitting advantage did not translate into a forecasting advantage when creating a forecast for an innovation without a market history&lt;/strong&gt;. The popularity of the Bass model derives from two unique factors. As this research has reinforced, the Bass model is very robust. In addition, the Bass model’s two coefficients have a theoretical foundation. The Bass model variants created for this research deliberately violated the assumption of a constant $m$. This resulted in a model (Bv) that outperformed any of the others in the radical low-priced innovation context. Unfortunately, there was just one innovation in this context – additional research is recommended to test the viability of this variation with more datasets in various contexts.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Simple Logistic model is one of the oldest diffusion models known. It is a very basic model, but it clearly outperformed the other models in the context of really new low-priced innovations. The Gompertz model it is not recommended for forecasting the diffusion of really new or radical innovations before the launch of an innovation. However, the Gompertz model may be very well suited for forecasts generated well after the launch of an innovation. While not the focus of this research, it was observed that the diffusion of the Projection Television innovation follows a perfect Gompertz curve.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Flexible Logistic Box and Cox model has a problem where the c variable tends to run to infinity in some scenarios. This was addressed by capping the upper limit of $c$ to 100,000. Despite (or because of) this fix, the &#xA;authors must admit to being skeptical as to how well the Box and Cox model would do in comparison to the other models. As it turned out, the Box and Cox was second only to the Bass model in terms of robustness. The Box and Cox was also the best model in the context of radical high-priced innovations.&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Moore's position as a co-founder of Intel helped ensure that he could help his prediction to come true and keep it on track.&lt;/strong&gt; Quantum computing is too near it's genesis to be pushed forward by simply pouring money on it, with so many paths to creating a successful quantum computing device money needs to be apportioned wisely to make the most gains from the many branches that research has taken.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;a href=&quot;https://arxiv.org/abs/1712.03773&quot; rel=&quot;nofollow noreferrer&quot;&gt;The European Quantum Technologies Roadmap&lt;/a&gt;&quot; (11 Dec 2017) lists some of the challenges, following the introduction:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;strong&gt;Introduction&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A quantum computer based on the unitary evolution of a modest number of robust logical qubits (N&gt;100) operating on a computational state space with 2$^N$ basis states would outperform conventional computers for a number of well identified tasks. A viable implementation of a quantum computer has to meet a set of requirements known as the &lt;a href=&quot;https://en.wikipedia.org/wiki/DiVincenzo%27s_criteria&quot; rel=&quot;nofollow noreferrer&quot;&gt;DiVincenzo criteria&lt;/a&gt;: That is, a quantum computer operates on &lt;/p&gt;&#xA;&#xA;&lt;p&gt;(1) an easily extendable set of well characterized qubits&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(2) whose coherence times are long enough for allowing coherent operation&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(3) and whose initial state can be set&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(4). The qubits of the system can be operated on logically with a universal set of gates&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(5) and the final state can be measured&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(6). To allow for communication, stationary qubits can be converted into mobile ones&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(7) and transmitted faithfully.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is also understood that it is essential for the operation of any quantum computer to correct for errors that are inevitable and much more likely than in classical computers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Today quantum processors are implemented using a range of physical systems. Quantum processors operating on registers of such qubits have so far been able to demonstrate many elementary instances of quantum algorithms and protocols. The development into a fully featured large quantum computer faces a scalability challenge which comprises of integrating a large number of qubits and correcting quantum errors. Different fault-tolerant architectures are proposed to address these challenges. The steadily growing efforts of academic labs, startups and large companies are a clear sign that large scale quantum computation is considered a challenging but potentially rewarding goal.&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;...&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are too many paths to choose, and determine the best way forward, to either plot a model for growth (like Moore's Law) nor should so straight a line be expected.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;With D-Wave's computer each doubling of qubits represents a doubling of computation power, for the subset of problems it is suited for, for universal quantum computers each single additional qubit represents a doubling of power; unfortunately each single qubit needs to be represented by multiple qubits, to permit error correction and maintain coherence. Some technologies used to implement qubits allow fewer or single qubits to be used as they are not error prone and have longer coherence and greater fidelity. Speed of control is also an important consideration when choosing which technology to implement and while it will affect the plot of the curve it's out of the scope of the answer offered here.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Further reading: &quot;&lt;a href=&quot;https://arxiv.org/abs/1801.07497&quot; rel=&quot;nofollow noreferrer&quot;&gt;Coherent control of single electrons: a review of current progress&lt;/a&gt;&quot; (1 Feb 2018), &quot;&lt;a href=&quot;https://arxiv.org/abs/1707.00581&quot; rel=&quot;nofollow noreferrer&quot;&gt;Hyperfine-assisted fast electric control of dopant nuclear spins in semiconductors&lt;/a&gt;&quot; (30 Mar 2018), &quot;&lt;a href=&quot;https://arxiv.org/abs/1708.01454&quot; rel=&quot;nofollow noreferrer&quot;&gt;A &gt;99.9%-fidelity quantum-dot spin qubit with coherence limited by charge noise&lt;/a&gt;&quot; (4 Aug 2017).&lt;/p&gt;&#xA;" OwnerUserId="278" LastEditorUserId="278" LastEditDate="2018-05-12T23:26:39.113" LastActivityDate="2018-05-12T23:26:39.113" CommentCount="1" />
  <row Id="1917" PostTypeId="1" CreationDate="2018-04-25T07:57:56.000" Score="6" ViewCount="32" Body="&lt;p&gt;This question is related (and complementary) to &quot;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1880/passive-improving-of-nanodiamond-surfaces-for-nv-centers&quot;&gt;Passive improving of nanodiamond surfaces for NV centers?&lt;/a&gt;&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Nitrogen-vacancy_center&quot; rel=&quot;noreferrer&quot;&gt;Nitrogen-Vacancy centers&lt;/a&gt; (NVs) have astonishing quantum properties, which make them interesting as potential hardware both for quantum computing in particular and for quantum technologies in general. In part this results from the center being protected by the diamond structure, which is at the same time very rigid and practically free from nuclear spins.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, their surfaces tend to be far from controlled. Neither in &lt;em&gt;chemical&lt;/em&gt; terms (composition, structure) not in terms of what it contributes to the &lt;em&gt;physical properties of the bulk&lt;/em&gt;. For example, in experiments of diamond levitation using lasers, at high powers of irradiation, the diamonds typically get noticeably lighter (and thus oscillate further in their potential wells) as they suddenly (and uncontrolledly lose the external rubbish.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Coming closer to the question: in these same experiments, even though diamonds are essentially transparent to the lasers employed for the levitation, eventually at high laser power and low pressure diamonds overheat and essentially &lt;em&gt;evaporate&lt;/em&gt;. Since these conditions are useful to fix the diamonds in place and reduce noise, this is a problem for the control of NV centers as qubits for quantum computing purposes. One reason for the poor thermal dissipation in diamonds -which in absence of gas that can carry convection necessarily happens via black body radiation- is the fact that the phonon spectrum of diamond is essentially empty: covalent bonds are too strong, everything is fix in its place, and there is nothing available that can vibrate.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is, since heat release is often governed by surface properties, what is the current status of efforts to alter diamond surface with the goal of obtaining &lt;strong&gt;spectrally selective thermal emittance properties&lt;/strong&gt;, meaning emitting preferentially at energies below the evaporation of the diamond starts?&lt;/p&gt;&#xA;" OwnerUserId="1847" LastActivityDate="2018-04-25T07:57:56.000" Title="Active improving of nanodiamond surfaces for NV centers?" Tags="&lt;architecture&gt;&lt;experimental-results&gt;&lt;solid-state&gt;" AnswerCount="0" CommentCount="0" FavoriteCount="1" />
  <row Id="1918" PostTypeId="1" AcceptedAnswerId="1923" CreationDate="2018-04-25T10:44:11.683" Score="11" ViewCount="268" Body="&lt;p&gt;An answer to &#xA;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1478/is-there-any-source-which-tabulates-quantum-computing-algorithms-for-simulating&quot;&gt;Is there any source which tabulates quantum computing algorithms for simulating physical systems?&lt;/a&gt; mentions the &lt;a href=&quot;https://math.nist.gov/quantum/zoo/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Algorithm Zoo&lt;/a&gt;, a list of quantum algorithms. Several answers to &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1367/programming-quantum-computers-for-non-physics-majors&quot;&gt;Programming quantum computers for non-physics majors&lt;/a&gt; include links to different kinds of development kits. Likewise, &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1474/what-programming-languages-are-available-for-quantum-computers&quot;&gt;What programming languages are available for quantum computers?&lt;/a&gt; gathers a couple of good attempts at listing those.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The present question is related to the above, and yet it's not answered by the above resources.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Does a complete list of open quantum software projects exist?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Ideal answers would be: if it exists, the link to said list, and if it doesn't, a (well-formatted) as-exhaustive-as-possible compilation of open quantum software projects.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Related question: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1973/are-there-any-quantum-software-startups&quot;&gt;Are there any quantum software startups?&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="1847" LastEditDate="2018-05-03T04:47:56.550" LastActivityDate="2018-05-03T04:47:56.550" Title="Does a complete list of open quantum software projects exist?" Tags="&lt;resource-request&gt;&lt;quantum-programming&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="5" />
  <row Id="1919" PostTypeId="2" ParentId="1914" CreationDate="2018-04-25T10:49:09.753" Score="1" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;How can a superposition of 0 and 1 represent any discrete information at all?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The inputs to a quantum computer are always the same as the inputs to a classical computer; a definite sequence of 0s and 1s. This superposition thing is something that happens in the middle of the computation, and what you're quantum algorithm tries to do is make sure that your output is also a definite sequence of 0s and 1s. So, you're not using the superposition to represent any information in the sense of an input or an output.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;What about the logic gates?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;In many ways, logic gates work just the same as in the classical case. For example, there are many gates which, given an input string of 0s and 1s output a different string of 0s and 1s. Examples include the not gate, controlled-not and Toffoli (controlled-controlled-not). For a quantum state, if you have it written out as a superposition of different strings of 0s and 1s, these gates act on each of these strings just as they would in the classical case. In this sense, you can do everything that a classical computer can (the Toffoli gate, in particular, is said to be 'universal' for classical reversible computation, i.e. arbitrary combinations have the full power of classical computation).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, quantum computation has &lt;em&gt;more&lt;/em&gt; logic gates. It has gates which can create and recombine superpositions, and gates which can change the complex argument on the coefficients of the superposition (the $\alpha$ and $\beta$ in a statement $\alpha|0\rangle+\beta|1\rangle$).&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;How can a discrete decision be taken by leveraging this superposition principle?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The trick, as mentioned above, is to make sure that there is a definite output, i.e.e that there is no (or almost no) superposition when the information is read out at the end. Where this superposition becomes useful is it gives these extra gates, over and above the classical stuff, some room to work. Without specifying exactly how they do it, you can easily imagine how having access to an additional set of abilities can sometimes be combined in new ways to give faster computations.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Combination of 0 and 1 is basically important for computing. How can this third state of qubits be leveraged to give a boost in computing?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The insight about how it works is to emphasise first that the superposition of a qubit is not only one extra state. It is an infinite number of them, because instead of either being a 0 or a 1, it can be &lt;em&gt;any&lt;/em&gt; state $\alpha|0\rangle+\beta|1\rangle$ that satisfies the constraint $|\alpha|^2+|\beta|^2$. What's more, when you combine $N$ qubits together, you can get superpositions across all $2^N$ different sequences of 0s and 1s.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, how is this useful? So far, we only know that it's useful for a limited set of problems, and these problems often require knowledge of some global property of a function, i.e. I don't just want to evaluate some function $f(x)$ for a specific value of $x$, but I want to know some relation between many different values of $f(x)$. The superposition can simultaneously evaluate all the different values of $f(x)$, and then it just needs a bit of magic to work out if it's possible to recombine these superpositions in order to get out the answer we're interested in. The point is that this opens up a completely new possibility for the way an algorithm could work.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="26" LastEditDate="2018-05-09T04:35:23.177" LastActivityDate="2018-05-09T04:35:23.177" CommentCount="1" />
  <row Id="1920" PostTypeId="1" CreationDate="2018-04-25T11:32:49.613" Score="6" ViewCount="222" Body="&lt;p&gt;In superdense coding, two qubits are prepared by Eve in an entangled state; one of them is sent to Alice and the other is sent to Bob. Alice is the one who wants to send (to Bob) two classical bits of information. Depending on what pair of classical bits Alice wants to send (i.e. one of $00$, $01$, $10$ and $11$), Alice applies a certain quantum operation or gate to her qubit, and sends the result to Bob, which then applies other operations to retrieve the &quot;classical message&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It doesn't seem to me that superdense coding provides any advantage over classical communication techniques. Two qubits (the one sent to Alice and the one sent to Bob by Eve) and bits (the two sent to Bob by Alice) are sent, two qubits (one is received by Alice and the other by Bob) and bits (the two sent by Alice to Bob) are received. Furthermore, I read that if someone has access to the qubit sent to Bob, then the communication seems not to be secure (anyway). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;What are the real advantages of superdense coding compared to just sending two bits of information from Alice to Bob?&lt;/p&gt;&#xA;" OwnerUserId="72" LastEditorUserId="72" LastEditDate="2018-04-25T11:42:05.033" LastActivityDate="2018-04-26T11:03:32.327" Title="What are the real advantages of superdense coding?" Tags="&lt;quantum-information&gt;&lt;superdense-coding&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="1921" PostTypeId="2" ParentId="1920" CreationDate="2018-04-25T11:40:32.067" Score="5" Body="&lt;p&gt;TL;DR: While two qubits must be transmitted in total, in the instant where two bits are to be communicated, only one qubit has to be sent. The information being sent is masked, but it is not truly secure.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;There are two distinct phases to a superdense coding protocol. In phase 1,&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Alice and Bob prepare a Bell state $(|00\rangle+|11\rangle)/\sqrt{2}$. This is a two-qubit state and Alice holds one qubit, and Bob the other.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Alice and Bob travel off to distant locations, each taking their qubit. We assume that there are no errors; the quantum state does not change over time.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;This has all happened in advance, long before Alice knows what message she wants to send to Bob. The second phase occurs later, when Alice decides what two bit message she wants to send to Bob.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Depending on the message she wishes to send (she has 4 possible options), Alice applies either $\mathbb{I},X, Z$ or $Y$ on her qubit.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Alice sends her qubit to Bob.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;When Bob receives Alice's qubit, he brings the two qubits together and measures in the Bell basis. Each of the four different possible measurement outcomes correspond to one of the 4 messages Alice had to choose from.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;So, overall, you are correct that two qubits have to be sent. However, one of these qubits can be provided to Bob in advance, long before the communication, and before the content of the message was decided. Thus, in the instant when you want to send two bits of information (phase 2), you only have to send one qubit (the one that Alice has). Its like if you know you have lots of deadlines all due on the same day. You don't leave doing each of those jobs until absolutely the last minute, even if there are some last minute adjustments that you have to make on each. You work on things in advance so that, when that last minute information is available, you have to do the minimum possible.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is the idea behind superdense coding, and it illustrates one of the principles of quantum information: you can provide some resource at an earlier time, independent of what is going to be done later and that resource can be consumed to achieve a more efficient result in the instant.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you're interested in security, then for the protocol as described above, an eavesdropper can only get access to the qubit that Alice sends to Bob. In that case, the eavesdropper cannot tell what information Alice was sending to Bob (the density matrix of that qubit is $\mathbb{I}/2$ no matter what Alice did to it to encode the message). However, the eavesdropper can scramble the message by applying a Pauli operation on that qubit. The eavesdropper won't know what message Bob will receive (because it will be a combination of what Alice and the eavesdropper did), but Bob won't receive what Alice intended.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If it is the case that Alice prepares both qubits and sends them to Bob (just at different times), so that an eavesdropper could intercept thefirst qubit as well, then the protocol is completely insecure as the eavesdropper can just replace Bob. There is no authentication of the receiver.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;What does it mean to &quot;prepare a quantum state&quot;?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Every quantum state of a particular dimension, $d$ has an associated quantum state. This quantum state can be described mathematically as a $d$-dimensional complex vector. As theorists, when we say &quot;prepare a quantum state&quot;, we mean that we specify a vector that we want that quantum system to be in.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In practice, how is this done? You first measure your quantum system to find out what state it's in already, and perform a unitary operation to convert it from what it is to what you want it to be.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-04-26T11:03:32.327" LastActivityDate="2018-04-26T11:03:32.327" CommentCount="10" />
  <row Id="1923" PostTypeId="2" ParentId="1918" CreationDate="2018-04-25T15:21:55.737" Score="12" Body="&lt;p&gt;There is a really long list of quantum software projects on &lt;a href=&quot;https://www.quantiki.org/wiki/list-qc-simulators&quot; rel=&quot;noreferrer&quot;&gt;Quantiki&lt;/a&gt;. It's mostly about quantum simulators, quantum compilers and QC programming environments.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But you inspired me to start a curated list of open-source quantum software projects on GitHub &lt;a href=&quot;https://github.com/markf94/os_quantum_software&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;. It should not be exclusive to the aforementioned categories but list ANY (reasonable) open-source quantum software project out there. I will be doing my best to add as many projects as I can, but it would be great if some of you would contribute!&lt;/p&gt;&#xA;" OwnerUserId="1234" LastEditorUserId="1234" LastEditDate="2018-04-25T16:52:32.153" LastActivityDate="2018-04-25T16:52:32.153" CommentCount="2" />
  <row Id="1924" PostTypeId="1" CreationDate="2018-04-25T15:27:01.150" Score="5" ViewCount="67" Body="&lt;p&gt;My question is somehow related with a previous one: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1842/what-is-the-most-optimistic-perspective-of-room-temperature-solid-state-qc&quot;&gt;What is the most optimistic perspective of room-temperature solid-state QC?&lt;/a&gt;. &lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Regarding solid-state qubits, &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;What is the highest temperature at which the simplest quantum logic operation has been performed?  Let's say: initialization, arbitrary rotation and measuring, repeated to have enough statistics in order to verify a good fidelity. In which solid-state system has this happened?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="1955" LastActivityDate="2018-04-30T06:33:12.720" Title="Which temperature has been the highest to achieve a quantum logic operation?" Tags="&lt;quantum-computer&gt;&lt;solid-state&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="1925" PostTypeId="2" ParentId="1920" CreationDate="2018-04-25T16:18:18.120" Score="2" Body="&lt;p&gt;Superdense coding can be used to smooth out network utilization by &quot;&lt;a href=&quot;http://algassert.com/quantum/2014/05/03/Storing-Bandwidth-with-Superdense-Coding.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;storing bandwidth&lt;/a&gt;&quot;. During low utilization, top up the traffic with EPR halves. During high utilization, burn the EPR halves to double the available capacity.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Superdense coding can turn a two-way quantum channel with bandwidth B (in both directions) &lt;a href=&quot;http://algassert.com/quantum/2015/01/17/Superdense-Coding-on-the-Fly-and-in-Reverse.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;into a one-way classical channel with bandwidth 2B&lt;/a&gt;. Just use the reverse direction to send EPR halves, which you then use to fuel superdense coding in the forward direction.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Superdense coding can convert high-latency bandwidth into low-latency bandwidth. For example, if you have two quantum channels with bandwidth B but one of them has a latency of 1 second instead of 10 milliseconds, you can deliver EPR halves over the high latency channel and use them to fuel the actual data being superdense coded over the low latency channel. (Picture a truck showing up with a box of EPR halves, so that your internet goes faster.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Caveat: all of these assume that a quantum channel is less than twice as expensive as a classical channel, which may not ever be true financially speaking.&lt;/p&gt;&#xA;" OwnerUserId="119" LastActivityDate="2018-04-25T16:18:18.120" CommentCount="0" />
  <row Id="1926" PostTypeId="1" AcceptedAnswerId="1972" CreationDate="2018-04-25T16:31:31.260" Score="7" ViewCount="299" Body="&lt;p&gt;I am from a computer science background and I find it difficult to decide on the resources I should focus on while learning quantum computing, since there is so much to read/watch. My ultimate goal is to make a programming language acting as an interface between quantum computers and the person similar to 1972 when C was made. As a realistic intermediate stage, I would like to get to the point of writing programs on IBM's QISKit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For that, I would need a schematic study guide in order to acquire the necessary background in Physics and the related fields required to dive into the field of quantum computing. Does this already exist: &lt;strong&gt;an ordered list of indispensable concepts and abilities to master, which if possible also mentions adequate material to acquire each of them&lt;/strong&gt;?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Assume a high school level physics knowledge. Provide a study guide i.e. from beginner to expert kind of guide. Try to list video/book resources that one should follow in a chronological order so as to become an expert in the field of quantum computing to the level I can write my own quantum computing language (assuming already have other CS skills to write the language).&lt;/p&gt;&#xA;" OwnerUserId="2209" LastEditorUserId="26" LastEditDate="2018-05-01T17:37:25.613" LastActivityDate="2018-05-13T18:40:35.547" Title="Does a study guide exist that starts from a &quot;purely CS background&quot; and advances towards &quot;making a new quantum programming language&quot;?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-programming&gt;&lt;resource-request&gt;" AnswerCount="2" CommentCount="6" FavoriteCount="3" />
  <row Id="1927" PostTypeId="2" ParentId="1867" CreationDate="2018-04-26T01:24:07.957" Score="2" Body="&lt;p&gt;For theoretical purposes, I would say that describing two qubits either as exactly that, two qubits ($\mathbb{C}^2\otimes\mathbb{C}^2$), or as a single $d=4$ spin, ($\mathbb{C}^4$) are essentially equivalent, assuming you have universal control over the whole Hilbert space, because it means you can do whatever you want. The distinction is usually most applicable when you separate the two qubits over some distance, and cannot easily implement a key gate in the universal set (i.e. the two-qubit interaction). But here, you're explicitly stating that that interaction is present. So, the theory claims it makes no difference; you can always do anything you want.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I expect that in practice (although I'm not an experimentalist), the difference comes down to the error mechanisms, which will be different between what you might actually describe as 3 different settings: two qubits $\mathbb{C}^2\otimes\mathbb{C}^2$, a single spin $\mathbb{C}^4$, or the Hilbert space structure implied by the two-qubit interaction you mentioned, $\mathbb{C}\oplus\mathbb{C}^3$. The energy levels in each case are quite different, which will affect the relaxation properties, and presumably more general interactions with the environment as well.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-04-26T01:24:07.957" CommentCount="2" />
  <row Id="1929" PostTypeId="1" CreationDate="2018-04-26T09:23:24.410" Score="4" ViewCount="88" Body="&lt;p&gt;In quantum computation, a common operation performed between two quantum states is the tensor product, which allows us to create a new and higher-dimensional state from two lower-dimensional states. The tensor product is usually denoted by the symbol $\otimes$. So, if $\lvert \psi\rangle = \alpha \lvert 0\rangle + \beta \lvert 1\rangle \in \mathbb{C}^n$ and $\lvert \phi\rangle = \gamma \lvert 0\rangle + \delta \lvert 1\rangle \in \mathbb{C}^n$ are the states of two qubits, then $\lvert \psi\rangle \otimes \lvert \phi\rangle \in \mathbb{C}^{n^2}$ is their tensor product.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I have just come across the notation $\lvert \mathbf{x}, 0\rangle$ while reading &lt;a href=&quot;http://pages.cs.wisc.edu/~dieter/Courses/2010f-CS880/Scribes/04/lecture04.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;section $1$ of this paper&lt;/a&gt;. What does it mean? I understood $\mathbf{x}$ is a (classical) bit string of length $n$ (and I think this the reason it's in bold).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am aware of the fact that the tensor product of two vectors $\lvert \psi\rangle$ and $\lvert \phi\rangle$ can be shortened as follows $\lvert \psi\rangle \lvert \phi\rangle$. So, I don't think $\lvert \mathbf{x}, 0\rangle$ is also a shorthand for $\lvert \mathbf{x} \rangle \otimes\lvert 0\rangle$. &lt;/p&gt;&#xA;" OwnerUserId="72" LastActivityDate="2018-04-26T11:20:45.437" Title="What do we mean by the notation $\lvert \mathbf{x}, 0\rangle$?" Tags="&lt;qubit&gt;&lt;qubit-state&gt;&lt;notation&gt;&lt;tensor-product&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="1930" PostTypeId="2" ParentId="1929" CreationDate="2018-04-26T09:43:22.060" Score="3" Body="&lt;p&gt;Yes, $|\mathbf{x},0\rangle$ is a shorthand for $|\mathbf x\rangle\otimes |0\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that $|\mathbf x\rangle$ itself, with $\mathbf x = x_1x_2\dots x_N$ a bit string, is just a shorthand for&#xA;$$&#xA;|\mathbf x\rangle \equiv |x_1\rangle \otimes &#xA;|x_2\rangle \otimes\cdots&#xA;|x_N\rangle\ .&#xA;$$&lt;/p&gt;&#xA;" OwnerUserId="491" LastEditorUserId="491" LastEditDate="2018-04-26T11:20:45.437" LastActivityDate="2018-04-26T11:20:45.437" CommentCount="5" />
  <row Id="1931" PostTypeId="1" AcceptedAnswerId="1932" CreationDate="2018-04-26T12:10:43.443" Score="3" ViewCount="78" Body="&lt;p&gt;I recently read hand-written notes about the &quot;secret mask&quot; or &quot;secret string&quot; algorithm (which I can't share here) with the following notation $\lvert \underline{x} \rangle$, i.e. a letter with a line under it. What could it mean? &lt;/p&gt;&#xA;" OwnerUserId="72" LastEditorUserId="72" LastEditDate="2018-04-26T15:34:43.350" LastActivityDate="2018-04-26T15:34:43.350" Title="What does the notation $\lvert \underline{x} \rangle$ mean?" Tags="&lt;notation&gt;&lt;quantum-state&gt;" AnswerCount="1" CommentCount="4" FavoriteCount="1" />
  <row Id="1932" PostTypeId="2" ParentId="1931" CreationDate="2018-04-26T12:59:20.353" Score="2" Body="&lt;p&gt;It probably means that you take $x$ to be a binary string, $x\in\{0,1\}^n$ where you're talking about a system of $n$ qubits. The underline probably isn't necessary (it's hard to tell without more context), but just conveys that you &lt;em&gt;could&lt;/em&gt; think of it as a vector, i.e. if $x=011010$, you could think of it as a vector $\underline{x}=(0,1,1,0,1,0)$. You don't always have to, it depends what you're going to do with it. Generally you only have to think about $x$ as a binary string. However, there are certain operations where it might help to think about it as a vector. For instance, the Hadamard transform can be written has&#xA;$$&#xA;H^{\otimes n}=\frac{1}{\sqrt{2^n}}\sum_{x,z\in\{0,1\}^n}(-1)^{x\cdot z}|x\rangle\langle z|,&#xA;$$&#xA;where you calculate $x\cdot z$ using the usual inner product for vectors. So, it can help to draw attention to the fact that you're using them like that by underlining them. Whether or not you do that largely depends on mood! For example, you can see that I haven't chosen to do it.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-04-26T13:10:53.577" LastActivityDate="2018-04-26T13:10:53.577" CommentCount="2" />
  <row Id="1934" PostTypeId="5" CreationDate="2018-04-26T15:14:06.107" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-26T15:14:06.107" LastActivityDate="2018-04-26T15:14:06.107" CommentCount="0" />
  <row Id="1935" PostTypeId="4" CreationDate="2018-04-26T15:14:06.107" Score="0" Body="For question about Quantum Merlin Arthur (QMA), a computational complexity class. QMA is the 'quantum analogue' of NP, that is QMA is to BQP as NP is to P." OwnerUserId="253" LastEditorUserId="253" LastEditDate="2018-04-26T19:17:18.913" LastActivityDate="2018-04-26T19:17:18.913" CommentCount="0" />
  <row Id="1936" PostTypeId="2" ParentId="1887" CreationDate="2018-04-26T17:00:54.023" Score="3" Body="&lt;p&gt;To answer your question, if there is an actual field of research, &lt;a href=&quot;https://arxiv.org/abs/1503.02515&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Information Biology (QIB)&lt;/a&gt; seems to fit what you are looking for. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Once &lt;a href=&quot;https://link.springer.com/article/10.1007%2Fs10701-015-9929-y&quot; rel=&quot;nofollow noreferrer&quot;&gt;a textbook has been written&lt;/a&gt; on a subject I think it is fair to classify it as a valid research field. Also you may consider &lt;a href=&quot;http://rsta.royalsocietypublishing.org/content/356/1743/1869&quot; rel=&quot;nofollow noreferrer&quot;&gt;the controversial Penrose–Hameroff ‘Orch OR‘ model&lt;/a&gt; to fall into this category, and maybe even the no less controversial research on &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_cognition&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Cognition&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But you seem to be most interested in learning from biology for QIS which is what &lt;a href=&quot;https://www.oxfordmartin.ox.ac.uk/research/programmes/quantum&quot; rel=&quot;nofollow noreferrer&quot;&gt;the Oxford Martin Programme on Bio-Inspired Quantum Technologies&lt;/a&gt; is investigating. &lt;strong&gt;A word of caution though&lt;/strong&gt;, if you look at &lt;a href=&quot;https://www.oxfordmartin.ox.ac.uk/research/programmes/quantum/publications&quot; rel=&quot;nofollow noreferrer&quot;&gt;their publications&lt;/a&gt; they appear to be mostly &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_biology&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Biology&lt;/a&gt;. To my knowledge no actual Quantum Information processing has been experimentally demonstrated to take place in biological systems.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And while there is no doubt that engineering and technology can often been inspired, and improved upon, by mimicking biology, I don't think this hypothesis is necessarily a foregone conclusion when it comes to quantum computing or quantum technologies.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Take photosynthesis for example. It is an incredibly well working process, arguably the most important life sustaining one on earth, but as you can tell from the color of leafs it only uses a small part of the sun light's spectrum. That is why &lt;a href=&quot;https://en.wikipedia.org/wiki/Photosynthetic_efficiency&quot; rel=&quot;nofollow noreferrer&quot;&gt;it is not very efficient&lt;/a&gt;. It only converts 3%-6% of the incoming light to energy that can be used by the plant. The best solar cells are pushing beyond 40% efficiency. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;So while these research fields are widely exciting, I don't see Quantum Biocomputing to happen anytime soon.&lt;/p&gt;&#xA;" OwnerUserId="1375" LastEditorUserId="1375" LastEditDate="2018-04-26T17:06:03.803" LastActivityDate="2018-04-26T17:06:03.803" CommentCount="0" />
  <row Id="1937" PostTypeId="1" AcceptedAnswerId="1941" CreationDate="2018-04-27T08:10:17.447" Score="16" ViewCount="989" Body="&lt;p&gt;I've read in many sources and books on &lt;em&gt;adiabatic quantum computation&lt;/em&gt; (AQC) that it is crucial for the &lt;em&gt;initial Hamiltonian&lt;/em&gt; $\hat{H}_i$ to not commute with the &lt;em&gt;final Hamiltonian&lt;/em&gt; $\hat{H}_f$, i.e. $\left[\hat{H}_i,\hat{H}_f\right]\neq 0$. But I've never seen an argument to why it's so important. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we assume a linear time dependence the Hamiltonian of the AQC is&#xA;$$&#xA;\hat{H}\left(t\right)~=~\left(1-\frac{t}{\tau}\right)\hat{H}_i+\frac{t}{\tau}\hat{H}_f, &#xA;\qquad \left(0\leq t\leq \tau \right)&#xA;$$&#xA;where $\tau$ is the adiabatic time scale.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So my &lt;strong&gt;question&lt;/strong&gt; is: Why is it crucial that the initial Hamiltonian does not commute with the final Hamiltonian?&lt;/p&gt;&#xA;" OwnerUserId="2136" LastEditorUserId="23" LastEditDate="2018-04-27T10:59:05.970" LastActivityDate="2018-07-02T07:13:26.463" Title="Why is it crucial that the initial Hamiltonian does not commute with the final Hamiltonian in adiabatic quantum computation?" Tags="&lt;quantum-annealing&gt;&lt;adiabatic-model&gt;" AnswerCount="4" CommentCount="0" FavoriteCount="4" />
  <row Id="1938" PostTypeId="2" ParentId="1937" CreationDate="2018-04-27T08:30:22.697" Score="3" Body="&lt;p&gt;In the context of Ising optimizers having an initial Hamiltonian that commutes with the problem Hamiltonian means it is essentially products of $\sigma^Z$ operators, which means that its eigenstates are classical bitstrings. Hence the groundstate at the beginning ($t$=0) will be classical as well, not a superposition of all possible bitstrings.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Moreover, even going beyond the strict boundaries of AQC (e.g. open-system quantum annealing, QAOA etc.) if the driving Hamiltonian commutes then it cannot induce transitions between the eigenstates of the problem Hamiltonian but only change the phase of the amplitudes in the wavefunction; and you want a driver which is able to induce spin-flips in order to explore the search space.&lt;/p&gt;&#xA;" OwnerUserId="410" LastActivityDate="2018-04-27T08:30:22.697" CommentCount="0" />
  <row Id="1939" PostTypeId="1" AcceptedAnswerId="1960" CreationDate="2018-04-27T09:58:07.370" Score="6" ViewCount="182" Body="&lt;p&gt;On page 157 of Kaye, Laflamme and Mosca they write that in Grover's algorithm we need to apply Grover's iterate a total of:&#xA;$$\Big\lfloor \frac{\pi}{4} \sqrt{N}\Big\rfloor$$&#xA;(They actually wrote $\Big\lfloor \frac{\pi}{4} \frac{1}{\sqrt{N}}\Big\rfloor$ but I assume the above is what is intended.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is why the floor? Would it not be better to go to the nearest integer - since if e.g. $ \frac{\pi}{4} \sqrt{N}=5.9999$ it would seem a bit silly to do $5$ rather then $6$ iterations. &lt;/p&gt;&#xA;" OwnerUserId="2015" LastEditorUserId="2015" LastEditDate="2018-04-27T10:37:07.753" LastActivityDate="2018-05-06T15:51:20.227" Title="Grover's Algorithm - why do we floor" Tags="&lt;grovers-algorithm&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="1940" PostTypeId="1" AcceptedAnswerId="1964" CreationDate="2018-04-27T10:01:11.743" Score="13" ViewCount="120" Body="&lt;p&gt;On the surface, quantum algorithms have little to do with classical computing and P vs NP in particular: Solving problems from NP with quantum computers tells us nothing about the relations of these classical complexity classes&lt;sup&gt;1&lt;/sup&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;On the other hand, the 'alternative description' of the classical complexity class PP as the class PostBQP presented in &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0412187&quot; rel=&quot;noreferrer&quot;&gt;this paper&lt;/a&gt; is, as far as I'm aware, considered as an important result &lt;em&gt;for&lt;/em&gt; 'classical complexity', &lt;em&gt;by&lt;/em&gt; 'quantum complexity'.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In fact, Scott Aaronson, the author of the paper, writes at the end of the abstract:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;This illustrates that quantum computing can yield new and simpler proofs of major results about classical computation. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Hence, my question is: are there results from the field of quantum complexity that 'simplify' the P vs NP problem, similar to the quantum description of PP? If there are no such results, is there a good reason to not expect these results, despite the 'success' for PP?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sub&gt;1: Take the answer to this question, for example: &lt;a href=&quot;https://cs.stackexchange.com/questions/73864/&quot;&gt;Would the P vs. NP problem become trivial as a result of the development of universal quantum computers?&lt;/a&gt;&lt;/sub&gt;&lt;/p&gt;&#xA;" OwnerUserId="253" LastActivityDate="2018-05-23T10:19:21.220" Title="Are there results from quantum algorithms or complexity that lead to advances on the P vs NP problem?" Tags="&lt;quantum-algorithms&gt;&lt;complexity-theory&gt;" AnswerCount="1" CommentCount="1" FavoriteCount="2" />
  <row Id="1941" PostTypeId="2" ParentId="1937" CreationDate="2018-04-27T11:26:02.603" Score="11" Body="&lt;p&gt;In adiabatic QC, you encode your problem in a Hamiltonian such that your result can be extracted from the ground state. Preparing that ground state is hard to do directly, so you instead prepare the ground state of an 'easy' Hamiltonian, and then slowly interpolate between the two. If you go slow enough, the state of your system will stay in the ground state. At the end of your process, you'll have the solution.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This works according to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Adiabatic_theorem&quot; rel=&quot;noreferrer&quot;&gt;Adiabatic theorem&lt;/a&gt;. For the theorem to hold, there must be an energy gap between the ground state and the first excited state. The smaller the gap becomes, the slower you need to interpolate to prevent mixing between the ground state and first excited states. If the gap closes, such mixing cannot be prevent, and you can't go slow enough. The procedure fails at that point.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If the initial and final Hamiltonian commute, it means they have the same energy eigenstates. So they agree on which states get assigned energy, and only disagree on the energies they get. Interpolating between the two Hamiltonians just changes the energies. The final ground state would therefore have been an excited state at the beginning, and the original ground state becomes excited at the end. At some point, when passing by each other, the energies of these states will be be equal, and so the gap between them closes. This is sufficient to see that the energy gap must close at some point.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Having non-commuting Hamiltonians is therefore a necessary condition of keeping the gap open, and hence for AQC.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-04-27T11:26:02.603" CommentCount="1" />
  <row Id="1942" PostTypeId="2" ParentId="1937" CreationDate="2018-04-27T11:27:49.733" Score="3" Body="&lt;p&gt;If two matrices (in this case, Hamiltonians) commute, they have the same eigenvectors. So, if you prepare a ground state of the first Hamiltonian, then that will (roughly speaking) remain an eigenstate throughout the whole adiabatic evolution, and so you get out just what you put in. There's no value to it.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you want to be a little more strict, then it could be that your initial Hamiltonian has a degeneracy which is lifted by the second Hamiltonian, and you might be hoping to cause the system to evolve into the unique ground state. Note, however, that the degeneracy is lifted the instant there's a non-zero amount of the second Hamiltonian. Whatever effect it can have is an instantaneous one. I believe that you don't get a proper adiabatic evolution. Instead, you have to write your initial state as a superposition of the new eigenstates, and these start to evolve over time, but you never increase the overlap of your state with the target state (the ground state).&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-04-27T11:27:49.733" CommentCount="2" />
  <row Id="1944" PostTypeId="2" ParentId="1939" CreationDate="2018-04-27T17:19:15.173" Score="1" Body="&lt;p&gt;Using floor is logical as a general recommendation to build a Grover's algorithm circuit, because it means that we need less gates compared with ceiling.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Grover's algorithm is probabilistic; the probability of obtaining correct result grows until we reach about $\pi/4\sqrt{N}$ iterations, and starts decreasing after that number. For large $N$ the probability of obtaining correct result is very close to $1$ if the number of iterations is close to $\pi/4\sqrt{N}$; exact number of iterations does not matter given it is close to $\pi/4\sqrt{N}$.&lt;/p&gt;&#xA;" OwnerUserId="2105" LastEditorUserId="2105" LastEditDate="2018-05-06T15:51:20.227" LastActivityDate="2018-05-06T15:51:20.227" CommentCount="0" />
  <row Id="1945" PostTypeId="1" AcceptedAnswerId="1954" CreationDate="2018-04-27T17:53:00.170" Score="5" ViewCount="57" Body="&lt;p&gt;Suppose we have a quantum system $Q$ with an initial state $\rho^{(Q)}$. The measurement process will involve two additional quantum systems: an apparatus system $A$ and an environment system $E$. We suppose that the system $Q$ is initially prepared in the state $\rho_{k}^{(Q)}$ with a priori probability $p_k$. The state of the apparatus $A$ and environment $E$ is $\rho_{0}^{(AE)}$, independent of the preparation of $Q$. The initial state of the entire system given the $k$th preparation for $Q$ is $$\rho_{k}^{(AEQ)} = \rho_{0}^{(AE)} \otimes \rho_{k}^{(Q)}.$$ Averaging over the possible preparations, we obtain $$\rho^{(AEQ)} = \sum_{k} p_{k} \rho_{k}^{(AEQ)}. $$  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In quantum information theory, the accessible information of a quantum system is given by $$\chi := S(\rho) - \sum_{j}P_{j}S(\rho_{j}),$$ where $S$ is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Von_Neumann_entropy&quot; rel=&quot;noreferrer&quot;&gt;von Neumann entropy&lt;/a&gt; of the quantum state. How can we show that if $\rho_{0}^{(AE)}$ is independent of the preparation $k$, that $$\chi^{(AEQ)} = \chi^{(Q)}?$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thanks for any assistance.&lt;/p&gt;&#xA;" OwnerUserId="2032" LastEditorUserId="2032" LastEditDate="2018-04-27T17:59:12.117" LastActivityDate="2018-04-28T09:25:33.367" Title="Accessible information of system vs system, apparatus and environment" Tags="&lt;measurement&gt;&lt;quantum-information&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="1946" PostTypeId="5" CreationDate="2018-04-27T19:54:43.910" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-27T19:54:43.910" LastActivityDate="2018-04-27T19:54:43.910" CommentCount="0" />
  <row Id="1947" PostTypeId="4" CreationDate="2018-04-27T19:54:43.910" Score="0" Body="For questions regarding applications of quantum computing and quantum information theory in quantum chemistry" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-27T20:40:01.863" LastActivityDate="2018-04-27T20:40:01.863" CommentCount="0" />
  <row Id="1948" PostTypeId="5" CreationDate="2018-04-27T19:55:42.847" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-04-27T19:55:42.847" LastActivityDate="2018-04-27T19:55:42.847" CommentCount="0" />
  <row Id="1949" PostTypeId="4" CreationDate="2018-04-27T19:55:42.847" Score="0" Body="In quantum information theory, superdense coding is a technique that allows increasing the classical information content that can be encoded within a number of qubits" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-04-27T20:39:48.220" LastActivityDate="2018-04-27T20:39:48.220" CommentCount="0" />
  <row Id="1952" PostTypeId="1" AcceptedAnswerId="1957" CreationDate="2018-04-28T04:26:08.697" Score="9" ViewCount="184" Body="&lt;p&gt;Quantum Annealing, (related questions &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1595/what-precisely-is-quantum-annealing&quot;&gt;Quantum Annealing&lt;/a&gt;, or &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1937/why-is-it-crucial-that-the-initial-hamiltonian-does-not-commute-with-the-final-h&quot;&gt;hamiltonian related&lt;/a&gt;) is the process used in D-Waves' Quantum Annealer, in which the energy landscapes are explored, for different solutions, and by tuning a suitable Hamiltonian, zero in to a possible optimal solution to a problem. The process of Quantum Annealing reduces &quot;transverse magnetic fields&quot; in the Hamiltonian, in addition to other quantum effects like quantum tunnelling, entanglement, and superposition, which in turn all play a part in zeroing to a &quot;valley&quot; of a quantum mechanical wave function, where the &quot;most likely&quot; solution lies.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The process of Reverse Annealing, very briefly, is to use classical methods such as Simulated Annealing, to find a solution, and hone into a valley using Quantum Annealing. If the Hamiltonian used by the Quantum Annealer is already in  a &quot;valley&quot;, as it is being passed a solution in the first place -Does the D-Wave machine reach another &quot;valley&quot;( a better solution?) using the Hamiltonian passed to it, in the first place? &lt;/p&gt;&#xA;" OwnerUserId="429" LastEditorUserId="26" LastEditDate="2018-05-04T13:23:11.800" LastActivityDate="2018-06-13T09:42:50.000" Title="What precisely is Reverse Annealing?" Tags="&lt;d-wave&gt;&lt;quantum-annealing&gt;&lt;adiabatic-model&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="1953" PostTypeId="2" ParentId="1701" CreationDate="2018-04-28T09:02:02.400" Score="1" Body="&lt;p&gt;Let me go for a &lt;em&gt;self-learner&lt;/em&gt; experience. After some reading, my short answer to my own question&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Would the calculation of the loss of entanglement be necessarily related to delocalized vibrational modes that simultaneously involve the local environment of both triplets?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;is: &lt;strong&gt;probably yes, but not &lt;em&gt;necessarily/primarily&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A longer answer follows. With a previous familiarity with decoherence but non-familiarity with disentanglement, this paper was extremely helpful: &lt;a href=&quot;http://iopscience.iop.org/article/10.1088/1361-648X/aab98d/pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Entanglement loss in molecular quantum-dot qubits due to interaction with the environment&lt;/a&gt; (Enrique P Blair et al, 2018, J. Phys.: Condens. Matter, 30, 195602). The physical scenario is not identical, but allows for a few key insights:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Like coherence, &lt;strong&gt;entanglement is maintained by default&lt;/strong&gt;, not by a process, which is to say: we only need to look for processes explicitly destroying it. This is whay one gets better numbers for entangled photons compared with solid state qubits, see &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1840/what-is-the-maximum-separation-between-two-entangled-qubits-that-has-been-achiev&quot;&gt;What is the maximum separation between two entangled qubits that has been achieved experimentally?&lt;/a&gt; &lt;/li&gt;&#xA;&lt;li&gt;From the above point (and from the paper above), let us first consider the case where two qubits are far enough to avoid interaction among each other, and also to avoid interaction with a common environment. &lt;strong&gt;For thus isolated qubits just by accounting for decoherence we will fully account for disentanglement&lt;/strong&gt;.&lt;/li&gt;&#xA;&lt;li&gt;Entanglement is exclusivity: entanglement between two parties is gradually lost as these parties entangle more and more with other parties. So, with entanglement between two qubits -as with coherence of one qubit- the primary focus of our attention should be how does the qubit interact with its environment. In the case under consideration: with the spin bath and the phonon bath. &lt;strong&gt;The same processes that destroy coherence will destroy entanglement, essentially at the same rate&lt;/strong&gt;. For details, calculate fidelities and/or entanglement witnesses.&lt;/li&gt;&#xA;&lt;li&gt;If the two qubits are not perfectly isolated from each other, there is an interaction between them, which can be direct or via a common environment. In that case, the two qubits can experience a collective evolution which, beyond affecting their individual coherence, also alters their entanglement. This is what the question is asking, and here the answer would be a conditional yes. &lt;strong&gt;Collective vibrational modes affecting both qubits need to be considered, since they promote a collective evolution that can either create or destroy entanglement&lt;/strong&gt;.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="1847" LastActivityDate="2018-04-28T09:02:02.400" CommentCount="0" />
  <row Id="1954" PostTypeId="2" ParentId="1945" CreationDate="2018-04-28T09:25:33.367" Score="6" Body="&lt;p&gt;For density matrices $\rho_A$ and $\rho_B$ having eigenvalues $\lambda^{\left(A\right)}$ and $\lambda^{\left(B\right)}$, \begin{align}S\left(\rho_A\otimes\rho_B\right) &amp;amp;= -\rho_A\otimes\rho_B\ln\left(\rho_A\otimes\rho_B\right)\\&#xA;&amp;amp;= -\sum_{j, k}\lambda^{\left(A\right)}_j\lambda^{\left(B\right)}_k\ln\left(\lambda^{\left(A\right)}_j\lambda^{\left(B\right)}_k\right)\\&#xA;&amp;amp;= -\sum_{j, k}\left[\lambda^{\left(A\right)}_j\lambda^{\left(B\right)}_k\ln\left(\lambda^{\left(A\right)}_j\right) + \lambda^{\left(A\right)}_j\lambda^{\left(B\right)}_k\ln\left(\lambda^{\left(B\right)}_k\right)\right]\\&#xA;&amp;amp;= -\sum_j\lambda^{\left(A\right)}_j\ln\left(\lambda^{\left(A\right)}_j\right)\sum_k\lambda^{\left(B\right)}_k - \sum_j\lambda^{\left(A\right)}_j\sum_k\lambda^{\left(B\right)}_k\ln\left(\lambda^{\left(B\right)}_k\right)\\&#xA;&amp;amp;= -\sum_j\lambda^{\left(A\right)}_j\ln\left(\lambda^{\left(A\right)}_j\right) - \sum_k\lambda^{\left(B\right)}_k\ln\left(\lambda^{\left(B\right)}_k\right)\\&#xA;&amp;amp;= S\left(\rho_A\right) + S\left(\rho_B\right).&#xA;\end{align}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This gives&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{align}&#xA;\chi^{\left(AEQ\right)} &amp;amp;= S\left(\rho^{\left(AEQ\right)}\right) - \sum_jp_jS\left(\rho_j^{\left(AEQ\right)}\right)\\&#xA;&amp;amp;=S\left(\rho^{\left(AE\right)}\right) + S\left(\rho^{\left(Q\right)}\right) - \sum_jp_j\left(S\left(\rho^{\left(AE\right)}\right) + S\left(\rho_j^{\left(Q\right)}\right)\right)\\&#xA;&amp;amp;= S\left(\rho^{\left(AE\right)}\right) + S\left(\rho^{\left(Q\right)}\right) - \sum_jp_jS\left(\rho^{\left(AE\right)}\right) -\sum_jp_jS\left(\rho_j^{\left(Q\right)}\right).&#xA;\end{align}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As $\sum_jp_j = 1$, it follows that $$\chi^{\left(AEQ\right)} = S\left(\rho^{\left(Q\right)}\right)-\sum_jp_jS\left(\rho_j^{\left(Q\right)}\right) = \chi^{\left(Q\right)}$$&lt;/p&gt;&#xA;" OwnerUserId="23" LastActivityDate="2018-04-28T09:25:33.367" CommentCount="2" />
  <row Id="1955" PostTypeId="1" AcceptedAnswerId="1970" CreationDate="2018-04-28T09:40:25.543" Score="8" ViewCount="172" Body="&lt;p&gt;I am trying to build a quantum computation library as my university project. I am still learning all the aspects of the Quantum Computing field. I know there are efficient libraries already for quantum emulation. I just want to make my own, which will help me to grasp some of the core concepts of Quantum Computing.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I know that $n$ qubits can be stored with a $2^n$ element complex array. Also, a $n$ qubit gate is a $2^n \times 2^n$ 2D array. So, the following are my doubts (mostly related to entanglement):&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;When do I need to find the tensor product of gates (like $I \otimes H \otimes I$, for a $3$ qubit system)? Is it always necessary to compute the tensor product of order $2^n \times 2^n$, even if the qubits are not entangled?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;With only a $2^n$ element array (which I store the coefficients), can I actually somehow calculate which qubits are entangled? Or do I need to make another data structure to store the entanglement information of my $n$ qubits (about which qubits are entangled)?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Is my 2nd question actually relevant? Do I need to keep track of the entanglement information at all? I mean, I don't know whether multiplying gates with coefficients is enough  (even if the system is entangled). Maybe it is relevant at the time of measurement only.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="2060" LastEditorUserId="253" LastEditDate="2018-05-01T12:54:36.133" LastActivityDate="2018-05-03T06:07:52.143" Title="How to keep track of entanglements when emulating quantum computation?" Tags="&lt;quantum-entanglement&gt;&lt;tensor-product&gt;&lt;emulation&gt;" AnswerCount="1" CommentCount="12" FavoriteCount="1" />
  <row Id="1956" PostTypeId="2" ParentId="1" CreationDate="2018-04-29T16:17:28.470" Score="2" Body="&lt;p&gt;To complete what others have said: as far as we know &lt;strong&gt;a (classical) Turing machine cannot truly simulate quantum correlations&lt;/strong&gt;. This is explicitly claimed in section &lt;em&gt;Properties of the universal quantum computer&lt;/em&gt; by the seminal paper by David Deutsch &lt;a href=&quot;https://web.archive.org/web/20081123183419/http://www.ceid.upatras.gr/tech_news/papers/quantum_theory.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum theory, the Church-Turing principle and the universal quantum computer&lt;/a&gt; (Proceedings of the Royal Society of London A&#xA;400, pp. 97-117 (1985)).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Details will depend on the implementation or on your exact definitions for Turing machine, of quantum computer, and especially of &lt;em&gt;simulate&lt;/em&gt; (if you are generous enough with what &lt;em&gt;simulates&lt;/em&gt; mean, anything can simulate anything). Generally speaking, it is possible to design a quantum computer which, when repeatedly operated by starting from the exact same starting state (or input bits), in every operation generates random output bits which present certain quantum correlations with each other. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;As far as I know, a Turing machine cannot do that.&lt;/p&gt;&#xA;" OwnerUserId="1847" LastActivityDate="2018-04-29T16:17:28.470" CommentCount="1" />
  <row Id="1957" PostTypeId="2" ParentId="1952" CreationDate="2018-04-29T19:47:32.247" Score="4" Body="&lt;p&gt;Until recently, D-Wave's quantum annealing devices always started from a uniform superposition over all $N$ qubits:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$H_{initial} = |+\rangle_0 \otimes |+\rangle_1 ... \otimes |+\rangle_N$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;where $|+\rangle_i = \frac{1}{\sqrt{2}} (|0\rangle_i + |1\rangle_i)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So let's suppose you already ran a few anneals with this setup and one of the low-energy results looks like a relatively good solution (some local optima) to your optimization problem. Until the very recent introduction of the &lt;em&gt;reverse annealing&lt;/em&gt; feature, it was impossible to use this solution as input for the next anneal in order to explore the local space around that solution for bitstrings with even lower energy. Hence, &lt;em&gt;reverse annealing&lt;/em&gt; allows us to initialize the quantum annealer with a known (classical) solution and search the state space around this local optima.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When exploring complicated (rugged) energy landscapes of optimization problems you need to balance the global &lt;em&gt;exploration&lt;/em&gt; of the state space with the &lt;em&gt;exploitation&lt;/em&gt; of local optima. In traditional (D-Wave) quantum annealing, we start with a high transverse field which then gets gradually decreased as you described in your question. D-Wave's quantum annealer was thereby performing a global search (due to a lot of quantum tunneling) at the beginning of the annealing schedule when the transverse field is strong. As the transverse field gets weaker, the search gets more and more local. In contrast, &lt;em&gt;reverse annealing&lt;/em&gt; starts with a classical solution defined by the user, then gradually increases the transverse field (backward annealing) to then decrease the transverse field again (forward annealing).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This introduces the new parameter &lt;em&gt;reversal distance&lt;/em&gt; which determines how far you want to anneal backward (how strong the transverse field should become). D-Wave published the following two plots in this &lt;a href=&quot;https://www.dwavesys.com/sites/default/files/14-1018A-A_Reverse_Quantum_Annealing_for_Local_Refinement_of_Solutions.pdf&quot; rel=&quot;noreferrer&quot;&gt;D-Wave Whitepaper&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/fydS0.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/fydS0.png&quot; alt=&quot;reversal distance plots&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the left plot you can see that reversal distance is a very important new hyperparameter since its value determines the probability of obtaining a new ground state (blue region). If the reversal distance is too low, you will get the &lt;em&gt;same&lt;/em&gt; state you started with (red region) which would be useless. And of course if you reverse anneal for too long you essentially perform traditional quantum annealing and loose the information that you started with. Remember that too much transverse field means that we are performing global search again!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The right plot shows essentially the same thing by plotting &lt;a href=&quot;https://en.wikipedia.org/wiki/Hamming_distance&quot; rel=&quot;noreferrer&quot;&gt;Hamming distance&lt;/a&gt; against reversal distance and the probability of obtaining a new ground state. For your problem at hand, you want to find that sweet spot (maxima of the red curve). For large reversal distances we again see that we get solution strings that are far from our initial state in terms of Hamming distance.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;All in all, &lt;em&gt;reverse annealing&lt;/em&gt; is pretty new stuff and to the best of my knowledge there are no published papers about its effectiveness. In their &lt;a href=&quot;https://www.dwavesys.com/sites/default/files/14-1018A-A_Reverse_Quantum_Annealing_for_Local_Refinement_of_Solutions.pdf&quot; rel=&quot;noreferrer&quot;&gt;Whitepaper&lt;/a&gt;, D-Wave claims the generation of 'new global optima up to&#xA;150 times faster than forward quantum annealing'.&lt;/p&gt;&#xA;" OwnerUserId="1234" LastActivityDate="2018-04-29T19:47:32.247" CommentCount="0" />
  <row Id="1958" PostTypeId="1" CreationDate="2018-04-30T04:17:42.940" Score="8" ViewCount="78" Body="&lt;p&gt;I have heard various talks at my institution from experimentalists (who all happened to be working on superconducting qubits) that the textbook idea of true &quot;Projective&quot; measurement is not what happens in real-life experiments. Each time I asked them to elaborate, and they say that &quot;weak&quot; measurements are what happen in reality.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I assume that by &quot;projective&quot; measurements they mean a measurement on a quantum state like the following:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$P\vert\psi\rangle=P(a\vert\uparrow\rangle+ b\vert\downarrow\rangle)=\vert\uparrow\rangle \,\mathrm{or}\, \vert\downarrow\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In other words, a measurement which fully collapses the qubit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, if I take the experimentalist's statement that real measurements are more like strong &quot;weak&quot;-measurements, then I run into Busch's theorem, which says roughly that you only get as much information as how strongly you measure. In other words, I can't get around not doing a full projective measurement, I need to do so to get the state information&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, I have two main questions:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Why is it thought that projective measurements cannot be performed experimentally? What happens instead?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;What is the appropriate framework to think about experimental measurement in quantum computing systems that is actually realistic? Both a qualitative and quantitative picture would be appreciated.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="2260" LastEditorUserId="2260" LastEditDate="2018-04-30T05:51:00.153" LastActivityDate="2018-04-30T20:37:53.083" Title="Are true Projective Measurements possible experimentally?" Tags="&lt;measurement&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="1" />
  <row Id="1959" PostTypeId="2" ParentId="1924" CreationDate="2018-04-30T06:16:26.210" Score="1" Body="&lt;p&gt;I think your reference has the answer: nitrogen vacancy centers in diamond, where you can do one qubit gates at room temperature. In fact, even higher temperatures are possible, but you will have to play a tradeoff between fidelity and temperature at some point. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;That said, NV centers are not scalable, and I don't think more than 2 qubits will ever be really possible due to the physical problems with interacting immobile NV centers which are randomly distributed. &lt;/p&gt;&#xA;" OwnerUserId="2260" LastEditorUserId="2260" LastEditDate="2018-04-30T06:33:12.720" LastActivityDate="2018-04-30T06:33:12.720" CommentCount="3" />
  <row Id="1960" PostTypeId="2" ParentId="1939" CreationDate="2018-04-30T09:36:09.417" Score="4" Body="&lt;p&gt;Applying the Grover iterate a total number of $\lfloor \frac{\pi}{4}\sqrt{N}\rfloor$ times is the best choice if we want to maximize the success probability of Grover's algorithm. This is to some extent explained in Kaye, Laflamme and Mosca (KLM), but let me elaborate on the most important details here.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let $n$ be a natural number, $N = 2^n$, and suppose that we have a function $f : \{0,1\}^n \to \{0,1\}$. Suppose that we can evaluate this function $f$ by a &lt;em&gt;quantum phase oracle&lt;/em&gt; $U_f$ (this is the same operator $U_f$ as described by KLM in equation 8.1.5 on page 155), with the property that for all $i \in \{0,1\}^n$:&#xA;$$U_f : |i\rangle \mapsto (-1)^{f(i)}|i\rangle$$&#xA;Now, we define $G = f^{-1}(\{1\})$ and $B = f^{-1}(\{0\})$. Hence, $G \subseteq \{0,1\}^n$ is the set of all $n$-bit strings that will evaluate to $1$ if we use them as input in $f$. Another way of saying this is $i \in G \Leftrightarrow f(i) = 1$. For the purpose of this question, let's assume that $|G| = 1$, hence there is exactly one $i \in \{0,1\}^n$ such that $f(i) = 1$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Next, we proceed with defining the &lt;em&gt;good&lt;/em&gt; and &lt;em&gt;bad&lt;/em&gt; states, as follows (these are defined by KLM in equation 8.1.3 on page 155):&#xA;$$|\psi_{good}\rangle = \frac{1}{\sqrt{|G|}}\sum_{i \in G}|i\rangle \qquad \text{and} \qquad |\psi_{bad}\rangle = \frac{1}{\sqrt{|B|}}\sum_{i \in B}|i\rangle$$&#xA;Moreover, we define:&#xA;$$|\psi_{uniform}\rangle = \frac{1}{\sqrt{N}}\sum_{i \in \{0,1\}^n}|i\rangle = \sin\theta |\psi_{good}\rangle + \cos\theta |\psi_{bad}\rangle$$&#xA;where $\theta = \arcsin(\sqrt{|G|/N}) = \arcsin(1/\sqrt{N})$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's now devise an intuitive visualization of Grover's algorithm. To that end, consider all the quantum states that can be written as $\alpha|\psi_{good}\rangle + \beta|\psi_{bad}\rangle$ with $|\alpha|^2 + |\beta|^2 = 1$, and let's display them in the following picture.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/qiQPk.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/qiQPk.png&quot; alt=&quot;Visualization of Grover&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We can use the visualization above to understand what Grover's iterate actually does. Grover's iterate does nothing but rotate any state in the circle above over an angle $2\theta$ counterclockwise. Hence, by applying Grover's iterate multiple times, we can rotate states over angles that are multiples of $2\theta$. How this works can be found in KLM, specifically we see the rotation over an angle of $2\theta$ appear in the last equation on page 160.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, suppose that we start with the state $|\psi_{uniform}\rangle$. After  applying $k$ iterations of Grover's iterate, we obtain the state $|\psi_k\rangle$. From the picture, using the intuitive interpretation of Grover's iterate, we can easily see that the angle between $|\psi_k\rangle$ and $|\psi_{bad}\rangle$ is $(2k+1)\theta$. Hence, we find:&#xA;$$|\psi_k\rangle = \sin((2k+1)\theta)|\psi_{good}\rangle + \cos((2k+1)\theta)|\psi_{bad}\rangle$$&#xA;As we want to maximize the success probability, we want our state to be as close to $|\psi_{good}\rangle$ as possible. Hence, we want $(2k+1)\theta$ to be as close to $\frac{\pi}{2}$ as possible. Solving this equation, we obtain:&#xA;$$(2k+1)\theta = \frac{\pi}{2} \Leftrightarrow k = \frac{\pi}{4\theta} - \frac12$$&#xA;Recall that $\theta = \arcsin(1/\sqrt{N})$. By making the assumption that $N$ is big, and using the approximation $\arcsin(x) \approx x$ when $|x| \ll 1$, we obtain that our ideal choice for $k$ would be:&#xA;$$k \approx \frac{\pi}{4}\sqrt{N} - \frac12$$&#xA;But we can only apply Grover's iterate an integer number of times, say $k^*$, so we must find the integer $k^*$ that matches $k$ as closely as possible. Hence, we round the quantity on the RHS to obtain (using the notation explained in the box on page 163 of KLM):&#xA;$$k^* = \left[\frac{\pi}{4}\sqrt{N} - \frac12\right] = \left\lfloor \frac{\pi}{4}\sqrt{N}\right\rfloor$$&#xA;as $[x-\frac12] = \lfloor x\rfloor$ for all real $x$. If we trace back where this $\frac12$ comes from, we can see that it originates from the fact that we already start at an elevated angle of $\theta$ in the circle, even before we apply any of the Grover iterates. The floor, hence, is a deep consequence of the fact that the total angle of rotation doesn't have to be all of $\frac{\pi}{2}$, but rather $\frac{\pi}{2} - \theta$.&lt;/p&gt;&#xA;" OwnerUserId="24" LastEditorUserId="24" LastEditDate="2018-04-30T09:44:12.783" LastActivityDate="2018-04-30T09:44:12.783" CommentCount="0" />
  <row Id="1961" PostTypeId="1" AcceptedAnswerId="1962" CreationDate="2018-04-30T11:49:30.383" Score="6" ViewCount="63" Body="&lt;p&gt;According to (&lt;a href=&quot;https://books.google.es/books?id=6hBq7Un57R0C&amp;amp;printsec=frontcover#v=onepage&amp;amp;q&amp;amp;f=false&quot; rel=&quot;nofollow noreferrer&quot;&gt;Macchiavello, Palma, Zeilinger, 2001; pg82&lt;/a&gt;) a lower bound of the encoding Hilbert space of a &lt;em&gt;non degenerate code&lt;/em&gt; is given by the quantum version of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Hamming_bound&quot; rel=&quot;nofollow noreferrer&quot;&gt;Hamming bound&lt;/a&gt;:&#xA;$$2^k \sum_{i=0}^t 3^i \begin{pmatrix} n \\ i\end{pmatrix}\le 2^n$$&#xA;where we are looking at a $[n,k,2t+1]$ code. Does such a bound exist for a degenerate code? and why is it different (if it indeed is)?&lt;/p&gt;&#xA;" OwnerUserId="2015" LastEditorUserId="26" LastEditDate="2018-05-07T13:17:13.163" LastActivityDate="2018-05-07T13:17:13.163" Title="Lower bound for Degenerate Codes?" Tags="&lt;quantum-error-correction&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="1962" PostTypeId="2" ParentId="1961" CreationDate="2018-04-30T15:40:34.207" Score="7" Body="&lt;p&gt;This bound works by counting the number of orthogonal states that must be available. If you're encoding into $n$ qubits, you can't require more than $2^n$ orthogonal states, because that's all that's available. This is the right hand side of the bound.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you wish to encode $k$ logical qubits in a distance $2t+1$ code, then each of the $2^k$ basis states of those logical qubits must encode to something different. Moreover, you need to be able to correct for up to $t$ errors of type $X$, $Y$ or $Z$. If we require each of these to map to a different orthogonal state, then there are $3n$ possible 1-qubit errors, $3^2\binom{n}{2}$ 2-qubit errors (choice of one of 3 Paulis for each error, and a pair of locations for them to happen at), and so on. So, this gives the stated bound, known as the Quantum Hamming bound (also Gilbert-Varshamov). However, an essential feature of the derivation is the assumption that each error is mapped onto a different orthogonal state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The very definition of a degenerate code is that multiple errors can be mapped onto the same state. As a trivial example, consider the effect of a single-qubit $Z$ error on any one of the qubits of the GHZ state&#xA;$$&#xA;\frac{1}{\sqrt{2}}(|0\rangle^{\otimes n}+|1\rangle^{\otimes n}).&#xA;$$&#xA;No matter where that error happens, the resultant state is the same, but that's fine: I don't need to be able to identify which of the $n$ qubits the error happened on to fix it. Once I know the error has happened, I can apply a $Z$ gate on any of the qubits that I choose in order to fix it. (I don't claim that this example enables you to detect that error.) So, &lt;strong&gt;the Quantum Hamming bound does not apply to degenerate codes&lt;/strong&gt;. Indeed, there are known examples where the bound is beaten, e.g.  &lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.57.830&quot; rel=&quot;noreferrer&quot;&gt;D. P. DiVincenzo, P. W. Shor, and J. A. Smolin, Phys. Rev. A 57, 830 (1998)&lt;/a&gt; (&lt;a href=&quot;https://arxiv.org/abs/quant-ph/9706061&quot; rel=&quot;noreferrer&quot;&gt;free version&lt;/a&gt;), although there are surprisingly few.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The only replacement that I know of is the Quantum Singleton Bound, $n-k\geq 4t$. The Quantum Hamming bound, in practice, appears to give very good estimates of what can be achieved, but is not absolute when it comes to degenerate codes.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-04-30T18:09:01.873" LastActivityDate="2018-04-30T18:09:01.873" CommentCount="0" />
  <row Id="1963" PostTypeId="2" ParentId="1958" CreationDate="2018-04-30T16:56:19.457" Score="5" Body="&lt;p&gt;Let's step back from QC for a moment and think about a textbook example: the projector onto position, $|x\rangle$.  This projective measurement is obviously unphysical, as the eigenstates of $|x\rangle$ are themselves unphysical due to the uncertainty principle.  The real measurement of position, then, is one with some uncertainty.  One can treat this either as a weak measurement of position, or as a projective measurement onto a non-orthonormal basis (a strong POVM), where the various basis elements have some support on multiple values of $x$: say pixels on a detector.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Going back into QC, most systems' measurements are pretty close to projective, or are 'strong' measurements at the least.  In some systems, like ion traps, the readout can be thought of as a series of weak measurements that collectively form a strong one.  A photon counter, on the other hand, is very close to a projective measurement with some odd projectors due to finite efficiency--no click corresponds to a projector onto $|0\rangle + (1-e)^n|n\rangle$, for instance.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;On the other hand, that projector doesn't leave behind the state listed above, because the apparatus also absorbs the photon.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;To sum up, thinking of things as POVMs (Positive operator-valued measures) is probably the most-right intuition, where you can think of the outcomes of the POVM mostly as non-orthonormal projectors.  Non-projective POVMs also exist, but are less common in practice in systems I've thought about.&lt;/p&gt;&#xA;" OwnerUserId="1807" LastEditorUserId="1807" LastEditDate="2018-04-30T20:37:53.083" LastActivityDate="2018-04-30T20:37:53.083" CommentCount="7" />
  <row Id="1964" PostTypeId="2" ParentId="1940" CreationDate="2018-04-30T17:27:07.010" Score="9" Body="&lt;p&gt;I don't think there are clear reasons for a 'yes' or a 'no' answer. However, I can provide a reason why &lt;strong&gt;PP&lt;/strong&gt; was much more likely to admit such a characterisation than &lt;strong&gt;NP&lt;/strong&gt; was, and to give some intuitions for why &lt;strong&gt;NP&lt;/strong&gt; might never have a &lt;em&gt;simple&lt;/em&gt; characterisation in terms of modification of the quantum computational model.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Counting complexity&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;The classes &lt;strong&gt;NP&lt;/strong&gt; and &lt;strong&gt;PP&lt;/strong&gt; can both be characterised in terms of the number of accepting branches of a non-deterministic Turing machine, which we can describe in a more down-to-earth way in terms of the possible outcomes of a randomised computation which uses uniformly random bits. We can then &lt;em&gt;describe&lt;/em&gt; these two classes as:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;em&gt;L&lt;/em&gt;&amp;nbsp;&amp;in;&amp;nbsp;&lt;strong&gt;NP&lt;/strong&gt; if there is a polynomial-time randomised algorithm which outputs a single bit &lt;em&gt;&amp;alpha;&lt;/em&gt;&amp;nbsp;&amp;in;&amp;nbsp;{0,1}, such that &lt;em&gt;x&lt;/em&gt;&amp;nbsp;&amp;in;&amp;nbsp;&lt;em&gt;L&lt;/em&gt; if and only if &lt;strong&gt;Pr&lt;/strong&gt;[&amp;nbsp;&lt;em&gt;&amp;alpha;&lt;/em&gt;&amp;thinsp;=&amp;thinsp;1&amp;nbsp;|&amp;nbsp;&lt;em&gt;x&lt;/em&gt;&amp;nbsp;] is non-zero (though this probability may be tiny), as opposed to zero.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;em&gt;L&lt;/em&gt;&amp;nbsp;&amp;in;&amp;nbsp;&lt;strong&gt;PP&lt;/strong&gt; if there is a polynomial-time randomised algorithm which outputs a single bit &lt;em&gt;&amp;alpha;&lt;/em&gt;&amp;nbsp;&amp;in;&amp;nbsp;{0,1}, such that &lt;em&gt;x&lt;/em&gt;&amp;nbsp;&amp;in;&amp;nbsp;&lt;em&gt;L&lt;/em&gt; if and only if &lt;strong&gt;Pr&lt;/strong&gt;[&amp;nbsp;&lt;em&gt;&amp;alpha;&lt;/em&gt;&amp;thinsp;=&amp;thinsp;1&amp;nbsp;|&amp;nbsp;&lt;em&gt;x&lt;/em&gt;&amp;nbsp;] is greater than 0.5 (though possibly only by the tiniest amount), as opposed to being equal to or less than 0.5 (&lt;em&gt;e.g.&lt;/em&gt;&amp;nbsp;by a tiny amount).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;One way of seeing why these classes can't be practically solved using this probabilistic description, is that it may take exponentially many repeats to be confident of a probability estimate for &lt;strong&gt;Pr&lt;/strong&gt;[&amp;nbsp;&lt;em&gt;&amp;alpha;&lt;/em&gt;&amp;thinsp;=&amp;thinsp;1&amp;nbsp;|&amp;nbsp;&lt;em&gt;x&lt;/em&gt;&amp;nbsp;] because of the tininess of the differences in the probabilities involved.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Gap complexity and quantum complexity&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Let us describe the outcomes '0' and '1' in the above computation as 'reject' and 'accept'; and let us call a randomised branch which gives a reject/accept result, a &lt;em&gt;rejecting&lt;/em&gt; or &lt;em&gt;accepting&lt;/em&gt; branch. Because every branch of the randomised computation which is not accepting is therefore rejecting, &lt;strong&gt;PP&lt;/strong&gt; can also be defined in terms of the difference between the number of accepting and rejecting computational paths &amp;mdash; a quantity which we may call the &lt;em&gt;acceptance gap&lt;/em&gt;: specifically, whether the acceptance gap is positive, or less than or equal to zero. With a little more work, we can obtain an equivalent characterisation for &lt;strong&gt;PP&lt;/strong&gt;, in terms of whether the acceptance gap is greater than some threshold, or less than some threshold, which may be zero or any other efficiently computable function of the input &lt;em&gt;x&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This in turn can be used to characterise languages in &lt;strong&gt;PP&lt;/strong&gt; in terms of quantum computation. From the description of &lt;strong&gt;PP&lt;/strong&gt; in terms of randomised computations having acceptance probabilities (possibly slightly) greater than 0.5, or at most 0.5, all problems in &lt;strong&gt;PP&lt;/strong&gt; admit a polynomial-time quantum algorithm which has the same distinction in acceptance probabilities; and by modelling quantum computations as a sum over computational paths, and simulating these paths using rejecting branches for paths of negative weight and accepting branches of paths of positive weight, we can also show that such a quantum algorithm making a (statistically weak) distinction describes a problem in &lt;strong&gt;PP&lt;/strong&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is not obvious that we can do the same thing for &lt;strong&gt;NP&lt;/strong&gt;. There is no natural way to describe &lt;strong&gt;NP&lt;/strong&gt; in terms of acceptance gaps, and the obvious guess for how you might try to fit it into the quantum computational model &amp;mdash; by asking whether the probability of measuring an outcome '1' is zero, or non-zero &amp;mdash; instead gives you a class called &lt;strong&gt;coC&lt;sub&gt;=&lt;/sub&gt;P&lt;/strong&gt;, which is not known to equal &lt;strong&gt;NP&lt;/strong&gt;, and very roughly could be described as being about as powerful as &lt;strong&gt;PP&lt;/strong&gt; rather than close to &lt;strong&gt;NP&lt;/strong&gt; in power.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Of course, someday one might somehow find a characterisation of &lt;strong&gt;NP&lt;/strong&gt; in terms of acceptance gaps, or one might find new ways of relating quantum computation to counting complexity, but I'm not sure anyone has any convincing ideas of how this might come about.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Summary&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;The prospects for getting insights into the &lt;strong&gt;P&lt;/strong&gt; versus &lt;strong&gt;NP&lt;/strong&gt; problem itself, via quantum computation, are not promising &amp;mdash; though it isn't impossible.&lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-05-23T10:19:21.220" LastActivityDate="2018-05-23T10:19:21.220" CommentCount="1" />
  <row Id="1965" PostTypeId="1" AcceptedAnswerId="1981" CreationDate="2018-04-30T22:44:39.170" Score="6" ViewCount="87" Body="&lt;p&gt;I am trying to understand the HHL algorithm for solving linear systems of equations (Harrow, Hassidim, Lloyd; presented in &lt;a href=&quot;https://arxiv.org/abs/0811.3171&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv:0811.3171&lt;/a&gt; and explained on page 17 of &lt;a href=&quot;https://arxiv.org/abs/1804.03719&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv:1804.03719&lt;/a&gt;). By reading some papers, I think I got rough idea but there are many things I still do not understand. Let me ask some.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When applying Quantum Phase Estimation, in page 49 of &lt;a href=&quot;https://arxiv.org/abs/1804.03719&quot; rel=&quot;nofollow noreferrer&quot;&gt;the same article&lt;/a&gt;, it says &quot;Prepare $n$ register qubits in $|0\rangle^{\bigotimes n}$ state with the vector $|b\rangle$&quot;, so that, by applying QPE to $|b\rangle |0\rangle^{\bigotimes n}$, we can get&#xA;$\sum_j \beta_j |u_j\rangle |\lambda_j\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And $|\lambda_j\rangle$ is the $j^{th}$ eigenvalue of matrix $A$ and $0 &amp;lt; \lambda_j &amp;lt; 1$, and $\left|u_j\right&amp;gt;$ is the corresponding eigenvector.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I also understand $|\lambda_j\rangle$ is the binary representation for fraction of $j^{th}$ eigenvalue of $A$. (i.e. $\left|01\right&amp;gt;$ for $\left|\lambda\right&amp;gt;=1/4$)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My questions are, &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Q1: How to decide $n$, how many qubits to prepare? I assume it is related to the precision of expressing the eigenvalue, but not sure.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Q2: What to do if $\lambda_j$ of $A$ is $≤ 0$ or $≥ 1$?&lt;/p&gt;&#xA;" OwnerUserId="2100" LastEditorUserId="23" LastEditDate="2018-05-01T08:24:58.853" LastActivityDate="2018-05-02T07:29:48.947" Title="HHL algorithm, how to decide n qubits to prepare for expressing eigenvalue of A?" Tags="&lt;quantum-algorithms&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="1966" PostTypeId="1" CreationDate="2018-05-01T06:51:41.983" Score="6" ViewCount="50" Body="&lt;p&gt;At the beginning of a quantum computational process we generally want to start in a perfectly known initial state, and evolve from there. This cannot be done perfectly, for fundamental reasons, but I strongly suspect there has to be a practical limit below which you are in a garbage-in-garbage-out situation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My full question is not on this input fidelity threshold per se (although feel free to provide that too), but rather on &lt;strong&gt;the factors to consider and minimum set(s) of requirements one needs to prepare a good-enough initial state&lt;/strong&gt; (maybe Di-Vincenzo-list style, but preferrably with some example numbers). Presumably the perfect answer has different sections, for example depending on whether one employs thermal initialization or algorithmic cooling.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For a little more context, this question is related with certain aspects of previous ones:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1889/are-there-measuring-standards-and-units-for-the-identification-of-qubits&quot;&gt;Are there measuring standards (and units) for the identification of qubits?&lt;/a&gt; (what could this kind of prospective standards say about initialization in different platforms?)&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1958/are-true-projective-measurements-possible-experimentally&quot;&gt;Are true Projective Measurements possible experimentally?&lt;/a&gt; (perfect projective measurements plus sufficiently coherent operations -including quantum error correction- would make good-enough initialization, but how do we deal with imperfect projective measurements?)&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1861/is-it-true-that-observing-a-quantum-state-will-end-the-superposition-of-states/&quot;&gt;Is it true that observing a quantum state will end the superposition of states, and how not to observe?&lt;/a&gt; (&quot;&lt;em&gt;How can i be sure my input was put in without looking?&lt;/em&gt;&quot;)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="1847" LastActivityDate="2018-05-01T06:51:41.983" Title="Threshold and practical requirements for initial state preparation?" Tags="&lt;qubit-state&gt;&lt;noise&gt;&lt;technical-standards&gt;&lt;initialization&gt;" AnswerCount="0" CommentCount="0" />
  <row Id="1967" PostTypeId="1" AcceptedAnswerId="1982" CreationDate="2018-05-01T12:34:54.377" Score="8" ViewCount="100" Body="&lt;p&gt;On the &lt;a href=&quot;https://en.wikipedia.org/wiki/Grover%27s_algorithm&quot; rel=&quot;noreferrer&quot;&gt;Wikipedia page for Grover's algorithm&lt;/a&gt;, it is mentioned that:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;&quot;Grover's algorithm can also be used for estimating the mean and median of a set of numbers&quot;&lt;/em&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;So far I only knew how it can be used to search a database. But not sure how to implement that technique to estimate the mean and median of a set of numbers. Moreover, there's no citation (as far as I noticed) on that page which explains the technique.  &lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-05-01T20:21:55.750" LastActivityDate="2018-05-02T10:02:07.387" Title="How is Grover's algorithm used to estimate the mean and median of a set of numbers?" Tags="&lt;quantum-algorithms&gt;&lt;grovers-algorithm&gt;" AnswerCount="1" CommentCount="3" FavoriteCount="2" />
  <row Id="1968" PostTypeId="5" CreationDate="2018-05-01T12:56:55.537" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-05-01T12:56:55.537" LastActivityDate="2018-05-01T12:56:55.537" CommentCount="0" />
  <row Id="1969" PostTypeId="4" CreationDate="2018-05-01T12:56:55.537" Score="0" Body="A stabilizer quantum error-correcting code appends ancilla qubits to qubits that we want to protect. A unitary encoding circuit rotates the global state into a subspace of a larger Hilbert space. This highly entangled, encoded state corrects for local noisy errors.&#xD;&#xA;&#xD;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-05-01T21:53:52.287" LastActivityDate="2018-05-01T21:53:52.287" CommentCount="0" />
  <row Id="1970" PostTypeId="2" ParentId="1955" CreationDate="2018-05-01T15:59:13.590" Score="5" Body="&lt;p&gt;It is certainly sufficient to always calculate the full $2^n\times 2^n$ unitary matrix, and then apply it to the $2^n$-entry state vector. If that's what you choose to do, that's &lt;em&gt;all&lt;/em&gt; you have to do as all the entanglement information is contained in that vector. A quick and easy way to see if a particular qubit is entangled is to take the partial trace of your (pure) state vector over all other qubits. If the resulting matrix is rank 1, that qubit is in a separable state, otherwise it's entangled.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I assume the point of your question is really &quot;How can this huge computational cost be avoided?&quot;. In general, it can't - if you're making use of the full power of the quantum computer, you will always need the $2^n$-entry state vector. However, there are various tricks that reduce the computational cost, such as delaying the need for such a large state vector by keeping track of the entanglement.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Efficiency Improvements&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;The biggest saving that you can make compared to the naive implementation above is to avoid the $2^n\times 2^n$ unitary matrices. For example, if you are only using 1- or 2-qubit gates, simply using the sparsity of matrices means you only need $O(2^n)$ storage instead of $O(2^{2n})$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then there are other tactics that you can employ. For example, imagine you want to apply the two-qubit unitary gate $U$ on qubits $i$ and $j$. You can take sets of 4 elements from your state vector ($|x\rangle_{1,2,\ldots n\setminus i,j}|y\rangle_{i,j}$ for fixed $x\in\{0,1\}^{n-2}$ by taking all different $y\in\{0,1\}^2$) and just applying the $4\times 4$ unitary $U$ on that 4-element vector. Repeating this for every $x$ will return $U$ enacted on the original state vector.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I imagine there are other strategies one could come up with. The one that suggested itself from the original question was entanglement tracking. This gives memory and speed improvements at the start of a computation, but ultimately ends up being equivalent because (presumably) everything in the quantum computer will end up entangled.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Entanglement Tracking&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Let's assume that your computation consists of &lt;em&gt;only&lt;/em&gt; unitary evolution and measurement on the set of $n$ qubits, i.e. there is no decoherence, probabilistic maps etc. Let's further assume that you start from a fully separable state such as $|0\rangle^{\otimes n}$. At this point, every qubit is separable, and it is sufficient to keep $n$ different registers, each conveying the state of a separable qubit. If your first gate is just a single-qubit operation $U$ on qubit $i$, then you just update the state stored on qubit $i$ as $|\psi_i\rangle\mapsto U|\psi_i\rangle$, and you don't have to touch anything else.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you want to do a two-qubit gate $V$ between qubits $i$ and $j$, say, then you have to combine the states at both sites. So, you replace two registers each of dimension 2 with one register of dimension 4, containing state $V|\psi_i\rangle|\psi_j\rangle$. The problem is that you now can't split this state up again, so you have to keep those two qubits in a register forever after. Of course, if you ever have a 1-qubit gate $U$ to apply on qubit $i$, you'll now have to apply $|\psi_{i,j}\rangle\mapsto U\otimes\mathbb{I}|\psi_{i,j}\rangle$. Then, the next time you want a 2-qubit gate between, say, $j$ and $k$, you'll have to combine the spaces for $(i,j)$ and $k$. Those spaces will keep growing, but if a gate is localised on just one space, you only have to apply it there (using $\mathbb{I}$ operators to pad it on the rest of the qubits), and you don't have to do anything to the other spaces.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you're doing things like this, you will not have (at least for the first few steps of your algorithm) a single $2^n$ element register. You'll have to have a bunch of different registers, and keep track of which qubits are described by which register in a separate array. Each time you combine the spaces of some qubits, you'll update that extra array.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here's some very crude pseudo-code that may help to convey my meaning:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#initialise variables&#xA;entangled_blocks={{1},{2},{3},...,{n}}&#xA;quantum_states={{1,0},{1,0},...,{1,0}}&#xA;&#xA;#apply action of each gate&#xA;for each gate&#xA;   for each gate_target&#xA;       target_block=entangled_blocks entry containing gate_target&#xA;   next gate_target&#xA;   if all target_blocks equal then&#xA;      apply gate on target_block (pad with identity on other qubits)&#xA;   else&#xA;      new_entangled_block=union(target_blocks)&#xA;      new_state_vec=tensor_product(quantum_states for each target block)&#xA;      apply gate on new_state_vec (pad with identity on other qubits)&#xA;      replace all target_blocks in entangled_blocks with new_entangled_block&#xA;      replace all quantum_states(all target blocks) with new_state_vec&#xA;   end if&#xA;next gate&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;Other Options&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;(By no means exhaustive)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You may be interested to read about Matrix Product States which are a nice way of encapsulating the information about not-too entangled states, and that may provide an alternative route for you, depending on exactly what it is that you're trying to achieve.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-05-03T06:07:52.143" LastActivityDate="2018-05-03T06:07:52.143" CommentCount="4" />
  <row Id="1971" PostTypeId="2" ParentId="1889" CreationDate="2018-05-01T15:59:59.617" Score="-1" Body="&lt;p&gt;This answer is divided into three parts: Standards, what you're measuring, and how to derive and specify the accuracy of the measurement.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Question: Are there measuring standards (and units) for the identification of qubits?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There isn't an ISO Standard for &quot;measuring qubits&quot;, there are ISO Standards called &quot;&lt;a href=&quot;https://www.iso.org/ics/17.020/x/&quot; rel=&quot;nofollow noreferrer&quot;&gt;17.020 - Metrology and measurement in general&lt;/a&gt;&quot; which set forth standards for: 'preferred numbers', 'expression of uncertainty in measurement', 'Propagation of distributions using a Monte Carlo method', 'uncertainty', 'vocabulary', 'Statistical interpretation of data and methods of uncertainty evaluation', 'accuracy', 'Measurement management systems', 'calibration', 'Capability of detection', 'repeatability, reproducibility and trueness estimates in measurement uncertainty evaluation', etc.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When using equipment calibrated and used in accordance with those Standards you can claim ISO Compliance. Those Standards are a couple of hundred dollars each, of interest might be the BIPM &quot;&lt;a href=&quot;https://www.bipm.org/en/publications/guides/gum.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;GUM: Guide to the Expression of Uncertainty in Measurement&lt;/a&gt;&quot; - they write standards that might be incorporated into the ISO Standards (so they are free to review).&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Question: From the point of view of quantum engineering, is there any standard technique/method to identify their value e.g. based on detection thresholds or fidelity verification like Bell inequalities violation? Are there units for that hidden signals?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Once you set forth a Standard for your laboratory to comply with, purchase and calibrate your equipment, and both use it correctly and audit its use, you come to your first big hurdle: &lt;a href=&quot;https://en.wikipedia.org/wiki/Uncertainty#Applications&quot; rel=&quot;nofollow noreferrer&quot;&gt;uncertainty&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;In quantum mechanics, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Uncertainty_principle&quot; rel=&quot;nofollow noreferrer&quot;&gt;uncertainty principle&lt;/a&gt; (also known as Heisenberg's uncertainty principle) is any of a variety of mathematical inequalities asserting a fundamental limit to the precision with which certain pairs of physical properties of a particle, known as complementary variables, such as position $x$ and momentum $p$, can be known.&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;... the uncertainty principle actually states a fundamental property of quantum systems and is not a statement about the observational success of current technology. It must be emphasized that measurement does not mean only a process in which a physicist-observer takes part, but rather any interaction between classical and quantum objects regardless of any observer.&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So: &lt;strong&gt;It's not how good you are, how much you spend, or what you do; there will always be something about which it is uncertain in quantum systems.&lt;/strong&gt; Also important: &lt;strong&gt;Measurement affects the result.&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Question: The best possible answer would probably contain specific details for different architectures (e.g. superconductors vs photons) or contexts (e.g. quantum computing vs quantum communications).&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;[Exceedingly brief explanation of quantum mechanics and computing - lots omitted. The question calls for: &quot;The best possible answer would probably contain specific details for different architectures ...&quot; - this answer is &lt;strong&gt;not&lt;/strong&gt; about &lt;em&gt;measuring the physical properties of a qubit&lt;/em&gt;, it's about measuring the &lt;strong&gt;information&lt;/strong&gt; contained &lt;strong&gt;within&lt;/strong&gt; &lt;em&gt;any&lt;/em&gt; qubit - architecture neutral.]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(Well known and respected) Scott Aaronson's webpage: &quot;PHYS771 Lecture 9: Quantum&quot; explains:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;... nature is &lt;strong&gt;described not by probabilities&lt;/strong&gt; (which are always nonnegative), &lt;strong&gt;but by numbers called amplitudes&lt;/strong&gt; that can be positive, negative, or even complex. ... Quantum mechanics is what you would inevitably come up with if you started from probability theory, and then said, let's try to generalize it so that the numbers we used to call &quot;probabilities&quot; can be negative numbers. ...&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[Lots omitted]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's consider a single bit. In probability theory, we can describe a bit as having a probability $p$ of being $0$, and a probability $1-p$ of being $1$. But if we switch from the 1-norm to the 2-norm, now we no longer want two numbers that sum to $1$, we want two numbers whose squares sum to $1$. (I'm assuming we're still talking about real numbers.) In other words, we now want a vector $(α,β)$ where  $α^2 + β^2 = 1$. Of course, the set of all such vectors forms a circle:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/n83iP.gif&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/n83iP.gif&quot; alt=&quot;Vector (α,β)&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The theory we're inventing will somehow have to connect to observation. So, suppose we have a bit that's described by this vector $(α,β)$. Then we'll need to specify what happens if we look at the bit. Well, since it is a bit, we should see either $0$ or $1$! Furthermore, the probability of seeing $0$ and the probability of seeing $1$ had better add up to $1$. Now, starting from the vector $(α,β)$, how can we get two numbers that add up to $1$? Simple: we can let $α^2$ be the probability of a $0$ outcome, and let $β^2$ be the probability of a $1$ outcome.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But in that case, why not forget about $α$ and $β$, and just describe the bit directly in terms of probabilities? Ahhhhh. The difference comes in how the vector changes when we apply an operation to it. In probability theory, if we have a bit that's represented by the vector $(p,1-p)$, then we can represent any operation on the bit by a stochastic matrix: that is, a matrix of nonnegative real numbers where every column adds up to $1$. So for example, the &quot;bit flip&quot; operation -- which changes the probability of a $1$ outcome from $p$ to $1-p$ -- can be represented as follows: $$\begin{pmatrix} 0 &amp;amp; 1\\ 1 &amp;amp; 0\end{pmatrix} \begin{pmatrix} p\\ 1-p\end{pmatrix}=\begin{pmatrix} 1-p\\ p\end{pmatrix}$$&#xA;Indeed, it turns out that a stochastic matrix is the most general sort of matrix that always maps a probability vector to another probability vector.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[A little omitted.]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This &quot;2-norm bit&quot; that we've defined has a name, which as you know is qubit. Physicists like to represent qubits using what they call &quot;Dirac ket notation&quot;, in which the vector $(α,β)$ becomes $α\left| 0 \right&amp;gt;+β\left| 1 \right&amp;gt;$. Here $α$ is the amplitude of outcome $\left| 0 \right&amp;gt;$, and $β$ is the amplitude of outcome $\left| 1 \right&amp;gt;$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This notation usually drives computer scientists up a wall when they first see it -- especially because of the asymmetric brackets! But if you stick with it, you see that it's really not so bad. As an example, instead of writing out a vector like $(0,0,3/5,0,0,0,4/5,0,0)$, you can simply write $\frac{3}{5}\left|3\right&amp;gt;+\frac{4}{5}\left|7\right&amp;gt;$, omitting all of the $0$ entries.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So given a qubit, we can transform it by applying any 2-by-2 unitary matrix -- and that leads already to the famous effect of quantum interference. For example, consider the unitary matrix &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\begin{pmatrix} \frac{1}{\sqrt{2}} - \frac{1}{\sqrt{2}}\\ \frac{1}{\sqrt{2}} \quad \frac{1}{\sqrt{2}}\end{pmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;which takes a vector in the plane and rotates it by 45 degrees counterclockwise. Now consider the state $\left| 0 \right&amp;gt;$. If we apply U once to this state, we'll get $\frac{1}{\sqrt{2}}\left(\left| 0 \right&amp;gt;+\left| 1 \right&amp;gt;\right)$ -- it's like taking a coin and flipping it. But then, if we apply the same operation U a second time, we'll get $\left| 1 \right&amp;gt;$:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\begin{pmatrix} \frac{1}{\sqrt{2}} - \frac{1}{\sqrt{2}}\\ \frac{1}{\sqrt{2}} \quad \frac{1}{\sqrt{2}}\end{pmatrix}  \begin{pmatrix} \frac{1}{\sqrt{2}}\\ \frac{1}{\sqrt{2}} \end{pmatrix}=  \begin{pmatrix} 0\\ 1 \end{pmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So in other words, applying a &quot;randomizing&quot; operation to a &quot;random&quot; state produces a deterministic outcome! Intuitively, even though there are two &quot;paths&quot; that lead to the outcome $\left| 0 \right&amp;gt;$, one of those paths has a positive amplitude and the other has a negative amplitude. As a result, the two paths interfere destructively and cancel each other out. By contrast, the two paths leading to the outcome $\left| 1 \right&amp;gt;$ both have positive amplitude and therefore interfere constructively.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\require{enclose} \begin{array}{}&#xA; &amp;amp; &amp;amp; &amp;amp; \left| 0 \right&amp;gt; \\&#xA; \quad &amp;amp; \quad &amp;amp; \swarrow &amp;amp; \quad \; &amp;amp; \quad \searrow \\&#xA; &amp;amp; \; \left| 0 \right&amp;gt; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \left| 1 \right&amp;gt; \\&#xA; \quad  \swarrow &amp;amp; &amp;amp; \searrow &amp;amp; \quad &amp;amp; \quad \swarrow &amp;amp; &amp;amp; \searrow \\&#xA; \enclose{downdiagonalstrike,updiagonalstrike}[mathcolor=&quot;red&quot;]{\color{black}{\left|0\right&amp;gt;}} &amp;amp; &amp;amp; \quad \left| 1 \right&amp;gt; &amp;amp; &amp;amp; \enclose{downdiagonalstrike,updiagonalstrike}[mathcolor=&quot;red&quot;]{\color{black}{-\left|0\right&amp;gt;}}  &amp;amp; &amp;amp; \quad \left| 1 \right&amp;gt; \\&#xA;\end{array}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The reason you never see this sort of interference in the classical world is that probabilities can't be negative. So, cancellation between positive and negative amplitudes can be seen as the source of all &quot;quantum weirdness&quot; -- the one thing that makes quantum mechanics different from classical probability theory. How I wish someone had told me that when I first heard the word &quot;quantum&quot;!&quot;. [End of quote from Scott Aaronson's webpage.]&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;[Read the remainder of his webpage linked above to learn about: Mixed States, The Squaring Rule, Real vs. Complex Numbers, and Linearity.]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;He concludes by recommending reading: &quot;&lt;a href=&quot;http://www.arxiv.org/abs/quant-ph/0104088&quot; rel=&quot;nofollow noreferrer&quot;&gt;Unknown Quantum States: The Quantum de Finetti Representation&lt;/a&gt;&quot;, but that paper is from 18 Apr 2001; a lot has changed since then, and the article draws attention to the shortcoming of the explanation it offers:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;To prove the quantum version of the de Finetti theorem, we rely on the classical theorem as much as possible. ... With this in mind, the proof is expedited by making use of the theory of generalized quantum measurements or positive operator-valued measures (POVMs). We give a brief introduction to that theory. ... That there is no quantum de Finetti theorem in real Hilbert space means that there are fundamental differences between real and&#xA;complex Hilbert spaces with respect to learning from measurement results. The ultimate reason for this is that in ordinary, complex-Hilbert-space quantum mechanics, exchangeability implies separability, i.e., the absence of entanglement. This follows directly from the quantum de Finetti theorem because of states of the form Eq. (3.15) are not entangled. This implication does not carry over to real Hilbert spaces.&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now to a partial explanation of modern tomography measurement techniques, that recover the data (not physical properties) from qubits - though physical properties can also be determined (and in some types of qubits it is a more easily noticeable physical property, size, rather than a less noticeable one, spin, that determines the data).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Further information on Quantum Computer Science and Measurement can be found on this webpage, along with numerous links: &quot;&lt;a href=&quot;http://www-inst.eecs.berkeley.edu/~cs191/sp12/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Chem/CS/Phys191: Qubits, Quantum Mechanics, and Computers&lt;/a&gt;&quot;. In particular see Chapters 1 and 2: &quot;Qubits and Quantum Measurement&quot; and &quot;Entanglement&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Possibly the takeaway, relevant to your question, is:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;strong&gt;.6 The Measurement Principle&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This linear superposition $\left| \psi \right&amp;gt; = \sum_{j=0}^{k-1} \alpha_j \left|j\right&amp;gt;$ is part of the private world of the electron. Access to the information describing this state is severely limited — in particular, we cannot actually measure the complex amplitudes $\alpha_j$ This is not just a practical limitation; it is enshrined in the measurement postulate of quantum physics.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A measurement on this k state system yields one of at most $k$ possible&#xA;outcomes: i.e. an integer between $0$ and $k − 1$. Measuring $\left| \psi \right&amp;gt;$ in the standard basis yields $j$ with probability $\left| \alpha_j \right|^2$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One important aspect of the measurement process is that it alters the&#xA;state of the quantum system: the effect of the measurement is that the new&#xA;state is exactly the outcome of the measurement. I.e., if the outcome of the measurement is $j$, then following the measurement, the qubit is in state $\left| j \right&amp;gt;$. This implies that you cannot collect any additional information about the amplitudes $\alpha_j$ by repeating the measurement.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Intuitively, a measurement provides the only way of reaching into the&#xA;Hilbert space to probe the quantum state vector. In general, this is done by&#xA;selecting an orthonormal basis $\left|e_0\right&amp;gt;,\ldots, \left|e_{k−1}\right&amp;gt;$. The outcome of the measurement is $\left|e_j\right&amp;gt;$ with probability equal to the square of the length of the projection of the state vector $\psi$ on $\left|e_j\right&amp;gt;$. A consequence of performing the measurement is that the new state vector is $\left|e_j\right&amp;gt;$. This measurement may be regarded as a probabilistic rule for projecting the state vector onto one of the vectors of the orthonormal measurement basis.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Accurate measurement and error specification:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;See how measurements were performed in 2010, in one particular paper: &quot;&lt;a href=&quot;http://iopscience.iop.org/article/10.1088/1367-2630/12/4/043034&quot; rel=&quot;nofollow noreferrer&quot;&gt;Optimal, reliable estimation of quantum states&lt;/a&gt;&quot;, 20 Apr 2010, by Robin Blume-Kohout:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;Abstract&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Accurately inferring the state of a quantum device from the results of measurements is a crucial task in building quantum information processing hardware. The predominant state estimation procedure, maximum likelihood estimation (MLE), generally reports an estimate with zero eigenvalues. These cannot be justified. Furthermore, the MLE estimate is incompatible with error bars, so &lt;strong&gt;conclusions drawn from it are suspect&lt;/strong&gt;. I propose an alternative procedure, Bayesian mean estimation (BME). BME never yields zero eigenvalues, its eigenvalues provide a bound on their own uncertainties, and under certain circumstances, it is provably the most accurate procedure possible. I show how to implement BME numerically, and how to obtain natural error bars that are compatible with the estimate. Finally, I briefly discuss the differences between Bayesian and frequentist estimation techniques.&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But a later paper, &quot;&lt;a href=&quot;http://iopscience.iop.org/article/10.1088/1367-2630/15/12/123026&quot; rel=&quot;nofollow noreferrer&quot;&gt;Optimal error regions for quantum state estimation&lt;/a&gt;&quot; (13 Dec 2013), by Jiangwei Shang, Et al, supports an extension to MLE:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;Abstract&lt;/p&gt;&#xA;&#xA;&lt;p&gt;An estimator is a state that represents one's best guess of the actual state of the quantum system for the given data. Such estimators are points in the state space. To be statistically meaningful, they have to be endowed with error regions, the generalization of error bars beyond one dimension. As opposed to standard ad hoc constructions of error regions, we introduce the maximum-likelihood region — the region of largest likelihood among all regions of the same size — as the natural counterpart of the popular maximum-likelihood estimator. Here, the size of a region is its prior probability. A related concept is the smallest credible region — the smallest region with pre-chosen posterior probability. In both cases, the optimal error region has a constant likelihood on its boundary. This surprisingly simple characterization permits concise reporting of the error regions, even in high-dimensional problems. For illustration, we identify optimal error regions for single-qubit and two-qubit states from computer-generated data that simulate incomplete tomography with few measured copies.&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.92.012108&quot; rel=&quot;nofollow noreferrer&quot;&gt;Determining which quantum measurement performs better for state estimation&lt;/a&gt;&quot; (13 July 2015), by Jaroslav Řeháček, Yong Siah Teo, and Zdeněk Hradil, Phys. Rev. A 92, 012108:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;Abstract&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We introduce an operational and statistically meaningful measure, the quantum tomographic transfer function, that possesses important physical invariance properties for judging whether a given informationally complete quantum measurement performs better tomographically in quantum-state estimation relative to other informationally complete measurements. This function is independent of the unknown true state of the quantum source and is directly related to the average optimal tomographic accuracy of an unbiased state estimator for the measurement in the limit of many sampling events. For the experimentally appealing minimally complete measurements, the transfer function is an extremely simple formula. We also give an explicit expression for this transfer function in terms of an ordered expansion that is readily computable and illustrate its usage with numerical simulations and its consistency with some known results.&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Compare with: &quot;&lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.117.010404&quot; rel=&quot;nofollow noreferrer&quot;&gt;Practical and Reliable Error Bars in Quantum Tomography&lt;/a&gt;&quot; (1 July 2016), by Philippe Faist and Renato Renner, Phys. Rev. Lett. 117, 010404:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;Abstract&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Precise characterization of quantum devices is usually achieved with quantum tomography. However, most methods which are currently widely used in experiments, such as maximum likelihood estimation, lack a well-justified error analysis. Promising recent methods based on confidence regions are difficult to apply in practice or yield error bars which are unnecessarily large. Here, we propose a practical yet robust method for obtaining error bars. We do so by introducing a novel representation of the output of the tomography procedure, the quantum error bars. This representation is (i) concise, being given in terms of few parameters, (ii) intuitive, providing a fair idea of the “spread” of the error, and (iii) useful, containing the necessary information for constructing confidence regions. The statements resulting from our method are formulated in terms of a figure of merit, such as the fidelity to a reference state. We present an algorithm for computing this representation and provide ready-to-use software. Our procedure is applied to actual experimental data obtained from two superconducting qubits in an entangled state, demonstrating the applicability of our method.&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.94.022113&quot; rel=&quot;nofollow noreferrer&quot;&gt;Fast universal performance certification of measurement schemes for quantum tomography&lt;/a&gt;&quot; (15 Aug 2016), by Dominik Koutný, Yong Siah Teo, Zdeněk Hradil, and Jaroslav Řeháček, Phys. Rev. A 94, 022113:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;Abstract&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Prior to a measurement in a quantum-state tomography experiment, it is important to evaluate the performance of this measurement with respect to the average accuracy in state estimation. &lt;strong&gt;We propose a fast and reliable numerical certification of measurement performance that is applicable to any known quantum measurement.&lt;/strong&gt; This numerical method is based on the statistical theory of unbiased estimation that is valid for any physically accessible quantum state that is necessarily full rank in the limit of a large number of measurement copies, and the Hoeffding inequality that applies to bounded statistical quantities in the quantum state space. We present the use of this straightforward certification procedure by illustrating the convergence to optimal pure-state tomography with an increasing number of overcomplete measurement outcomes. Furthermore, we demonstrate that the performances of symmetric informationally complete measurements and mutually unbiased bases, which are commonly regarded as optimal measurements, can be easily beaten in tomographic performance with randomly generated measurements that are only slightly more informationally overcomplete. Two important classes of random measurements are also discussed with the help of our numerical machinery.&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &lt;strong&gt;&lt;em&gt;design&lt;/em&gt;&lt;/strong&gt; of the measurement protocol will change over the years, but there are Standards under which one can operate while calibrating equipment, documenting procedures, and making measurements.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If results were not statistically reproducible you would have a random number generator, not a quantum computer.&lt;/p&gt;&#xA;" OwnerUserId="278" LastEditorUserId="278" LastEditDate="2018-07-13T15:34:33.587" LastActivityDate="2018-07-13T15:34:33.587" CommentCount="0" />
  <row Id="1972" PostTypeId="2" ParentId="1926" CreationDate="2018-05-01T17:27:28.730" Score="6" Body="&lt;p&gt;I don't think there is a &lt;em&gt;single&lt;/em&gt; golden resource which can you provide you all the necessary knowledge. But I could suggest a pathway (or &lt;em&gt;schematic study guide&lt;/em&gt; in your words):&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If your aim is to create a &lt;em&gt;new&lt;/em&gt; quantum programming language I'd rather say you should thoroughly learn an existing quantum programming language first along with the basic concepts of quantum computing, both from the physics side and the computer science side (maybe even the Mathematics side!).&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Microsoft has their quantum programming language named &lt;strong&gt;Q#&lt;/strong&gt; (which is a part of their &lt;strong&gt;Quantum Development Kit&lt;/strong&gt;). The complete documentation-cum-guide is on their website: &lt;a href=&quot;https://docs.microsoft.com/en-us/quantum&quot; rel=&quot;noreferrer&quot;&gt;https://docs.microsoft.com/en-us/quantum&lt;/a&gt;. If you are from the CS side, I hope you already have &lt;em&gt;some&lt;/em&gt; knowledge of vectors, matrices and linear algebra in general. If so, you can directly start reading the guide article-by-article. Initially, they start with a brief revision of matrices, vectors, etc. followed by a brief introduction to qubits. That much is sufficient for at least getting started with writing a basic quantum program, with minimal understanding of the physics behind it. By the way, if your linear algebra concepts are weak, you could always try &lt;strong&gt;Khan Academy&lt;/strong&gt;'s lectures on the same.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Next, you'd want to learn at least some basics of quantum mechanics. I personally love &lt;a href=&quot;https://www.youtube.com/playlist?list=PL2jykFOD1AWap0r8WOuZ-08BFgMyx-5RT&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;Professor Vazirani's lectures&lt;/strong&gt;&lt;/a&gt;, which are now on Youtube. In about 60 ten minute lectures he covers all the necessary basics of quantum mechanics and quantum computation algorithms. After this, you'd be in good shape to pick up new algorithms on your own.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;As a third step, I'd suggest picking up &quot;&lt;strong&gt;Quantum Computation and Quantum Information by Isaac Chuang and Michael Nielsen&lt;/strong&gt;&quot; and also &quot;&lt;strong&gt;Quantum Computing for Computer Scientists by Mirco A. Mannucci and Noson S. Yanofsky&lt;/strong&gt;&quot; for covering the important topics which you missed out. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;That should be enough for you to get a solid grounding to start writing your own quantum programming language. You may also look into tutorials for the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_programming&quot; rel=&quot;noreferrer&quot;&gt;other common quantum computing languages&lt;/a&gt; to get an idea of how to write quantum programs and design quantum programming languages.&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-05-01T17:32:56.943" LastActivityDate="2018-05-01T17:32:56.943" CommentCount="0" />
  <row Id="1973" PostTypeId="1" AcceptedAnswerId="1980" CreationDate="2018-05-01T19:27:39.140" Score="11" ViewCount="287" Body="&lt;p&gt;I am aware of the quantum hardware startup &lt;a href=&quot;https://www.rigetti.com/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rigetti&lt;/a&gt; and I wonder if there are any quantum startups that build software on top of current quantum computer hardware for commercial applications?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Related question: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1918/does-a-complete-list-of-open-quantum-software-projects-exist&quot;&gt;Does a complete list of open quantum software projects exist?&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="2287" LastEditorUserId="1847" LastEditDate="2018-05-03T11:25:50.390" LastActivityDate="2018-05-03T11:44:54.047" Title="Are there any quantum software startups?" Tags="&lt;quantum-computer&gt;&lt;quantum-programming&gt;" AnswerCount="3" CommentCount="0" FavoriteCount="2" />
  <row Id="1974" PostTypeId="1" CreationDate="2018-05-01T21:06:11.837" Score="2" ViewCount="190" Body="&lt;p&gt;I just came across this (apparently) entropy-reversing &lt;a href=&quot;https://www.youtube.com/watch?v=LrmK9kDc5SM&quot; rel=&quot;nofollow noreferrer&quot;&gt;video&lt;/a&gt;. It is in fact nothing more than a computer-generated animation: first rendering the physical simulation of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bean_machine&quot; rel=&quot;nofollow noreferrer&quot;&gt;bean machine&lt;/a&gt; (often seen in statistical mechanics educational experiments) using color-neutral balls and then assigning color by their destination bin.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/fGLub.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/fGLub.jpg&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I find this amusing from a computational perspective, and hence my questions:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;If it was possible to achieve the portrayed effect physically, a &lt;em&gt;spontaneous&lt;/em&gt; sorting based on pairwise interactions between the objects, what would be the computational implications of such effect?&lt;/li&gt;&#xA;&lt;li&gt;Are there any quantum algorithms described/implemented that achieve some kind of &lt;em&gt;spontaneous&lt;/em&gt; sorting based on interference between the objects to be sorted? &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="1346" LastEditorUserId="1847" LastEditDate="2018-05-03T07:25:49.093" LastActivityDate="2018-05-03T09:19:26.153" Title="What is the relation between this CGI device and a quantum sorting algorithm?" Tags="&lt;quantum-algorithms&gt;" AnswerCount="1" CommentCount="11" />
  <row Id="1975" PostTypeId="2" ParentId="1973" CreationDate="2018-05-01T21:26:52.170" Score="7" Body="&lt;p&gt;Rigetti is not just a hardware company. It also builds quite a bit of software -- check out &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://www.rigetti.com/index.php/forest&quot; rel=&quot;noreferrer&quot;&gt;Forest&lt;/a&gt;, which gives access to both a simulator and a quantum computer via the cloud&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://github.com/rigetticomputing/pyquil&quot; rel=&quot;noreferrer&quot;&gt;PyQuil&lt;/a&gt;, a Python library for programming quantum computers&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://github.com/rigetticomputing/grove&quot; rel=&quot;noreferrer&quot;&gt;Grove&lt;/a&gt;, a Python library of quantum algorithmic primitives&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://github.com/rigetticomputing/forestopenfermion&quot; rel=&quot;noreferrer&quot;&gt;Forest OpenFermion&lt;/a&gt;, a library to interface &lt;a href=&quot;https://github.com/quantumlib/OpenFermion&quot; rel=&quot;noreferrer&quot;&gt;OpenFermion&lt;/a&gt; with Forest&lt;/li&gt;&#xA;&lt;li&gt;Many more projects on &lt;a href=&quot;https://github.com/rigetticomputing&quot; rel=&quot;noreferrer&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; I work at Rigetti&lt;/p&gt;&#xA;" OwnerUserId="2129" LastEditorUserId="2129" LastEditDate="2018-05-03T03:30:39.680" LastActivityDate="2018-05-03T03:30:39.680" CommentCount="0" />
  <row Id="1976" PostTypeId="1" AcceptedAnswerId="1977" CreationDate="2018-05-01T21:55:31.737" Score="6" ViewCount="102" Body="&lt;p&gt;I read the basic introductory information about qubits on Wikipedia:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;There are two possible outcomes for the measurement of a qubit—usually&#xA;  0 and 1, like a bit. The difference is that whereas the state of a bit&#xA;  is either 0 or 1, the state of a qubit can also be a superposition of&#xA;  both. [&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_Computation_and_Quantum_Information_(book)&quot; rel=&quot;nofollow noreferrer&quot;&gt;1&lt;/a&gt;]&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;and&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The state of a three-qubit quantum computer is similarly described by&#xA;  an eight-dimensional vector&#xA;  $(a_{0},a_{1},a_{2},a_{3},a_{4},a_{5},a_{6},a_{7})$ (or a one&#xA;  dimensional vector with each vector node holding the amplitude and the&#xA;  state as the bit string of qubits). [&lt;a href=&quot;http://science.sciencemag.org/content/270/5234/255&quot; rel=&quot;nofollow noreferrer&quot;&gt;2&lt;/a&gt;]&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Hence does it mean that qubit using superdense coding can achieve a double capacity with the possible number of combinations of $2^{2^n}$?&lt;/p&gt;&#xA;" OwnerUserId="2290" LastEditorUserId="55" LastEditDate="2018-05-02T17:52:19.520" LastActivityDate="2018-05-02T17:52:19.520" Title="Does superdense coding allow to double the information capacity of a set of qubits?" Tags="&lt;qubit&gt;&lt;qubit-state&gt;&lt;superdense-coding&gt;" AnswerCount="1" CommentCount="8" />
  <row Id="1977" PostTypeId="2" ParentId="1976" CreationDate="2018-05-02T04:42:01.587" Score="6" Body="&lt;p&gt;The short answer is no: we don't &lt;em&gt;double the capacity&lt;/em&gt;. It turns out it's not that quite simple. There is no general mathematical expression that gives you the storage (or processing power) of a number of qubits in terms of bits. Bits, qubits and ebits work in qualitatively different ways, which in some contexts allows to draw an advantage.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The closest thing to an answer to your question are the so-called &lt;a href=&quot;https://en.wikipedia.org/wiki/Bennett&amp;#39;s_laws&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bennett's laws&lt;/a&gt;, four inequalities comparing the practical information contents of classical bits, quantum bits (or qubits) and entanglement bits (or ebits), reproduced here from wikipedia. The ⩾ signs are to be taken as &quot;&lt;em&gt;can do the job of&lt;/em&gt;&quot;:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1 qubit ⩾ 1 bit (classical),&lt;/li&gt;&#xA;&lt;li&gt;1 qubit ⩾  1 ebit (entanglement bit),&lt;/li&gt;&#xA;&lt;li&gt;1 ebit + 1 qubit ⩾  2 bits (via superdense coding),&lt;/li&gt;&#xA;&lt;li&gt;1 ebit + 2 bits ⩾  1 qubit (via quantum teleportation),&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;On the particular aspect of superdense coding, I refer you to the question &quot;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1920/what-are-the-real-advantages-of-superdense-coding&quot;&gt;What are the real advantages of superdense coding?&lt;/a&gt;&quot; and its answers.&lt;/p&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="1847" LastEditDate="2018-05-02T06:18:58.810" LastActivityDate="2018-05-02T06:18:58.810" CommentCount="1" />
  <row Id="1979" PostTypeId="2" ParentId="1899" CreationDate="2018-05-02T05:53:49.913" Score="1" Body="&lt;p&gt;No quantum computing approach has ever been successful for predicting a reaction rate or transition state that a classical computer could not already do. There are many quantum algorithms for solving the FCI problem with a polynomial number of quantum-computer gates, so there are many algorithms that show promise for building the high-accuracy potential energy surfaces to study the reactions you describe.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-05-02T05:53:49.913" CommentCount="0" />
  <row Id="1980" PostTypeId="2" ParentId="1973" CreationDate="2018-05-02T07:04:06.317" Score="7" Body="&lt;p&gt;There are lots of startups, many of which have no hardware efforts. Here is a selection, distinguished only by the fact that I have heard of them at least once.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;http://artiste-qb.net/wp/&quot; rel=&quot;nofollow noreferrer&quot;&gt;artiste.qb&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://cambridgequantum.com/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Cambridge Quantum Computing&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;http://horizonquantum.com/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Horizon&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://q-ctrl.com/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Q-Ctrl&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;http://quantumbenchmark.com/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Benchmark&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;http://www.qxbranch.com/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Q$^x$ Branch&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://strangeworks.com/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Strangeworks&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;http://zapatacomputing.com/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Zapata&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;There are also &lt;a href=&quot;https://www.qiskit.org&quot; rel=&quot;nofollow noreferrer&quot;&gt;QISKit&lt;/a&gt; and &lt;a href=&quot;https://projectq.ch/&quot; rel=&quot;nofollow noreferrer&quot;&gt;ProjectQ&lt;/a&gt;. Though not startups, they also deserve a mention as important quantum software projects.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-05-02T09:50:27.263" LastActivityDate="2018-05-02T09:50:27.263" CommentCount="1" />
  <row Id="1981" PostTypeId="2" ParentId="1965" CreationDate="2018-05-02T07:29:48.947" Score="2" Body="&lt;p&gt;The number $n$ decides the size of the register to be used for phase estimation, which in turn determines the accuracy. If you knew your eigenvalues (for a unitary) were a subset of the ${2^n}^{th}$ roots of unity, $e^{2\pi i m/2^n}$, then using $n$ bits is guaranteed to give you the exact answer. Assuming you don't have exactly this guarantee, then you can think of the phase estimation as returning the best $n$-bit approximation of those values, i.e. $\phi/(2\pi)$, where the eigenvalue is $e^{i\phi}$, would be approximated to within $1/2^{n+1}$ (with caveats about the probability of this happening, which we can lower-bound by $4/\pi^2$, and can improve further by using a slightly larger $n$).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If memory serves, what you want to do to prepare $A$ is two things (I'm leaving out the connection between implementing a non-unitary $A$ and the unitaries required for phase estimation, since you didn't ask):&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Add enough $\mathbb{I}$ so that $A^{(1)}=A^{(0)}+B\mathbb{I}$ is non-negative (i.e. all $\lambda_i\geq 0$)&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Rescale to $A=\epsilon A^{(1)}$ so that the maximum eigenvalue is less than 1.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;These operations don't change the eigenvectors, and change the eigenvalues by known amounts that you can compensate for later, $\lambda_i=\epsilon(\lambda_i^{(0)}+B)$. You might worry that this rescaling requires you to know the very information that you're trying to calculate. However, it's easy to make at least some crude estimates of the limits of the spectrum via, for example, &lt;a href=&quot;https://en.wikipedia.org/wiki/Gershgorin_circle_theorem&quot; rel=&quot;nofollow noreferrer&quot;&gt;Gershgorin's Circle Theorem&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Actually, you could probably get away with just a rescaling (and no $\mathbb{I}$) if you ensure all eigenvalues are in the range $-1/2$ to $1/2$, due to the periodicity of the Quantum Fourier Transfer, but making use of it gives you the maximum opportunity to spread all the eigenvalues out as much as possible, and hence to get as accurate an estimate on them as possible.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-05-02T07:29:48.947" CommentCount="0" />
  <row Id="1982" PostTypeId="2" ParentId="1967" CreationDate="2018-05-02T09:43:28.677" Score="5" Body="&lt;p&gt;The idea for estimating the mean is roughly as follows:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;For any $f(x)$ that gives outputs in the reals, define a rescaled $F(x)$ that gives outputs in the range 0 to 1. We aim to estimate the mean of $F(x)$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Define a unitary $U_a$ whose operation is $$U_a:|0\rangle|0\rangle\mapsto\frac{1}{2^{n/2}}\sum_x|x\rangle(\sqrt{1-F(x)}|0\rangle+\sqrt{F(x)}|1\rangle).$$ It is important to note that this unitary is easily implemented. You start with a Hadamard transform on the first register, perform a computation of $f(x)$ on an ancilla register, use this to implement a controlled-rotation of the second register, and then uncompute the ancilla register.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Define the unitary $G=U_a (\mathbb{I}-2|0\rangle\langle 0|\otimes |0\rangle\langle 0|)U_a^\dagger \mathbb{I}\otimes Z$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Starting from a state $U_a|0\rangle|0\rangle$, use $G$ much like you would use the Grover iterator to estimate the number of solutions to a search problem.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;The main bulk of this algorithm is amplitude amplification, as described &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0005055&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;. The main idea is that you can define two states&#xA;$$&#xA;|\psi\rangle=\frac{1}{\sqrt{\sum_x F(x)}}\sum_x\sqrt{F(x)}|x\rangle|1\rangle \qquad |\psi^\perp\rangle=\frac{1}{\sqrt{\sum_x 1-F(x)}}\sum_x\sqrt{1-F(x)}|x\rangle|0\rangle,&#xA;$$&#xA;and this defines a subspace for the evolution. The initial state is $U_a|0\rangle|0\rangle=(\sqrt{\sum_x F(x)}|\psi\rangle+\sqrt{\sum_x 1-F(x)}|\psi^\perp\rangle)2^{-n/2}$. The amplitude of the $|\psi\rangle$ term clearly contains the information about the mean of $F(x)$, if we could just estimate it. You could just repeatedly prepare this state and measure the probability of getting a $|1\rangle$ on the second register, but Grover's search gives you a quadratic improvement. If you compare to the way Grover's is usually set up, the amplitude of this $|\psi\rangle$ which you can 'mark' (in this case by applying $\mathbb{I}\otimes Z$) would be $\sqrt{\frac{m}{2^n}}$ where $m$ is the number of solutions.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Incidentally, this is interesting to compare to the &quot;power of one clean qubit&quot;, also known as DQC1. There, if you apply $U_a$ to $\frac{\mathbb{I}}{2^n}\otimes|0\rangle\langle 0|$, the probability of getting the 1 answer is just the same as the non-accelerated version, and gives you an estimate of the mean.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;For the median, it can &lt;a href=&quot;https://arxiv.org/abs/1106.4267&quot; rel=&quot;noreferrer&quot;&gt;apparently&lt;/a&gt; be defined as the value $z$ that minimises&#xA;$$&#xA;\sum_x|f(x)-f(z)|.&#xA;$$&#xA;There are two steps here. The first is to realise that the function we're trying to minimise over is basically just a mean. Then the second step is to use a &lt;a href=&quot;http://xxx.lanl.gov/abs/quant-ph/9607014&quot; rel=&quot;noreferrer&quot;&gt;minimisation algorithm&lt;/a&gt; which can also be accelerated by a Grover search. The idea here is to use a Grover's search, and mark all items for which the function evaluation gives a value less than some threshold $T$. You can estimate the number of inputs $x$ that give $f(x)\leq T$, then repeat for a different $T$ until you localise the minimum value sufficiently.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Of course, I am skipping over some details of precise running times, error estimates etc.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-05-02T10:02:07.387" LastActivityDate="2018-05-02T10:02:07.387" CommentCount="0" />
  <row Id="1984" PostTypeId="2" ParentId="1854" CreationDate="2018-05-02T21:06:33.193" Score="6" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;One major idea there seems to be that the &quot;environment&quot; (quantum&#xA;  decoherence) &lt;strong&gt;&lt;em&gt;assists&lt;/em&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;em&gt;optimizes&lt;/em&gt;&lt;/strong&gt; the transport of a signal&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The idea that photosynthetic systems are doing a Grover search or implementing some quantum algorithm, turned out not to be accepted in the community, and while scientists remained too professional to ridicule the original papers of their fellow-scientists in published papers, the opposition to this idea was observed in many many talks at conferences. Eventually it was even published that the quantum coherence in the FMO has no relevance to its photosynthetic function: see &lt;a href=&quot;https://pubs.acs.org/doi/abs/10.1021/ct501066k&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;Why quantum coherence is not important in the FMO complex&quot;&lt;/a&gt; by Dattani and Wilkins.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Furthermore, decoherence is not &lt;strong&gt;&lt;em&gt;optimizing&lt;/em&gt;&lt;/strong&gt; the transfer. Optimizing it would involve searching the space of all possible bath models, all possible couplings to those bath models, all possible bath spectral densities, and all possible models of static disorder, among other things. This is an uncountably infinite space, and finding some optimum transfer rate is a problem too hard even for a quantum computer to solve. To think that the living organism has found a way to transfer the energy &lt;strong&gt;&lt;em&gt;optimally&lt;/em&gt;&lt;/strong&gt; is also flawed. Maybe by removing one water molecule there would be less disturbance and the energy transfer would happen 10$^{-22}$ seconds faster, which means the previous configuration that included that water molecule was not optimal.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The environment/bath does &lt;strong&gt;&lt;em&gt;assist&lt;/em&gt;&lt;/strong&gt; the energy transfer, because without it you would have infinitely long Rabi oscillations:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;br&gt;&#xA;&lt;a href=&quot;https://i.stack.imgur.com/7pVbD.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/7pVbD.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;By coupling to the bath, we get damped Rabi oscillations that get localized on the lowest-energy site (known as the &quot;sink&quot;) which couples to the reaction center that the excitation needs to get to for photosynthesis: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;br&gt;&#xA;&lt;a href=&quot;https://i.stack.imgur.com/MbN7V.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/MbN7V.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Isn't that &lt;strong&gt;beautiful&lt;/strong&gt; how none of the excitation was getting to the blue site without the bath, but simply by turning on the bath we get a major energy transfer from antenna to reaction center?&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;All calculations were done in Octave using Nike Dattani's FeynDyn (Feynman Dynamics) code:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1) sudo apt-get install octave &lt;br&gt;&#xA;2) git clone &lt;a href=&quot;https://github.com/ndattani/FeynDyn.git&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://github.com/ndattani/FeynDyn.git&lt;/a&gt; &lt;br&gt;&#xA;3) open sampleInput_7x7_FMO_WilkinsDattani_2015_JCTC.m in octave&lt;br&gt;&#xA;4) Press F5 and the dynamics &lt;strong&gt;&lt;em&gt;with bath&lt;/em&gt;&lt;/strong&gt; pops up after 62 seconds &lt;br&gt;&#xA;5) On line 51 make J = 0, for &lt;strong&gt;&lt;em&gt;no coupling to bath&lt;/em&gt;&lt;/strong&gt;, press F5 again. &lt;br&gt;    &lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can change the temperature, spectral density, and Hamiltonian parameters and get slower and faster energy transfer rates, and you will &lt;strong&gt;&lt;em&gt;quickly&lt;/em&gt;&lt;/strong&gt; see why the crystal structure parameters used in this simulation are not optimal, and why it is going to be impossible even for a quantum computer to find THE optimal transfer rate.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;has this been explored in artificial systems either as quantum computation or in a quantum simulator?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I have explained that the photosynthetic complexes are not &quot;doing quantum computation&quot;, even though that was claimed in the early papers of Fleming &lt;em&gt;et al.&lt;/em&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;However it has been found that with quantum annealing, sometimes the ground state solution is found faster when the temperature is increased: &lt;a href=&quot;http://convexoptimization.com/TOOLS/manufacturedspins.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://convexoptimization.com/TOOLS/manufacturedspins.pdf&lt;/a&gt;. Having a noisy environment helps to escape local minima where the annealing process would get trapped if you were at 0 Kelvin. So this is an example of an artificial system that uses this phenomenon, and after thinking about your question all of yesterday and today, it is the only example I could come up with.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-08-27T23:40:40.370" LastActivityDate="2018-08-27T23:40:40.370" CommentCount="2" />
  <row Id="1985" PostTypeId="2" ParentId="1687" CreationDate="2018-05-03T00:08:12.210" Score="3" Body="&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; Fidelity of 0.9999 at 1.08 seconds in 2013: &lt;a href=&quot;http://science.sciencemag.org/content/342/6160/830.full?ijkey=uhZaDNPnwgTdA&quot; rel=&quot;nofollow noreferrer&quot; title=&quot;Science 2013&quot;&gt;http://science.sciencemag.org/content/342/6160/830.full?ijkey=uhZaDNPnwgTdA&lt;/a&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;More details&lt;/strong&gt;: The $T_2$ was 180 minutes, or 3 hours.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;What about the 81% that Heather mentioned?&lt;/strong&gt;: The fidelity of 81% that Heather quotes, was actually referring to something else. In the same paper they wanted to show that they could change the temperature of the sample while still maintaining the spins in a coherent superposition. The sample was increased in temperature from 4.2K to 300K gradually over 6 minutes, held there for 2 minutes, then reduced back to 4.2K gradually over 4 minutes. After doing all that, the spins had impressively maintained a fidelity of 81% with respect to the starting state. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;But that 12 minute experiment where they wanted to show that they can maintain coherence even when majorly disturbing the thermal equilibrium of the sample, was far less than the 3 hours $T_2$ they measured in an experiment where the coherence survived for 300 minutes (5 hours) with temperature kept constant at 1.2K.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;What about the 2014 paper with 0.9999 fidelity?&lt;/strong&gt;: This comes from Figure S2c in the Supplement, which is only up to 0.0002 seconds. If you want to get the fidelity at 30 seconds, or at 180 minutes, look at the $T_2$ times in Fig S1 of the supplement, and you will see that all of these are orders of magnitude smaller than what it was in the 2013 paper. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The authors admit this 3 times: &lt;br&gt;&#xA;1) &quot;Despite the record coherence times discussed above, our results do not match those obtained in bulk ensembles[6–8]&quot; Reference 8 is the 2013 paper. &lt;br&gt;&#xA;2) &quot;This currently represents the record coherence for any &lt;em&gt;single&lt;/em&gt; qubit in the solid state.&quot; Note they say &quot;single&quot; qubit and &quot;solid state&quot;. &lt;br&gt;&#xA;3) &quot;which reach here a new record for solid-state single qubits with $T_2$ &gt; 30 s in the $^{31}$P$^+$spin&quot; Note the 30s is a T2!! This is much smaller than the $T_2$ = 180 minutes mentioned above.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-05-03T23:27:01.880" LastActivityDate="2018-05-03T23:27:01.880" CommentCount="5" />
  <row Id="1986" PostTypeId="5" CreationDate="2018-05-03T07:19:37.283" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-05-03T07:19:37.283" LastActivityDate="2018-05-03T07:19:37.283" CommentCount="0" />
  <row Id="1987" PostTypeId="4" CreationDate="2018-05-03T07:19:37.283" Score="0" Body="For questions regarding the initial state of a system for quantum computation and their preparation" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-05-03T07:25:57.280" LastActivityDate="2018-05-03T07:25:57.280" CommentCount="0" />
  <row Id="1988" PostTypeId="1" AcceptedAnswerId="1994" CreationDate="2018-05-03T09:10:56.473" Score="11" ViewCount="255" Body="&lt;p&gt;I recently noticed that Oxford's computer science department has started offering &lt;a href=&quot;https://www.cs.ox.ac.uk/teaching/courses/cqm/&quot; rel=&quot;noreferrer&quot;&gt;a grad course&lt;/a&gt; on &lt;a href=&quot;https://en.wikipedia.org/wiki/Categorical_quantum_mechanics&quot; rel=&quot;noreferrer&quot;&gt;Categorical quantum mechanics&lt;/a&gt;. Apparently they say that it is relevant for the study of quantum foundations and quantum information, and that it uses paradigms from category theory.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Questions:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;How exactly does it help in the study of quantum information?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Has this formulation actually produced any new results or predictions apart from what our general formulation of quantum mechanics has already done? If so, what are those?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-15T13:10:17.600" LastActivityDate="2018-07-15T13:10:17.600" Title="What is the use of Categorical quantum mechanics?" Tags="&lt;quantum-information&gt;&lt;categorical-quantum-mechanics&gt;&lt;quantum-foundations&gt;" AnswerCount="1" CommentCount="3" FavoriteCount="4" />
  <row Id="1989" PostTypeId="2" ParentId="1974" CreationDate="2018-05-03T09:19:26.153" Score="1" Body="&lt;p&gt;We could assign integers from $1$ to $k$ for each colour. This then becomes an &lt;a href=&quot;https://en.wikipedia.org/wiki/Integer_sorting&quot; rel=&quot;nofollow noreferrer&quot;&gt;integer sort&lt;/a&gt; of $n$ balls over a range of integers $r$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I'm no expert on such sorting algorithms, but it seems that they can be done with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms&quot; rel=&quot;nofollow noreferrer&quot;&gt;worst case time complexity&lt;/a&gt; of $O(n+r)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For the interacting bean machine to beat this, it would need to be faster to pass $n$ balls through a board of width $r$ (and I'll assume height $r$ too). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we pass the balls through one-by-one, the falling process would presumably take $O(r)$ time in each case. So for the $n$ balls, that makes $O(nr)$ time, which is much too slow. They also wouldn't get any opportunity to interact, unless the falling was a quantum process with interference effects.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we pass many balls through at once, the time taken for the process will depend on the dynamics of the balls, which depends on how they interact. If the interaction were to simulate a known sorting algorithm, the falling time would reflect that algorithm's time complexity. If the interaction does not simulate a known sorting algorithm, it could be used to define a new algorithm. The nature of the interaction (classical or quantum) would determine the kind of computer that we could run that algorithm on.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So in answer to your first question, we would need to know how the spontaneous sorting occurs to know how it compares to known algorithms.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-05-03T09:19:26.153" CommentCount="0" />
  <row Id="1990" PostTypeId="5" CreationDate="2018-05-03T09:47:14.123" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-05-03T09:47:14.123" LastActivityDate="2018-05-03T09:47:14.123" CommentCount="0" />
  <row Id="1991" PostTypeId="4" CreationDate="2018-05-03T09:47:14.123" Score="0" Body="Categorical quantum mechanics is the study of quantum foundations and quantum information using paradigms from higher mathematics, notably monoidal category theory and string diagrams." OwnerUserId="26" LastEditorUserId="124" LastEditDate="2018-07-13T10:33:46.453" LastActivityDate="2018-07-13T10:33:46.453" CommentCount="0" />
  <row Id="1992" PostTypeId="2" ParentId="1926" CreationDate="2018-05-03T11:18:10.910" Score="5" Body="&lt;p&gt;I’d suggest you reflect upon whether goal of &quot;making a new quantum programming language&quot; is suitable at this point in the development of quantum computation. It is not the most common approach, since mostly we are still at the stage of thinking in terms of what is essentially machine language. When we create algorithms, the level at which this is done is similar to expressing classical algorithms in terms of logic gates (such as &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_multiplier&quot; rel=&quot;nofollow noreferrer&quot;&gt;this example&lt;/a&gt; for multiplication). The quantum SDKs, like QISKit are essentially ways of creating jobs to be sent to quantum hardware or simulators. This includes tools for performing simulations, optimizing for run time or noise levels, etc. They aren't really languages in the high-level sense we are used to for classical computation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For an introduction to what is going on at this level of the quantum stack, &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/0999063502&quot; rel=&quot;nofollow noreferrer&quot;&gt;Q is for Quantum&lt;/a&gt; by Terry Rudolph might be helpful.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For your intermediate goal of writing programs with QISKit, I'd recommend the &lt;a href=&quot;https://github.com/QISKit/qiskit-tutorial&quot; rel=&quot;nofollow noreferrer&quot;&gt;QISKit tutorial&lt;/a&gt;. It has many worked examples of implementing short quantum programs. There is also a &lt;a href=&quot;https://medium.com/qiskitters&quot; rel=&quot;nofollow noreferrer&quot;&gt;QISKit publication on Medium&lt;/a&gt; in which some of the things in the tutorial are explained in more detail. There is also a &lt;a href=&quot;https://github.com/decodoku/Quantum_Programming_Tutorial&quot; rel=&quot;nofollow noreferrer&quot;&gt;gamified tutorial to QISKit&lt;/a&gt;, which might be useful as a warm-up for the full QISKit tutorial.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Full dislosure: I have contributed to all the things mentioned in the final paragraph.&lt;/em&gt;&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-05-13T18:40:35.547" LastActivityDate="2018-05-13T18:40:35.547" CommentCount="3" />
  <row Id="1993" PostTypeId="2" ParentId="1973" CreationDate="2018-05-03T11:44:54.047" Score="4" Body="&lt;p&gt;Apart from the ones &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1980/26&quot;&gt;James Wotton mentioned&lt;/a&gt;, recently &lt;a href=&quot;https://www.ibm.com/blogs/research/2018/04/ibm-startups-accelerate-quantum/&quot; rel=&quot;nofollow noreferrer&quot;&gt;IBM collaborated with a few top quantum computing software startups&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;ul&gt;&#xA;  &lt;li&gt;&lt;p&gt;&lt;strong&gt;Zapata Computing&lt;/strong&gt; – Based in Cambridge, MA, Zapata Computing is a quantum software, applications and services company developing&#xA;  algorithms for chemistry, machine learning, security, and error&#xA;  correction.&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;&lt;strong&gt;Strangeworks&lt;/strong&gt; (our site's sponsor!) – Based in Austin, TX and founded by William Hurley, Strangeworks is a quantum computing&#xA;  software company designing and delivering tools for software&#xA;  developers and systems management for IT Administrators and CIOs.&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;&lt;strong&gt;QC Ware&lt;/strong&gt; – Based in Palo Alto, CA, QC Ware develops hardware-agnostic enterprise software solutions running on quantum&#xA;  computers. QC Ware’s investors include Airbus Ventures, DE Shaw&#xA;  Ventures and Alchemist, and it has relationships with NASA and other&#xA;  government agencies. QC Ware won a NSF grant, and its customers&#xA;  include Fortune 500 industrial and technology companies.&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;&lt;strong&gt;1QBit&lt;/strong&gt; – Headquartered in Vancouver, Canada, 1QBit builds quantum and quantum-inspired software designed to solve the world’s&#xA;  most demanding computational challenges. The company’s&#xA;  hardware-agnostic platforms and services are designed to enable the&#xA;  development of applications which scale alongside the advances in both&#xA;  classical and quantum computers. 1QBit is backed by Fujitsu Limited,&#xA;  CME Ventures, Accenture, Allianz and The Royal Bank of Scotland.  &lt;/p&gt;&lt;/li&gt;&#xA;  &lt;/ul&gt;&#xA;  &#xA;  &lt;p&gt;Apart from these, the list also includes &lt;strong&gt;Cambridge Quantum Computing&lt;/strong&gt;,&#xA;  &lt;strong&gt;QxBranch&lt;/strong&gt; and &lt;strong&gt;Quantum Benchmark&lt;/strong&gt;. But James already mentioned them! :-)&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;As of now, it seems USA is leading in the number of quantum computing startups. I'd like to hear from others about startups in this area, in the other countries, too. And well, congratulations to &lt;a href=&quot;https://strangeworks.com&quot; rel=&quot;nofollow noreferrer&quot;&gt;Strangeworks&lt;/a&gt;! They have been doing great.&lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-05-03T11:44:54.047" CommentCount="0" />
  <row Id="1994" PostTypeId="2" ParentId="1988" CreationDate="2018-05-03T11:45:52.027" Score="13" Body="&lt;p&gt;This answer is the opinion of someone who is essentially an outsider to &quot;CQM&quot; (= Categorical Quantum Mechanics), but a broadly sympathetic outsider. It should be interpreted as such.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;The motivations of CQM&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;The motivations of Categorical quantum mechanics are not computation as such, but &lt;em&gt;logic&lt;/em&gt;; and not quantum dynamics as such, but &lt;em&gt;foundations of physics&lt;/em&gt;. The symptoms of this can be seen in what it describes as its achievements and points of reference, for instance:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Its results about &quot;completeness&quot; should be interpreted in the same sense as it would in &lt;a href=&quot;https://en.wikipedia.org/wiki/G%C3%B6del%27s_completeness_theorem&quot; rel=&quot;noreferrer&quot;&gt;&lt;em&gt;G&amp;ouml;del's Completeness Theorem&lt;/em&gt;&lt;/a&gt; [sic]: that a set of axioms can perfectly capture a model, which in this case is the model of transformations on a set of qubits expressed in terms of transformations of degrees of freedom expressed in terms of the Z and X eigenbases.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Occasional comparisons to things like &quot;&lt;strong&gt;Rel&lt;/strong&gt;&quot; (that is: the category of relations, which from a computational point of view is more closely allied to non-deterministic Turing machines than quantum computers) illustrate the fact that they are aware of quantum information theory as being part of a larger landscape of computational theories, where the distinctions between these theories may lead to a robust top-down intuition about what distinguishes quantum theory from other possible dynamical theories of information.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Thus CQM is very much more in a tradition of &lt;a href=&quot;https://perimeterinstitute.ca/conferences/foundations-quantum-mechanics&quot; rel=&quot;noreferrer&quot;&gt;foundations of physics&lt;/a&gt; and &lt;a href=&quot;https://blog.computationalcomplexity.org/2003/03/theory-and-theory-b.html&quot; rel=&quot;noreferrer&quot;&gt;the Theory B branch of computer science&lt;/a&gt;. So if it does not seem to have developed a lot of &quot;applications&quot; as such, you should not be surprised, because the development of applications is not its primary motivation. (And of course, so far only a very small subset of people in the field are ever really exposed to it.)&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Why CQM might seem a bit obscure&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;The difference in motivation of CQM to the rest of the field, also reveals itself in the approach which is taken to analysis, in which linear algebra over $\mathbb C$ takes very much a background role.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Linear algebra over $\mathbb C$ is certainly still present in the background, essentially as the target model for CQM. But the usual approach to quantum mechanics in terms of linear algebra over $\mathbb C$ it is seen as potentially obscuring &quot;what is actually going on&quot;. And to give the proponents of CQM their due, they have a good argument here: the usual presentation of quantum information theory, starting from vectors over $\mathbb C$ and unitary transformations, working through density operators and CPTP maps, requires a non-trivial amount of work to develop an intuition of what it is for and in what ways it differs (&lt;em&gt;and in what ways it does not differ&lt;/em&gt;) from probability theory. It is certainly possible to get that intuition by the usual complex-linear-algebraic approach, but the proponents of CQM would claim that the usual approach is not likely to be the most effective approach.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CQM attempts to put the intuitive meaning front-and-centre, in a mathematically rigorous way. This obligates them to talk about such apparently obscure things as &quot;dagger commutative Frobenius algebras&quot;. Of course, such terminology means little to nothing to almost anyone else in the field &amp;mdash; but then this is not much different from how quantum information theorists come across to other computer scientists.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is just the starting point of the potential confusion for an outsider &amp;mdash; as those pursuing CQM are in effect mathematicians/logicians with top-down motivations, there is not one single thread of research in CQM, and there is not a sharp boundary between work on CQM and work in higher category theory. This is analogous to the lack of sharp boundary between computational complexity expressed in terms of quantum circuits, quantum communication complexity, query complexity, and the classical version of these topics, along with Fourier analysis and other relevant mathematical tools. Without a clear frame of reference, it can sometimes be a bit confusing as to where CQM begins and ends, but it has in principle as well-defined a notion of scope as any other topic in quantum information theory.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you wonder why people might like to investigate CQM rather than a more mainstream question in quantum information theory, we should first acknowledge that there are other lines of research in quantum information theory which are not exactly directed towards meaningful impact on anyone else. If we are happy for people to do research into such things as approaches to quantum computation involving physical phenomena which no-one has yet exhibited in the lab [&lt;a href=&quot;https://arxiv.org/pdf/1701.05052.pdf&quot; rel=&quot;noreferrer&quot;&gt;arXiv:1701.05052&lt;/a&gt;] or approaches to error correction on closed &lt;em&gt;d&lt;/em&gt;-dimensional manifolds for&#xA;   &lt;em&gt;d&lt;/em&gt;&gt;2 [&lt;a href=&quot;https://arxiv.org/pdf/1503.02065.pdf&quot; rel=&quot;noreferrer&quot;&gt;arXiv:1503.02065&lt;/a&gt;], we should be equally happy to admit other lines of investigation which is somewhat divorced from the mainstream. The justification in each case is the same: that while the arc of theory is long, it bends towards application, and things which are investigated for purely theoretical reasons have a way of yielding practical fruits.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;The use of CQM&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;On that note: one view of the purpose of paying attention to foundations is to get the sort of insight necessary to solve problems more easily. Does CQM provide that insight?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I think that it is only very recently that the proponents of CQM have seriously considered the question of whether the insights it provides, allow one to obtain new results in subjects which are more in the mainstream of quantum information theory. This is again because the main motivation are the foundations, but recent work has started to develop on the theme of payoffs in the wider field.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are at least two results which I can point to, which represent ways in which the CQM community has developed results which I would judge to be broadly relevant to the interests of the quantum information community, and in which the results are entirely new:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Novel techniques for constructing unitary error bases and Hadamard matrices (e.g. [&lt;a href=&quot;https://arxiv.org/abs/1504.02715&quot; rel=&quot;noreferrer&quot;&gt;arXiv:1504.02715&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1609.07775&quot; rel=&quot;noreferrer&quot;&gt;arXiv:1609.07775&lt;/a&gt;]. These appeared to be of enough interest to the quantum information community that these results were presented as talks in QIP 2016 and 2017 respectively.&lt;/li&gt;&#xA;&lt;li&gt;A well-thought out and clear definition of a &lt;a href=&quot;https://arxiv.org/pdf/1801.09705.pdf&quot; rel=&quot;noreferrer&quot;&gt;quantum graph&lt;/a&gt;, which recovers the definition of a &lt;em&gt;noncommutative graph&lt;/em&gt; from [&lt;a href=&quot;https://arxiv.org/pdf/1002.2514.pdf&quot; rel=&quot;noreferrer&quot;&gt;arXiv:1002.2514&lt;/a&gt;] in such a way that makes the relationship to 'classical' graphs clear, allows them to connect to higher algebra, and obtain (Corollary&amp;nbsp;5.6) a result on the asymptotic density of pairs of graphs for which there is a quantum advantage in pseudo-telepathy games.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;As one should expect of abstract mathematical techniques with foundational motivations, there are also payoffs for areas of computer science which are adjacent to quantum information theory:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Some recent techniques for solving problems in counting complexity regarding  the Holant, which are inspired by quantum computation [&lt;a href=&quot;https://arxiv.org/abs/1702.00767&quot; rel=&quot;noreferrer&quot;&gt;arXiv:1702.00767&lt;/a&gt;], are more specifically inspired by a particular line of investigation into CQM which involved the distinction between GHZ states and W states.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Finally, something which is not yet a result, but which seems a promising direction of research and which in principle does not require category theory to pursue:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;One of the main products of CQM is the ZX-calculus, which one might describe as a tensor-notation which is similar to circuit notation, but which also comes equipped with a formal system for transforming equivalent diagrams to one another. There is a line of investigation into using this as a practical tool for circuit simplification, and for realising unitary circuits in particular architectures. This is based in part on the fact that ZX diagrams are a notation which allows you to reason about tensors beyond just unitary circuits, and which is therefore  more flexible in principle.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Should everyone start using CQM immediately?&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Probably not.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As with many things which have been devised for heterodox academic reasons, it is not necessarily the best tool for every question which one might want to ask. &#xA;If you want to run numerical simulations, chances are you use C or Python as your programming language rather than SML. However, on that same note, just as &lt;a href=&quot;https://fsharp.org&quot; rel=&quot;noreferrer&quot;&gt;programming languages developed in earnest by major software firms&lt;/a&gt; may in time be informed by ideas which were first developed in such a heterodox academic context, so too might some of the ideas and priorities of CQM eventually filter out to the broader community, making it less an isolated line of investigation than it may seem today.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are also subjects for which CQM does not (yet) seem to provide a useful way of approaching, such as distance measures between different states or operations. But every mathematical tool has it's limits: I expect that I won't be using quantum channel theory any time soon to consider how to simplify unitary circuits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There will be problems for which CQM sheds some insight, and may provide a convenient means for analysis. A few examples of such topics are provided above, and it is reasonable to suppose that more areas of application will become evident with time. For those topics where CQM is useful, one can choose whether to take the time to learn how to use the useful tool; apart from that, it's up to you whether or not you are curious enough. In this respect, it is like every other potential mathematical technique in quantum information theory.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Summary&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;If there don't seem to be many novel applications of CQM yet, it's because there aren't &amp;mdash; because this isn't the main motivation of CQM, nor have many people studied it.&lt;/li&gt;&#xA;&lt;li&gt;Its main motivations are along the lines of foundations of computer science and of physics.&lt;/li&gt;&#xA;&lt;li&gt;Applications of the tools of CQM to mainstream quantum information theory do exist, and you can expect to see more as time goes on.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-05-04T10:38:04.570" LastActivityDate="2018-05-04T10:38:04.570" CommentCount="0" />
  <row Id="1995" PostTypeId="5" CreationDate="2018-05-03T13:04:42.250" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-05-03T13:04:42.250" LastActivityDate="2018-05-03T13:04:42.250" CommentCount="0" />
  <row Id="1996" PostTypeId="4" CreationDate="2018-05-03T13:04:42.250" Score="0" Body="For questions relating to Hermitian operators specifically in their role of measurement observables (as opposed to continuous time quantum state evolution), and more generally questions relating to the relationship of Hermitian operators to unitary changes of basis." OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-05-03T20:43:22.640" LastActivityDate="2018-05-03T20:43:22.640" CommentCount="0" />
  <row Id="1997" PostTypeId="5" CreationDate="2018-05-03T13:12:47.760" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-05-03T13:12:47.760" LastActivityDate="2018-05-03T13:12:47.760" CommentCount="0" />
  <row Id="1998" PostTypeId="4" CreationDate="2018-05-03T13:12:47.760" Score="0" Body="Relating to special cases of quantum information theory which considers dynamics or properties of the system which are characterised by commuting operators, such as commuting Hamiltonians, IQP, commuting measurement observables, or mathematical aspects of the stabiliser formalism." OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-05-03T20:43:29.333" LastActivityDate="2018-05-03T20:43:29.333" CommentCount="0" />
  <row Id="1999" PostTypeId="1" CreationDate="2018-05-03T19:38:39.930" Score="13" ViewCount="276" Body="&lt;p&gt;It is a well known result that the &lt;a href=&quot;https://en.wikipedia.org/wiki/Discrete_Fourier_transform&quot; rel=&quot;noreferrer&quot;&gt;Discrete Fourier Transform (DFT)&lt;/a&gt; of $N=2^n$ numbers has complexity $\mathcal O(n2^n)$ with the &lt;a href=&quot;https://en.wikipedia.org/wiki/Fast_Fourier_transform&quot; rel=&quot;noreferrer&quot;&gt;best known algorithm&lt;/a&gt;, while performing the Fourier transform of the amplitudes of a quantum state, with the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_Fourier_transform&quot; rel=&quot;noreferrer&quot;&gt;classical QFT algorithm&lt;/a&gt;, only requires $\mathcal O(n^2)$ elementary gates.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is there any known reason why this is the case? By this I mean whether there are known characteristics of the DFT that make it possible to implement an efficient &quot;quantum version&quot; of it.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Indeed, a DFT over $N$-dimensional vectors can be thought of as the linear operation&#xA;$$\vec y=\operatorname{DFT} \vec x, \qquad \text{DFT}_{jk}\equiv \frac{1}{\sqrt N}\exp\left(\frac{2\pi i}{N}jk\right).$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &quot;quantum version&quot; of this problem is the task of, given a quantum state $|\boldsymbol x\rangle\equiv\sum_{k=1}^N x_k|k\rangle$, obtaining the output state $|\boldsymbol y\rangle\equiv\sum_{k=1}^N y_k |k\rangle$ such that&#xA;$$|\boldsymbol y\rangle=\operatorname{DFT}|\boldsymbol x\rangle=\operatorname{QFT}|\boldsymbol x\rangle.$$&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;A first simplification seems to come from the fact that, due to the linearity of QM, we can focus on the basis states $|j\rangle, \,\,j=1,...,N$, with the evolution of general vectors $|\boldsymbol x\rangle$ then coming for free.&lt;/li&gt;&#xA;&lt;li&gt;If $N=2^n$, one can express $|j\rangle$ in base two, having $|j\rangle=|j_1,...,j_n\rangle$.&lt;/li&gt;&#xA;&lt;li&gt;In the standard QFT algorithm one then exploits the fact that the transformation can be written as&#xA;$$|j_1,...,j_n\rangle\to2^{-n/2}\bigotimes_{l=1}^n\big[|0\rangle+\exp(2\pi i (0.j_{n-l+1}\cdots j_{n}))|1\rangle\big],$$&#xA;which can then be implemented as a quantum circuit of the form&#xA;$$\operatorname{QFT}|j_1,...,j_n\rangle=\Big(\prod_{k=1}^n \mathcal U_k\Big)|j_1,...,j_n\rangle,$$&#xA;where $\mathcal U_k$ is implemented with $\mathcal O(n)$ elementary gates.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Suppose we have now some unitary transformation $A$, and we want to find a circuit implementing efficiently the equivalent quantum transformation&#xA;$$|\boldsymbol y\rangle=A|\boldsymbol x\rangle.$$&#xA;The first two tricks mentioned above can always be applied, but it is then nontrivial when and how the other point can be used to obtain efficiency results like we have for the QFT.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Are there known criteria for this to be true? Or in other words, is it possible to precisely pin down what are the characteristics of the DFT that make it possible to efficiently implement the associated quantum transformation?&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="26" LastEditDate="2018-05-03T20:06:56.210" LastActivityDate="2018-08-07T21:32:04.953" Title="Why can the Discrete Fourier Transform be implemented efficiently as a quantum circuit?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-speedup&gt;&lt;quantum-fourier-transform&gt;" AnswerCount="4" CommentCount="1" FavoriteCount="1" />
  <row Id="2000" PostTypeId="5" CreationDate="2018-05-03T20:25:04.053" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-05-03T20:25:04.053" LastActivityDate="2018-05-03T20:25:04.053" CommentCount="0" />
  <row Id="2001" PostTypeId="4" CreationDate="2018-05-03T20:25:04.053" Score="0" Body="In quantum computing, the Quantum Fourier Transform (QFT) is a linear transformation on quantum bits and is the quantum analogue of the discrete Fourier transform. The quantum Fourier transform is a part of many quantum algorithms, notably Shor's algorithm for factoring and computing the discrete logarithm, the quantum phase estimation algorithm for estimating the eigenvalues of a unitary operator, and algorithms for the hidden subgroup problem." OwnerUserId="26" LastEditorUserId="23" LastEditDate="2018-05-03T23:28:45.817" LastActivityDate="2018-05-03T23:28:45.817" CommentCount="0" />
  <row Id="2002" PostTypeId="2" ParentId="1999" CreationDate="2018-05-04T10:17:25.167" Score="8" Body="&lt;h2&gt;Introduction to the Classical Discrete Fourier transform:&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;The DFT transforms a sequence of $N$ complex numbers $\{\mathbf{x}_n\}:=x_0,x_1,x_2,...,x_{N-1}$ into another sequence of complex numbers $\{\mathbf{X}_k\}:=X_0,X_1,X_2,...$ which is defined by $$X_k=\sum_{n=0}^{N-1}x_n.e^{\pm\frac{2\pi i k n}{N}}$$ We might multiply by suitable normalization constants as necessary. Moreover, whether we take the plus or minus sign in the formula depends on the convention we choose.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Suppose, it's given that $N=4$ and $\mathbf{x}=\begin{pmatrix} 1 \\ 2-i \\ -i \\ -1+2i \end{pmatrix}$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;We need to find the column vector $\mathbf{X}$. The general method is already shown on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Example&quot; rel=&quot;noreferrer&quot;&gt;Wikipedia page&lt;/a&gt;. But we will develop a matrix notation for the same. $\mathbf{X}$ can be easily obtained by pre multiplying $\mathbf{x}$ by the matrix:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$M=\frac{1}{\sqrt{N}}\begin{pmatrix} 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\ 1 &amp;amp; w &amp;amp; w^{ 2 } &amp;amp; w^{ 3 } \\ 1 &amp;amp; w^ 2 &amp;amp; w^4 &amp;amp; w^6 \\ 1 &amp;amp; w^3 &amp;amp; w^6 &amp;amp; w^9 \end{pmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;where $w$ is $e^{\frac{-2\pi i}{N}}$. Each element of the matrix is basically $w^{ij}$. $\frac{1}{\sqrt{N}}$ is simply a normalization constant.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Finally, $\mathbf{X}$ turns out to be: $\frac{1}{2}\begin{pmatrix} 2 \\ -2-2i \\ -2i \\ 4+4i \end{pmatrix}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, sit back for a while and notice a few important properties:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;All the columns of the matrix $M$ are orthogonal to each other. &lt;/li&gt;&#xA;&lt;li&gt;All the columns of $M$ have magnitude $1$. &lt;/li&gt;&#xA;&lt;li&gt;If you post multiply $M$ with a column vector having lots of zeroes (large spread) you'll end up with a column vector with only a few zeroes (narrow spread). The converse also holds true. (Check!)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;It can be very simply noticed that the classical DFT has a time complexity $\mathcal O(N^2)$. That is because for obtaining every row of $\mathbf{X}$, $N$ operations need to be performed. And there are $N$ rows in $\mathbf{X}$.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;The Fast fourier transform:&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Now, let us look at the Fast fourier transform. The fast Fourier transform uses the symmetry of the Fourier transform to reduce the computation time. Simply put, we rewrite the Fourier transform of size $N$ as two Fourier transforms of size $N/2$ - the odd and the even terms. We then repeat this over and over again to exponentially reduce the time. To see how this works in detail, we turn to the matrix of the Fourier transform. While we go through this, it might be helpful to have $\text{DFT}_8$ in front of you to take a look at. Note that the exponents have been written modulo $8$, since $w^8 = 1$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/1Td1t.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/1Td1t.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Notice how row $j$ is very similar to row $j + 4$. Also, notice how column $j$&#xA;is very similar to column $j + 4$. Motivated by this, we are going to split the&#xA;Fourier transform up into its even and odd columns.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/BdYkS.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/BdYkS.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the first frame, we have represented the whole Fourier transform matrix&#xA;by describing the $j$th row and $k$th column: $w^{jk}$. In the next frame, we separate the odd and even columns, and similarly separate the vector that is to be transformed. You should convince yourself that the first equality really is&#xA;an equality. In the third frame, we add a little symmetry by noticing that&#xA;$w^{j+N/2} = −w^j$ (since $w^{n/2} = −1$).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Notice that both the odd side and even side contain the term $w^{2jk}$. But&#xA;if $w$ is the primitive Nth root of unity, then $w^2$ is the primitive $N/2$ nd root of unity. Therefore, the matrices whose $j$, $k$th entry is $w^{2jk}$ are really just $\text{DFT}_{(N/2)}$! Now we can write $\text{DFT}_N$ in a new way:&#xA;Now suppose we are calculating the Fourier transform of the function $f(x)$.&#xA;We can write the above manipulations as an equation that computes the jth&#xA;term $\hat{f}(j)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/3Zn5o.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/3Zn5o.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Note: QFT in the image just stands for DFT in this context. Also, M refers to what we are calling N.&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This turns our calculation of $\text{DFT}_N$ into two applications of $\text{DFT}_{(N/2)}$. We&#xA;can turn this into four applications of $\text{DFT}_{(N/4)}$, and so forth. As long as $N = 2n$ for some $n$, we can break down our calculation of $\text{DFT}_N$ into $N$&#xA;calculations of $\text{DFT}_1 = 1$. This greatly simplifies our calculation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In case of the Fast fourier transform the time complexity reduces to $\mathcal{O}(N\log(N))$ (try proving this yourself). This is a huge improvement over the classical DFT and pretty much the state-of-the-art algorithm used in modern day music systems like your iPod!&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;The Quantum Fourier transform with quantum gates:&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;The strength of the FFT is that we are able to use the symmetry of the&#xA;discrete Fourier transform to our advantage. The circuit application of QFT&#xA;uses the same principle, but because of the power of superposition QFT is&#xA;even faster.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The QFT is motivated by the FFT so we will follow the same steps, but&#xA;because this is a quantum algorithm the implementation of the steps will be&#xA;different. That is, we first take the Fourier transform of the odd and even&#xA;parts, then multiply the odd terms by the phase $w^{j}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In a quantum algorithm, the first step is fairly simple. The odd and even&#xA;terms are together in superposition: the odd terms are those whose least&#xA;significant bit is $1$, and the even with $0$. Therefore, we can apply $\text{QFT}_{(N/2)}$ to both the odd and even terms together. We do this by applying we will simply apply $\text{QFT}_{(N/2)}$ to the $n-1$ most significant bits, and recombine the odd and even appropriately by applying the Hadamard to the least significant bit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now to carry out the phase multiplication, we need to multiply each odd&#xA;term $j$ by the phase $w^{j}$ . But remember, an odd number in binary ends with a $1$ while an even ends with a $0$. Thus we can use the controlled phase shift, where the least significant bit is the control, to multiply only the odd terms by the phase without doing anything to the even terms. Recall that the controlled phase shift is similar to the CNOT gate in that it only applies a phase to the target if the control bit is one.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/4MbDF.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/4MbDF.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Note:  In the image M refers to what we are calling N.&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The phase associated with each controlled phase shift should be equal to&#xA;$w^{j}$ where $j$ is associated to the $k$-th bit by $j = 2k$.&#xA;Thus, apply the controlled phase shift to each of the first $n − 1$ qubits,&#xA;with the least significant bit as the control. With the controlled phase shift&#xA;and the Hadamard transform, $\text{QFT}_N$ has been reduced to $\text{QFT}_{(N/2)}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/5L5TU.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/5L5TU.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Note:  In the image, M refers to what we are calling N.&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Lets construct $\text{QFT}_3$. Following the algorithm, we will turn $\text{QFT}_3$ into $\text{QFT}_2$&#xA;and a few quantum gates. Then continuing on this way we turn $\text{QFT}_2$ into&#xA;$\text{QFT}_1$ (which is just a Hadamard gate) and another few gates. Controlled&#xA;phase gates will be represented by $R_\phi$. Then run through another iteration to get rid of $\text{QFT}_2$. You should now be able to visualize the circuit for $\text{QFT}$ on more qubits easily. Furthermore, you can see that the number of gates necessary to carry out $\text{QFT}_N$ it takes is exactly $$\sum_{i=1}^{\log(N)} i=\log(N)(\log(N)+1)/2 = \mathcal{O}(\log^2 N)$$&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Sources:&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Discrete_Fourier_transform&quot; rel=&quot;noreferrer&quot;&gt;https://en.wikipedia.org/wiki/Discrete_Fourier_transform&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_Fourier_transform&quot; rel=&quot;noreferrer&quot;&gt;https://en.wikipedia.org/wiki/Quantum_Fourier_transform&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.edx.org/course/quantum-mechanics-quantum-computation-uc-berkeleyx-cs-191x&quot; rel=&quot;noreferrer&quot;&gt;Quantum Mechanics and Quantum Computation MOOC (UC BerkeleyX)&lt;/a&gt; - &lt;a href=&quot;https://courses.edx.org/c4x/BerkeleyX/CS191x/asset/chap5.pdf&quot; rel=&quot;noreferrer&quot;&gt;Lecture Notes : Chapter 5&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;P.S: This answer is in its preliminary version. As @DaftWillie mentions in the comments, it doesn't go much into &quot;&lt;em&gt;any insight that might give some guidance with regards to other possible algorithms&lt;/em&gt;&quot;. I encourage alternate answers to the original question. I personally need to do a bit of reading and resource-digging so that I can answer that aspect of the question.&lt;/sup&gt;&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-05-09T11:52:30.520" LastActivityDate="2018-05-09T11:52:30.520" CommentCount="3" />
  <row Id="2003" PostTypeId="2" ParentId="1999" CreationDate="2018-05-04T10:40:11.740" Score="5" Body="&lt;p&gt;This is deviating a little from the original question, but I hope gives a little more insight that could be relevant to other problems.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One might ask &quot;What is it about order finding that lends itself to efficient implementation on a quantum computer?&quot;. Order Finding is the main component of factoring algorithms, and includes the Fourier transform as part of it.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The interesting thing is that you can put things like order finding, and Simon's problem, in a general context called the &lt;a href=&quot;https://en.wikipedia.org/wiki/Hidden_subgroup_problem&quot; rel=&quot;noreferrer&quot;&gt;&quot;Hidden Subgroup Problem&quot;&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let us take a group $G$, with elements indexed by $g$, and a group operation '$\oplus$'. We are given an oracle that evaluates the function $f(g)$, and we are assured that there is a subgroup, $K$, of $G$ with elements $k$ such that for all $g\in G$ and $k\in K$, $f(g)=f(g\oplus k)$. It is our task to uncover the generators of the subgroup $K$. For example, in the case of Simon's problem, the group $G$ is all $n$-bit numbers, and the subgroup $K$ is a pair of elements $\{0,s\}$. The group operation is bitwise addition.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Efficient solutions (that scale as a polynomial of $\log|G|$) exist if the group $G$ is Abelian, i.e. if the operation $\oplus$ is commutative, making use of the Fourier Transform over the relevant group. There are well-established links between the group structure (e.g. $\{0,1\}^n,\oplus$) and the problem that can be solved efficiently (e.g. Simon's problem). For example, if we could solve the Hidden Subgroup Problem for the symmetric group, it would help with the solution of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Graph_isomorphism&quot; rel=&quot;noreferrer&quot;&gt;graph isomorphism problem&lt;/a&gt;. In this particular case, how to perform the Fourier Transform is known, although this in itself is not sufficient for creating an algorithm, in part because there is some additional post-processing that is required. For example, in the case of Simon's Problem, we required multiple runs to find enough linearly independent vectors to determine $s$. In the case of factoring, we were required to run a continued fractions algorithm on the output. So, there's still some classical post-processing that has to be done efficiently, even once the appropriate Fourier transform can be implemented.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Some more details&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;In principle, the Hidden Subgroup Problem for Abelian groups is solved as follows. We start with two registers, $|0\rangle|0\rangle$, and prepare the first in a uniform superposition of all group elements,&#xA;$$&#xA;\frac{1}{\sqrt{|G|}}\sum_{g\in G}|g\rangle|0\rangle,&#xA;$$&#xA;and perform the function evaluation&#xA;$$&#xA;\frac{1}{\sqrt{|G|}}\sum_g|g\rangle|f(g)\rangle=\frac{1}{\sqrt{|G|}}\sum_{g\in K^\perp}\sum_{k\in K}|g\oplus k\rangle|f(g)\rangle,&#xA;$$&#xA;where $K^\perp$ is defined such that by taking each element and combining with the members of $K$ yields the whole group $G$ (i.e. each member of $K^\perp$ creates a different coset, yielding distinct values of $f(g)$), and is known as the orthogonal subgroup. Tracing over the second register,&#xA;$$&#xA;\frac{1}{|K|}\sum_{g\in K^\perp}\sum_{k,k'\in K}|g\oplus k\rangle\langle g\oplus k'|.&#xA;$$&#xA;Now we perform the Fourier Transform over the group $G$, giving the output state&#xA;$$&#xA;\frac{|K|}{|G|}\sum_{g\in K^\perp}|g\rangle\langle g|.&#xA;$$&#xA;Each of the vectors $|g\in K^\perp\rangle$ has a probability of $|K|/|G|$ of being found, and all others have 0 probability. Once the generators of $K^\perp$ have been determined, we can figure out the generators of $K$ via some linear algebra.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-05-04T10:40:11.740" CommentCount="0" />
  <row Id="2004" PostTypeId="1" AcceptedAnswerId="2005" CreationDate="2018-05-04T10:49:03.160" Score="8" ViewCount="248" Body="&lt;p&gt;Grover's Search algorithm is usually talked about in terms of finding a marked entry in an unsorted database. This is a natural formalism that lets it be applied directly to searching for solutions to NP problems (where a good solution is easily recognised).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I was &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/1967/1837&quot;&gt;interested to learn&lt;/a&gt; about other applications of Grover's search to finding the minimum, mean and median of a set of numbers. That leaves me wondering if there are any other less-obvious applications of Grover's search (or applications of its generalisations such as amplitude amplification) which are already known? Any brief insight about how this is done would be appreciated.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-06T12:50:33.920" Title="What applications does Grover's Seach Algorithm have?" Tags="&lt;quantum-algorithms&gt;&lt;grovers-algorithm&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="2005" PostTypeId="2" ParentId="2004" CreationDate="2018-05-04T10:57:27.897" Score="4" Body="&lt;p&gt;Apart from the ones you mentioned, another application of (a modified) Grover's algorithm which I'm aware of is solving the &lt;a href=&quot;https://en.wikipedia.org/wiki/Collision_problem&quot; rel=&quot;nofollow noreferrer&quot;&gt;Collision problem in complexity theory, quantum computing and computational mathematics&lt;/a&gt;. It's also called the &lt;a href=&quot;https://en.wikipedia.org/wiki/BHT_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;BHT algorithm&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;Introduction&lt;/strong&gt;:&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;The collision problem most often refers to the &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0412143&quot; rel=&quot;nofollow noreferrer&quot;&gt;2-to-1&#xA;  version&lt;/a&gt; which was described by Scott Aaronson in his PhD thesis. Given that $n$ is&#xA;  even and a function $f:\{1,...,n\}\to\{1,...,n\}$ we know beforehand&#xA;  that either $f$ is 1-to-1 or 2-to-1. We are only allowed to make&#xA;  queries about the value of $f(i)$ for any $i\in\{1,2,...,n\}$. The&#xA;  problem then asks how many queries we need to make to determine with&#xA;  certainty whether $f$ is 1-to-1 or 2-to-1.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Solving the 2-to-1 version deterministically requires $n/2+1$ queries,&#xA;  and in general distinguishing r-to-1 functions from 1-to-1 functions&#xA;  requires $n/r+1$ queries.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;strong&gt;&lt;em&gt;Deterministic classical solution&lt;/em&gt;:&lt;/strong&gt;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;This is a straightforward application of the pigeonhole principle: if&#xA;  a function is r-to-1, then after $n/r+1$ queries we are guaranteed to&#xA;  have found a collision.  If a function is 1-to-1, then no collision&#xA;  exists. If we are unlucky then $n/r$ queries could return distinct&#xA;  answers. So $n/r+1$ queries are necessary.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;strong&gt;&lt;em&gt;Randomized classical solution&lt;/em&gt;:&lt;/strong&gt;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;If we allow randomness, the problem is easier. By the birthday&#xA;  paradox, if we choose (distinct) queries at random, then with high&#xA;  probability we find a collision in any fixed 2-to-1 function after&#xA;  $\Theta(\sqrt{n})$ queries.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;strong&gt;&lt;em&gt;Quantum BHT solution&lt;/em&gt;:&lt;/strong&gt;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Intuitively, the algorithm combines the square root speedup from the&#xA;  &lt;a href=&quot;https://en.wikipedia.org/wiki/Birthday_attack&quot; rel=&quot;nofollow noreferrer&quot;&gt;birthday paradox&lt;/a&gt;&#xA;  using (classical) randomness with the square root speedup from&#xA;  Grover's (quantum) algorithm. &lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;First, $n^{1/3}$ inputs to $f$ are selected at random and $f$ is&#xA;  queried at all of them. If there is a collision among these inputs,&#xA;  then we return the colliding pair of inputs. Otherwise, all these&#xA;  inputs map to distinct values by $f$. Then Grover's algorithm is used&#xA;  to find a new input to $f$ that collides. Since there are only&#xA;  $n^{2/3}$ such inputs to $f$, Grover's algorithm can find one (if it&#xA;  exists) by making only&#xA;  $\mathcal{O}(\sqrt{n^{2/3}})=\mathcal{O}(n^{1/3})$ queries to $f$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Sources:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Collision_problem&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://en.wikipedia.org/wiki/Collision_problem&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/BHT_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://en.wikipedia.org/wiki/BHT_algorithm&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/9705002&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Algorithm for the Collision Problem - Gilles Brassard, Peter Hoyer, Alain Tapp&lt;/a&gt; &lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-05-04T14:34:08.177" LastActivityDate="2018-05-04T14:34:08.177" CommentCount="5" />
  <row Id="2006" PostTypeId="2" ParentId="1999" CreationDate="2018-05-04T16:09:26.203" Score="7" Body="&lt;p&gt;One possible answer as to why we can realise the QFT efficiently is down to the structure of its coefficients. To be precise, we can represent it easily as a &lt;a href=&quot;https://arxiv.org/abs/0801.2461&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;em&gt;quadratic form expansion&lt;/em&gt;&lt;/a&gt;, which is a sum over paths which have phases  given by a quadratic function:&#xA;$$&#xA;   F_{2^n}&#xA;   =&#xA;   \frac{1}{\sqrt{2^n}}&#xA;     \sum_{k,x \in \{0,1\}^n}&#xA;       \exp\bigl(i Q(k,x)\bigr) \; \lvert k \rangle\!\langle x \rvert,&#xA;$$&#xA;where $Q(z) = \sum_{1 \leqslant j \leqslant k \leqslant 2n} \theta_{j,k} z_j z_k$ is a quadratic form defined on $2n$-bit strings. The quantum Fourier transform in particular involves a quadratic form whose angles are given by&#xA;$$&#xA;  \theta_{j,k}&#xA;  =&#xA;  \begin{cases}&#xA;    \pi\big/2^{2n-j-k},&#xA;       &amp;amp; \text{if $1 \leqslant j \leqslant n &amp;lt; k \leqslant 2n-j+1$}&#xA;\\&#xA;0, &amp;amp; \text{otherwise}.&#xA;\end{cases} $$&#xA;The structure of these angles has an important feature, which allows the QFT to be easily realised as a unitary circuit:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;There is a function $f: \{1,2,\ldots,n\} \to \{n{+}1,n{+}2,\ldots,2n\}$ such that $\theta_{j,k} = \pi$ for each $1 \leqslant j \leqslant n$ (where $f(j) = 2n-j+1$ in the case of the QFT);&lt;/li&gt;&#xA;&lt;li&gt;For any $1 \leqslant h,j \leqslant n$ for which $\theta_{h,\,f(j)} \ne 0$, we have $\theta_{j,\,f(h)} = 0$.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;We may think of the indices of $z = (k,x) \in \{0,1\}^{2n}$ as input and output wires of a quantum circuit, where our task is to show what the circuit in the middle is which shows how the inputs connect to the outputs. The function $f$ above allows us to see the association of output wires to input wires, that in each case there is a Hadamard gate which connects the two ends together, and that apart from the Hadamards (and SWAP gates which accounts for the reversal of in the order of the indices between $(1,2,\ldots,n)$ and $(f(1), f(2), \ldots, f(n))$), all of the other operations are two-qubit controlled-phase gates for relative phases of $\exp(i \theta_{j,k})$. The second condition on $f$ serves to ensure that these controlled-phase gates can be given a well-defined time ordering.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are more general conditions which one could describe for when a quadratic form expansion gives rise to a realisable circuit, along similar lines. The above describes one of the simplest cases, in which there are no indices in the sum except for those for the standard basis of the input and output states (in which case the coefficients of the associated unitary all have the same magnitude).&lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-05-05T10:32:30.810" LastActivityDate="2018-05-05T10:32:30.810" CommentCount="2" />
  <row Id="2007" PostTypeId="1" CreationDate="2018-05-04T17:45:18.863" Score="4" ViewCount="298" Body="&lt;p&gt;There have been a couple of simulations already made and I recently saw this high performance, hardware accelerated quantum computer simulator &lt;a href=&quot;https://qcgpu.github.io/&quot; rel=&quot;nofollow noreferrer&quot;&gt;QCGPU&lt;/a&gt; and started to wonder about how to simulate quantum computing in VR. I would like to look at demonstrating the theory behind it. As a teaching experience. Then afterwards simulating the algorithms that could run on it. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The motivation is that VR doesn't have similar limitations we have in the physical world. Essentially it will graphically illustrate the quantum physics behind this computer and to show Mesoscopic physics at work. The VR will illustrate experiments of quantum physics and theory behind this computer but it will also illustrate speed and algorithm execution. For example, this is like showing the mainframe generation how a 7'th Gen CPU would function. From hardware to software, theoretically. It would simulate how algorithms would work on this machine.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Superposition and entanglement would be the main focus. For instance to show entanglement the player would interact with a photon, electron , molecule, or laser (polarization) .The distance between electrons can be scaled to show qubits that are separated by incredible distances interacting with each other instantaneously. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is it possible to build such a research environment for enthusiast and professionals to refer to with authenticity?  &lt;/p&gt;&#xA;" OwnerUserId="2215" LastEditorUserId="2215" LastEditDate="2018-05-07T05:45:07.533" LastActivityDate="2018-05-09T15:52:57.200" Title="Is it possible to simulate a quantum computer in Virtual Reality? If yes, how?" Tags="&lt;quantum-computer&gt;&lt;simulation&gt;&lt;quantum-computing-models&gt;" AnswerCount="3" CommentCount="3" FavoriteCount="1" />
  <row Id="2008" PostTypeId="2" ParentId="2007" CreationDate="2018-05-04T19:58:20.927" Score="6" Body="&lt;p&gt;Virtual reality in a classical computer is just a fancy front-end on top of a classical simulation. A classical computer can simulate all of the quantum physics happening inside a quantum computer, including all the phenomena referred to in the question, but only for a limited number of qubits.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;A &lt;a href=&quot;https://arxiv.org/abs/1704.01127&quot; rel=&quot;noreferrer&quot;&gt;45-qubit circuit was simulated&lt;/a&gt; using 0.5PB of RAM in 2017.&lt;br&gt;&#xA;A &lt;a href=&quot;https://arxiv.org/pdf/1710.05867.pdf&quot; rel=&quot;noreferrer&quot;&gt;49-qubit circuit was simulated&lt;/a&gt; using 3TB of RAM in 2017.&lt;br&gt;&#xA;A &lt;a href=&quot;https://arxiv.org/pdf/1802.06952.pdf&quot; rel=&quot;noreferrer&quot;&gt;64-qubit circuit was simulated&lt;/a&gt; using 8TB of RAM in 2018.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;These were universal random circuits. If you allow the circuit to be non-random, as in the case of most &lt;em&gt;specific&lt;/em&gt; quantum algorithms, you can simulate more qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, Bravyi ad Gosset showed that &lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.116.250501&quot; rel=&quot;noreferrer&quot;&gt;circuits dominated by Clifford gates can be simulated in polynomial time with respect to the number of $T$ gates on a classical computer&lt;/a&gt;. Here is the &lt;a href=&quot;https://arxiv.org/abs/1601.07601&quot; rel=&quot;noreferrer&quot;&gt;arXiv&lt;/a&gt; link if you don't have access to PRL.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you want to simulate a real physical system (for example for your VR demonstration for students) you need to also model decoherence, but a Lindblad master equation can approximate this with the same amount of RAM as the above &quot;exact&quot; simulations for closed systems. If you want to simulate the decoherence without a Markovian approxiation, there are programs on GitHub such as &lt;a href=&quot;https://github.com/ndattani/FeynDyn&quot; rel=&quot;noreferrer&quot;&gt;FeynDyn (Feynman Dynamics)&lt;/a&gt;. In my &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1984/2293&quot;&gt;answer&lt;/a&gt; to a recent question here, I simulated 3 qubits in the presence of non-Markovian decoherence in 62 seconds, and the authors of FeynDyn claim they can simulate up to 16 qubits with non-Markovian decoherence.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-05-06T19:33:17.090" LastActivityDate="2018-05-06T19:33:17.090" CommentCount="2" />
  <row Id="2009" PostTypeId="1" AcceptedAnswerId="2010" CreationDate="2018-05-05T19:02:59.153" Score="5" ViewCount="86" Body="&lt;p&gt;My understanding of Shor's algorithm is that you have to carry out the following steps if you are trying to factor $N$:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Chose a random number less than $N$. Let's call it $a$. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Calculate the period of $a^x \ \text{mod} \ N$. Let's call the period $r$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;One of the factors is the GCD of $a^{r/2}+1$ and $N$. The other is the GCD of $a^{r/2}-1$ and $N$. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;However this does not work in some cases such as if $N=35$ and $a=10$. You should be getting $5$ and $7$ as the prime factors of $35$, but this is not the case. The period of $10^x \ \text{mod} \ 35$ is $6$. The GCD of $10^{6/2}+1$, $1001$ and $35$ is $7$, which is one of the factors. But the GCD of $10^{6/2}-1$, $999$ and $35$ is $1$, which is not what you should be getting. Why doesn't Shor's algorithm work in this case?&lt;/p&gt;&#xA;" OwnerUserId="699" LastEditorUserId="699" LastEditDate="2018-05-05T21:08:01.443" LastActivityDate="2018-05-05T22:39:58.833" Title="Confusion about random sampling of integers in Shor's algorithm" Tags="&lt;quantum-algorithms&gt;&lt;shors-algorithm&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="0" />
  <row Id="2010" PostTypeId="2" ParentId="2009" CreationDate="2018-05-05T19:35:35.217" Score="5" Body="&lt;p&gt;You skipped a step in the algorithm.&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;First check if $N$ is even. $35$ is not even.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Next determine if $N=a^b$ for $a \geq 1$ and $b \geq 2$. It's not.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Randomly choose $x$ in the range $1$ to $N-1$. If $\text{gcd}(x,N) &amp;gt; 1$ then return the factor $\text{gcd}(x,N)$. This is what you missed. $\text{gcd}(10,35) = 5$ There's no reason to perform order finding if you choose $x = 10$. $x$ should be co-prime to $N$ in order to continue.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;For completeness: &lt;/p&gt;&#xA;&#xA;&lt;ol start=&quot;4&quot;&gt;&#xA;&lt;li&gt;&lt;p&gt;Find the order $r$ of $x\bmod N$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;If $r$ is even and $x^{r/2} \neq -1 \pmod N$ then compute the $\text{gcd}(x^{r/2} -1,N)$ to see if one of these is a non-trivial factor. Otherwise, the algorithm fails. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;The reason the algorithm could fail is because you don't have enough qubits to perform the order-finding part to enough precision. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;These steps came from Section 5.3.2 of Nielsen &amp;amp; Chuang.&lt;/p&gt;&#xA;" OwnerUserId="54" LastEditorUserId="23" LastEditDate="2018-05-05T22:39:58.833" LastActivityDate="2018-05-05T22:39:58.833" CommentCount="4" />
  <row Id="2011" PostTypeId="2" ParentId="2007" CreationDate="2018-05-06T08:36:13.107" Score="4" Body="&lt;p&gt;Virtual reality is just a pretty front-end on top of a computer program. So, anything the computer program can do can be given a VR interface. As I see it, what is really being asked for is nice, yet 'authentic' ways of visualising quantum mechanics. One thing that immediately springs to mind is a book I read as an undergraduate, &lt;a href=&quot;https://www.amazon.co.uk/Mr-Tompkins-Paperback-Comprising-Wonderland/dp/0521093554/ref=sr_1_2?ie=UTF8&amp;amp;qid=1525613851&amp;amp;sr=8-2&amp;amp;keywords=mr%20tompkins%20in%20paperback&quot; rel=&quot;nofollow noreferrer&quot;&gt;Mr. Tompkins in Paperback&lt;/a&gt;. &lt;a href=&quot;https://www.amazon.co.uk/Alice-Quantumland-Allegory-Quantum-Physics/dp/0387914951&quot; rel=&quot;nofollow noreferrer&quot;&gt;Alice in Quantumland&lt;/a&gt; may also provide inspiration, I haven't read it. Then there's the &lt;a href=&quot;http://iqim.caltech.edu/outreach/#qcraft&quot; rel=&quot;nofollow noreferrer&quot;&gt;minecraft mod&lt;/a&gt; (which I haven't played).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The standard trick for doing the maths would essentially be to solve the Schrodinger equation but make the value of $\hbar$ much larger. That way, you should be able to get diffraction effects and similar at a macroscopic scale. This is a trick which probably works quite well for continuous systems (e.g. where you measure position), but I don't think it helps so much where you're talking about discrete systems (e.g. a qubit). In fact, there are probably some more fundamental questions you have to answer first, like 'What does an electron look like?' Is it really a nice little ball that you can pick up and play with, or is it something more diffuse and wavy? How do you represent its spin? (I don't think an arrow pointing in some direction is very authentic.) Part of the problem you rapidly get into here is that by looking at a quantum object, you're measuring it, and therefore changing it, and often making it so that it can't do the cool quantum trick you want it to do. So, I think you generally have to make some compromises to authenticity somewhere in order to create a representation that hopefully facilitates some sort of understanding.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-05-06T13:54:34.750" LastActivityDate="2018-05-06T13:54:34.750" CommentCount="0" />
  <row Id="2012" PostTypeId="1" CreationDate="2018-05-07T05:30:05.307" Score="7" ViewCount="69" Body="&lt;p&gt;Within &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_error_correction&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Error Correction&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Stabilizer_code&quot; rel=&quot;nofollow noreferrer&quot;&gt;stabilizer codes&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Toric_code&quot; rel=&quot;nofollow noreferrer&quot;&gt;toric codes&lt;/a&gt;/&lt;em&gt;surface codes&lt;/em&gt; are very tempting, mainly for their high error threshold. For more background please check up, in our Physics sister (aunt?) site: &lt;a href=&quot;https://physics.stackexchange.com/questions/169176/quantum-error-correction-surface-code-vs-color-code&quot;&gt;Quantum Error Correction: Surface code vs. color code&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, these codes require fairly specific measurements in specific bases, which I find hard to translate in practice, especially into my language of interest which is spin states in a solid-state few-spin collection. To see my motivation, here is a not-quite successful attept from a few years ago, using a more naïve QEC scheme: &quot;&lt;a href=&quot;https://arxiv.org/abs/1404.6912&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Error Correction with magnetic molecules&lt;/a&gt;&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, the problem:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;I am designing a realistic (molecular/supramolecular) network of 7 spins 1/2 (or something almost equivalent, see &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1867/is-qubit-qudit-terms-where-is-the-experimental-limit-between-an-s-3-2-and-2-s-1&quot;&gt;Is qubit/qudit terms, where is the experimental limit between an S=3/2 and 2&amp;#183;S=1/2?&lt;/a&gt;)&lt;/li&gt;&#xA;&lt;li&gt;a necessary first: what are the operations/measurements that I need to be able to do? here assume I'm able to do &lt;a href=&quot;https://en.wikipedia.org/wiki/Pulsed_electron_paramagnetic_resonance&quot; rel=&quot;nofollow noreferrer&quot;&gt;Pulsed electron paramagnetic resonance&lt;/a&gt; to address every transition coherently&lt;/li&gt;&#xA;&lt;li&gt;and, as a consequence, what is a good coupling scheme between my spins so that the required number of physical operations is reasonable?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Related: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2098/how-does-the-size-of-a-toric-code-torus-affect-its-ability-to-protect-qubits&quot;&gt;How does the size of a toric code torus affect its ability to protect qubits?&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="1847" LastEditDate="2018-05-19T05:19:25.927" LastActivityDate="2018-05-19T09:12:21.783" Title="Translation of color/toric code to a small network of solid-state spins" Tags="&lt;architecture&gt;&lt;experimental-results&gt;&lt;solid-state&gt;&lt;quantum-error-correction&gt;" AnswerCount="1" CommentCount="4" FavoriteCount="1" />
  <row Id="2013" PostTypeId="1" CreationDate="2018-05-07T15:19:40.753" Score="11" ViewCount="106" Body="&lt;p&gt;Recently, I heard that there can be transfer of &lt;em&gt;rational&lt;/em&gt; classical bits (for example 1.5 cbits) from one party to another via quantum teleportation. In the &lt;a href=&quot;https://courses.physics.illinois.edu/phys596/fa2011/StudentWork/team10_final.pdf&quot; rel=&quot;noreferrer&quot;&gt;Standard Teleportation Protocol&lt;/a&gt;, 2 classical bits and 1 maximally entangled shared resource state is required for perfect teleportation of the unknown state. But I do not understand how $1.x$ bits can be sent over in the classical channel.&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Is that possible? If yes, could you give a brief explanation?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;It'd be helpful if you could point me to some papers in which perfect teleportation is possible using fractional bits (and possibly extra quantum resources).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Some people might be wondering as to how this may be relevant to quantum computing. D. Gottesman and I.L. Chuang &lt;a href=&quot;https://www.nature.com/articles/46503&quot; rel=&quot;noreferrer&quot;&gt;suggested&lt;/a&gt; that quantum teleportation will play an important role as a primitive subroutine in quantum computation. G. Brassard, S.L. Braunstein and R. Cleve &lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S0167278998000438&quot; rel=&quot;noreferrer&quot;&gt;showed&lt;/a&gt; that quantum teleportation can be understood as quantum computation.&lt;/p&gt;&#xA;" OwnerUserId="506" LastEditorUserId="1837" LastEditDate="2018-05-07T16:18:49.797" LastActivityDate="2018-05-11T10:11:25.823" Title="Using a fractional number of classical bits within quantum teleportation" Tags="&lt;quantum-entanglement&gt;&lt;quantum-information&gt;&lt;resource-request&gt;" AnswerCount="2" CommentCount="8" />
  <row Id="2014" PostTypeId="2" ParentId="2013" CreationDate="2018-05-07T16:21:55.910" Score="7" Body="&lt;p&gt;I don't know for sure how you would achieve fewer than two bits of classical communication for a teleportation, but here's one way that you could have a non-integer number: if you teleport a qudit with dimension $d$ that is not a power of two. For each teleportation protocol, you'd have to send two dits of information, which you could represent in bits using $\lceil 2\log_2(d)\rceil$ bits. If you then repeat the protocol many times, you could combine the classical messages that you're sending and reduce it to $2\log_2(d)$ per teleportation protocol on average.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One possible route towards fewer than two bits of classical communication (if that's what you're after) is to use a combination of imperfect teleportation and non-universal teleportation (where we have some prior knowledge of what the state to be teleported could be). If your resource state is $\alpha|00\rangle+\sqrt{1-\alpha^2}|11\rangle$, then the probability of getting each measurement result in the teleportation protocol depends on the value of $\alpha$: teleporting a state $(\cos\frac{\theta}{2}|0\rangle+\sin\frac{\theta}{2}e^{i\phi}|1\rangle)$ gives the probailities of the four different Bell measurements,&#xA;$$&#xA;|B_{xy}\rangle=\frac{1}{\sqrt{2}}\left(|0x\rangle+(-1)^y|1\bar x\rangle\right)&#xA;$$&#xA;as&#xA;$$&#xA;p_{xy}=\frac{1}{4}(1+(-1)^x(2\alpha^2-1)\cos\theta),&#xA;$$&#xA;where $x$ and $y$ are single bits. Using the input distribution for the unknown quantum state, we can calculate the average value of $\sin\theta$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;For universal teleportation (where the input state could be any state), one has $\int_0^{\pi}\cos\theta\sin\theta d\theta=0$. In this case, the probabilities are all equal, and the best we can do is just to send the measurement result as two bits, $xy$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now imagine the case where $(2\alpha^2-1)\langle\cos\theta\rangle=\frac12$. Then, the probabilities are $(\frac38,\frac38,\frac18,\frac18)$. One can compress this information using, for example, Huffman encoding: $\{00,01,10,11\}\mapsto\{0,10,110,111\}$. This has an expected message length $\frac{15}{8}$. Thus, if you repeat this protocol many times, on average you send 1.875 bits per teleportation. This, of course, is just an example. Any value $(2\alpha^2-1)\langle\cos\theta\rangle&amp;gt;\frac13$ gives compression.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The trade-off is that unless $|\alpha|^2=|\beta|^2=\frac12$ (where you don't get any compression), the teleportation is imperfect.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-05-08T06:38:45.800" LastActivityDate="2018-05-08T06:38:45.800" CommentCount="1" />
  <row Id="2015" PostTypeId="2" ParentId="1285" CreationDate="2018-05-08T20:46:44.197" Score="2" Body="&lt;p&gt;You do not even need $Z$ and $X$. &lt;br&gt;&#xA;$\rm{CNOT}$, $H$, and $T=\pi/8$ are enough. &lt;br&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;1) $H$ and $T$ are enough to make any possible unitary transformation on one qubit. &lt;br&gt;&#xA;2) Adding $\rm{CNOT}$, you can synthesize a general unitary transformation to within any error $\epsilon&amp;gt;0$ using only $\mathcal{O}(\log^2(1/\epsilon))$ gates..&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you wish for the error to be $\epsilon=0$ and you are only willing to add the phase gate $\pi/2$, &lt;a href=&quot;https://arxiv.org/pdf/1212.0506.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;it is still possible&lt;/a&gt;, if and only if the elements of the unitary you want to make are of the form: $\frac{a+ib}{2^n} + \frac{c+id}{2^{n+1/2}}$, where all variables are integers. Remarkably, at most 1 auxiliary qubit is required for this exact synthesis.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Another universal gate set is $\{{\rm{CCNOT}},H\}$, and in fact there's a single gate that's uniersal: the 3-qubit &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_logic_gate#Universal_quantum_gates&quot; rel=&quot;nofollow noreferrer&quot;&gt;Deutsch gate&lt;/a&gt; ${D(\theta)}$.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-05-08T20:46:44.197" CommentCount="9" />
  <row Id="2016" PostTypeId="2" ParentId="2007" CreationDate="2018-05-09T15:52:57.200" Score="3" Body="&lt;p&gt;As others have said, VR is just a way of visualizing an output from a computer. If the computer producing the output is classical, it will struggle to visualize a universal set of gates on a many qubit system.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Even so, there are ways to visualize systems of few qubits with a classical computer (though not with VR). The &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Bloch_sphere&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bloch sphere&lt;/a&gt; is the well known example for a single qubit. There are also a couple of games that have visualizations for few qubits:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;http://www.meqanic.com/app/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Meqanic&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://medium.com/qiskitters/visualizing-bits-and-qubits-9af287047b28&quot; rel=&quot;nofollow noreferrer&quot;&gt;Hello Quantum&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;I’m sure there are others too. I’ll add them as I think of them, or as people point them out in the comments&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Regarding VR specifically, the only project I know of is &lt;a href=&quot;http://libbyheaney.co.uk/quantum-breathing/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Breathing&lt;/a&gt;. So you might want to check that out.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-05-09T15:52:57.200" CommentCount="0" />
  <row Id="2017" PostTypeId="1" AcceptedAnswerId="2019" CreationDate="2018-05-09T16:56:13.163" Score="11" ViewCount="265" Body="&lt;p&gt;It seems to me that an extremely relevant question for the prospects of quantum computing would be how the engineering complexity of quantum systems scales with size. Meaning, it's easier to build $n$ $1$-qubit computers than one $n$-qubit computer. In my mind, this is roughly analogous to the fact that it's easier to analytically solve $n$ $1$-body problems than one $n$-body problem, since entanglement is the primary motivating factor behind quantum computing in the first place.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is the following: It seems that we should really care about how the 'difficulty' of building and controlling an $n$-body quantum system grows with $n$. Fix a gate architecture, or even an algorithm--is there a difficulty in principle arising from the fact that an $n$-qubit computer &lt;em&gt;is&lt;/em&gt; a quantum many-body problem? And that mathematically speaking, our understanding of how quantum phenomena scale up into classical phenomena is quite poor? Here difficulty could be defined in any number of ways, and the question we would care about, roughly is, is controlling a $1000$-qubit machine (that is, preserving the coherence of its wavefunctions) 'merely' $100$x harder than controlling a $10$-qubit machine, or $100^2$, or $100!$ or $100^{100}$? Do we have any reasons for believing that it is more or less the former, and not the latter?&lt;/p&gt;&#xA;" OwnerUserId="1254" LastEditorUserId="1254" LastEditDate="2018-05-09T20:09:17.577" LastActivityDate="2018-07-13T14:59:16.657" Title="Are there any estimates on how complexity of quantum engineering scales with size?" Tags="&lt;quantum-computer&gt;&lt;architecture&gt;" AnswerCount="4" CommentCount="3" FavoriteCount="4" />
  <row Id="2018" PostTypeId="2" ParentId="2017" CreationDate="2018-05-09T18:33:13.820" Score="3" Body="&lt;h1&gt;Circuit Complexity&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;I think the first issue is to really understand what is meant by 'controlling' a quantum system. For this, it might help to start thinking about the classical case.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;How many different $n$-bit input, 1-bit output classical computations are there? For each of the $2^n$ possible inputs, there are $2$ different possible outputs. Thus, there are $2^{2^n}$ different possible functions that you could be asked to build, if what you're talking about in terms of controllability is &quot;build any of the possible functions&quot;. You might then go on to ask &quot;what fraction of these functions can I create by using no more than $2^n/n$ two-bit gates?&quot; (you could presumably generalise this to $k$-bit gates to get a relative complexity argument between two circuit sizes). There's a detailed calculation you can perform to get a good bound on this number, showing that it's small. This is something called Shannon's Theorem (but what isn't?), but there's at least an intuitive explanation: it requires a bit string of $2^n$ bits to specify which possible computation you're wanting to perform. This information must be incompressible, as there's no 'space' to be saved. But, if you could create all of these functions using shorter circuits, then describing that circuit would be a way of compressing the data. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The equivalent statement in quantum computing is &quot;build any $n$-qubit unitary to within some accuracy, $\epsilon$&quot;. But the classical answer is already horrific, even before we have to take into account the precision issues of specifying an arbitrary unitary. The point is that with both classical and quantum computations, we focus very specifically on the algorithms that we can implement 'easily', for some definition of 'easily', which is usually that the algorithms that we want to implement scale as some polynomial of the input size (with the possible exception of things like Grover's algorithm). So really the answer to the question depends on the algorithms you wish to run on the computer. If the algorithm scales as $O(n^2)$, then appropriately controlling an 1000-qubit machine is kind of 10000 times harder than controlling a 10-qubit machine, in the sense that you need to protect it from decoherence for that much longer, implement that many more gates etc.&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;Decoherence&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Following up on the comments, &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Let's consider a specific algorithm or a specific kind of circuit. My question could be restated--is there any indication, theoretical or practical, of how the (engineering) problem of &lt;em&gt;preventing decoherence&lt;/em&gt; scales as we scale the number of these circuits? &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;This divides into two regimes. For small scale quantum devices, before error correction, you might say we're in the &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1888/1837&quot;&gt;NISQ regime&lt;/a&gt;. &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2019/1837&quot;&gt;This answer&lt;/a&gt; is probably most relevant to that regime. However, as your device gets larger, there will be diminishing returns; it gets harder and harder to accomplish the engineering task just to add a few more qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;At that point, you have to transition to using error correction and, indeed, fault-tolerance (which is just a form of error correction which is capable of tolerating errors in the gates that implement the correction). Specifically, fault-tolerance says that there exists a threshold error probability $p$ such that, if you can perform every gate with an error probability $\leq p$, you can define some logical qubits (made up of multiple physical qubits) such that the result of any computation or arbitrary length can be accomplished with arbitrary precision. Whatever your physical hardware, by the time you've left the NISQ regime, you've done a lot of work eliminating decoherence as much as possible, and made sure you're as far below the $p$ threshold as possible. Current estimates place $p$ somewhere around the $1\%$ mark. The question becomes &quot;what are the overheads for these fault-tolerant processes&quot;. The precise details are scheme dependent, and much work continues into how to minimise these costs. The scaling argument, however, says that for each logical qubit, you require $O(-\log\epsilon)$ physical qubits to achieve an overall accuracy of $\epsilon$. There is also a time cost; most of your time is spent performing error correction rather than the logical gates. Again, this is an $O(-\log\epsilon)$ scale factor. For specific numbers, you might be interested in the sorts of calculations that Andrew Steane has performed: see &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0412165&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt; (although the numbers could probably be improved a bit now). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;What is really quite compelling is to see how the coefficients in these relations change as your gate error gets closer and closer to the error correcting threshold. I can't seem to lay my hands on a suitable calculation (I'm sure Andrew Steane did one at some point. Possibly it was a talk I went to.), but they blow up really badly, so you want to be operating with a decent margin below the threshold.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;That said, there are a few assumptions that have to be made about your architecture before these considerations are relevant. For example, there has to be sufficient parallelism; you have to be able to act on different parts of the computer simultaneously. If you only do one thing at a time, errors will always build up too quickly. You also want to be able to scale up your manufacturing process without things getting any worse. It seems that, for example, superconducting qubits will be quite good for this. Their performance mainly depends on how accurately you can make different parts of the circuit. You get it right for one, and you can &quot;just&quot; repeat many times to make many qubits.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-05-10T08:16:15.163" LastActivityDate="2018-05-10T08:16:15.163" CommentCount="2" />
  <row Id="2019" PostTypeId="2" ParentId="2017" CreationDate="2018-05-09T20:53:23.247" Score="8" Body="&lt;p&gt;This is a question that I have been thinking about for more than 10 years. &#xA;In 2008 I was a student, and I told my quantum computing professor that I wanted to study the &quot;physical complexity&quot; of performing quantum algorithms for which the &quot;computational complexity&quot; was known to benefit from quantum computation. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example Grover search requires $\mathcal{O}(\sqrt{n})$ quantum gates as opposed to $\mathcal{O}(n)$ classical gates, but what if the cost of controlling quantum gates scales as $n^4$ while for classical gates it's only $n$? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;He instantly replied: &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;Surely your idea of physical complexity will be implementation&#xA;  dependent&quot;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;That turned out to be true. The &quot;physical complexity&quot; of manipulating $n$ qubits with NMR is much worse than it is for superconducting qubits, but we do not have a formula for the physical difficulty with respect to $n$ for either case. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;These are the steps you'd need to take:&lt;/strong&gt; &lt;br&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; Come up with an accurate decoherence model for your quantum computer. This will be different for a spin qubit in a GaAs quantum dot, vs a spin qubit in a diamond NV centre, for example. &lt;br&gt;&#xA; &lt;strong&gt;2.&lt;/strong&gt; Accurately calculate the dynamics of the qubits in the presence of decoherence.&lt;br&gt;&#xA; &lt;strong&gt;3.&lt;/strong&gt; Plot $F$ vs $n$, where $F$ is the fidelity of the $n$ decohered qubits compared to the outcome you'd get without decoherence.&lt;br&gt;&#xA; &lt;strong&gt;4.&lt;/strong&gt; This can give you an indication of the error rate (but different algorithms will have different fidelity requirements). &lt;br&gt;&#xA; &lt;strong&gt;5.&lt;/strong&gt; Choose an error correcting code. This will tell you how many physical qubits you need for each logical qubit, for an error rate $E$.&lt;br&gt;&#xA; &lt;strong&gt;6.&lt;/strong&gt; Now you can plot cost (in terms of number of auxiliary qubits needed) of &quot;engineering&quot; the quantum computer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Now you can see why you had to come here to ask the question and the answer wasn't in any textbook:&lt;br&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Step 1&lt;/strong&gt; depends on the type of implementation (NMR, Photonics, SQUIDS, etc.) &lt;br&gt;&#xA;&lt;strong&gt;Step 2&lt;/strong&gt; is very hard. Decoherence-free dynamics has been simulated without physical approximations for &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2007/is-it-possible-to-simulate-a-quantum-computer-in-virtual-reality-if-yes-how&quot;&gt;64 qubits&lt;/a&gt;, but non-Markovian, non-perturbative dynamics with decoherence is presently limited to &lt;a href=&quot;https://github.com/ndattani/FeynDyn&quot; rel=&quot;noreferrer&quot;&gt;16 qubits&lt;/a&gt;.&lt;br&gt;&#xA;&lt;strong&gt;Step 4&lt;/strong&gt; depends on the algorithm. So there is no &quot;universal scaling&quot; of physical complexity, even if working with a particular type of implementation (like NMR, Photonics, SQUIDs, etc.)&lt;br&gt;&#xA;&lt;strong&gt;Step 5&lt;/strong&gt; depends on the choice of error correcting code&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;So, to answer your two questions specifically:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Is controlling a 1000-qubit machine (that is, preserving the&#xA;  coherence of its wavefunctions) 'merely' $100$x harder than&#xA;  controlling a $10$-qubit machine, or $100^2$, or $100!$ or&#xA;  $100^{100}$?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;It depends on your choice in &lt;strong&gt;Step 1&lt;/strong&gt;, and no one has been able to go all the way through &lt;strong&gt;Step 1 to Step 3&lt;/strong&gt; yet to get a precise formula for the physical complexity with respect to the number of qubits, even for a specific algorithm. So this is still an open question, limited by the difficulty of simulating open quantum system dynamics.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Do we have any reasons for believing that it is more or less the&#xA;  former, and not the latter?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The best reason is that this is our experience when we play with IBM's 5-qubit, 16-qubit and 50-qubit quantum computers. The error rates are not going up by $n!$ or $n^{100}$. How does the energy it takes to &lt;strong&gt;&lt;em&gt;make&lt;/em&gt;&lt;/strong&gt; the 5-qubit, 16-qubit and 50-qubit quantum computer, and how does &lt;strong&gt;&lt;em&gt;that&lt;/em&gt;&lt;/strong&gt; scale with $n$? This &quot;engineering complexity&quot; is even more implementation-dependent (think NMR vs SQUIDs) of an open question, albeit an interesting one. &lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="26" LastEditDate="2018-05-09T22:14:39.013" LastActivityDate="2018-05-09T22:14:39.013" CommentCount="3" />
  <row Id="2020" PostTypeId="1" AcceptedAnswerId="2021" CreationDate="2018-05-09T22:24:01.733" Score="10" ViewCount="97" Body="&lt;p&gt;There is a number of emerging quantum technologies, among which we find the category of photon-based quantum technologies, including quantum key distribution or quantum random number generators. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The question is: what is the &lt;strong&gt;short-term viability of photon-based quantum computation and simulation, compared with other photon-based quantum technologies&lt;/strong&gt;?&lt;/p&gt;&#xA;" OwnerUserId="1847" LastActivityDate="2018-05-11T13:39:09.303" Title="What is the status of quantum computing compared with other (photonic) quantum technologies?" Tags="&lt;quantum-computer&gt;&lt;optical-quantum-computing&gt;&lt;quantum-technologies&gt;" AnswerCount="1" CommentCount="3" FavoriteCount="1" />
  <row Id="2021" PostTypeId="2" ParentId="2020" CreationDate="2018-05-09T22:24:01.733" Score="6" Body="&lt;p&gt;According to &lt;a href=&quot;https://goochandhousego.com/wp-content/uploads/2018/05/GH-Market-Report-UK-Market-for-Quantum-Enabling-Photon-Sources-2018-2022-Report.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;this UK-oriented report by Gooch and Housego&lt;/a&gt; dated May 8, 2018, quantum computing is only one of several main key applications expected to have a market impact:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;ul&gt;&#xA;  &lt;li&gt;Clock technology/timing (e.g. bridging between the optical frequencies typical of atomic clocks and electrical/microwave&#xA;  frequencies typical of timing signals within telecommunication&#xA;  networks and computer systems)&lt;/li&gt;&#xA;  &lt;li&gt;LIDAR&lt;/li&gt;&#xA;  &lt;li&gt;Magnetometry and gravimetry&lt;/li&gt;&#xA;  &lt;li&gt;Medical imaging&lt;/li&gt;&#xA;  &lt;li&gt;Microscopy, imaging and calibration&lt;/li&gt;&#xA;  &lt;li&gt;Navigation&lt;/li&gt;&#xA;  &lt;li&gt;Non-QKD communications&lt;/li&gt;&#xA;  &lt;li&gt;QKD/quantum cryptography/secure communications&lt;/li&gt;&#xA;  &lt;li&gt;QRNG –quantum random number generator&lt;/li&gt;&#xA;  &lt;li&gt;Quantum computing and simulation&lt;/li&gt;&#xA;  &lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;To put the validity of this report into perspective, one needs to take into account that this study is an estimate of UK's demand (rather than global demand). Within this limitation, one can see that quantum computation and simulation is expected to be a relatively minor player within photon-based quantum technologies.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In bulk number of devices (demand volume), &lt;strong&gt;quantum random number generators&lt;/strong&gt; are expected to dominate absolutely. The linked report explicitly mentions: &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;em&gt;It will be incorporated into every device that requires encryption, which will drive the growth in sales volume&lt;/em&gt;. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;In demand value, &lt;strong&gt;QKD/quantum cryptography/secure communications&lt;/strong&gt; are expected to be a major player among quantum technologies. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Other applications, while minor, are considered solid, for example, &lt;strong&gt;gravimetry&lt;/strong&gt;, about which it is stated that:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;em&gt;Commercialisation is forecast for the beginning of 2019 when gravimeters will be used for geo-surveying such as bedrock analysis,&#xA;  detection of underground features and site surveying&lt;/em&gt;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Imaging, navigation or non-QKD communications&lt;/strong&gt; are similarly appreciated as photon-based quantum technologies that are about to hit a small but realistic market.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;In comparison, the report also asserts that : &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;em&gt;Experts &lt;strong&gt;do not&lt;/strong&gt; believe that a quantum computer will be developed within the next 5 years&lt;/em&gt;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;and &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;em&gt;Companies in sectors such as finance and banking and telecoms are adopting a ‘watch and wait’ approach, monitoring developments in&#xA;  academia, investing in know-how and awareness and purchasing small&#xA;  numbers of systems so that they will be ready when the technology&#xA;  reaches commercialisation&lt;/em&gt;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="26" LastEditDate="2018-05-11T13:39:09.303" LastActivityDate="2018-05-11T13:39:09.303" CommentCount="4" />
  <row Id="2022" PostTypeId="2" ParentId="2017" CreationDate="2018-05-09T22:29:49.667" Score="2" Body="&lt;p&gt;One way to think about quantum systems, which is qubits with error correction, and an encoded algorithm built in, or even in the general case where we program an algorithm is to ensure the fidelity of a qubit. So, for a system of $m$ qubits, we could could use proper error correction - for a given system of qubits, whether they are ion trap, superconducting, or any other scheme, and say the &quot;fidelity&quot; of a system given all these parameters is $n$ qubits. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;So in a sense, the &quot;fidelity&quot; could give an estimate, how error prone the processor is.  If you used the quantum computer to compute say chemical reaction dynamics, or any other problem, that could use superposition to achieve quantum speedup (or even &quot;quantum supremacy&quot; eventually) you could be impacted by decoherence, or even  how quickly you achieve a superposition, could play a part in error free operation.  &quot;Fidelity&quot; could give an error estimation, whether we use 1 qubit, or say 200 qubits. You could even &quot;engineer&quot; a Hamiltonian, to give high fidelity qubits, in the adiabatic case, where leakage errors, take place. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that in practice, error rates of 99.5%+ are highly desirable, to facilitate efficient error correction. Error rates could be of the type of reading electron spins between qubits to accuracy. In such a case, error rates, of 99.5%, or 99.8%(five or six sigma type confidence) would require less overheads(error correction) when scaling the system. &lt;/p&gt;&#xA;" OwnerUserId="429" LastEditorUserId="429" LastEditDate="2018-05-09T23:21:40.713" LastActivityDate="2018-05-09T23:21:40.713" CommentCount="1" />
  <row Id="2023" PostTypeId="5" CreationDate="2018-05-09T22:36:09.530" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-05-09T22:36:09.530" LastActivityDate="2018-05-09T22:36:09.530" CommentCount="0" />
  <row Id="2024" PostTypeId="4" CreationDate="2018-05-09T22:36:09.530" Score="0" Body="Questions about quantum technologies that act as enabling technologies for quantum computing. Also for for questions comparing the challenges faced and opportunities created by different quantum technologies with those corresponding to quantum computing." OwnerUserId="1847" LastEditorUserId="409" LastEditDate="2018-05-10T10:38:39.860" LastActivityDate="2018-05-10T10:38:39.860" CommentCount="0" />
  <row Id="2025" PostTypeId="2" ParentId="53" CreationDate="2018-05-09T23:52:33.253" Score="5" Body="&lt;p&gt;As one of the authors of the paper, and of the original theory papers on which that experimental realisation is based, perhaps I can attempt to answer. The BQC protocol used in that paper is based on a model of computations where measurements are made on a specially chosen entangled state (this is known as measurement-based quantum computation or MBQC, and was introduced in 2003 by Raussendorf and Briegel (&lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.68.022312&quot; rel=&quot;nofollow noreferrer&quot;&gt;PRA&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/pdf/quant-ph/0301052.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv&lt;/a&gt;). In MBQC the resource state is called a graph state, because a circuit to construct the graph state can be associated with a graph: for every vertex prepare a qubit in $|+\rangle$, and then perform a CZ gate between every pair of qubits for which the corresponding vertices share an edge in the graph. It turns out that you can implement an arbitrary quantum computation by first preparing a suitable graph state, and then by measuring out each qubit in turn, with measurement bases determined based on the target computation and on previous measurement outcomes. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;What the BQC protocol does is to effectively implement an MBQC in a way that hides measurement bases from Bob. The reason we mention a need for a generic structure is because the protocol does not hide the graph. Now, it turns out that you can actually choose a generic graph which can implement any quantum computation which can be expressed as a quantum circuit of a given depth and breadth if the measurement bases are chosen appropriately. Using such a graph ensures that only circuit depth and breadth are leaked, and not the details of the computation. Furthermore, the computation can always be randomly padded to ensure that only an upper bound on depth and breadth are leaked. This is the minimum possible leakage, since ultimately Bob knows how much memory his device has (~circuit breadth) and how long it ran (~circuit depth), and so it is impossible to avoid leaking such upper bounds.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For more information you may wish to take a look at the following review paper, and references contained therein:&#xA;&lt;a href=&quot;https://www.nature.com/articles/s41534-017-0025-3&quot; rel=&quot;nofollow noreferrer&quot;&gt;Private quantum computation: an introduction to blind quantum computing and related protocols&lt;/a&gt;, J.F. Fitzsimons, &lt;em&gt;npj Quantum Information&lt;/em&gt; 2017.&lt;/p&gt;&#xA;" OwnerUserId="2353" LastEditorUserId="409" LastEditDate="2018-05-10T10:37:43.227" LastActivityDate="2018-05-10T10:37:43.227" CommentCount="0" />
  <row Id="2026" PostTypeId="2" ParentId="2017" CreationDate="2018-05-10T06:04:52.920" Score="-1" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;Questions:&lt;/strong&gt; Are there any estimates on how complexity of quantum engineering scales with size?&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;My question is the following: It seems that we should really care about how the 'difficulty' of building and controlling a $n$-body quantum system grows with $n$. Fix a gate architecture or even an algorithm--is there a difficulty in principle arising from the fact that an n-qubit computer is a quantum many-body problem?&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Here difficulty could be defined in any number of ways, and the question we would care about, roughly is, is controlling a 1000-qubit machine (that is, preserving the coherence of its wavefunctions) 'merely' 100x harder than controlling a 10-qubit machine, or $100^2$, or $100!$ or $100^{100}$? &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The paper &quot;&lt;a href=&quot;http://iopscience.iop.org/article/10.1088/1367-2630/14/9/093039&quot; rel=&quot;nofollow noreferrer&quot;&gt;Measures of macroscopicity for quantum spin systems&lt;/a&gt;&quot; 21 Sept 2012, by Fröwis and Dür, has a useful introduction explaining one viewpoint of the complexity of this:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;strong&gt;1. Introduction&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quantum mechanics is probably the most successful and fascinating physical theory of the last century. In the first place, it provides a deep understanding of atoms and their interaction with light. In recent years, the prospects of improved technologies have been intensively investigated. This success comes with the price of a difficult interpretation of the theory, which was intensively discussed from a philosophical point of view. As long as we consider only microscopic systems on the scale of an atomic radius, objections to quantum mechanics are nevertheless rare, mainly because of the overwhelming experimental evidence. When it comes to macroscopic systems, many things are not clear anymore. Already in 1935, Schrödinger pointed out in his seminal paper$^{[1]}$ that quantum mechanics in principle allows superpositions of macroscopic states, like a cat that is alive and dead at the same time. This gedanken experiment is deeply connected with the so-called quantum measurement problem and was discussed by generations of physicists.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Besides the interest in the foundations of quantum mechanics, the question of macroscopic quantum mechanics also has practical aspects. Proposed architectures for quantum computers are based on a large number of qubits. Computational tasks that can overcome classical algorithms may require long-range quantum correlations$^{[2, 3]}$. A further application, quantum metrology, uses a certain kind of multipartite entanglement among many particles for an increased sensitivity in phase estimation protocols$^{[4]}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In 1980, Leggett$^{[5]}$ gave an important impulse to the topic of macroscopic quantum mechanics. He asked for a clear definition of the phrases 'macroscopic quantum phenomenon' and 'macroscopic superposition'. He realized that one should distinguish between quantum effects that originate on a microscopic level from 'true' macroscopic quantum effects. Among other examples, he highlights the specific heat of insulators. Classical statistical mechanics predicts a specific heat that is constant with respect to the temperature T. On the other hand, the quantum mechanical Debye model correctly predicts T3 behaviour for small temperatures. Many physicists considered this as an example of a macroscopic quantum phenomenon, since this law is valid even for large insulators. Leggett argued that the phrase macroscopic in this context is not justified, because the interactions that cause this effect are on an atomic scale and thus microscopic. In the following, he demanded a distinction between classical and microscopic quantum effects on the one hand, and macroscopic quantum effects on the other hand. Only the latter allow us to verify quantum mechanics (against classical theories) on a macroscopic scale, as in the example of Schrödinger's cat.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Consequently, we call quantum states that are capable of inducing macroscopic quantum effects the 'macroscopic quantum states'. The question at issue is: which properties of a many-body quantum state are appropriate for such a characterization? It is clear that the number of particles is an important but not sufficient criterion. If we consider superpositions of semi-classical quantum states, it seems to be crucial that they be 'macroscopically distinct', as Leggett$^{[5]}$ phrased it. However, a straightforward mathematical formulation of this intuitive characterization does not exist. Furthermore, there may be quantum states that do not exhibit a superposition of two semi-classical states but are superpositions of a large number of those. These and further concerns led to various proposals of macroscopic quantum states$^{[5–12]}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The goal of this work is twofold. Firstly, we motivate and introduce another aspect of macroscopic quantum effects in discrete systems. After basic considerations in section 2, we propose to use the so-called quantum Fisher information as a measure of 'macroscopicity'.&quot; ...&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;References for above:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;References&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[1] Schrödinger E 1935 Naturwissenschaften 23 807&#xA;&#xA;[2] Jozsa R and Linden N 2003 Phil. Trans. R. Soc. A 459 2011–32&#xA;&#xA;[3] Datta A and Vidal G 2007 Phys. Rev. A 75 042310&#xA;&#xA;[4] Pezzé L and Smerzi A 2009 Phys. Rev. Lett. 102 100401&#xA;&#xA;[5] Leggett A J 1980 Prog. Theor. Phys. Suppl. 69 80&#xA;&#xA;[6] Dür W, Simon C and Cirac J I 2002 Phys. Rev. Lett. 89 210402&#xA;&#xA;[7] Shimizu A and Miyadera T 2002 Phys. Rev. Lett. 89 270403&#xA;&#xA;[8] Björk G and Mana P G L 2004 J. Opt. B: Quantum Semiclass. Opt. 6 429–36&#xA;&#xA;[9] Shimizu A and Morimae T 2005 Phys. Rev. Lett. 95 090401&#xA;&#xA;[10] Korsbakken J I, Whaley K B, Dubois J and Cirac J I 2007 Phys. Rev. A 75 042106&#xA;&#xA;[11] Marquardt F, Abel B and von Delft J 2008 Phys. Rev. A 78 012109&#xA;&#xA;[12] Lee C and Jeong H 2011 Phys. Rev. Lett. 106 220401&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Another metric put forth to measure complexity is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Greenberger%E2%80%93Horne%E2%80%93Zeilinger_state&quot; rel=&quot;nofollow noreferrer&quot;&gt;Greenberger–Horne–Zeilinger state&lt;/a&gt; but Fröwis and Dür explain why they favor Fisher. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;GHZ is explained as:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;The GHZ state is an entangled quantum state of $M \gt 2$ subsystems. In the case of each of the subsystems being two-dimensional, that is for qubits, it reads:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$${\displaystyle |\mathrm {GHZ}}\rangle ={\frac {|0\rangle ^{{\otimes M}}+|1\rangle ^{{\otimes M}}}{{\sqrt {2}}}}.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In simple words, it is a quantum superposition of all subsystems being in state 0 with all of them being in state 1 (states 0 and 1 of a single subsystem are fully distinguishable).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The simplest one is the 3-qubit GHZ state:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$${\displaystyle |\mathrm {GHZ}}\rangle ={\frac {|000\rangle +|111\rangle }{{\sqrt {2}}}}.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This state is non-biseparable$^{[1]}$ and is the representative of one of the two non-biseparable classes of 3-qubit states (the other being the W state), which cannot be transformed (not even probabilistically) into each other by local quantum operations.$^{[2]}$ Thus $|\mathrm {GHZ} \rangle$ and $|W\rangle$ represent two very different kinds of tripartite entanglement. The W state is, in a certain sense &quot;less entangled&quot; than the GHZ state; however, that entanglement is, in a sense, more robust against single-particle measurements, in that, for an N-qubit W state, an entangled (N − 1)-qubit state remains after a single-particle measurement. By contrast, certain measurements on the GHZ state collapse it into a mixture or a pure state.&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Notes:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[1]. A pure state $| \psi \rangle$ of $\text{N}$ parties is called biseparable, if one can find a partition of the parties in two disjoint subsets $\text{A}$ and $\text{B}$ with $A\cup B=\{1,\dots ,N\}$ such that $|\psi \rangle =|\phi \rangle _{A}\otimes |\gamma \rangle _{B}$, i.e. $|\psi \rangle$ is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Product_state&quot; rel=&quot;nofollow noreferrer&quot;&gt;product state&lt;/a&gt; with respect to the partition $A|B$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[2]. W. Dür; G. Vidal &amp;amp; J. I. Cirac (2000). &quot;Three qubits can be entangled in two inequivalent ways&quot;. Phys. Rev. A. 62: 062314. &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0005115&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv:quant-ph/0005115&lt;/a&gt; . &lt;a href=&quot;http://adsabs.harvard.edu/abs/2000PhRvA..62f2314D&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bibcode&lt;/a&gt;:2000PhRvA..62f2314D. &lt;a href=&quot;https://doi.org/10.1103%2FPhysRevA.62.062314&quot; rel=&quot;nofollow noreferrer&quot;&gt;doi&lt;/a&gt;:10.1103/PhysRevA.62.062314.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; &quot;Do we have any reasons for believing that it is more or less the former, and not the latter?&quot;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;My own favorite would be the &lt;a href=&quot;https://en.wikipedia.org/wiki/Hyperoperation&quot; rel=&quot;nofollow noreferrer&quot;&gt;hyperoperation&lt;/a&gt; called &lt;a href=&quot;https://en.wikipedia.org/wiki/Tetration&quot; rel=&quot;nofollow noreferrer&quot;&gt;tetration&lt;/a&gt; or in &lt;a href=&quot;https://en.wikipedia.org/wiki/Rudy_Rucker&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rudy Rucker&lt;/a&gt; notation $^{n}a$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://math.blogoverflow.com/2015/01/05/climbing-the-ladder-of-hyper-operators-tetration/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Tetration&lt;/a&gt; is defined as:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$T(a, b) = {}^ba = \underbrace{a^{a^{a^{…^{a}}}}}_{b \&amp;gt; times}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A single qubit we will call &lt;em&gt;easy&lt;/em&gt; for the sake of comparison, adding another qubit, not as another single qubit but as a fully operational pair, increases the complexity beyond $2^2$. There's the building, maintenance, maintaining of state, programming and measurement complexity; which are all increased for each additional universal qubit.&lt;/p&gt;&#xA;" OwnerUserId="278" LastEditorUserId="26" LastEditDate="2018-07-13T14:59:16.657" LastActivityDate="2018-07-13T14:59:16.657" CommentCount="0" />
  <row Id="2027" PostTypeId="2" ParentId="2013" CreationDate="2018-05-11T10:11:25.823" Score="4" Body="&lt;p&gt;I recently found a &lt;a href=&quot;https://arxiv.org/pdf/quant-ph/0305085v4.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;paper&lt;/a&gt; by Subhash Kak that introduces teleportation protocols that require lesser classical communication cost (with more quantum resource). I thought it'd be better to write a separate answer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Kak discusses three protocols; two of them use 1 cbit and the last one requires 1.5 cbits. But the first two protocols are in a &lt;em&gt;different&lt;/em&gt; setting, i.e the entangled particles are initially in Alice's lab (and a few local operations are performed), then one of the entangled particle is transferred to Bob's lab; this is unlike the &lt;a href=&quot;https://www.researchgate.net/publication/13237765_Teleporting_an_unknown_quantum_state_via_dual_classical_and_Einstein-Podolsky-Rosen_channels&quot; rel=&quot;nofollow noreferrer&quot;&gt;Standard&lt;/a&gt; setting where the entangled particles are pre-shared between Alice and Bob before the protocol is even started. Interested people can go through those protocols that use only 1 cbit. I'll &lt;em&gt;try&lt;/em&gt; to explain the last protocol that uses only &lt;strong&gt;1.5&lt;/strong&gt; cbits (fractional cbits).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are four particles, namely, $X, Y, Z$ and $U$. $X$ is the unkown particle (or state) that has to be teleported from Alice's lab to Bob's lab. $X, Y$ and $Z$ are with Alice, and $U$ is with Bob. Let $X$ be represented as $\alpha|0\rangle + \beta|1\rangle$, such that $|\alpha|^2+|\beta|^2=1$. The three particles $Y, Z$ and $U$ are in the pure entangled state $|000\rangle+|111\rangle$ (leaving the normalization constants for now).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, the initial state of the whole system is:&#xA;$$&#xA;\alpha|0000\rangle + \beta|1000\rangle + \alpha|0111\rangle + \beta|1111\rangle&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Step 1&lt;/strong&gt;: Apply chained XOR transformations on $X, Y$ and $Z$ (i) XOR the states of $X$ and $Y$ (ii) XOR the states of $Y$ and $Z$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The $XOR$ unitary is given by:&#xA;$$&#xA;XOR =&#xA;\left[{\begin{array}{cccc}&#xA;1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0\\&#xA;0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0\\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1\\&#xA;0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0&#xA;\end{array}}\right].&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In other words, the state transformations are the following:&#xA;$$&#xA;|00\rangle \rightarrow |00\rangle \\&#xA;|01\rangle \rightarrow |01\rangle \\&#xA;|10\rangle \rightarrow |11\rangle \\&#xA;|11\rangle \rightarrow |10\rangle \\&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;After Step 1, the state of the whole system is:&#xA;$$&#xA;\alpha|0000\rangle + \beta|1110\rangle + \alpha|0101\rangle + \beta|1011\rangle&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Step 2&lt;/strong&gt;: Apply Hadamard tranform on the state of $X$.&#xA;$$&#xA;\alpha(|0000\rangle + |1000\rangle) + \beta(|0110\rangle - |1110\rangle) + \alpha(|0101\rangle + |1101\rangle) + \beta(|0011\rangle - |1011\rangle)&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Step 3&lt;/strong&gt;: Alice measures the state of $X$ and $Y$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;On simplifying the above representation, we get&#xA;$$&#xA;|00\rangle(\alpha|00\rangle + \beta|11\rangle) + |01\rangle(\alpha|01\rangle + \beta|10\rangle) + |10\rangle(\alpha|00\rangle - \beta|11\rangle) + |11\rangle(\alpha|01\rangle - \beta|10\rangle).&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Step 4&lt;/strong&gt;: Depending on Alice's measurement outcome, appropiate unitaries are applied on $Z$ (by Alice) and $U$ (by Bob).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(a) If Alice gets $|00\rangle$, then both Alice and Bob do nothing.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(b) If Alice gets $|10\rangle$, then Alice applies $\left[{\begin{array}{cc}1 &amp;amp; 0 \\0 &amp;amp; -1 \end{array}}\right]$ and Bob does nothing.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(c) If Alice gets $|01\rangle$, then Alice does nothing and Bob applies $\left[{\begin{array}{cc}0 &amp;amp; 1 \\1 &amp;amp; 0 \end{array}}\right]$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(d) If Alice gets $|11\rangle$, then Alice applies $\left[{\begin{array}{cc}1 &amp;amp; 0 \\0 &amp;amp; -1 \end{array}}\right]$ and Bob applies $\left[{\begin{array}{cc}0 &amp;amp; 1 \\1 &amp;amp; 0 \end{array}}\right]$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Basically, $\left[{\begin{array}{cc}1 &amp;amp; 0 \\0 &amp;amp; 1 \end{array}}\right]$, $\left[{\begin{array}{cc}1 &amp;amp; 0 \\0 &amp;amp; -1 \end{array}}\right]$, $\left[{\begin{array}{cc}0 &amp;amp; 1 \\1 &amp;amp; 0 \end{array}}\right]$ and $\left[{\begin{array}{cc}0 &amp;amp; 1 \\-1 &amp;amp; 0 \end{array}}\right]$ can be appropiately used to alter the combined state of $Z$ and $U$ so that it becomes $\alpha|00\rangle + \beta|11\rangle$. &lt;strong&gt;Note&lt;/strong&gt; that if Alice gets $|01\rangle$ or $|11\rangle$, then Bob &lt;em&gt;has&lt;/em&gt; to apply some unitary so that the combined state of $Z$ and $U$ is $\alpha|00\rangle + \beta|11\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Step 5&lt;/strong&gt;: Apply Hadamard transform on the state of $Z$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;After applying the unitaries, the combined state of $Z$ and $U$ is $\alpha|00\rangle + \beta|11\rangle$ (as mentioned above). So, after Step 5, the combined state of $Z$ and $U$ is,&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;\alpha|00\rangle + \alpha|10\rangle + \beta|01\rangle - \beta|11\rangle \\&#xA;= |0\rangle(\alpha|0\rangle + \beta|1\rangle) + |1\rangle(\alpha|0\rangle - \beta|1\rangle).&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Step 6&lt;/strong&gt;: Alice measures the state of $Z$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Based on her measurement, she transmits &lt;em&gt;one&lt;/em&gt; classical bit of information to Bob so that he can use an appropriate unitary to obtain the unkown state!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Discussion&lt;/strong&gt;: So, how does the protocol require $1.5$ bits of clasiical communication? Cleary, Step 6 uses 1 cbit, and in Step 4, it is easy notice that for two outcomes (namely, $|10\rangle$ or $|00\rangle$), Bob need &lt;em&gt;not&lt;/em&gt; apply any unitary. Bob has to apply some unitary (specified prior to the protocool; say $\left[{\begin{array}{cc}0 &amp;amp; 1 \\1 &amp;amp; 0 \end{array}}\right]$) if Alice gets the other two outcomes, and in those scenarios, Alice sends one cbit indicating that the unitary is to be used by Bob. So, it is &lt;strong&gt;mentioned&lt;/strong&gt; that this has a &lt;em&gt;computational burden&lt;/em&gt; of 0.5 cbits (because 50% of the time, Bob need not apply any unitary). Hence, the whole protocol &lt;em&gt;requires&lt;/em&gt; only 1.5 cbits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But, Alice must send that 1 cbit whether or not she gets those outcomes, right? Alice and Bob &lt;em&gt;cannot&lt;/em&gt; agree on a particular time (after the protocol) when Alice sends that 1 cbit, and if Bob doesn't get that classical bit by that time, then he knows that he need not apply any unitary. These time dependent protcols are, in general, not allowed due to relativistic consequences (otherwise, you can even make the Standard protocol to use time for indicating information and reduce the classical communication cost to 1 cbit; for example, at $t_1$, send one cbit or at $t_2$, send one cbit). So, Alice must send that cbit everytime, right? In that case, the protcol requires 2 cbits (one in Step 4 and another in Step 6). I thought it'd be good if there was a discussion on this particular part.&lt;/p&gt;&#xA;" OwnerUserId="506" LastActivityDate="2018-05-11T10:11:25.823" CommentCount="2" />
  <row Id="2028" PostTypeId="1" CreationDate="2018-05-11T14:47:33.197" Score="13" ViewCount="533" Body="&lt;p&gt;When a qubit is measured, there is a ‘collapse of the wave-function’ as a result is randomly chosen.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If the qubit is entangled with others, this collapse will also effect them. And the way it affects them depends on the way we chose to measure our qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;From this it seems as though things we do on one qubit have instantaneous effects on another. Is this the case, or is the apparent effect more like a &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Bayesian_inference&quot; rel=&quot;noreferrer&quot;&gt;Bayesian update&lt;/a&gt; of our knowledge about the qubits?&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="26" LastEditDate="2018-05-17T13:43:34.103" LastActivityDate="2018-05-17T13:43:34.103" Title="Is it true to say that one qubit in an entangled state can instantaneously affect all others?" Tags="&lt;quantum-entanglement&gt;&lt;qubit-state&gt;&lt;bayesian-learning&gt;&lt;non-locality&gt;&lt;contextuality&gt;" AnswerCount="2" CommentCount="1" FavoriteCount="1" />
  <row Id="2029" PostTypeId="2" ParentId="2028" CreationDate="2018-05-11T14:55:34.207" Score="6" Body="&lt;p&gt;It is certainly true that, within the mathematical description of qubits, operations on one qubit can require the whole description to be updated. This therefore affects the description of every qubit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Those who take a 'epistemic' view of this mathematical description might say that we are just updating our knowledge about the other qubits, and that it doesn't affect the qubits themselves. Those who take an 'ontic' view, however, regard the wave function described by the mathematics of quantum mechanics as being a physical property of the qubits. So they would certainly conclude that the the operation on one qubit instantly affected the others.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I think the ontic view is more prevalent these days, among those who have opinions on these things. Though most take the 'Shut up and calculate' option and don't think about them too much.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Another interesting issue is the fact that instantaneous effects cause problems for relativity. Different observers in different reference frames can disagree on the time ordering of events. So one observer might see one qubit being used to affect a second, whereas another observer might see the same events and conclude that the second qubit is affecting the first. Entanglement avoids direct confrontation with relativity by making sure that the affect cannot be used to send any information instantaneously. But nevertheless, they don't play very well together. So that's why we can be hesitant to state that very strongly that entanglement allows instantaneous effects.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The process of teleportation is, I think, a good one to argue that entanglement does indeed allow qubits to instantly affect each other, as well as showing how it compromises with relativity. It is a process by which the state of a qubit is instantaneously sent from one qubit to another, using entanglement. But the state being sent also gets 'scrambled' during the process. This means that it is impossible for the receiving end to even confirm that the qubit has been sent, never mind see what its state is. However, the transmitter can send a message to the receiver with instructions on how to unscramble the qubit. Once this is done, the receivers can confirm that the teleportation did indeed send the state of the qubit. So there was indeed an instantaneous effect, but non-instantaneous effects (sending the unscrambling information) were also needed to reveal the effect and make it useful.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-05-11T14:55:34.207" CommentCount="2" />
  <row Id="2030" PostTypeId="1" AcceptedAnswerId="2039" CreationDate="2018-05-11T15:17:18.643" Score="10" ViewCount="167" Body="&lt;p&gt;I have been trying to get a basic idea of what anyons are for the past couple of days. However, the online articles (including Wikipedia) seem unusually vague and impenetrable as far as explaining topological quantum computing and anyons goes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Topological_quantum_computer&quot; rel=&quot;noreferrer&quot;&gt;Wiki page&lt;/a&gt; on &lt;em&gt;Topological quantum computer&lt;/em&gt; says:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;A topological quantum computer is a theoretical quantum computer that&#xA;  employs two-dimensional quasiparticles called &lt;strong&gt;anyons&lt;/strong&gt;, whose world&#xA;  lines pass around one another to &lt;strong&gt;form braids&lt;/strong&gt; in a three-dimensional&#xA;  spacetime (i.e., &lt;strong&gt;one temporal plus two spatial dimensions&lt;/strong&gt;). These braids &#xA;  &lt;strong&gt;form the logic gates&lt;/strong&gt; that make up the computer. The advantage of a&#xA;  quantum computer based on &lt;strong&gt;quantum braids&lt;/strong&gt; over using trapped quantum&#xA;  particles is that the former is much more stable. Small, cumulative&#xA;  perturbations can cause quantum states to decohere and introduce&#xA;  errors in the computation, but such small perturbations do not change&#xA;  the braids' topological properties.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;This sounded interesting. So, on seeing this definition I tried to look up what &lt;a href=&quot;https://en.wikipedia.org/wiki/Anyon&quot; rel=&quot;noreferrer&quot;&gt;anyons&lt;/a&gt; are: &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;In physics, an anyon is a type of &lt;strong&gt;quasiparticle&lt;/strong&gt; that occurs only in&#xA;  &lt;strong&gt;two-dimensional systems&lt;/strong&gt;, with properties much less restricted than&#xA;  fermions and bosons. In general, the operation of exchanging two&#xA;  identical particles may cause a &lt;strong&gt;global phase shift&lt;/strong&gt; but cannot affect&#xA;  observables.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Okay, I do have &lt;em&gt;some&lt;/em&gt; idea about what &lt;strong&gt;quasiparticles&lt;/strong&gt; are. For example, as an electron travels through a semiconductor, its motion is disturbed in a complex way by its interactions with all of the other electrons and nuclei; however, it approximately behaves like an electron with a different mass (effective mass) travelling unperturbed through free space. This &quot;electron&quot; with a different mass is called an &quot;electron quasiparticle&quot;. So I tend to assume that a quasiparticle, in general, is an approximation for the complex particle or wave phenomenon that may occur in matter, which would be difficult to mathematically deal with otherwise. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, I could not follow what they were saying after that. I do know that bosons are particles which follow the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bose%E2%80%93Einstein_statistics&quot; rel=&quot;noreferrer&quot;&gt;Bose-Einstein statistics&lt;/a&gt; and fermions follow the &lt;a href=&quot;https://en.wikipedia.org/wiki/Fermi%E2%80%93Dirac_statistics&quot; rel=&quot;noreferrer&quot;&gt;Fermi-Dirac statistics&lt;/a&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Questions:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;However, what do they mean by &quot;much less restricted than fermions and bosons&quot;? Do &quot;anyons&quot; follow a different kind of statistical distribution than what bosons or fermions follow? &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;In the next line, they say that exchanging two identical particles may cause a global phase shift but cannot affect the observables. What is meant by &lt;strong&gt;global phase shift&lt;/strong&gt; in this context? Moreover, &lt;em&gt;which&lt;/em&gt; &lt;strong&gt;observables&lt;/strong&gt; are they actually talking about here? &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;How are these quasiparticles i.e. anyons actually relevant to quantum computing? I keep hearing vague things likes &quot;&lt;em&gt;The world-lines of anyons form braids/knots in 3-dimensions (2 spatial and 1 temporal). These knots help form stable forms of matter, which aren't easily susceptible to decoherence&lt;/em&gt;&quot;. I think that &lt;a href=&quot;https://www.youtube.com/watch?v=GJHhnr9R_ZM&quot; rel=&quot;noreferrer&quot;&gt;this Ted-Ed video&lt;/a&gt; gives &lt;em&gt;some&lt;/em&gt; idea, but it seems to deal with restricting &lt;em&gt;electrons&lt;/em&gt; (rather than &quot;anyons&quot;) to move on a certain closed path inside a material.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;I would be glad if someone could help me to &lt;em&gt;connect the dots&lt;/em&gt; and understand the &lt;em&gt;meaning&lt;/em&gt; and &lt;em&gt;significance&lt;/em&gt; of &quot;anyons&quot; at an intuitive level. I think a &lt;em&gt;layman-level&lt;/em&gt; explanation would be more helpful for me, initially, rather than a full-blown mathematical explanation. However, I do know basic undergraduate level quantum mechanics, so you may use that in your explanation. &lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-05-11T19:06:07.347" LastActivityDate="2018-05-15T10:11:43.293" Title="What exactly are anyons and how are they relevant to topological quantum computing?" Tags="&lt;topological-quantum-computing&gt;&lt;anyons&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="2031" PostTypeId="5" CreationDate="2018-05-11T15:22:17.167" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-05-11T15:22:17.167" LastActivityDate="2018-05-11T15:22:17.167" CommentCount="0" />
  <row Id="2032" PostTypeId="4" CreationDate="2018-05-11T15:22:17.167" Score="0" Body="For questions about anyons as relevant to quantum computing. An anyon is a type of quasiparticle that occurs only in two-dimensional systems, with properties much less restricted than fermions and bosons. In general, the operation of exchanging two identical particles may cause a global phase shift but cannot affect observables. Anyons are generally classified as abelian or non-abelian (from Wikipedia). They are necessary for topological quantum computing." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-06T09:04:30.177" LastActivityDate="2018-07-06T09:04:30.177" CommentCount="0" />
  <row Id="2033" PostTypeId="2" ParentId="2028" CreationDate="2018-05-11T15:26:15.570" Score="6" Body="&lt;p&gt;If Alice and Bob have an entangled pair of qubits and Alice locally measures her qubit, it does not affect local state of the Bob's qubit in any way. Mathematically, if Alice measures but does not look at the measurement outcome, density matrix of the Bob's qubit does not change. The sole fact of Alice's measurement does not affect the Bob's qubit in any way. If Alice measures and knows the measurement outcome, then Alice has more information about the Bob's qubit than Bob, but this is pure classical situation described by conditional probabilities.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So the Alice's measurement can only instantly affect Alice's information about the Bob's qubit, and no more.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The above said does not explain the &quot;spooky action at distance&quot;, we know the satisfying explanation does not exist. Still we can argue about entanglement and measurements avoiding paradoxes and contradictions, and so the answer to the question in the title:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;No, it is not true&lt;/strong&gt;.&lt;/p&gt;&#xA;" OwnerUserId="2105" LastEditorUserId="2105" LastEditDate="2018-05-11T15:52:58.750" LastActivityDate="2018-05-11T15:52:58.750" CommentCount="5" />
  <row Id="2034" PostTypeId="2" ParentId="2030" CreationDate="2018-05-12T02:15:47.410" Score="4" Body="&lt;p&gt;You are right, it does look like the Wikipedia page needs work, so I will have to update it. But for now I will answer all five questions:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;1)&lt;/strong&gt; What do they mean by &quot;much less restricted than fermions and bosons? &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The exchange of two fermions or bosons is &lt;strong&gt;&lt;em&gt;restricted&lt;/em&gt;&lt;/strong&gt; by:&#xA;$|\psi_1\psi_2\rangle = \pm|\psi_2\psi_1\rangle$.&lt;br&gt;&#xA;The &quot;$+$&quot; corresponds to bosons and the &quot;$-$&quot; corresponds to fermions.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For anyons we have the much &lt;strong&gt;&lt;em&gt;less restricted&lt;/em&gt;&lt;/strong&gt;: $|\psi_1\psi_2\rangle = e^{i\theta}|\psi_2\psi_1\rangle$. &lt;br&gt;&#xA;Notice that when $\theta=0$ we have bosons, and when $\theta=\pi$ we have fermions (by &lt;a href=&quot;https://en.wikipedia.org/wiki/Euler%27s_formula&quot; rel=&quot;nofollow noreferrer&quot;&gt;Euler's formula&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;2)&lt;/strong&gt; Do &quot;anyons&quot; follow a different kind of statistical distribution than what bosons or fermions follow?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Anyons can obey statistics ranging continuously between Fermi-Dirac statistics and Bose-Einstein statistics, because $\theta$ can be $0$ (bosons), $\pi$ (fermions), or anything in between. &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;3)&lt;/strong&gt; Exchanging two identical particles may cause a global phase shift but cannot affect the observables. What is meant by global phase shift in this context? &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;That line from Wikipedia needs to be improved. The &quot;global phase shift&quot; is the $e^{i\theta}$ in the above formula. So it is &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; specific to anyons, since there is a global phase change of $-1$  when we exchange fermions as well.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What the Wikipedia article &lt;strong&gt;&lt;em&gt;should&lt;/em&gt;&lt;/strong&gt; have said was that when you exchange two identical particles &lt;strong&gt;&lt;em&gt;twice&lt;/em&gt;&lt;/strong&gt; you still get a global phase shift, which is not true for bosons and fermions. Here the first and second arrows indicate the first and second times we exchange particles 1 and 2:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Bosons: $|\psi_1\psi_2\rangle \rightarrow |\psi_2\psi_1\rangle \rightarrow |\psi_1\psi_2\rangle$ (no global phase)&lt;br&gt;&#xA;Fermions: $|\psi_1\psi_2\rangle \rightarrow -|\psi_2\psi_1\rangle \rightarrow -(-|\psi_1\psi_2\rangle)=|\psi_1\psi_2\rangle$ (no global phase)&lt;br&gt;&#xA;Anyons: $|\psi_1\psi_2\rangle \rightarrow e^{i\theta}|\psi_2\psi_1\rangle \rightarrow e^{i\theta}(e^{i\theta})=e^{i2\theta}|\psi_1\psi_2\rangle$ (global phase of $e^{i2\theta}$)&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;4)&lt;/strong&gt; Moreover, which observables are they actually talking about here? &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;An observable is anything that can be observed in an experiment. For example, the position of the particle, $x$. When measuring the position of the particle, the probability of finding the particle at position $x$ is given by $\langle \psi|\hat{x}|\psi\rangle $. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Notice that this is unaffected by a global phase, because we have:&lt;br&gt;&#xA;$| \psi\rangle=e^{i\theta}|\phi\rangle$&lt;br&gt;&#xA;$\langle \psi|=e^{-i\theta}\langle\phi|$&lt;br&gt;&#xA;$\langle\psi|\hat{x}|\psi\rangle = \langle\phi|\hat{x}|\phi\rangle $.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So two states $|\phi\rangle$ and $|\psi\rangle$, which differ by a phase of $e^{i\theta}$, as in this case, have the &lt;strong&gt;&lt;em&gt;same&lt;/em&gt;&lt;/strong&gt; observations in experiment.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;5)&lt;/strong&gt; How are these quasiparticles i.e. anyons actually relevant to quantum computing? &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There are many proposals for building a quantum computer, for example:&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;(i)&lt;/strong&gt; NMR quantum computers make use of fermions (such as the spin of a proton).&lt;br&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;(ii)&lt;/strong&gt; Photonic quantum computers make use of bosons (photons are bosons) &lt;br&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;(iii)&lt;/strong&gt; Topological quantum computers are a proposed type of quantum computer which would make use of anyons.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;An advantage of (iii) over (i) is that fidelities should be much greater. The advantage over (ii) is that it should be easier to get the qubits to interact. The disadvantage over both (i) and (ii) is that experiments involving anyons are comparatively rather new. NMR has been around since 1938 and lasers (photonics) have been around since 1960, but experiments with anyons began in the 1980s and are still far away from reaching the maturity of spin science or laser science, not to say that it will never happen in the future.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;I think a layman-level explanation would be more helpful for me, initially, rather than a full-blown mathematical explanation.&quot;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;A layman definition without mathematics is going to be very difficult because what distinguishes anyons from bosons and anyons is that the exchange of anyons introduces a factor of $e^{i\theta}$ to the wavefunction, which is a mathematical explanation. If I had to explain anyons to someone who knows what a wavefunction is but nothing else, I would say:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;When two particles are switched, the wavefunction of the overall system stays the same for bosons, picks up a negative sign for fermions, and can pick up any factor of the form $e^{i\theta}$ for anyons.&quot;&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-05-12T03:31:21.883" LastActivityDate="2018-05-12T03:31:21.883" CommentCount="12" />
  <row Id="2035" PostTypeId="1" CreationDate="2018-05-12T17:34:38.400" Score="4" ViewCount="38" Body="&lt;p&gt;&lt;strong&gt;CTs / ZEFOZs&lt;/strong&gt;: Energy level structures that include &lt;a href=&quot;https://en.wikipedia.org/wiki/Avoided_crossing&quot; rel=&quot;nofollow noreferrer&quot;&gt;avoided crossings&lt;/a&gt; at accessible energies tend to be resilient to noise and therefore present high coherence times, at least in the case of spin qubits and magnetic noise: as the at first order effect of the magnetic field on the qubit energy vanishes, so does effectively most magnetic noise. Different people call these Atomic Clock Transitions (CTs or ACTs) or Zero First-Order-Zeeman (ZEFOZ) shift, but it's essentially the same phenomenon. This is experimentally expressed as high spin-spin $T_2$ relaxation times, even in presence of relatively high sources of noise.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, in a quantum computing scenario, what we want is typically not a qubit surviving for long periods of inactivity (high $T_2$) but rather to obtain a high fidelity after a series of quantum gates, which can in general be rather complicated and involve entanglement with other qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;My question&lt;/strong&gt;: Do CTs / ZEFOZs with their high relaxation times generally also translate into a high fidelity after a complicated series of quantum gates?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For context, the examples I have in mind are solid-state, mainly these two:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://www.uv.es/gaita/16Nature.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Enhancing coherence in molecular spin qubits via atomic clock transitions&lt;/a&gt; (Shiddiq et al, doi: 10.1038/nature16984)&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1201.4610.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Reducing decoherence in optical and spin transitions in rare-earth-ion doped materials&lt;/a&gt; (McAuslan et al, doi: 10.1103/PhysRevA.85.032339)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;As well as this more refined variation, with electric field:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://www.nature.com/articles/s41467-017-00378-x&quot; rel=&quot;nofollow noreferrer&quot;&gt;Silicon quantum processor with robust long-distance qubit couplings&lt;/a&gt; (Tosi et al, doi:10.1038/s41467-017-00378-x)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="2293" LastEditDate="2018-05-12T20:46:50.420" LastActivityDate="2018-05-13T05:23:33.643" Title="Do avoided crossings / CTs /ZEFOZs optimize quantum fidelity in practice?" Tags="&lt;qubit&gt;&lt;noise&gt;&lt;solid-state&gt;&lt;fidelity&gt;" AnswerCount="1" CommentCount="2" />
  <row Id="2036" PostTypeId="1" AcceptedAnswerId="2038" CreationDate="2018-05-12T21:57:48.573" Score="8" ViewCount="222" Body="&lt;p&gt;Given that the global phases of states cannot be physically discerned, why is it that quantum circuits are phrased in terms of unitaries and not special unitaries? One answer I got was that it is just for convenience but I'm still unsure. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;A related question is this: are there any differences in the physical implementation of a unitary $U$ (mathematical matrix) and $ V: =e^{i\alpha}U$, say in terms of some elementary gates? Suppose there isn't (which is my understanding). Then the physical implementation of $c\text{-}U$ and $c\text{-}V$ should be the same (just add controls to the elementary gates). But then I get into the contradiction that $c\text{-}U$ and $c\text{-}V$ of these two unitaries may not be equivalent up to phase (as mathematical matrices), so it seems plausible they correspond to different physical implementations. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;What have I done wrong in my reasoning here, because it suggests now that $U$ and $V$ must be implemented differently even though they are equivalent up to phase?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Another related question (in fact the origin of my confusion, I'd be extra grateful for an answer to this one): it seems that one can use a quantum circuit to estimate both the modulus and phase of the complex overlap $\langle\psi|U|\psi\rangle$ (see &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0203016&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/quant-ph/0203016&lt;/a&gt;). But doesn't this imply again that $U$ and $e^{i\alpha}U$ are measurably different? &lt;/p&gt;&#xA;" OwnerUserId="2375" LastEditorUserId="26" LastEditDate="2018-05-13T08:41:44.637" LastActivityDate="2018-05-14T15:24:10.033" Title="Why are quantum gates unitary and not special unitary?" Tags="&lt;quantum-gate&gt;&lt;unitarity&gt;" AnswerCount="4" CommentCount="3" />
  <row Id="2037" PostTypeId="2" ParentId="2035" CreationDate="2018-05-13T05:23:33.643" Score="1" Body="&lt;p&gt;&lt;em&gt;The best I have it's this generic answer, which I put here for clarity, hoping for improvements/corrections or even to be superseded by something better:&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;If the limiting factor for fidelity in a given architecture+algorithm are the single-qubit gates, or the two-qubit gates, or the measurement, and if this limiting factor is not optimized in a ZEFOZ point, then effectively quantum fidelity will not be optimal in the ZEFOZ point.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="1847" LastActivityDate="2018-05-13T05:23:33.643" CommentCount="0" />
  <row Id="2038" PostTypeId="2" ParentId="2036" CreationDate="2018-05-13T05:23:52.050" Score="6" Body="&lt;p&gt;Even if you only limit yourself to special-unitary operations, states will still accumulate global phase. For example, $Z = \begin{bmatrix} i &amp;amp; 0 \\ 0 &amp;amp; -i \end{bmatrix}$ is special-unitary but $Z \cdot |0\rangle = i |0\rangle \neq |0\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If states are going to accumulate unobservable global phase &lt;em&gt;anyways&lt;/em&gt;, what benefit do we get out of limiting ourselves to special unitary operations?&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;are there any differences in the physical implementation of a unitary $U$ (mathematical matrix) and $V :=e^{i\alpha}U$, say in terms of some elementary gates?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;As long you're not doing anything that could make the global phases relevant, they can have the same implementation. But if you're going to do something like, uh-&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;add controls to the elementary gates&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Yeah, like that. If you do stuff like that, then you can't ignore global phases. Controls turn global phases into relative phases. If you want to completely ignore global phase, you can't have a black box &quot;add a control&quot; operation modifier.&lt;/p&gt;&#xA;" OwnerUserId="119" LastActivityDate="2018-05-13T05:23:52.050" CommentCount="2" />
  <row Id="2039" PostTypeId="2" ParentId="2030" CreationDate="2018-05-13T09:44:02.567" Score="6" Body="&lt;p&gt;The first thing to do is to think topologically: make sure you understand why a coffee cup is the same thing topologically as a donut.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, imagine we swap two identical particles, and do it again, so that we are back where we started. Apply this topological thinking to the paths taken by the particles: it is the same as doing nothing.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here I show a picture of this, where one particle is dragged around another particle. Topologically, the path taken can be deformed back to the &quot;do nothing&quot; path.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/oxoUi.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/oxoUi.png&quot; alt=&quot;particle monodromy&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The square root of this operation is a swap:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/pqWfC.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/pqWfC.png&quot; alt=&quot;particle swap&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Since the square root of 1 is either +1 or -1, a swap affects the state by multiplying by either +1 (for bosons) or -1 (for fermions.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To understand anyons, we are going to do the same analysis, but with one less dimension. So now a particle winding around another particle is not topologically the same as the &quot;do nothing&quot; operation:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/lJ7JB.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/lJ7JB.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We need the extra third dimension to untangle the path of the anyon, and since we can't do this topologically, the state of the system could be modified by such a process.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Things get more interesting as we add particles. With three anyons, the paths taken can get tangled, or &lt;em&gt;braided&lt;/em&gt; in arbitrary ways. To see how this works it helps to use three dimensions: two space dimensions and one time dimension. Here is an example of three anyons wandering around and then returning back where they started:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/ifCYr.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/ifCYr.png&quot; alt=&quot;three anyons braid&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Long before physicists started to think about anyons, the mathematicians already worked out how these braiding processes combine to form new braids or undo braids. These are known as &quot;braid groups&quot; in work that dates back to Emil Artin in 1947.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Like the distinction between Bosons and Fermions above, different anyon systems will behave differently when you do these braid operations. One example of anyon, known as the Fibonacci anyon, are able to approximate &lt;em&gt;any&lt;/em&gt; quantum operation just by doing these kinds of braids. And so theoretically we could use these to build a quantum computer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I wrote an introductory paper on anyons, which is where I got these pictures from: &lt;a href=&quot;https://arxiv.org/abs/1610.05384&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/1610.05384&lt;/a&gt;. There's more mathematics there, as well as a description of a close cousin of anyon theory known as a &quot;modular functor&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here is another good reference, with more Fibonacci anyon goodness: &lt;a href=&quot;https://arxiv.org/abs/1802.06176&quot; rel=&quot;nofollow noreferrer&quot;&gt;Introduction to topological quantum computation with non-Abelian anyons&#xA;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;EDIT&lt;/strong&gt;: I see that I didn't say anything about the observables. &#xA;The &lt;em&gt;observables&lt;/em&gt; of the system measure the total anyon content within a region. In terms of anyon paths we can think of this as bringing all the anyons in some region together and &quot;fusing&quot; them into one anyon, which may be the &quot;no anyon&quot; aka vacuum state. For a system supporting Fibonacci anyons there will only ever be two outcomes for such a measurement: fibonacci anyon or vacuum. Another example is the toric code where there are four anyon outcomes.&lt;/p&gt;&#xA;" OwnerUserId="263" LastEditorUserId="263" LastEditDate="2018-05-15T10:11:43.293" LastActivityDate="2018-05-15T10:11:43.293" CommentCount="0" />
  <row Id="2040" PostTypeId="2" ParentId="2036" CreationDate="2018-05-13T13:33:07.543" Score="6" Body="&lt;p&gt;The fact that quantum gates are unitary, is rooted in  the fact that the evolution of (closed) quantum systems is by the Schr&amp;ouml;diner equation. For a time interval in which we are trying to realise a particular unitary transformation at a constant rate, we use the time-independent Schr&amp;ouml;dinger equation:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ \tfrac{\mathrm d}{\mathrm dt} \lvert \psi(t) \rangle = \tfrac {1}{i\hbar}H \lvert \psi(t) \rangle, $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;where $H$ is the Hamiltonian of the system: a Hermitian matrix, whose eigenvalues describe energy eigenvalues. In particular, the eigenvalues of $H $ are real. The solution to this equation is &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ \lvert \psi(t) \rangle = \exp\bigl(-i H t/\hbar\bigr) \lvert \psi(0) \rangle $$&#xA;where $U = \exp(-iHt/\hbar)$ is the matrix which you obtain by taking the eigenvectors of $H$, and replacing their eigenvalues $E$ with $\mathrm{e}^{iEt/\hbar}$. Thus, from a matrix with real eigenvalues, we get a matrix whose eigenvalues are complex numbers with unit norm.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What would it take for this evolution to specifically be a special unitary matrix? A special unitary matrix is one whose determinant is precisely $1$; that is, whose eigenvalues all multiply to $1$. This corresponds to the restriction that the eigenvalues of $H$ all sum to zero. Furthermore, because the eigenvalues of $H$ are energy levels, &lt;em&gt;whether&lt;/em&gt; the sum of its eigenvalues is equal to zero depends on how you have decided to fix what your zero energy point is &amp;mdash; which is in effect a subjective choice of reference frame. (In particular, if you decide to adopt the convention that all of your energy levels are non-negative, this implies that no interesting system will ever have the property of the energy eigenvalues summing to zero.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In short, gates are unitary rather than special unitary, because the determinant of a gate does not correspond to physically meaningful properties &amp;mdash; in the explicit sense that the gate arises from the physics, and the conditions which correspond to the determinant of the gate being 1 is a condition of one's own reference frame and not the physical dynamics.&lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-05-13T14:38:23.253" LastActivityDate="2018-05-13T14:38:23.253" CommentCount="0" />
  <row Id="2041" PostTypeId="1" AcceptedAnswerId="2042" CreationDate="2018-05-13T14:09:15.530" Score="8" ViewCount="183" Body="&lt;p&gt;Question: Given a unitary matrix acting on $n$ qubits, can we find the shortest sequence of Clifford + T gates that correspond to that unitary?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For background on the question, two important references:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1206.5236&quot; rel=&quot;noreferrer&quot;&gt;Fast and efficient exact synthesis of single qubit unitaries generated by Clifford and T gates&lt;/a&gt;  by Kliuchnikov, Maslov, and Mosca &lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1212.0506&quot; rel=&quot;noreferrer&quot;&gt;Exact synthesis of multiqubit Clifford+T circuits&lt;/a&gt; by Giles and Selinger.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="1860" LastEditorUserId="1860" LastEditDate="2018-05-13T15:07:37.240" LastActivityDate="2018-08-07T21:07:33.170" Title="Shortest sequence of universal quantum gates that correspond to a given unitary" Tags="&lt;circuit-model&gt;&lt;universal-gates&gt;&lt;gate-synthesis&gt;" AnswerCount="2" CommentCount="1" FavoriteCount="0" />
  <row Id="2042" PostTypeId="2" ParentId="2041" CreationDate="2018-05-13T15:12:46.007" Score="7" Body="&lt;p&gt;Getting an optimal decomposition is definitely an open problem. (And, of course, the decomposition is intractable, $\exp(n)$ gates for large $n$.)  A &quot;simpler&quot; question you might ask first is what is the shortest sequence of cnots and single qubit rotations by any angle, (what IBM, Rigetti, and soon Google currently offer, this universal basis of gates can be expressed in terms of your basis of Cliffords and t-gates). This &quot;simpler&quot; question is also open and has a non-unique answer. A related question is what is an exact optimal decomposition of gates from a universal basis to go from ground state to a given final state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am assuming you are referring to exact decompositions. If you want approximate decompositions, there are different methods for that, such as the Trotter-Suzuki decomposition, or approximating an exact decomposition.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &quot;quantum csd compiler&quot; in Qubiter does a non-optimized decomposition of any n qubit unitary into cnots and single qubit rots using the famous csd (Cosine-Sine Decomposition) subroutine from LAPACK. Some enterprising person could try to find optimizations for Qubiter's quantum compiler. You can use Qubiter's compiler, for example (I wrote a paper on this), to let your classical computer re-discover Coppersmith's quantum Fourier Transform decomposition!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://github.com/artiste-qb-net/qubiter&quot; rel=&quot;nofollow noreferrer&quot;&gt;Qubiter&lt;/a&gt; is open source and available at github (full disclosure - I wrote it).&lt;/p&gt;&#xA;" OwnerUserId="1974" LastEditorUserId="91" LastEditDate="2018-08-07T21:07:33.170" LastActivityDate="2018-08-07T21:07:33.170" CommentCount="0" />
  <row Id="2043" PostTypeId="1" AcceptedAnswerId="2044" CreationDate="2018-05-13T15:17:10.763" Score="5" ViewCount="64" Body="&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Consider the state $|X\rangle = \sqrt{0.9} |00\rangle + \sqrt{0.1} |11\rangle$, shared between Alice and Bob, who are located far apart.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Alice brings in an ancilla qubit at her location (left-most qubit in the kets): $|X\rangle = \sqrt{0.9} |000\rangle + \sqrt{0.1} |011\rangle$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Now Alice performs a CNOT gate with the control being her entangled qubit, and the target being the ancilla: $|X\rangle = \sqrt{0.9} |000\rangle + \sqrt{0.1} |111\rangle$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Then Alice measures the ancilla in the basis $\{\sqrt{0.1} |0\rangle + \sqrt{0.9} |1\rangle  ,   \sqrt{0.9} |0\rangle - \sqrt{0.1} |1\rangle\}$. Supposing the measurement outcome is $+1$, i.e., the ancilla collapsed to the state $\sqrt{0.1} |0\rangle + \sqrt{0.9} |1\rangle$ , the remaining state of the initial $2$ qubits will be $|X\rangle = \sqrt{0.1 \times 0.9} |00\rangle + \sqrt{0.9 \times 0.1} |11\rangle$, which is the maximally entangled state up to a normalization factor.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;We started from a state that was not maximally entangled, and we were able to boost the entanglement by doing a local measurement and post-selecting on the outcome. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Is entanglement distillation using post-selection as I have described above feasible?&lt;/p&gt;&#xA;" OwnerUserId="1860" LastEditorUserId="26" LastEditDate="2018-05-13T16:16:44.533" LastActivityDate="2018-05-13T17:27:28.033" Title="Entanglement distillation by local operations and post-selection using one entanglement pair" Tags="&lt;quantum-entanglement&gt;&lt;state-distillation&gt;" AnswerCount="1" CommentCount="4" />
  <row Id="2044" PostTypeId="2" ParentId="2043" CreationDate="2018-05-13T17:27:28.033" Score="3" Body="&lt;p&gt;There are two different contexts where the term &quot;entanglement distillation&quot; is used, and are largely incomparable, even if they are conceptually extremely close (and I'm sure you'll be able to find papers that blur these boundaries).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the first, Alice and Bob share a &lt;strong&gt;known&lt;/strong&gt; quantum state which is (usually) a &lt;strong&gt;pure&lt;/strong&gt; state. They use this to make a maximally entangled state with some probability. You can see this, for example, in section 12.5.1 of Nielsen &amp;amp; Chuang (&quot;Transforming bi-partite pure state entanglement&quot;). The protocol described in the question is the standard protocol in this context, except that the measurements are often expressed as POVMs instead of projective measurements in a larger Hilbert space.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the second, one has many copies of a mixed state that one wishes to to make more entangled. This situation may be referred to as &quot;purification&quot; because one of the aims is, essentially, to make the state as pure as possible. The use of the mixed state, as usual, may describe part of an entangled system, or may describe some lack of knowledge/stochastic preparation procedure etc. In essence, there is some lack of knowledge about what you have, and variation between the copies, and it is this extra complication that necessitates multiple copies. See, for example, section 12.5.3 of Nielsen &amp;amp; Chuang (&quot;Entanglement distillation and quantum error-correction&quot;).&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-05-13T17:27:28.033" CommentCount="0" />
  <row Id="2045" PostTypeId="2" ParentId="2036" CreationDate="2018-05-14T06:03:49.063" Score="3" Body="&lt;p&gt;When writing gates for, for example, a quantum circuit diagram, you &lt;em&gt;could&lt;/em&gt; always write them using the convention of having determinant one (from the special unitary group), but it's just a convention. It makes no physical difference to the circuit that you implement. As said &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2040/1837&quot;&gt;elsewhere&lt;/a&gt;, whether what you naturally produce corresponds directly to the special unitary is really a choice of convention, and where you define your 0 energy to be.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As for the issue when you start implementing controlled-$U$, there is an interesting comparison to be made. Let's say we define $V=e^{i\alpha}$. How can we implement controlled-$V$ in terms of controlled-$U$? You apply controlled-$U$ and then, on the control qubit, you apply the phase gate $\left(\begin{array}{cc} 1 &amp;amp; 0 \\ 0 &amp;amp; e^{i\alpha} \end{array}\right)$. There are two things to observe here. First, the difference is on the control qubit rather than the target qubit. The target qubit, where you're implementing the $U$, doesn't really care about the difference in phase. It's the control-qubit that's hit by the phase gate. The second is that I didn't write the phase gate as a special unitary. Of course, I could have written it as $\left(\begin{array}{cc} e^{-i\alpha/2} &amp;amp; 0 \\ 0 &amp;amp; e^{i\alpha/2}\end{array}\right)$ but I didn't because the way that I chose to write it was notationally more convenient - less writing for me, and hopefully more immediately obvious to you why it works.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-05-14T06:03:49.063" CommentCount="0" />
  <row Id="2046" PostTypeId="2" ParentId="2041" CreationDate="2018-05-14T07:46:04.290" Score="3" Body="&lt;p&gt;Suppose that an exact synthesis was possible for your provided unitary (the number of theoretic restriction on the entries) and so the algorithms described in the question gave you a sequence of Clifford+T gates that implemented that unitary. As stated in the Giles-Selinger paper, you get a sequence that is very far from optimal. So at this point you have reduced to the word problem in the group generated by the Clifford+T gate set. Some groups have algorithms to shorten a given word while still representing the same element of the group into a normal form that is the shortest within that class. Others do not.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;More details to illustrate the principle: Let us say there are $2$ qubits. Denote $S_1$ etc for the generator that does the phase gate on qubit $1$, $CNOT_{12}$ for $1$ being the control etc. Each one of these is treated as a letter. The algorithm will spit out some word in these generators. The group is the group with these generators and many relations like $S_i^4=1$ and $X_i Y_j = Y_j X_i$ when $i \neq j$ among many other relations. So this defines some finitely generated group. Because we have a word from the provided algorithms but has not been optimized, the task is to provide a convenient shortest possible normal form in the word problem for this group. So if given the word $S_1 S_1 S_2 S_1 S_1$ one could use the relation $S_1 S_2 = S_2 S_1$ twice and the $S_1^4=1$ relation once to get $S_2$ as a shorter word that represents the same group element. For a given group presentation, one would like an algorithm that takes an arbitrary word and reduces it. In general this is not possible.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Disclaimer for below: Forthcoming project/Haskell implementation joint w/ Jon Aytac.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I don't know about the solvability of the word problem for the Clifford+T gate set, but one can do something simpler with only the involutions (call them $r_i$) in that set and only the relations of the form $(r_i r_j)^{m_{ij}}=1$. That is a Coxeter group related to the Clifford+T gate set, but with an efficiently solvable word problem. So one may take the result of the Giles-Selinger algorithm and potentially shorten it using only these very simple relations (after looking at segments with only those involution letters). In fact any algorithm that takes a given unitary and approximates or exactly synthesizes it into Clifford+T can be fed into this procedure to potentially shorten it slightly.&lt;/p&gt;&#xA;" OwnerUserId="434" LastEditorUserId="434" LastEditDate="2018-05-15T04:40:50.097" LastActivityDate="2018-05-15T04:40:50.097" CommentCount="0" />
  <row Id="2047" PostTypeId="1" AcceptedAnswerId="2048" CreationDate="2018-05-14T08:18:45.467" Score="5" ViewCount="59" Body="&lt;p&gt;I understand that there are two ways to think about 'general quantum operators'. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Way 1&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We can think of them as trace-preserving completely positive operators. These can be written in the form &#xA;$$\rho'=\sum_k A_k \rho A_k^\dagger \tag{1}$$&#xA;where $A_k$ are called Kraus operators.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Way 2&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As given in (An Introduction to Quantum Computing by Kaye, Laflamme and Mosca, 2010; pg59) we have a&#xA;$$\rho'=\mathrm{Tr}_B\left\{ U(\rho \otimes \left| 00\ldots 0\right&amp;gt;\left&amp;lt;00\ldots 0 \right|) U^\dagger  \right\} \tag{2}$$&#xA;where $U$ i s a unitary matrix and the ancilla $\left|00 \ldots 0\right&amp;gt;$ has at most size $N^2$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Exercise 3.5.7 (in Kaye, Laflamme and Mosca, 2010; pg60) gets you to prove that  operators defined in (2) are completely positive and trace preserving (i.e. can be written as (1)). My question is the natural inverse of this; can we show that any completely positive, trace preserving map can be written as (2)? I.e. are (1) and (2) equivalent definitions of a 'general quantum operator'?&lt;/p&gt;&#xA;" OwnerUserId="2015" LastEditorUserId="2015" LastEditDate="2018-05-14T09:26:59.247" LastActivityDate="2018-05-14T09:26:59.247" Title="Two notions of General Quantum Operators?" Tags="&lt;quantum-gate&gt;" AnswerCount="1" CommentCount="6" />
  <row Id="2048" PostTypeId="2" ParentId="2047" CreationDate="2018-05-14T08:59:39.093" Score="5" Body="&lt;p&gt;This question is posed, and answered positively, in Nielsen &amp;amp; Chuang in a subsection of chapter 8 entitled &quot;System-environment models for and operator-sum representation&quot;. In my version, it can be found on page 365.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Imagine $|\psi\rangle$ is an arbitrary pure state on the space upon which you wish to enact the operators. Let $|e_0\rangle$ be some fixed state on another quantum system (with dimension equal to at least the number of Krauss operators, and labelled 'B'). Then you can define a unitary by its action on the space of states spanned by $|\psi\rangle$:&#xA;$$&#xA;U|\psi\rangle|e_0\rangle=\sum_k(A_k|\psi\rangle)|e_k\rangle,&#xA;$$&#xA;where the $|e_k\rangle$ are an orthonormal basis. To check that this corresponds to a valid unitary, we just have to test it for different input states and ensure that the initial overlap is preserved:&#xA;$$&#xA;\langle\psi|\phi\rangle\langle e_0|e_0\rangle=\langle\psi|\langle e_0|U^\dagger U|\phi\rangle|e_0\rangle=\langle\psi|\sum_kA_k^\dagger A_k|\phi\rangle,&#xA;$$&#xA;which is true thanks to the completeness relation of the Krauss operators.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Finally, one just has to check that this unitary does indeed implement the claimed map:&#xA;$$&#xA;\text{Tr}_B\left(U|\psi\rangle\langle \psi|\otimes|e_0\rangle\langle e_0|U^\dagger\right)=\sum_kA_k|\psi\rangle\langle\psi|A_k^\dagger.&#xA;$$&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-05-14T08:59:39.093" CommentCount="0" />
  <row Id="2049" PostTypeId="1" CreationDate="2018-05-14T10:19:31.483" Score="5" ViewCount="72" Body="&lt;p&gt;The feature of quantum error correcting codes called &lt;em&gt;degeneracy&lt;/em&gt; is that they can sometimes be used to correct more errors than they can uniquely identify. It seems that codes exhibiting such characteristic are able to overcome the performance of quantum error correction codes that are nondegenerate.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am wondering if there exists some kind of measure, or classification method in order to determine how degenerate is a quantum code, and so if there has been any study trying to determine the error correction abilities of quantum codes depending on the degeneracy of them.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Apart from that, it would be interesting to give reference or some intuition about how to construct good degenerate codes, or just reference about the current state of the art of those issues.&lt;/p&gt;&#xA;" OwnerUserId="2371" LastEditorUserId="2371" LastEditDate="2018-05-29T22:52:09.813" LastActivityDate="2018-05-29T22:52:09.813" Title="Degeneracy of Quantum Error Correction Codes" Tags="&lt;quantum-error-correction&gt;&lt;quantum-information&gt;&lt;stabilizer-code&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="2050" PostTypeId="2" ParentId="2049" CreationDate="2018-05-14T13:10:19.080" Score="3" Body="&lt;p&gt;I don't have a complete answer, but perhaps others can improve on this starting point.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are probably 3 things to ask about the code:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;How degenerate is it?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;How hard is it to perform the classical post-processing of the error syndrome in order to determine which corrections to make?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;What are its error correcting/fault-tolerant thresholds?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;I suppose a simple enough measure of degeneracy is the extent to which the Quantum Hamming Bound is surpassed. For an $[[N,k,d]]$ code, a non-degenerate code must satisfy:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$2^{N-k}\geq\sum_{n=0}^{\lfloor d/2\rfloor}3^n\binom{N}{n}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So the amount by which that bound is violated suggests something interesting about how densely the information is packed. Of course, that's no use if your mega-degenerate code cannot actually correct for any errors. Similarly, if your code is in principle awesome, but it takes too long to actually work out what the correction is, your code isn't really any use in practice because errors will continue to accumulate as you try to work out what corrections to do.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="26" LastEditDate="2018-05-14T16:13:23.890" LastActivityDate="2018-05-14T16:13:23.890" CommentCount="4" />
  <row Id="2051" PostTypeId="1" AcceptedAnswerId="2052" CreationDate="2018-05-14T13:19:53.713" Score="6" ViewCount="62" Body="&lt;p&gt;I submitted a job in the 0.5.0 version of QISKit using&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;job = execute(qc, 'ibmqx5', shots=shots)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;This just submits the job, and does not wait for a result.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I then immediately tested whether the job was still running using&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;print(job.running)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;This gave the result &lt;code&gt;False&lt;/code&gt;. However, when I requested the result using&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;job.result()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;This still took a while to get the result, suggesting that the job actually was still running after all. What is going on here?&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-05-14T13:25:37.837" Title="Why does job.running in QISKit output False, even if the job is still running?" Tags="&lt;quantum-programming&gt;&lt;qiskit&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2052" PostTypeId="2" ParentId="2051" CreationDate="2018-05-14T13:19:53.713" Score="4" Body="&lt;p&gt;There are three stages that the job goes through, as you'll see if you also print the status using &lt;code&gt;print(job.status)&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The first is an initialization stage. This returns &lt;code&gt;False&lt;/code&gt; for &lt;code&gt;job.running&lt;/code&gt;, because it hasn't started running yet.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then your job actually will run, and so give &lt;code&gt;True&lt;/code&gt; for &lt;code&gt;job.running&lt;/code&gt;. Finally it will have finished running, and so &lt;code&gt;job.running&lt;/code&gt; goes back to &lt;code&gt;False&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So don't use &lt;code&gt;job.running&lt;/code&gt; to test whether a result is ready.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-05-14T13:25:37.837" LastActivityDate="2018-05-14T13:25:37.837" CommentCount="0" />
  <row Id="2053" PostTypeId="2" ParentId="2036" CreationDate="2018-05-14T15:24:10.033" Score="0" Body="&lt;p&gt;&lt;strong&gt;&lt;em&gt;Plain and simple answer:&lt;/em&gt;&lt;/strong&gt; In the absence of decoherence, state vectors evolve according to $|\psi(t)\rangle = e^{-iHt}|\psi(0)\rangle$ for a Hamiltonian $H$. This is what a &quot;gate&quot; is doing. Hamiltonians have to be Hermitian, so this transformation is unitary. Hamiltonians do not have to have eigenvalues that sum to 0, so the transformation does not have to be special unitary. &lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-05-14T15:24:10.033" CommentCount="0" />
  <row Id="2054" PostTypeId="1" CreationDate="2018-05-14T18:37:53.887" Score="11" ViewCount="105" Body="&lt;p&gt;In a comment on &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2034/26&quot;&gt;my answer&lt;/a&gt; to the question: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2030/what-exactly-are-anyons-and-how-are-they-relevant-to-topological-quantum-computi&quot;&gt;What exactly are anyons and how are they relevant to topological quantum computing?&lt;/a&gt; I was asked to give specific examples of occurrence of anyons in nature. I've spent 3 days searching, but every article refers to either &quot;proposed experiments&quot; or &quot;nearly definitive evidence&quot;. &lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;strong&gt;Abelian anyons&lt;/strong&gt;:&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Fractional charges have been measured directly since 1995, but in my search, all articles pointing to evidence of &lt;strong&gt;&lt;em&gt;fractional statistics&lt;/em&gt;&lt;/strong&gt; or an exchange factor $e^{i\theta}\ne\pm1$, point to this nearly 7-year old &lt;a href=&quot;https://arxiv.org/abs/1112.3400&quot; rel=&quot;noreferrer&quot;&gt;pre-print&lt;/a&gt;, where they say in the abstract that they &quot;confirm&quot; detecting the theoretically predicted phase of $\theta =2\pi/3$ in the $\nu=7/3$ state of a quantum Hall system. However, the paper seems never passed a journal's peer review. There is no link to a journal DOI on arXiv. On Google Scholar I clicked &quot;see all 5 versions&quot;, but all 5 were arXiv versions. I then suspected the article's name might have changed at the time of publication so went hunting for it on the authors' websites. The last author has Princeton University's Department of Electrical Engineering listed as affiliation, but does not show up on that department's list of people (after clicking on &quot;People&quot;, I clicked on &quot;Faculty&quot;, &quot;Technical&quot;, &quot;Graduate Students&quot;, &quot;Administrative&quot;, and &quot;Research Staff&quot; but nothing showed up). The same happened for the second-last author! The third-last author does have a lab website with a publication list, but nothing like this paper appears in the &quot;Selected Publications out of more than 800&quot; page.  The fourth-last author is at a different university, but his website's publication list is given as a link to his arXiv page (still no published version visible). The 5th last, 6th last, and 7th last authors have an affiliation of James Franck Institute and Department of Physics at the University of Chicago, but none of their three names shows up on either website's People pages. One of the authors also has affiliation at a university in Taiwan, and her website there lists publications co-authored with some of the people from the pre-print in question, but never anything with a similar title or with a similar enough author list. Interestingly, even her automatically generated but manually adjustable Google Scholar page does not have even the arXiv version but does have earlier papers (with completely different titles and no mention of anyons) with some of the co-authors. That covers all authors. No correspondence emails were made available.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; Is this &lt;a href=&quot;https://arxiv.org/abs/1112.3400&quot; rel=&quot;noreferrer&quot;&gt;pre-print&lt;/a&gt; the only claim of confirming an exchange factor $\ne\pm1$ ?&lt;br&gt;&#xA; &lt;strong&gt;2.&lt;/strong&gt; If yes, what is wrong with their claimed confirmation of this? (It appears to have not passed any journal's peer review, and it also appears that an author has even taken down the arXiv version from her Google Scholar page).&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;strong&gt;Non-abelian anyons&lt;/strong&gt;:&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;I found &lt;a href=&quot;https://en.wikipedia.org/wiki/Anyon#Non-abelian_anyons&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt; this quote: &quot;Experimental evidence of non-abelian anyons, although not yet conclusive and currently contested &lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.115.126807&quot; rel=&quot;noreferrer&quot;&gt;&lt;sup&gt;[12]&lt;/sup&gt;&lt;/a&gt; was presented in October 2013 &lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.111.186401&quot; rel=&quot;noreferrer&quot;&gt;&lt;sup&gt;[13]&lt;/sup&gt;&lt;/a&gt;.&quot; The abstract of [&lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.115.126807&quot; rel=&quot;noreferrer&quot;&gt;12&lt;/a&gt;] says that the experiment in [&lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.111.186401&quot; rel=&quot;noreferrer&quot;&gt;13&lt;/a&gt;] is inconsistent with a plausible model and that the authors of [&lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.111.186401&quot; rel=&quot;noreferrer&quot;&gt;13&lt;/a&gt;] may have measured &quot;Coulomb effects&quot; rather than non-Abelian braiding. Interestingly the author list of [&lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.111.186401&quot; rel=&quot;noreferrer&quot;&gt;13&lt;/a&gt;] overlaps with the pre-print mentioned in the Abelian section of this question, though that pre-print was from 2 years earlier and said in the abstract &quot;Our results provide compelling support for the existence of non-Abelian anyons&quot; which is a much weaker statement than what they say in the same abstract for the Abelian case: &quot;We confirm the Abelian anyonic braiding statistics in the $\nu=7/3$ FQH state through detection of the predicted statistical phase angle of $2\pi/3$, consistent with a change of the anyonic particle number by one.&quot;&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-05-14T23:20:37.990" LastActivityDate="2018-05-15T06:02:14.450" Title="What is the status of confirming the existence of anyons?" Tags="&lt;experimental-results&gt;&lt;topological-quantum-computing&gt;&lt;anyons&gt;" AnswerCount="1" CommentCount="1" FavoriteCount="2" />
  <row Id="2055" PostTypeId="2" ParentId="2054" CreationDate="2018-05-14T20:50:34.587" Score="5" Body="&lt;p&gt;It depends what you mean by the 'existence' of anyons.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One way is to engineer a Hamiltonian which leads to quasiparticles (or other defects) that have anyonic statistics. This will require the Hamiltonian to be implemented, the system to be cooled to sufficiently near the ground state, the anyons to be manipulated, etc. So there's a lot to be done, and I don’t think that the development of the systems required has a lot of other applications. So it suffers from being both hard to do, and quite a niche.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Hopefully, someone else will give you the answers you want on this kind of approach. However, I thought it is important to note that there is another way to get anyons. This is to not bother with the Hamiltonian. Instead, the eigenstates can be prepared and manipulated directly.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In this case, you aren’t getting any topological protection from the Hamiltonian. Instead, measurements are constantly made of what eigenstate you are in, in order to detect and help you mitigate the unwanted effects of errors. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The most realistic examples of this approach will be ones for which these operations can be easily performed on a quantum computer. All the development and progress towards building qubits and their gates can then be directly used in the search for anyons.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Anyons are systems that can be easily implemented with qubits or qubits are typically a specific form of quantum error correcting code. Specifically, they are stabilizer codes for which the states of the stabilizer space are topologically ordered, and syndrome measurements correspond to measuring whether anyons are present at each point throughout the system.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Th simplest example is the surface code. The basic quasiparticles of this are Abelian anyon. There have been experiments that create and manipulate these anyons to demonstrate their braiding behaviour. &lt;a href=&quot;https://arxiv.org/abs/0710.0895&quot; rel=&quot;noreferrer&quot;&gt;The first example&lt;/a&gt; was done over a decade ago in photonics systems.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The surface code can also host defects which behave as Majorana modes, and therefore non-Abelian anyons. I implemented a very minimal example of their braiding in &lt;a href=&quot;https://arxiv.org/abs/1609.07774&quot; rel=&quot;noreferrer&quot;&gt;this paper&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As quantum processors get larger, cleaner and more sophisticated, there will be a lot more of this kind of study. I would think that the majority of the anyons that we will see and use will be realized in this manner, rather than with an implementation of the Hamiltonian.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="26" LastEditDate="2018-05-15T06:02:14.450" LastActivityDate="2018-05-15T06:02:14.450" CommentCount="7" />
  <row Id="2056" PostTypeId="1" CreationDate="2018-05-15T02:06:58.443" Score="6" ViewCount="61" Body="&lt;p&gt;The recent McClean et al. paper &lt;a href=&quot;https://arxiv.org/pdf/1803.11173.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Barren plateaus in quantum neural network training landscapes&lt;/a&gt; shows that for a wide class of reasonable parameterized quantum circuits, the probability that the gradient along any reasonable direction is non-zero to some fixed precision is exponentially small as a function of the number of qubits. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This seems to affect &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1885/what-is-meant-by-noisy-intermediate-scale-quantum-nisq-technology&quot;&gt;Noisy Intermediate-Scale Quantum (NISQ)&lt;/a&gt; programs (as proposed by e.g. &lt;a href=&quot;https://arxiv.org/pdf/1801.00862.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;John Preskill&lt;/a&gt;) since they involve hybrid quantum-classical algorithms, ie training a parameterized quantum circuit with a classical optimization loop.&#xA;&lt;a href=&quot;https://i.stack.imgur.com/zRKZR.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/zRKZR.png&quot; alt=&quot;Fig 1 from the paper&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;My question&lt;/strong&gt;: How do you avoid getting stranded on those barren plateaus? Concretely, how would one go about building one's Ansatz Haar states to avoid getting stuck in those plateaus? The paper proposes but does not elaborate:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;em&gt;One approach to avoid these landscapes in the quantum setting is to&#xA;  use structured initial guesses, such as those adopted in quantum&#xA;  simulation&lt;/em&gt;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="2387" LastEditorUserId="26" LastEditDate="2018-05-15T06:34:05.777" LastActivityDate="2018-05-15T06:34:05.777" Title="Devising &quot;structured initial guesses&quot; for random parametrized quantum circuits to avoid getting stuck in a flat plateau" Tags="&lt;quantum-computer&gt;&lt;neural-network&gt;&lt;optimization&gt;" AnswerCount="0" CommentCount="2" />
  <row Id="2057" PostTypeId="1" CreationDate="2018-05-15T04:25:47.303" Score="6" ViewCount="36" Body="&lt;p&gt;I am currently trying to implement a boosting algorithm akin to &lt;a href=&quot;https://en.wikipedia.org/wiki/Xgboost&quot; rel=&quot;noreferrer&quot;&gt;XGBoost&lt;/a&gt; with a quantum device. The reason is that I want to make use of a quantum device to train weak classifiers. However, as far as I know, the current quantum device can only be used for binary variables including both input variables and outputs. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is it possible to use all binary variables to implement the additive training as it does in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Xgboost&quot; rel=&quot;noreferrer&quot;&gt;XGBoost&lt;/a&gt;?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sub&gt; &lt;a href=&quot;https://github.com/dmlc/xgboost&quot; rel=&quot;noreferrer&quot;&gt;XGBoost GitHub Project&lt;/a&gt; &lt;/sub&gt;&lt;/p&gt;&#xA;" OwnerUserId="2354" LastEditorUserId="26" LastEditDate="2018-05-15T06:26:23.907" LastActivityDate="2018-05-15T06:26:23.907" Title="Gradient boosting akin to XGBoost using a quantum device" Tags="&lt;quantum-algorithms&gt;&lt;quantum-annealing&gt;&lt;quantum-programming&gt;&lt;machine-learning&gt;" AnswerCount="0" CommentCount="4" />
  <row Id="2058" PostTypeId="1" CreationDate="2018-05-15T07:33:05.183" Score="9" ViewCount="191" Body="&lt;p&gt;In the comments to a &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2047/two-notions-of-general-quantum-operators&quot;&gt;question&lt;/a&gt; I asked recently, there is a discussion between &lt;a href=&quot;https://quantumcomputing.stackexchange.com/users/2293/user1271772&quot;&gt;user1271772&lt;/a&gt; and myself on positive operators. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I know that for a positive trace-preserving operator $\Lambda$ (e.g. the partial transpose) if acting on a mixed state $\rho$ then although $\Lambda(\rho)$ is a valid density matrix it mucks up the density matrix of the system it is entangled to - hence this is not a valid operator.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This and user1271772's comments, however, got me thinking. $\Lambda$ acting on a state which is not part of a larger system does indeed give a valid density matrix and there is no associated entangled system to muck it up.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is, therefore: Is such an operation allowed (i.e. the action of a positive map on a state which is not part of a larger system). If not, why not? And if so, is it true that any positive map can be extended to a completely positive map (perhaps nontrivially)?&lt;/p&gt;&#xA;" OwnerUserId="2015" LastEditorUserId="2015" LastEditDate="2018-05-15T19:08:52.777" LastActivityDate="2018-06-15T12:39:07.157" Title="Positive maps on pure states?" Tags="&lt;quantum-gate&gt;&lt;quantum-state&gt;" AnswerCount="3" CommentCount="9" />
  <row Id="2059" PostTypeId="1" CreationDate="2018-05-15T08:13:51.020" Score="9" ViewCount="76" Body="&lt;p&gt;Long-range entanglement is characterized by topological order (some kinds of global entanglement properties), and the &quot;modern&quot; definition of topological order is &lt;em&gt;the ground state of the system cannot be prepared by a constant-depth circuit from a product state&lt;/em&gt;, instead of ground states dependency and boundary excitations in traditional. Essentially, a quantum state which can be prepared by a constant-depth circuit is called &lt;em&gt;trivial state&lt;/em&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;On the other hand, quantum states with long-range entanglement are &quot;robust&quot;. One of the most famous corollaries of quantum PCP conjecture which proposed by Matt Hastings is the &lt;em&gt;No Low-energy Trivial States&lt;/em&gt; conjecture, and the weaker case proved by Eldar and Harrow two years ago (i.e. NLETS theorem: &lt;a href=&quot;https://arxiv.org/abs/1510.02082&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/1510.02082&lt;/a&gt;). Intuitively, the probability of a series of the random errors are exactly some log-depth quantum circuit are very small, so it makes sense that the entanglement here is &quot;robust&quot;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;It seems that this phenomenon is some kinds of similar to topological quantum computation. Topological quantum computation is robust for any local error since the quantum gate here is implemented by braiding operators which is connected to some global topological properties. However, it needs to point that &lt;strong&gt;&quot;robust entanglement&quot; in the NLTS conjecture setting only involved the amount of entanglement, so the quantum state itself maybe changed&lt;/strong&gt; -- it does not deduce a quantum error-correction code from non-trivial states automatically. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Definitely, long-range entanglement is related to homological quantum error-correction codes, such as the Toric code (it seems that it is related to abelian anyons). However, my question is that are there some connections between long-range entanglement (or &quot;robust entanglement&quot; in the NLTS conjecture setting) and topological quantum computation? &#xA;Perhaps there exists some conditions regarding when the correspondent Hamiltonian can deduce a quantum error-correction code. &lt;/p&gt;&#xA;" OwnerUserId="1777" LastEditorUserId="1777" LastEditDate="2018-05-22T21:36:55.580" LastActivityDate="2018-05-22T21:36:55.580" Title="Are there connections between long-range entanglement and topological quantum computation?" Tags="&lt;quantum-entanglement&gt;&lt;topological-quantum-computing&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="1" />
  <row Id="2060" PostTypeId="1" CreationDate="2018-05-15T08:16:16.503" Score="10" ViewCount="48" Body="&lt;p&gt;The quantum Hamming bound for a non-degenerate $[[N,k,d]]$ quantum error correction code is defined as: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{equation}&#xA;2^{N-k}\geq\sum_{n=0}^{\lfloor d/2\rfloor}3^n\begin{pmatrix}N \\ n\end{pmatrix}.&#xA;\end{equation}&#xA;However, there is no proof stating that degenerate codes should obey such bound. I wonder if there exists any example of a degenerate code violating the quantum Hamming bound, or if there have been some advances in proving similar bounds for degenerate codes.&lt;/p&gt;&#xA;" OwnerUserId="2371" LastEditorUserId="26" LastEditDate="2018-05-15T08:30:07.153" LastActivityDate="2018-05-15T16:30:37.967" Title="Violation of the Quantum Hamming bound" Tags="&lt;quantum-error-correction&gt;&lt;quantum-information&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="2061" PostTypeId="2" ParentId="2059" CreationDate="2018-05-15T09:29:13.220" Score="5" Body="&lt;p&gt;There were two simultaneous PRLs published by &lt;a href=&quot;https://arxiv.org/abs/hep-th/0510092&quot; rel=&quot;noreferrer&quot;&gt;Kitaev &amp;amp; Preskill&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/abs/cond-mat/0510613&quot; rel=&quot;noreferrer&quot;&gt;Levin &amp;amp; Wen&lt;/a&gt; that I think answer your question.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;These use the &lt;a href=&quot;https://arxiv.org/abs/0808.3773&quot; rel=&quot;noreferrer&quot;&gt;area law&lt;/a&gt; of entanglement seen by states that can be expressed as ground states of a Hamiltonian with only local interactions.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Specifically, suppose you have a 2D system of interacting particles in a pure state. You then single out some region, and calculate the von Neumann entropy of the reduced density matrix for that region. This will essentially be a measure of how entangled the region is with its complement. The area law tells us that this entropy, $S$, should obey&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$S = \alpha L - \gamma + \ldots$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here $L$ is the length of the perimeter of the region. The first term accounts for the fact that correlations in these systems are typically short range, and so the entanglement is mostly composed of correlations between particles on each side of the boundary.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The $\gamma$ term is unaffected by the size or shape of the region, and so represents a contribution of global and topological effects. Whether this is non-zero, and what the value is, tells you about the topologically ordered nature of your entangled system.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The $\ldots$ term just represents contributions that decay as the region increases, and so can be ignored as $L\rightarrow \infty$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The two papers, and ones based upon them, then find ways to isolate and calculate $\gamma$ for different entangled states. The value is shown to depend on the anyon model for which these entangled states represent the vacuum.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-05-15T09:29:13.220" CommentCount="0" />
  <row Id="2062" PostTypeId="1" AcceptedAnswerId="2063" CreationDate="2018-05-15T10:12:46.183" Score="5" ViewCount="184" Body="&lt;p&gt;To use certain things in QISKIt, such as acessing the real quantum processors, it seems that there is a file 'Qconfig.py'. That needs to be set up.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;How do I do this?&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-05-15T10:12:46.183" Title="What is Qconfig in QISKit and how do I set it up?" Tags="&lt;quantum-programming&gt;&lt;qiskit&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2063" PostTypeId="2" ParentId="2062" CreationDate="2018-05-15T10:12:46.183" Score="5" Body="&lt;p&gt;To get access to the real devices and remote simulators, you need to have an account with the &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/&quot; rel=&quot;noreferrer&quot;&gt;IBM Q Experience&lt;/a&gt;. Once you do, you can get your API key from the account page.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Once you have the API key, you can set up a Qconfig file. Let's assume that you want to run things from the &lt;a href=&quot;https://github.com/QISKit/qiskit-tutorial&quot; rel=&quot;noreferrer&quot;&gt;QISKit tutorial&lt;/a&gt;. The Qconfig file can then be set up by editing the file located &lt;a href=&quot;https://github.com/QISKit/qiskit-tutorial/blob/master/Qconfig.py.template&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You just need to replace the line&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;APItoken = None&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;with&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;APItoken = &quot;randomstringoflettersandnumbersyoucopiedfromthewebsite&quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Where the stuff within the quotation marks should be your actual API token.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You also need to rename the file from 'Qconfig.py.template' to just &lt;code&gt;Qconfig.py&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now you need to import the information from this file in your programs. This will depend on where you program sits in your computer relative to the Qconfig file.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If the &lt;code&gt;.py&lt;/code&gt; or &lt;code&gt;.ipynb&lt;/code&gt; file containing your program is sitting in the same directory as 'Qconfig.py', you can import with just&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import Qconfig&#xA;qx_config = {&#xA;    &quot;APItoken&quot;: Qconfig.APItoken,&#xA;    &quot;url&quot;: Qconfig.config['url']}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;except Exception as e:&#xA;    print(e)&#xA;    qx_config = {&#xA;        &quot;APItoken&quot;:&quot;YOUR_TOKEN_HERE&quot;,&#xA;        &quot;url&quot;:&quot;&lt;a href=&quot;https://quantumexperience.ng.bluemix.net/api&quot; rel=&quot;noreferrer&quot;&gt;https://quantumexperience.ng.bluemix.net/api&lt;/a&gt;&quot;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;and then register your connection to the API with&lt;/p&gt;&#xA;&#xA;&lt;p&gt;register(qx_config['APItoken'], qx_config['url'])&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If your &lt;code&gt;.py&lt;/code&gt; or &lt;code&gt;.ipynb&lt;/code&gt; is one directory level down, such as for &lt;a href=&quot;https://github.com/QISKit/qiskit-tutorial/tree/master/hello_world&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt; you'll need to have the lines&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import sys&#xA;sys.path.append(&quot;../&quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;before you try to import. This tells the program to look for the Qconfig file in the directory above instead.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-05-15T10:12:46.183" CommentCount="0" />
  <row Id="2064" PostTypeId="2" ParentId="2058" CreationDate="2018-05-15T10:49:44.393" Score="4" Body="&lt;p&gt;Any map which is not Completely Positive, Trace Preserving (CPTP), is not possible as an &quot;allowed operation&quot; (a more-or-less complete account of how some system transforms) in quantum mechanics, regardless of what states it is meant to act upon. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The constraint of maps being CPTP comes from the physics itself. Physical transformations on closed systems are unitary, as a result of the Schr&amp;ouml;dinger equation. If we allow for the possibility to introduce auxiliary systems, or to ignore/lose auxiliary systems, we obtain a more general CPTP map,  expressed in terms of a Stinespring dilation. Beyond this, we must consider maps which may occur only with a significant probability of failure (as with postselection). This is perhaps one way of describing an &quot;extension&quot; for non-CPTP maps to CPTP maps &amp;mdash; engineering it so that it can be described as a provocative thing with some probability, and something uninteresting with possibly greater probability; or at least a mixture of a non-CPTP map with something else to yield a total evolution which is CPTP &amp;mdash; but whether it is useful to do so in general is not clear to me. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;On a higher level &amp;mdash; while &lt;em&gt;we&lt;/em&gt; may consider entanglement a strange phenomenon, and in some way special to quantum mechanics, the laws of quantum mechanics themselves make no distinctions between entangled states and product states. There is no sense in which quantum mechanics is delicate or sensitive to the mere presence of nonlocal correlations (which are correlations in things which &lt;em&gt;we&lt;/em&gt; are concerned with), which would render impossible some transformation on entangled states merely because it might produce an embarrassing result. Either a process is impossible &amp;mdash; and in particular not possible on product states &amp;mdash; or it is possible, and any embarrassment about the outcome for entangled states is our own, on account of the difficulty in understanding what has happened. What is special about entanglement is the way it challenges our classically-motivated preconceptions, not how entangled states themselves evolve in time. &lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-05-17T09:20:46.440" LastActivityDate="2018-05-17T09:20:46.440" CommentCount="26" />
  <row Id="2065" PostTypeId="2" ParentId="2060" CreationDate="2018-05-15T15:14:51.043" Score="5" Body="&lt;p&gt;You may be interested in the answers to &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/1961/1837&quot;&gt;this question&lt;/a&gt;. One example of a degenerate code beating the quantum Hamming bound is &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9706061&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;. I also have a numerical example of a small violation in my own work, &lt;a href=&quot;https://arxiv.org/abs/1208.4924&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;. In Figure two, you will see a zoomed in section. Essentially, the black line is the quantum Hamming bound (that may not be entirely obvious from what is written!), and the grey line is an approximation of what can be achieved with something related to the Toric code. There will be other examples as well!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There appear to be a number of results about classes of degenerate codes that do not violate the quantum Hamming bound (e.g. &lt;a href=&quot;https://arxiv.org/abs/0812.2674&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/abs/0711.4603&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;). I haven't read them, so don't know how useful they are, but the abstracts suggest that they provide a nice counter-point, conveying the rarity of good degenerate codes.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-05-15T16:30:37.967" LastActivityDate="2018-05-15T16:30:37.967" CommentCount="1" />
  <row Id="2066" PostTypeId="2" ParentId="2058" CreationDate="2018-05-15T19:01:26.523" Score="-3" Body="&lt;p&gt;&lt;strong&gt;No law of physics states that we must be able to evolve a sub-system of the universe on its own.&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;There would be no way to definitively test such a law. &lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;The density matrix of the universe must have a trace of 1 and be positive semi-definite, by the mathematical definition of probabilities&lt;sup&gt;&lt;strong&gt;&lt;a href=&quot;https://arxiv.org/pdf/0811.2068.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;1&lt;/a&gt;&lt;/strong&gt;&lt;/sup&gt;. Any change in the universe must&lt;sup&gt;&lt;strong&gt;&lt;a href=&quot;https://arxiv.org/pdf/0811.2068.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;1&lt;/a&gt;&lt;/strong&gt;&lt;/sup&gt; preserve this, for mathematical reasons and due to definitions. If $\rm{Tr}(\rho_{\rm{universe}})\lt1$, you just haven't included the whole universe in $\rho_{\rm{universe}}$. If it's more than 1, or if $\rho_{\rm{universe}}&amp;lt;0$, what you have is not actually a density matrix, by the definition of probability&lt;sup&gt;&lt;strong&gt;&lt;a href=&quot;https://arxiv.org/pdf/0811.2068.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;1&lt;/a&gt;&lt;/strong&gt;&lt;/sup&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So the map: $\rho_{\rm{universe}}(0)\rightarrow\rho_{\rm{universe}}(t)$ must&lt;sup&gt;&lt;strong&gt;&lt;a href=&quot;https://arxiv.org/pdf/0811.2068.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;1&lt;/a&gt;&lt;/strong&gt;&lt;/sup&gt; be positive and trace-preserving. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;For convenience, we like to &lt;strong&gt;&lt;em&gt;model&lt;/em&gt;&lt;/strong&gt; sub-regions of the universe, and introduce complete positivity for that. But one day an experiment might come along that we find impossible to explain&lt;sup&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/sup&gt;, perhaps because we have chosen to model the universe in a way that's not compatible with how the universe actually works.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we assume gravity doesn't exist, and we can magically compute anything we want, we believe that evolving $\rho_{\rm{universe}}$ using the right &lt;strong&gt;positive&lt;/strong&gt; trace-preserving map, then doing a partial trace over all parts of the universe not of concern, will give accurate predictions. &#xA;Introducing the notion of modeling &lt;strong&gt;only&lt;/strong&gt; a sub-system of  $\rho_{\rm{universe}}$, using a CPT map, is also something we believe will work, but we might bet &lt;strong&gt;&lt;em&gt;slightly&lt;/em&gt;&lt;/strong&gt; less on this, because we've added the &lt;em&gt;assumption&lt;/em&gt; that &lt;strong&gt;&lt;em&gt;sub-systems&lt;/em&gt;&lt;/strong&gt; evolve this way, not just the universe as a whole.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;hr&gt;&#xA;&lt;strong&gt;&lt;a href=&quot;https://arxiv.org/pdf/0811.2068.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;1&lt;/a&gt;&lt;/strong&gt;: Even this is debatable because the relationship between a wavefunction or density matrix and probabilities comes from a postulate of quantum mechanics called the Born rule, which until fewer than 10 years ago was never tested at all, and still has only been confirmed to be true within an $\epsilon$, and for a particular system: If Born's rule isn't true, Eq. 6 of &lt;a href=&quot;https://arxiv.org/pdf/0811.2068.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;this&lt;/a&gt; would not be zero. To test if Born's rule is true for a &lt;em&gt;particular&lt;/em&gt; system (in this case, photons coming from some particular source), you would have to do an infinite number of instances, of all 7 of these experiments, or come up with a different way to test Born's rule (and I don't know of any). In 2009 we published this saying that Born's rule was true (for this system) to within an $\epsilon$ that was smaller than the experimental uncertainty, so we only know Born's rule is true for this system, and to within a precision limited by the experiment.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;2&lt;/strong&gt;: This is actually already the case, but let's pretend that gravity does not exist and that quantum mechanics (QED+QFD+QCD) is correct, and we still find it impossible to explain something, despite having (somehow) magical computer power to compute anything we want instantly.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-05-15T23:57:22.280" LastActivityDate="2018-05-15T23:57:22.280" CommentCount="6" />
  <row Id="2068" PostTypeId="1" AcceptedAnswerId="2069" CreationDate="2018-05-16T01:45:04.353" Score="6" ViewCount="76" Body="&lt;p&gt;I am aware that of the difference of Adiabatic Quantum Computing (AQC) and Quantum Annealing (QA) as explained &lt;a href=&quot;https://cstheory.stackexchange.com/questions/17703/quantum-annealing-vs-adiabatic-quantum-computation&quot;&gt;here&lt;/a&gt;. However, another term which came up in some papers was &lt;strong&gt;Adiabatic Quantum Optimization (AQO)&lt;/strong&gt;. Where does AQO fit in among AQC and QA?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It seems that it is another name for QA and is restricted to solving the Ising model, just like D-Wave's QA? I would think AQO is more general than QA where QA is a form of AQO where its Hamiltonian can be any algebraic function of spin variables without restrictions on the interaction, unlike the Ising model.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Anyone mind clarifying this? Thank you!&lt;/p&gt;&#xA;" OwnerUserId="2398" LastActivityDate="2018-05-17T01:03:33.473" Title="Adiabatic Quantum Computing vs Adiabatic Quantum Optimization vs Quantum Annealing" Tags="&lt;quantum-computer&gt;&lt;quantum-annealing&gt;&lt;adiabatic-model&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2069" PostTypeId="2" ParentId="2068" CreationDate="2018-05-16T04:29:35.527" Score="3" Body="&lt;p&gt;I'm very happy my answer from 3 years ago to that question is still helping people!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The answer to your new question is found here:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/vtdgj.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/vtdgj.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Notice that there is &lt;strong&gt;&lt;em&gt;another&lt;/em&gt;&lt;/strong&gt; term here which is &quot;Quantum Adiabatic Algorithm&quot; or QAA. In fact those QAA papers from 2000 and 2001 papers call it &quot;Quantum Adiabatic Evolution Algorithm&quot; or QAEA, and &quot;Quantum Computation by Adiabatic Evolution&quot; or QCAE.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;I think we should agree on just using the terms AQC and Quantum Annealing to describe the two things in my answer to the question you provided the link to. &lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-05-17T01:03:33.473" LastActivityDate="2018-05-17T01:03:33.473" CommentCount="1" />
  <row Id="2070" PostTypeId="1" CreationDate="2018-05-16T17:42:16.183" Score="4" ViewCount="62" Body="&lt;p&gt;A lot of the tutorials on BB84 protocol talks about these two measurement bases, 'Rectilinear' or 'Vertical-Horizontal' and 'Diagonal'. I understand that it is possible to create a physical device that would be able to measure a qubit in both vertical and horizontal direction, or in other words, in 'Rectilinear' basis, but what would be the matrix representation of it?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, we can use $\lvert 0 \rangle \langle 0 \lvert$ to measure a qubit in the $\lvert 0 \rangle$ basis and $\lvert 1 \rangle \langle 1 \lvert$ to measure in the $\lvert 1 \rangle$ basis. &#xA;But what would be the combined measurement basis which we could call 'rectilinear' or 'vertical-horizontal'?&lt;/p&gt;&#xA;" OwnerUserId="2403" LastEditorUserId="23" LastEditDate="2018-05-16T21:36:39.727" LastActivityDate="2018-05-16T21:36:39.727" Title="'Rectilinear' and 'Diagonal' Basis in BB84 Protocol" Tags="&lt;qubit&gt;&lt;quantum-gate&gt;&lt;measurement&gt;&lt;cryptography&gt;" AnswerCount="2" CommentCount="2" FavoriteCount="1" />
  <row Id="2071" PostTypeId="2" ParentId="2070" CreationDate="2018-05-16T20:38:02.503" Score="3" Body="&lt;p&gt;For the diagonal basis, the measurement operators are the $|0\rangle\langle 0|$ and $|1\rangle\langle 1|$, as stated in the question. For the other basis, any mutually unbiased basis will do, but people usually go for the two operators $(|0\rangle+|1\rangle)(\langle 0|+\langle 1|)/2$ and $(|0\rangle-|1\rangle)(\langle 0|-\langle 1|)/2$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The labels of which basis you call what are fairly arbitrary, but I think that the rectilinear basis is usually the one that corresponds with horizontal/vertical polarisation and is labelled 0/1. The diagonal basis is then the other one.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-05-16T20:57:29.150" LastActivityDate="2018-05-16T20:57:29.150" CommentCount="0" />
  <row Id="2072" PostTypeId="2" ParentId="2070" CreationDate="2018-05-16T21:34:50.070" Score="4" Body="&lt;p&gt;Talking about bases such as $\left|0\rangle\langle0\right|$ and $\left|1\rangle\langle1\right|$ (or the equivalent vector notation $\left|0\right&amp;gt;$ and $\left|1\right&amp;gt;$, which I'll use in this answer) at the same time as 'horizontal' and 'vertical' are, to a fair extent (pardon the pun) orthogonal concepts.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;On a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bloch_sphere&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bloch sphere&lt;/a&gt;, there are 3 different orthonormal bases - we generally consider $\left|0\right\rangle$ and $\left|1\right\rangle$; $\frac{1}{\sqrt 2}\left(\left|0\right\rangle+\left|1\right\rangle\right)$ and $\frac{1}{\sqrt 2}\left(\left|0\right\rangle-\left|1\right\rangle\right)$; $\frac{1}{\sqrt 2}\left(\left|0\right\rangle+i\left|1\right\rangle\right)$ and $\frac{1}{\sqrt 2}\left(\left|0\right\rangle-i\left|1\right\rangle\right)$. I'll refer to these as the 'quantum information bases' as this is the notation generally used in quantum information.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;That looks a bit of a mess, so we can also write this as $\left|\uparrow_z\right\rangle$, $\left|\downarrow_z\right\rangle$; $\left|\uparrow_x\right\rangle$, $\left|\downarrow_x\right\rangle$; $\left|\uparrow_y\right\rangle$, $\left|\downarrow_y\right\rangle$, where the different bases are now labelled as $x, y$ and $z$. In terms of spin-half particles, this has a natural definition of up/down spin in each of those directions. However, there is freedom in choosing which direction (in the lab) these axes are in (unless otherwise constrained).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Photons (used in the BB84 protocol) aren't spin-half particles (they have a spin of one), but nevertheless have similarities to this - the 'axes' are the possible directions of the polarisation of a photon, only instead of labelling these as $x, y$ and $z$, they're labelled as horizontal/vertical, diagonal/antidiagonal and left-/right-circular, or in vector notation, this is shortened to $\left|H\right&amp;gt;$, $\left|V\right&amp;gt;$; $\left|D\right&amp;gt;$, $\left|A\right&amp;gt;$; $\left|L\right&amp;gt;$ and $\left|R\right&amp;gt;$. These can then be mapped on to the 'quantum information' bases above, although which basis gets labelled as $\left|0\right&amp;gt;$ and $\left|1\right&amp;gt;$ is somewhat arbitrary.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For the BB84 protocol (and indeed, frequently used in other applications), the rectilinear (vertical/horizontal) basis is the one labelled using $\left|0\right&amp;gt;$ and $\left|1\right&amp;gt;$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;That is: $$\left|H\right&amp;gt;=\left|0\right&amp;gt;$$ &#xA;$$\left|V\right&amp;gt;=\left|1\right&amp;gt;$$&#xA;$$\left|D\right&amp;gt;=\frac{1}{\sqrt 2}\left(\left|H\right\rangle+\left|V\right\rangle\right)=\frac{1}{\sqrt 2}\left(\left|0\right\rangle+\left|1\right\rangle\right)$$&#xA;$$\left|A\right&amp;gt;=\frac{1}{\sqrt 2}\left(\left|H\right\rangle-\left|V\right\rangle\right)=\frac{1}{\sqrt 2}\left(\left|0\right\rangle-\left|1\right\rangle\right)$$&#xA;$$\left|R\right&amp;gt;=\frac{1}{\sqrt 2}\left(\left|H\right\rangle+i\left|V\right\rangle\right)=\frac{1}{\sqrt 2}\left(\left|0\right\rangle+i\left|1\right\rangle\right)$$&#xA;$$\left|L\right&amp;gt;=\frac{1}{\sqrt 2}\left(\left|H\right\rangle-i\left|V\right\rangle\right)=\frac{1}{\sqrt 2}\left(\left|0\right\rangle-i\left|1\right\rangle\right)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you want to measure in any of these bases, use the 'projectors' of that basis. That is, &lt;strong&gt;if you want to measure in the rectilinear basis&lt;/strong&gt;, the projectors are $\left|H\rangle\langle H\right|$ and $\left|V\rangle\langle V\right|$. Similarly, in the diagonal basis, $\left|D\rangle\langle D\right|$ and $\left|A\rangle\langle A\right|$; and in the circularly polarised basis, $\left|L\rangle\langle L\right|$ and $\left|R\rangle\langle R\right|$&lt;/p&gt;&#xA;" OwnerUserId="23" LastActivityDate="2018-05-16T21:34:50.070" CommentCount="1" />
  <row Id="2073" PostTypeId="1" CreationDate="2018-05-17T00:23:41.620" Score="4" ViewCount="176" Body="&lt;p&gt;If we only assume that the wavefunction of the universe evolves according to $e^{-iHt}$, is there any proof that all subsystems of the universe (partial traces over parts of the universe) must evolve according to a completely positive, trace-preserving (CPTP) map?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;An example of a perfectly valid quantum map that is &lt;em&gt;not&lt;/em&gt; completely positive is given in the paragraph containing &lt;strong&gt;Eq. 6&lt;/strong&gt; of the paper: &lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S0375960105005748#!&quot; rel=&quot;nofollow noreferrer&quot;&gt;Who's afraid of not completely positive maps?&lt;/a&gt;. This was possible because they made the system and its environment entangled at the time $t=0$. So my question is whether such a proof exists for the case where there is no initial entanglement. &lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-05-17T18:33:57.057" LastActivityDate="2018-06-14T19:43:07.113" Title="Only assuming the universe evolves according to a positive trace-preserving map, is there a proof that all subsystem evolution must be CPTP?" Tags="&lt;quantum-decoherence&gt;&lt;open-quantum-systems&gt;&lt;cptp-maps&gt;&lt;quantum-dynamics&gt;&lt;density-matrix&gt;" AnswerCount="2" CommentCount="6" FavoriteCount="1" />
  <row Id="2074" PostTypeId="1" CreationDate="2018-05-17T03:52:58.673" Score="14" ViewCount="158" Body="&lt;p&gt;Many papers assert that Hamiltonian simulation is BQP-complete&#xA;(e.g., &#xA;&lt;a href=&quot;https://arxiv.org/abs/1501.01715&quot; rel=&quot;nofollow noreferrer&quot;&gt;Hamiltonian simulation with nearly optimal dependence on all parameters&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/abs/1610.06546&quot; rel=&quot;nofollow noreferrer&quot;&gt;Hamiltonian Simulation by Qubitization&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is easy to see that Hamiltonian simulation is BQP-hard because any quantum algorithm can be reduced to Hamiltonian simulation, but how is Hamiltonian simulation in BQP? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;i.e., what precisely is the Hamiltonian simulation &lt;em&gt;decision problem&lt;/em&gt; in BQP and under what conditions on the Hamiltonian? &lt;/p&gt;&#xA;" OwnerUserId="1885" LastEditorUserId="55" LastEditDate="2018-08-03T14:18:06.973" LastActivityDate="2018-08-03T14:18:06.973" Title="Hamiltonian simulation is BQP-complete" Tags="&lt;quantum-algorithms&gt;&lt;complexity-theory&gt;&lt;simulation&gt;&lt;bqp&gt;&lt;hamiltonian-simulation&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="2" />
  <row Id="2075" PostTypeId="5" CreationDate="2018-05-17T05:34:20.280" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-05-17T05:34:20.280" LastActivityDate="2018-05-17T05:34:20.280" CommentCount="0" />
  <row Id="2076" PostTypeId="4" CreationDate="2018-05-17T05:34:20.280" Score="0" Body="For questions about the effect of a quantum system's environment on the system of interest." OwnerUserId="26" LastEditorUserId="2293" LastEditDate="2018-07-06T01:08:01.780" LastActivityDate="2018-07-06T01:08:01.780" CommentCount="0" />
  <row Id="2077" PostTypeId="5" CreationDate="2018-05-17T05:35:11.047" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-05-17T05:35:11.047" LastActivityDate="2018-05-17T05:35:11.047" CommentCount="0" />
  <row Id="2078" PostTypeId="4" CreationDate="2018-05-17T05:35:11.047" Score="0" Body="For questions about how a quantum state (wavefunction, density matrix, Wigner distribution, etc.) changes with respect to time. Also for questions about how to calculate quantum dynamics." OwnerUserId="26" LastEditorUserId="2293" LastEditDate="2018-07-06T01:07:55.653" LastActivityDate="2018-07-06T01:07:55.653" CommentCount="0" />
  <row Id="2079" PostTypeId="5" CreationDate="2018-05-17T05:35:47.633" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-05-17T05:35:47.633" LastActivityDate="2018-05-17T05:35:47.633" CommentCount="0" />
  <row Id="2080" PostTypeId="4" CreationDate="2018-05-17T05:35:47.633" Score="0" Body="A density matrix is a matrix that can be used to describe a quantum system in a mixed state, a statistical ensemble of several quantum states. This should be contrasted with a single state vector that describes a quantum system in a pure state. The density matrix is the quantum-mechanical analogue to a phase-space probability measure (probability distribution of position and momentum) in classical statistical mechanics." OwnerUserId="26" LastEditorUserId="23" LastEditDate="2018-05-17T07:07:54.667" LastActivityDate="2018-05-17T07:07:54.667" CommentCount="0" />
  <row Id="2081" PostTypeId="2" ParentId="2074" CreationDate="2018-05-17T06:43:34.610" Score="12" Body="&lt;p&gt;There are plenty of different variants, particularly with regards to the conditions on the Hamiltonian. It's a bit of a game, for example, to try and find the simplest possible class of Hamiltonians for which simulation is still BQP-complete.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The statement will roughly be along the lines of: let $|\psi\rangle$ be a (normalised) product state, $H$ be a Hamiltonian from some particular class (e.g. consisting only of nearest-neighbour couplings on a one-dimensional lattice), $\hat O$ an observable comprising a tensor product of one-body operators such that $\|\hat O\|\leq 1$, and $t$ be a time. Given the promise that $\langle\psi|e^{iHt}\hat O e^{-iHt}|\psi\rangle$ is either greater than $\frac12+a$ or less than $\frac12-a$ for some $a$ (e.g. $a=\frac16$), decide which is the case.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h1&gt;Further Details&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;Hamiltonian Simulation is BQP-hard&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;The basic construction (originally due to Feynman, here tweaked a bit) basically shows how you can design a Hamiltonian that implements any quantum computation, including any BQP-complete computation. The observable you would measure is just $Z$ on a particular output qubit, the two measurement outcomes corresponding to 'yes' and 'no'.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The simplest sort of Hamiltonian you might think of is to consider a computation of $N-1$ sequential unitaries $U_n$ acting on $M$ qubits, starting from a state $|0\rangle^{\otimes M}$. Then you can introduce an extra $N$ qubits, and specify the Hamiltonian&#xA;$$&#xA;H=\frac{2}{N}\sum_{n=1}^{N-1}\sqrt{n(N-n)}\left(|10\rangle\langle 01|_{n,n+1}\otimes U+|01\rangle\langle 10|_{n,n+1}\otimes U^\dagger\right).&#xA;$$&#xA;If you prepare your initial state as $|1\rangle|0\rangle^{\otimes(N-1)}|0\rangle^{\otimes M}$ then after a time $N\pi/4$, it will be in a state $|0\rangle^{\otimes (N-1)}|1\rangle|\Phi\rangle$ where $|\Phi\rangle$ is the output of the desired computation. The funny coupling strengths that I've used here, the $\sqrt{n(N-n)}$ are chosen specifically to give deterministic evolution, and are related to the concept of &lt;a href=&quot;https://arxiv.org/abs/0903.4274&quot; rel=&quot;noreferrer&quot;&gt;perfect state transfer&lt;/a&gt;. Usually you'll see results stated with equal couplings, but probabilistic evolution.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To see how this works, you define a set of states&#xA;$$&#xA;|\psi_n\rangle=|0\rangle^{\otimes(n-1)}|1\rangle|0\rangle^{\otimes{N-n}}\otimes\left(U_{n-1}U_{n-2}\ldots U_1|0\rangle^{\otimes M}\right).&#xA;$$&#xA;The action of the Hamiltonian is then&#xA;$$&#xA;H|\psi_n\rangle=\frac2N\sqrt{(n-1)(N+1-n)}|\psi_{n-1}\rangle+\frac2N\sqrt{n(N-n)}|\psi_{n+1}\rangle,&#xA;$$&#xA;which proves that the evolution is restricted to an $N\times N$ subspace which is represented by a tridiagonal matrix (which is the specific thing studied in perfect state transfer).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Of course, this Hamiltonian doesn't have any particularly nice properties - it is highly non-local, for example. There are many tricks that can be played to simplify the Hamiltonian to being, for example, one-dimensional. It can even be translationally invariant if you want, at the cost of having to prepare a more complex initial product state (at that point, the computation is no longer encoded in the Hamiltonian, which is universal, but is encoded in the input state). See &lt;a href=&quot;https://arxiv.org/abs/0704.3432&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;, for example.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Hamiltonian Simulation&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;The evolution of any Hamiltonian which is local on some lattice, acting on an initial product state, for a time that is no more than polynomial in the system size, can be simulated by a quantum computer, and any efficiently implementable measurement can be applied to estimate an observable. In this sense, you can see that Hamiltonian simulation is no harder than a quantum computation, the counter-point to the previous statement that quantum computation is no harder than Hamiltonian simulation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are many ways to do this (and there have been some recent papers that show significant improvements in error scaling for certain classes of Hamiltonian). Hre's quite a simple one. Take the Hamiltonian $H$ that you want to simulate. Split it up into different parts, $H_i$, each of which commutes. For example, on a nearest-neighbour Hamiltonian on some graph, you don't need more pieces than the maximum degree of the graph. You then Trotterize the evolution, writing the approximation&#xA;$$&#xA;e^{iHt}\approx \left(e^{-iH_1\delta t}e^{-iH_2\delta t}\ldots e^{-iH_n\delta t}\right)^{t/\delta t}&#xA;$$&#xA;So, you just have to construct a circuit that implements terms like $e^{-iH_1\delta t}$, which is composed of commuting terms $H_1=\sum_nh_n$, each of which acts only on a small number of qubits.&#xA;$$&#xA;e^{-iH_1\delta t}=\prod_{n}e^{-ih_n\delta t}&#xA;$$&#xA;Since this is just a unitary on a small number of terms, a universal quantum computer can implement it.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-05-18T06:49:12.817" LastActivityDate="2018-05-18T06:49:12.817" CommentCount="0" />
  <row Id="2082" PostTypeId="1" AcceptedAnswerId="2084" CreationDate="2018-05-17T11:22:41.280" Score="15" ViewCount="733" Body="&lt;p&gt;I am a computer science student and am currently searching for resources from where I can learn about quantum computers, quantum computing models, their working principles, their gates and some simple quantum algorithms.&lt;/p&gt;&#xA;" OwnerUserId="2405" LastEditorUserId="26" LastEditDate="2018-05-17T13:19:50.597" LastActivityDate="2018-05-17T21:00:32.377" Title="Are there any organised resources available from where I can begin my quantum computing studies?" Tags="&lt;quantum-computer&gt;&lt;resource-request&gt;" AnswerCount="3" CommentCount="2" FavoriteCount="8" />
  <row Id="2083" PostTypeId="2" ParentId="2082" CreationDate="2018-05-17T11:43:37.850" Score="6" Body="&lt;p&gt;The book &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_Computation_and_Quantum_Information_(book)&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;em&gt;Quantum computation and quantum information&lt;/em&gt;&lt;/a&gt; by Nielsen and Chuang is a good read in order to introduce yourself to the world of quantum computation. The book assumes minimal prior experience with quantum mechanics and with computer science, aiming instead to be a self-contained introduction to the relevant features of both, so it is really a nice starting point for anyone who wishes to introduce himself to world of quantum information science.&lt;/p&gt;&#xA;" OwnerUserId="2371" LastEditorUserId="15" LastEditDate="2018-05-17T21:00:32.377" LastActivityDate="2018-05-17T21:00:32.377" CommentCount="0" />
  <row Id="2084" PostTypeId="2" ParentId="2082" CreationDate="2018-05-17T12:37:39.753" Score="7" Body="&lt;p&gt;A curated list of resources can be found &lt;a href=&quot;https://github.com/desireevl/awesome-quantum-computing&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In case of the link above one day going dead, I should pick out some highlights. Though this will be entirely subjective&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/tutorial?sectionId=full-user-guide&amp;amp;page=introduction&quot; rel=&quot;noreferrer&quot;&gt;IBM Q Experience user guide&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://github.com/QISKit/qiskit-tutorial&quot; rel=&quot;noreferrer&quot;&gt;Tutorial for QISKit SDK&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;http://www.theory.caltech.edu/%7Epreskill/ph219/index.html#lecture&quot; rel=&quot;noreferrer&quot;&gt;Preskill's lecture notes&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://ocw.mit.edu/courses/media-arts-and-sciences/mas-865j-quantum-information-science-spring-2006/lecture-notes/&quot; rel=&quot;noreferrer&quot;&gt;Open course by MIT&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://www.futurelearn.com/courses/intro-to-quantum-computing&quot; rel=&quot;noreferrer&quot;&gt;Open course by Keio University&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-05-17T12:37:39.753" CommentCount="0" />
  <row Id="2085" PostTypeId="5" CreationDate="2018-05-17T13:31:57.343" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-05-17T13:31:57.343" LastActivityDate="2018-05-17T13:31:57.343" CommentCount="0" />
  <row Id="2086" PostTypeId="4" CreationDate="2018-05-17T13:31:57.343" Score="0" Body="For questions related to completely positive (CP) trace-preserving (TP) maps between spaces of operators" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-05-17T21:18:04.707" LastActivityDate="2018-05-17T21:18:04.707" CommentCount="0" />
  <row Id="2087" PostTypeId="5" CreationDate="2018-05-17T13:47:43.657" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-05-17T13:47:43.657" LastActivityDate="2018-05-17T13:47:43.657" CommentCount="0" />
  <row Id="2088" PostTypeId="4" CreationDate="2018-05-17T13:47:43.657" Score="0" Body="the phenomenon by which measurements made at a microscopic level contradict a collection of notions known as local realism that are regarded as intuitively true in classical mechanics. However, some quantum mechanical predictions of multi-system measurement statistics on entangled quantum states cannot be simulated by any local hidden variable theory. An explicit example is demonstrated by Bell's theorem, which has been verified by experiment (Wikipedia)" OwnerUserId="-1" LastEditorUserId="26" LastEditDate="2018-07-05T09:23:51.047" LastActivityDate="2018-07-05T09:23:51.047" CommentCount="0" />
  <row Id="2089" PostTypeId="5" CreationDate="2018-05-17T13:48:15.120" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-05-17T13:48:15.120" LastActivityDate="2018-05-17T13:48:15.120" CommentCount="0" />
  <row Id="2090" PostTypeId="4" CreationDate="2018-05-17T13:48:15.120" Score="0" Body="For questions related to contextuality (a foundational concept in quantum mechanics) as relevant to quantum computing and/or quantum information. Contextuality means that in any theory that attempts to explain quantum mechanics deterministically, the measurement result of a quantum observable depends on the specific experimental setup being used to measure that observable, in particular, the commuting observables being measured with it. (from Wikipedia)" OwnerUserId="-1" LastEditorUserId="26" LastEditDate="2018-07-05T08:36:58.273" LastActivityDate="2018-07-05T08:36:58.273" CommentCount="0" />
  <row Id="2091" PostTypeId="2" ParentId="2082" CreationDate="2018-05-17T14:36:37.103" Score="1" Body="&lt;p&gt;It really depends on where your brain is at. In particular, how much mathematics you have under your belt. Much of what you will need to understand is contained within linear algebra (over the complex numbers.) Zooming in more: it's all in the tensor product. Most explanations I see of how tensoring works are brutally difficult to understand as a novice. In fact, the case can be made that the whole field of quantum computing has been held back by our understanding of tensor products and ability to work with them (calculate.) In this vein, I would highly recommend the recent book by Coecke and Kissinger &quot;Picturing Quantum Processes.&quot; Although perhaps you would like to struggle with a more traditional text first, in order to more appreciate the diagrammatic approach.&lt;/p&gt;&#xA;" OwnerUserId="263" LastActivityDate="2018-05-17T14:36:37.103" CommentCount="0" />
  <row Id="2093" PostTypeId="2" ParentId="1679" CreationDate="2018-05-17T19:10:51.340" Score="1" Body="&lt;p&gt;That Wikipedia article you mention says &quot;Blockchain security methods include the use of public-key cryptography.&quot; The most widely used pubic-key cryptography methods are RSA and some elliptic curve methods. Quantum computers are a threat to both RSA and elliptic curve methods because they rely on it being difficult to factor large number or to calculate difficult discrete logarithms, and Peter Shor showed in 1994 that a quantum computer can perform both these tasks with exponentially fewer arithmetic operations than a classical computer. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;If it is possible to build a big enough quantum computer, most if not all blockchain implementations will be at threat because of relying on public-key cryptography implementations which are not safe against quantum computing.&lt;/strong&gt;&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-05-17T19:10:51.340" CommentCount="1" />
  <row Id="2094" PostTypeId="2" ParentId="1679" CreationDate="2018-05-17T20:38:09.603" Score="1" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Are the current implementations of blockchain resistant to attacks using quantum computation?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Quick answers:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Resistant against near-term technology?  Sure.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Reliably secure in the long term?  Probably not.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Will this pose a major problem?  Very likely not.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Is this risk unique to blockchains?  Nope.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Because even if quantum computers would become a major threat to current implementations, the community could just elect to do a &lt;a href=&quot;https://www.investopedia.com/terms/h/hard-fork.asp&quot; rel=&quot;nofollow noreferrer&quot;&gt;hard fork&lt;/a&gt; to &lt;a href=&quot;https://en.wikipedia.org/wiki/Post-quantum_cryptography&quot; rel=&quot;nofollow noreferrer&quot;&gt;post-quantum cryptography&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Not to say that blockchain technology developers and researchers don't need to worry about working on this issue, though I'd imagine that the average user needn't be concerned with this particular threat.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Also worth noting that other financial institutions, including banks, would be prone to a similar risk in some weird hypothetical world in which people inexplicably elected against upgrading their crypto.  For example, hackers could use quantum computers to crack a financial institution's &lt;a href=&quot;https://en.wikipedia.org/wiki/Public_key_certificate&quot; rel=&quot;nofollow noreferrer&quot;&gt;TLS/SSL certificate&lt;/a&gt;, allowing them to &lt;a href=&quot;https://en.wikipedia.org/wiki/Man-in-the-middle_attack&quot; rel=&quot;nofollow noreferrer&quot;&gt;man-in-the-middle attack&lt;/a&gt; (random &lt;a href=&quot;https://ieeexplore.ieee.org/document/7163047/&quot; rel=&quot;nofollow noreferrer&quot;&gt;2015 paper&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h1&gt;Long answer&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Here's a 2017 paper that projects that Bitcoin could potentially become vulnerable by 2027, using generous assumptions:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The key cryptographic protocols used to secure the internet and financial transactions of today are all susceptible to attack by the development of a sufficiently large quantum computer. One particular area at risk are cryptocurrencies, a market currently worth over 150 billion USD. We investigate the risk of Bitcoin, and other cryptocurrencies, to attacks by quantum computers. We find that the proof-of-work used by Bitcoin is relatively resistant to substantial speedup by quantum computers in the next 10 years, mainly because specialized ASIC miners are extremely fast compared to the estimated clock speed of near-term quantum computers. On the other hand, the elliptic curve signature scheme used by Bitcoin is much more at risk, and could be completely broken by a quantum computer as early as 2027, by the most optimistic estimates. We analyze an alternative proof-of-work called Momentum, based on finding collisions in a hash function, that is even more resistant to speedup by a quantum computer. We also review the available post-quantum signature schemes to see which one would best meet the security and efficiency requirements of blockchain applications.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&amp;ndash;&lt;a href=&quot;https://arxiv.org/abs/1710.10377&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;Quantum attacks on Bitcoin, and how to protect against them&quot;&lt;/a&gt; (2017-10-28)&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;That said, I'm not too sure how relevant a concern this might be in practice as it seems like that the situation'll change before that point.  Even if Bitcoin's still around and going strong by the time it could be attacked, various mitigation techniques might go into effect.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &lt;a href=&quot;https://en.bitcoin.it/wiki/Weaknesses&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;Weakness&quot;&lt;/a&gt; article on Bitcoin's wiki doesn't even mention quantum stuff, though their article on &lt;a href=&quot;https://en.bitcoin.it/wiki/Myths#Quantum_computers_would_break_Bitcoin.27s_security&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;Myths&quot; does&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;h3&gt;Quantum computers would break Bitcoin's security&lt;/h3&gt;&#xA;  &#xA;  &lt;hr&gt;&#xA;  &#xA;  &lt;p&gt;While ECDSA is indeed not secure under quantum computing, quantum computers don't yet exist and probably won't for a while. The DWAVE system often written about in the press is, even if all their claims are true, not a quantum computer of a kind that could be used for cryptography. Bitcoin's security, when used properly with a new address on each transaction, depends on more than just ECDSA: Cryptographic hashes are much stronger than ECDSA under QC.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Bitcoin's security was designed to be upgraded in a forward compatible way and could be &lt;a href=&quot;https://en.wikipedia.org/wiki/Post-quantum_cryptography&quot; rel=&quot;nofollow noreferrer&quot;&gt;upgraded&lt;/a&gt; if this were considered an imminent threat (cf. Aggarwal et al. 2017, &quot;&lt;a href=&quot;https://arxiv.org/abs/1710.10377&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum attacks on Bitcoin, and how to protect against them&lt;/a&gt;&quot;).&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;See the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_computer#Potential&quot; rel=&quot;nofollow noreferrer&quot;&gt;implications of quantum computers on public key cryptography.&lt;/a&gt;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;The &lt;em&gt;risk&lt;/em&gt; of quantum computers is also there for financial institutions, like banks, because they heavily rely on cryptography when doing transactions.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&amp;ndash;&lt;a href=&quot;https://en.bitcoin.it/wiki/Myths#Quantum_computers_would_break_Bitcoin.27s_security&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;Myths&quot;&lt;/a&gt;, bitcoinwiki&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Regarding the point about updating mentioned above, it's that while Bitcoin and other blockchains do tend to require standard algorithms that may be foreseeably attacked by quantum computers, before that's an issue, they can basically just do a &lt;strong&gt;&lt;em&gt;hard fork&lt;/em&gt;&lt;/strong&gt;, which is basically an update that everyone in the network migrates to, enabling stuff like algorithm changes.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;What is 'Hard Fork'&lt;/strong&gt;&lt;br/&gt;A hard fork (or sometimes hardfork), as it relates to blockchain technology, is a radical change to the protocol that makes previously invalid blocks/transactions valid (or vice-versa). This requires all nodes or users to upgrade to the latest version of the protocol software. Put differently, a hard fork is a permanent divergence from the previous version of the blockchain, and nodes running previous versions will no longer be accepted by the newest version. This essentially creates a fork in the blockchain: one path follows the new, upgraded blockchain, and the other path continues along the old path. Generally, after a short period of time, those on the old chain will realize that their version of the blockchain is outdated or irrelevant and quickly upgrade to the latest version.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&amp;ndash;&lt;a href=&quot;https://www.investopedia.com/terms/h/hard-fork.asp&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;Hard Fork&quot;&lt;/a&gt;, Investopedia&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Of course, pushing a hard fork requires getting much of the community to accept it, though since pretty much all members of a cryptocurrency network wouldn't want to get hacked/scammed/etc., a hard fork pushed to avert a foreseeable risk of attack by quantum computers would almost certainly be uncontroversial.&lt;/p&gt;&#xA;" OwnerUserId="15" LastEditorUserId="15" LastEditDate="2018-05-17T20:53:21.080" LastActivityDate="2018-05-17T20:53:21.080" CommentCount="2" />
  <row Id="2095" PostTypeId="1" CreationDate="2018-05-18T05:15:35.113" Score="7" ViewCount="59" Body="&lt;p&gt;In a simple form, &lt;a href=&quot;https://en.wikipedia.org/wiki/Bell&amp;#39;s_theorem&quot; rel=&quot;noreferrer&quot;&gt;Bell's theorem&lt;/a&gt; states that:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;No physical theory of local hidden variables can ever reproduce all of the predictions of quantum mechanics.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Bell developed a series of inequalities to provide specific experimental examples to distinguish between the predictions of any theory relying on &lt;em&gt;local hidden variables&lt;/em&gt; and those of &lt;em&gt;quantum mechanics&lt;/em&gt;. As such, &lt;a href=&quot;https://en.wikipedia.org/wiki/Bell_test_experiments&quot; rel=&quot;noreferrer&quot;&gt;Bell test inequality experiments&lt;/a&gt; are of fundamental interest in quantum mechanics. However, if one wants to do things properly, one realizes that there are &lt;a href=&quot;https://en.wikipedia.org/wiki/Loopholes_in_Bell_test_experiments&quot; rel=&quot;noreferrer&quot;&gt;a number of loopholes that affects, &lt;em&gt;in different degrees&lt;/em&gt;, all experiments trying to perform Bell tests&lt;/a&gt;.[1] Experiments trying to close these loopholes tend to be unique rather than routine. One of the results of having general-purpose quantum computers, or networks thereof, would be the ability to routinely perform sophisticated quantum experiments.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Question: &lt;strong&gt;What requirements would have to fulfill a general-purpose quantum computer (network) to be able to implement Bell tests that are &lt;em&gt;at least as loophole-free&lt;/em&gt; as the best realization that has been done so far&lt;/strong&gt;?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;For clarity: ideally the best answer will take a quantum computing approach and contain close-to-engineering details, or at least close-to-architecture. For example, writing the experiment as a simple quantum circuit, one of the current architectures can be chosen and from that one would make some realistic order-of-magnitude estimates to the required times of the different quantum gates / measurements and of the required physical distance between the different qubits.&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[1] As commented by @kludg, it has been argued that &quot;&lt;em&gt;..no experiment, as ideal as it is, can be said to be totally loophole-free.&lt;/em&gt;&quot;, see &lt;a href=&quot;https://physics.aps.org/articles/v8/123&quot; rel=&quot;noreferrer&quot;&gt;Viewpoint: Closing the Door on Einstein and Bohr’s Quantum Debate&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="1847" LastEditDate="2018-05-18T07:19:58.993" LastActivityDate="2018-05-18T07:30:03.737" Title="How would a Quantum Computer (network) perform loophole-free Bell tests?" Tags="&lt;quantum-computer&gt;&lt;architecture&gt;&lt;non-locality&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="1" />
  <row Id="2096" PostTypeId="2" ParentId="2095" CreationDate="2018-05-18T06:58:44.783" Score="5" Body="&lt;p&gt;When people talk about a loophole free Bell test, what they really mean is that the two loopholes that most concern the majority of people are closed simultaneously: the measurement loophole and the locality loophole.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let us briefly review the protocol:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;A Bell state $(|00\rangle+|11\rangle)/\sqrt{2}$ is produced, and two parties, Alice and Bob, each take one qubit.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Alice and Bob must be separated by a distance $d$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Alice and Bob each pick a random bit value.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;If Alice's random bit value, $x$, is 0, she measures her qubit in the $Z$ basis. If it's 1, she measures in the $X$ basis. Her measurement outcome is a bit, recorded in the variable $A_x$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;If Bob's random bit value is $y\in\{0,1\}$, he measures in the basis $(Z+(-1)^yX)/\sqrt{2}$. His measurement outcome is a bit, recorded in the variable $B_y$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Alice and Bob repeat this many times, and evaluate the expected value of $$S=A_0(B_0+B_1)+A_1(B_0-B_1).$$&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Closing the locality loophole requires that the two parties that are taking part are separated by a distance $d$ such that the time between Alice's measurement basis being chosen, and Bob's answer being given is less than $d/c$, where $c$ is the speed of light (so that there is no way an adversary choosing Bob's answer can know Alice's measurement basis). It also requires, symmetrically, that Alice's answer is given no later than a time $d/c$ after Bob's measurement choice is made.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Closing the measurement loophole requires the use of detectors that have a sufficiently high accuracy (otherwise, an adversary obeying a Local Hidden Variable model could replace your detectors with better detectors, and use the margin of error to throw away results that would betray the presence of eavesdropping/manipulation). The precise value of this threshold depends on your precise formulation of the Bell test. The commonly quoted value is a detector efficiency of about $83\%$ for the CHSH test.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Recently, there have been experiments that have closed both these loopholes simultaneously. See &lt;a href=&quot;https://www.nature.com/articles/nature15759&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;, for example. Their results are good enough that they can quantify the likelihood of there being a local hidden variable model that describes their results ($P=0.039$). Ultimately, if you want to do better, you either need devices that perform better than theirs, or to perform more runs of the experiment. That is, perhaps, now the main experimental challenge; to improve the speed of such devices so that it doesn't take 18 days to generate 245 trials! These experiments also claim to remove the freedom of choice loophole, wherein one worries that the random number generators that are used for choosing the measurement bases of Alice and Bob are also governed by the same local hidden variable model, instead of generating perfect randomness that is uncorrelated with the rest of the experiment.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In terms of a quantum computing architecture for implementing this, that is not a particularly natural issue: for a quantum computer, one wants to be able to create as much connection and interaction between the qubits as possible, which is rather the opposite of needing to separate them over great distances. I suppose the sort of context which is starting to generate the right scenario are the designs for scalable ion trap quantum computers, where there are multiple separated traps, each of which only interacts occasionally. If each of these were far enough apart, you could think of a loophole-free Bell test. I believe the measurement efficiencies in these scenarios are high enough. The question then is, how far apart do these different locations have to be to close the locality loop hole? I haven't done any sort of calculation based on real data, but I think the answer is of the order of kilometers, i.e. completely unreasonable for a single computer. For me, those would be separate computers, working very hard to cooperatively compute using the minimum of shared resources (i.e. entanglement).&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-05-18T07:30:03.737" LastActivityDate="2018-05-18T07:30:03.737" CommentCount="7" />
  <row Id="2097" PostTypeId="1" AcceptedAnswerId="2099" CreationDate="2018-05-18T19:46:48.373" Score="8" ViewCount="106" Body="&lt;p&gt;Schrödinger wrote a letter to Einstein after the 1935 EPR paper, and in that letter Schrödinger used the German word &quot;Verschränkung&quot; which translates into &quot;entanglement&quot;, but when was the word first used in English?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Schrödinger's 1935 paper written in English, called &lt;a href=&quot;https://www.cambridge.org/core/journals/mathematical-proceedings-of-the-cambridge-philosophical-society/article/discussion-of-probability-relations-between-separated-systems/C1C71E1AA5BA56EBE6588AAACB9A222D&quot; rel=&quot;noreferrer&quot;&gt;Discussion of Probability Relations between Separated Systems&lt;/a&gt;, says (according to Wikipedia) &quot;I would not call [entanglement] one but rather the characteristic trait of quantum mechanics, the one that enforces its entire departure from classical lines of thought&quot; which means the concept was there but it whatever word he used for it was not entanglement (hence the square brackets). Unfortunately I do not have access to the full paper.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-05-18T20:24:42.280" LastActivityDate="2018-05-24T04:38:52.077" Title="When was the first use of the word Entanglement?" Tags="&lt;quantum-entanglement&gt;&lt;terminology&gt;&lt;history&gt;" AnswerCount="3" CommentCount="1" FavoriteCount="1" />
  <row Id="2098" PostTypeId="1" CreationDate="2018-05-18T20:16:22.253" Score="8" ViewCount="57" Body="&lt;p&gt;The Toric code Hamiltonian is:&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\sum_{x,y}\left( \prod_{i\in p(x,y)} Z_{ixy} + \prod_{i\in v(x,y)} X_{ixy}   \right),$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;where the $v$ and $p$ are defined according to this picture (courtesy of James Wooton's contribution to Wikipedia):&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/4Ydj9m.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/4Ydj9m.png&quot; alt=&quot;Toric Code Lattice courtesy of James Wooton from Wikipedia&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;At the moment we have an infinite 2D lattice:&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$x\rightarrow \pm \infty$ &lt;br&gt;&#xA;$y\rightarrow \pm \infty$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But if we set periodic boundary conditions such that (and feel free to edit the question if I am incorrect about this):&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$p(x+10,y)=p(x,y)$&lt;br&gt;&#xA;$v(x,y+10)=v(x,y)$,&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We get the follownig torus (image courtesy of James Wooton's contribution to Wikipedia) :&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/pFM3Nm.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/pFM3Nm.png&quot; alt=&quot;Toric Code Torus courtesy of James Wooton from Wikipedia&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Now in my periodic boundary conditions, I chose to add $+10$ but could have added some other number instead. How does this &quot;size of the torus&quot; affect the function of the toric code?&lt;/strong&gt;&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-05-19T03:06:37.930" LastActivityDate="2018-05-19T06:23:38.910" Title="How does the size of a toric code torus affect its ability to protect qubits?" Tags="&lt;architecture&gt;&lt;fault-tolerance&gt;&lt;topological-quantum-computing&gt;&lt;anyons&gt;&lt;toric-code&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="2099" PostTypeId="2" ParentId="2097" CreationDate="2018-05-18T23:28:05.820" Score="6" Body="&lt;p&gt;I managed to get access to the paper mentioned in the question. Schrödinger  in 1935 (the same year the original EPR paper was published) wrote in English: &quot;By the interaction the two representatives (or $\psi$-functions) have become entangled.&quot; This was in the abstract.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;He also wrote later in the paper: &quot;What constitutes the entanglement is that $\psi$ is not a product of a function of x and a function of y.&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;He also used the term &quot;disentanglement&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However the use of the term as found by searching: quantum entanglement&lt;br&gt;&#xA;in Google Scholar indicates that the term was merely doubling every 10 years until roughly 1990 when it went up by a factor of 5 in a 10-year period, followed by further factor of 6 in the next 10-year period:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/TGjW9.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/TGjW9.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Data was collected just now:&lt;br&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1900-1940: 63 results &lt;br&gt;&#xA;1900-1950: 93 results &lt;br&gt;&#xA;1900-1960: 146 results &lt;br&gt;&#xA;1900-1970: 313 results &lt;br&gt;&#xA;1900-1980: 718 results &lt;br&gt;&#xA;1900-1990: 1700 results &lt;br&gt;&#xA;1900-2000: 9380 results &lt;br&gt;&#xA;1900-2010: 61700 results &lt;br&gt;&#xA;1900-2020: 151000 results &lt;br&gt;&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-05-18T23:28:05.820" CommentCount="4" />
  <row Id="2100" PostTypeId="1" CreationDate="2018-05-19T02:02:13.063" Score="6" ViewCount="117" Body="&lt;p&gt;For example, has anyone seen something like:&lt;br&gt;&#xA;&quot;quqrit&quot; for a 4-level system&lt;sup&gt;[1]&lt;/sup&gt;, or&lt;br&gt;&#xA;&quot;qupit&quot; for a 5-level system&lt;sup&gt;[2]&lt;/sup&gt; ?&lt;br&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;1&lt;/sup&gt; From &quot;quad&quot; or &quot;quart&quot; since &quot;tetra&quot; would be qutrit, which is already a 3-level system.&lt;br&gt;&#xA;&lt;sup&gt;2&lt;/sup&gt; From &quot;penta&quot; since &quot;quint&quot; would interfere with quqrit for 4-level system.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I understand that we could call a quqrit a &quot;spin-3/2 particle&quot; which would be overloading the meaning of spin, but I wonder if these terms have ever been used. I have searched &quot;quqrit&quot; and &quot;qupit&quot; on Google but what if it's not called &quot;quqrit&quot; but something else? Also, perhaps no one had the bravery to publish something with these words written down but have been used orally at conferences. Surprisingly, after asking this question I found &lt;em&gt;one&lt;/em&gt; &lt;a href=&quot;https://arxiv.org/abs/1202.0052&quot; rel=&quot;noreferrer&quot;&gt;paper&lt;/a&gt; using the term &quot;qupit&quot; but the word only appears in the title and nowhere else, so it's not clear what their definition of qupit is!&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-05-19T02:08:07.750" LastActivityDate="2018-06-07T07:32:45.983" Title="Do any specific types of qudits other than qubits and qutrits have a name?" Tags="&lt;terminology&gt;&lt;qudit&gt;" AnswerCount="2" CommentCount="3" FavoriteCount="1" />
  <row Id="2101" PostTypeId="2" ParentId="2100" CreationDate="2018-05-19T04:39:11.730" Score="3" Body="&lt;p&gt;After a lot of searching, it appears that the word &quot;quqrit&quot; has indeed been used in one (but I found only one!) &lt;a href=&quot;https://www.researchgate.net/profile/Mozammel_Khan/publication/254019812_Minimized_reversiblequantum_synthesis_of_non-reversible_quinary_logic_function/links/54bf3e5d0cf2f6bf4e04e019/Minimized-reversible-quantum-synthesis-of-non-reversible-quinary-logic-function.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;paper&lt;/a&gt; from 2011, and indeed it was used to describe a 4-level system. But the word &quot;quqit&quot; is used to describe 4-level systems in two papers &lt;a href=&quot;https://www.researchgate.net/publication/235542053_Bell_states_in_a_resonant_quantum_waveguide_network?_sg=m3rWoIRIuDoqe4l3MBPBbd1dM4oGLrKBKuuzYGrgcAe-N-10Th3hpLbG5X_gIyvBPdcwcjCZgQ&quot; rel=&quot;nofollow noreferrer&quot;&gt;[1]&lt;/a&gt;&lt;a href=&quot;http://order.ph.utexas.edu/PhysRevA_70_052330.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;[2]&lt;/a&gt; dating back to 2004. This time there's four different authors in total, but two of them are on both papers so no independent groups using this term (as far as I have found). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;As for higher-order qudits beyond $d=5$, it appears to be an open question.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-05-19T04:47:38.697" LastActivityDate="2018-05-19T04:47:38.697" CommentCount="0" />
  <row Id="2102" PostTypeId="2" ParentId="2100" CreationDate="2018-05-19T05:46:12.440" Score="5" Body="&lt;p&gt;There is no standard name for a qudit for $d&amp;gt;3$. The community has mostly settled on the term qudit (but you will still find qunit or quNit, for example, using $n$ or $N$ instead of $d$ in some older papers).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You will find the odd paper where an individual author will pick a name for the $d=4$ case. I’ve certainly seen ququad and &lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.81.052317&quot; rel=&quot;nofollow noreferrer&quot;&gt;ququart&lt;/a&gt;. But I think mostly people just use qudit, and specify $d$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The other term that you'll see (thanks to Niel de Beaudrap for pointing it out) is qupit, a quantum system where the Hilbert space dimension is an odd prime, $p$.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="23" LastEditDate="2018-06-07T07:32:45.983" LastActivityDate="2018-06-07T07:32:45.983" CommentCount="2" />
  <row Id="2103" PostTypeId="2" ParentId="2098" CreationDate="2018-05-19T06:23:38.910" Score="5" Body="&lt;p&gt;The Toric code is an error correcting code. The distance of the code (I.e. the number of local operations required to convert one logical state into an orthogonal one) is equal to $N$, where the Toric code is defined on an $N\times N$ grid.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One of the places that the performance of the Toric code really wins out is that although it is only distance $N$, the vast majority of sets of $N$ single qubit errors can be corrected, and it is only once you get $O(N^2)$ errors that you get killed. That means that as $N\rightarrow\infty$, those $O(N)$ terms vanish, and you get a finite per-qubit error rate as a threshold for error correction. For finite $N$, the error correcting threshold will be lower.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-05-19T06:23:38.910" CommentCount="0" />
  <row Id="2104" PostTypeId="2" ParentId="2012" CreationDate="2018-05-19T07:49:20.730" Score="2" Body="&lt;p&gt;I don't know the translation into physics, but the circuit you want for the most basic demonstration is the following:&#xA;&lt;a href=&quot;https://i.stack.imgur.com/dQbYK.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/dQbYK.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&#xA;Here, $|+\rangle=(|0\rangle+|1\rangle)/\sqrt{2}$, and the gates are controlled-not gates and controlled-phase gates. The state $|\psi\rangle$ can be any input state initially. The first time the circuit is run prepares the $|\psi\rangle$ qubits in a 4-qubit Toric code (up to some corrections depending on what measurement results you got). Repeat the measurements again, and you get a round of error correction. In effect, what the first qubit is doing is measuring the expectation value of the observable $XXXX$ on the Toric code qubits, while the second qubit measures the $ZZZZ$ observable.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I seem to remember that Jiannis Pachos (and coauthors) explicitly described the smallest Toric code implementation possible (which I guess was this version), but I can't seem to find the paper. I had assumed that JamesWooton would have jumped in by now to tell you where that paper is. It must be commented, however, that such a small size of Toric Code is completely hopeless for error correcting properties; you cannot even correct for single-qubit errors!&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-05-19T09:12:21.783" LastActivityDate="2018-05-19T09:12:21.783" CommentCount="2" />
  <row Id="2105" PostTypeId="1" AcceptedAnswerId="2124" CreationDate="2018-05-19T10:26:28.080" Score="6" ViewCount="53" Body="&lt;p&gt;When applying each of the six degree of freedom rotations (or certain combinations of them) in an SO(4) using quantum gates, the results I expected are produced. For example, the following circuit in Craig Gidney's Quirk tool demonstrates rotations in three degrees of freedom, along with some displays of the resulting matrices expressed as percentages:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/Pz8Ew.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/Pz8Ew.png&quot; alt=&quot;Rotating three degrees of freedom in an SO(4) with expected results&quot;&gt;&lt;/a&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, when applying some combinations of rotations, such as the following, results I didn't expect are produced in the final matrix:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/VArq8.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/VArq8.png&quot; alt=&quot;Rotating four degrees of freedom in an SO(4) with expected results&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In contrast, the results I am expecting are the following:&#xA;$$&#xA;\begin{bmatrix}&#xA;    .73 &amp;amp; .07 &amp;amp; .13 &amp;amp; .07 \\&#xA;    .00 &amp;amp; .73 &amp;amp; .15 &amp;amp; .13 \\&#xA;    .13 &amp;amp; .07 &amp;amp; .73 &amp;amp; .07 \\&#xA;    .15 &amp;amp; .13 &amp;amp; .00 &amp;amp; .73&#xA;\end{bmatrix}&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For convenience, here is a &lt;a href=&quot;http://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22QFT2%22%5D%2C%5B%22inputA2%22%2C1%2C%22%2B%3DA2%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%97%A6%22%2C%22%E2%97%A6%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%80%A2%22%2C%22%E2%97%A6%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%97%A6%22%2C%22%E2%80%A2%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%5D%2C%5B1%2C%22X%22%5D%2C%5B%22Y%5E%C2%BC%22%2C%22%E2%97%A6%22%5D%2C%5B1%2C%22X%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%97%A6%22%2C%22%E2%97%A6%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%80%A2%22%2C%22%E2%97%A6%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%97%A6%22%2C%22%E2%80%A2%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%5D%2C%5B%22X%22%5D%2C%5B%22%E2%97%A6%22%2C%22Y%5E%C2%BC%22%5D%2C%5B%22X%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%97%A6%22%2C%22%E2%97%A6%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%80%A2%22%2C%22%E2%97%A6%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%97%A6%22%2C%22%E2%80%A2%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%5D%2C%5B%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22Y%5E%C2%BC%22%2C%22%E2%80%A2%22%5D%2C%5B%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%97%A6%22%2C%22%E2%97%A6%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%80%A2%22%2C%22%E2%97%A6%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%97%A6%22%2C%22%E2%80%A2%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%5D%2C%5B%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22Y%5E%C2%BC%22%2C%22%E2%97%A6%22%5D%2C%5B%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%97%A6%22%2C%22%E2%97%A6%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%80%A2%22%2C%22%E2%97%A6%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%97%A6%22%2C%22%E2%80%A2%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%5D%2C%5B%22X%22%5D%2C%5B%22%E2%80%A2%22%2C%22Y%5E%C2%BC%22%5D%2C%5B%22X%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%97%A6%22%2C%22%E2%97%A6%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%80%A2%22%2C%22%E2%97%A6%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%97%A6%22%2C%22%E2%80%A2%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%5D%2C%5B1%2C%22X%22%5D%2C%5B%22Y%5E%C2%BC%22%2C%22%E2%80%A2%22%5D%2C%5B1%2C%22X%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%97%A6%22%2C%22%E2%97%A6%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%80%A2%22%2C%22%E2%97%A6%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%97%A6%22%2C%22%E2%80%A2%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%5D%5D%2C%22gates%22%3A%5B%7B%22id%22%3A%22~1rvi%22%2C%22name%22%3A%22disp%22%2C%22circuit%22%3A%7B%22cols%22%3A%5B%5B%22Chance2%22%2C1%2C%22%E2%97%A6%22%2C%22%E2%97%A6%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%80%A2%22%2C%22%E2%97%A6%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%97%A6%22%2C%22%E2%80%A2%22%5D%2C%5B%22Chance2%22%2C1%2C%22%E2%80%A2%22%2C%22%E2%80%A2%22%5D%5D%7D%7D%2C%7B%22id%22%3A%22~o6fc%22%2C%22circuit%22%3A%7B%22cols%22%3A%5B%5B%22%E2%97%A6%22%2C%22%E2%97%A6%22%5D%2C%5B%22%E2%80%A2%22%2C%22%E2%97%A6%22%5D%2C%5B%22%E2%97%A6%22%2C%22%E2%80%A2%22%5D%2C%5B%22%E2%80%A2%22%2C%22%E2%80%A2%22%5D%5D%7D%7D%5D%7D&quot; rel=&quot;noreferrer&quot;&gt;link to the Quirk circuit with all six degree of freedom rotations&lt;/a&gt;, albeit with an unexpected final result. The results I expect are the following:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;\begin{bmatrix}&#xA;    .62 &amp;amp; .01 &amp;amp; .08 &amp;amp; .29 \\&#xA;    .11 &amp;amp; .80 &amp;amp; .01 &amp;amp; .08 \\&#xA;    .13 &amp;amp; .07 &amp;amp; .80 &amp;amp; .01 \\&#xA;    .15 &amp;amp; .13 &amp;amp; .11 &amp;amp; .62&#xA;\end{bmatrix}&#xA;$$ &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I don't know enough about using ancilla bits and uncomputation techniques to apply them to this, but I suspect that it might explain part of the unexpected results. Any advice would be greatly appreciated. &lt;/p&gt;&#xA;" OwnerUserId="2421" LastActivityDate="2018-05-21T09:40:28.593" Title="How to avoid error when applying certain combinations of degree of freedom rotations using a quantum circuit" Tags="&lt;quantum-gate&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2106" PostTypeId="1" AcceptedAnswerId="2107" CreationDate="2018-05-19T14:16:46.973" Score="14" ViewCount="343" Body="&lt;p&gt;I am studying Quantum Computing and Information. I have crossed with the 'Surface Code' phrase but I can't find a brief explanation of what it is and how it works. Hopefully you guys can help me with this.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note: If you like you can use some complicated math, I am familiar with quantum mechanics to some extent.&lt;/p&gt;&#xA;" OwnerUserId="2422" LastEditorUserId="15" LastEditDate="2018-05-19T14:22:34.147" LastActivityDate="2018-05-21T08:26:43.287" Title="What is 'Surface Code'? (Quantum Error Correction)" Tags="&lt;quantum-computer&gt;&lt;quantum-error-correction&gt;&lt;terminology&gt;" AnswerCount="2" CommentCount="5" FavoriteCount="2" />
  <row Id="2107" PostTypeId="2" ParentId="2106" CreationDate="2018-05-19T18:13:31.267" Score="8" Body="&lt;p&gt;The surfaces codes are a family of quantum error correcting codes defined on a 2D lattice of qubits. Each code within this family has stabilizers that are defined equivalently in the bulk, but they differ in their boundary conditions.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The members of the surface code family are sometimes also described by more specific names: The &lt;a href=&quot;https://en.wikipedia.org/wiki/Topic_code&quot; rel=&quot;noreferrer&quot;&gt;toric code&lt;/a&gt; is a surface code with periodic boundary conditions, the planar code is one defined on a plane, etc. The term ‘surface code’ is sometimes also used interchangeably with ‘planar code’, since this is the most realistic example of the surface code family.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The surface codes are currently a large research area, so I’ll just point you towards some good entry points (in addition to the Wikipedia article linked to above).&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0110143&quot; rel=&quot;noreferrer&quot;&gt;Topological quantum memory (paper)&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1208.0928&quot; rel=&quot;noreferrer&quot;&gt;Surface codes: Towards practical large-scale quantum computation (paper)&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://decodoku.blogspot.ch/2016/02/5-story-so-far_57.html&quot; rel=&quot;noreferrer&quot;&gt;My blog series introducing surface codes&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;The surface codes can also be generalized to qudits. For more on that, see &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9707021&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-05-19T18:13:31.267" CommentCount="2" />
  <row Id="2108" PostTypeId="1" AcceptedAnswerId="2122" CreationDate="2018-05-19T18:56:31.730" Score="7" ViewCount="151" Body="&lt;p&gt;I am trying to run some code using &lt;code&gt;qiskit&lt;/code&gt;, but I get the error message, that I have run out of necessary &lt;code&gt;Experiment Units&lt;/code&gt;. I tried to remove pending jobs using the API with the following code&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;for job in api.get_jobs():&#xA;    if job[&quot;status&quot;] == &quot;RUNNING&quot;:&#xA;    api.cancel_job(id_job=job[&quot;id&quot;], hub=None, group=None, project=None,&#xA;        access_token=None, user_id=None)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;but it didn't work.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Am I even going in the right direction or is there some other way to retrieve these used &lt;code&gt;Experiment Units&lt;/code&gt;? I have read, that they normally are given back just after the execution of program is finished or after 24 hours (depending on which one ends earlier), but I am waiting now for over than two days and nothing happens.&lt;/p&gt;&#xA;" OwnerUserId="2098" LastEditorUserId="409" LastEditDate="2018-05-19T22:47:43.870" LastActivityDate="2018-05-21T07:34:13.137" Title="How to delete pending jobs on IBM Quantum Computer to retrieve units?" Tags="&lt;ibm-q-experience&gt;&lt;qiskit&gt;" AnswerCount="1" CommentCount="6" />
  <row Id="2109" PostTypeId="1" CreationDate="2018-05-20T07:48:47.487" Score="3" ViewCount="41" Body="&lt;p&gt;I have some practical difficulties with projective measurements, so I'd welcome inspiration from others. This is beyond the question &quot;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1958/are-true-projective-measurements-possible-experimentally&quot;&gt;Are true Projective Measurements possible experimentally?&lt;/a&gt;&quot; in that I'm not aiming for perfection but for something practical. In particular, I care about the case where we want to keep computing after a measurement.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let us say we try to effect an upwards transition between two energy levels, by illuminating the sample with the appropiate wavelength. The transition is only possible if the initial state is occupied, since the final state is outside of out computational basis. For this to be a projective measurement rather than an unitary operation in a larger basis, we need to irreversibly detect this, say by a radiative spontaneous relaxation of this &quot;final&quot; state of the transition to a third energy level. If we were subsequently able to go back to the original level (coherently and rapidly), then I assume we'd have a messy work-around for an ideal projective measurement.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The question is: is this doable, or is this scheme fundamentally flawed? If it is doable, please illustrate with examples where this works.&lt;/p&gt;&#xA;" OwnerUserId="1847" LastActivityDate="2018-05-20T07:48:47.487" Title="Projective measurements: aftermath and restoration" Tags="&lt;measurement&gt;&lt;initialization&gt;" AnswerCount="0" CommentCount="0" />
  <row Id="2110" PostTypeId="1" AcceptedAnswerId="2113" CreationDate="2018-05-20T11:41:37.023" Score="10" ViewCount="218" Body="&lt;p&gt;Grover's algorithm is used, among other things, to search an item $\mathbf{y}$ in an unordered list of items $[\mathbf{x}_0, \mathbf{x}_1, ..., \mathbf{x}_{n-1}]$ of length $n$. Even though there are &lt;a href=&quot;https://quantumcomputing.stackexchange.com/search?q=grover%27s%20algorithm&quot;&gt;plenty of questions&lt;/a&gt; here regarding this topic, I still miss the point.&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;Searching in a list, the classical way&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Normally, I would design a search function in this way&#xA;$$ \mathrm{search}([\mathbf{x}_0, \mathbf{x}_1, ..., \mathbf{x}_{n-1}], \mathbf{y}) = i \in \mathbb{N} \quad \text{such that } \mathbf{x}_i = \mathbf{y} $$&#xA;So I give the list and the wanted item as inputs, and I receive the position of the item in the list as output. I think I have understood that the information about $\mathbf{y}$ is embedded in the algorithm through the oracle gate $O$, so our function becomes&#xA;$$ \mathrm{search}_\mathbf{y}([\mathbf{x}_1, \mathbf{x}_2, ..., \mathbf{x}_n] ) = i \in \mathbb{N} \quad \text{such that } \mathbf{x}_i = \mathbf{y} $$&#xA;Let's make a practical example. Consider searching the ace of spades $1\spadesuit$ in a sequence of 8 cards from a &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_52-card_deck&quot; rel=&quot;noreferrer&quot;&gt;standard 52-card deck&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/AUQIl.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/AUQIl.png&quot; alt=&quot;shuffled deck&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The list of length $8$ is $[&#xA;    \mathbf{x}_0 = J\clubsuit,$ $&#xA;    \mathbf{x}_1 = 10\diamondsuit,$ $&#xA;    \mathbf{x}_2 = 4\heartsuit,$ $&#xA;    \mathbf{x}_3 = Q\clubsuit,$ $&#xA;    \mathbf{x}_4 = 3\spadesuit,$ $&#xA;    \mathbf{x}_5 = 1\spadesuit,$ $&#xA;    \mathbf{x}_6 = 6\spadesuit, $ $&#xA;    \mathbf{x}_7 = 6\clubsuit]$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The wanted element is $\mathbf{x}_5$. I should obtain $\mathrm{search}_{\spadesuit}(cards) = 5$. Each card can be encoded with $\lceil{\log_2 52}\rceil = 6$bits, the list has $8$ elements so we need $6\times 8 = 48$ bits to encode the list. In this case, the oracle $O$ will implement the function:&#xA;$$f(\mathbf{x}) = \begin{cases} 1, &amp;amp; \mathbf{x} = 1\spadesuit \\ 0, &amp;amp; \text{otherwise} \end{cases}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, the input of Grover's algorithm is not a state of $48$qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(NB: Image of shuffled deck is taken from &lt;a href=&quot;https://www.random.org/playing-cards/&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;)&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;Grover and its oracle&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Several sources (eg. &lt;a href=&quot;https://qudev.phys.ethz.ch/content/QSIT16/talks/Grover_QSIT.pdf&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt; - graphically explained) says that the inputs of the algorithm are different: the input is a state taken from the search space $S = \{ 0, 1, 2, ..., N \} = \{0, 1, 2, ..., 7 \} $ where $N$ is the number of elements of the list. Each number corrispond to the position of an element in the list.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The input of $\mathrm{search}_{\spadesuit}(\cdot)$ is now a $\lceil \log_2 8 \rceil = 3$qubit vector $|\psi\rangle$, which must be a superposition of all the items in the search space $S$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;We know &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$|0_{3\text{qubits}}\rangle = |000\rangle$ corrisponds to $J\clubsuit$;&lt;/li&gt;&#xA;&lt;li&gt;$|1_{3\text{qubits}}\rangle = |001\rangle$ corrisponds to $10\diamondsuit$; &lt;/li&gt;&#xA;&lt;li&gt;$|2_{3\text{qubits}}\rangle = |010\rangle$ corrisponds to $4\heartsuit$;&lt;/li&gt;&#xA;&lt;li&gt;$|5_{3\text{qubits}}\rangle = |101\rangle$ corrisponds to $1\spadesuit$ which is the wanted element;&lt;/li&gt;&#xA;&lt;li&gt;and so on...&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;In this case we have &#xA;$$\mathrm{search}_{\spadesuit}(|\psi\rangle) = |5_{3\text{qubits}}\rangle$$&#xA;But in this case, our oracle would have to implement the function&#xA;$$f(|\psi\rangle) = \begin{cases} 1, &amp;amp; |\psi\rangle = |5_{3\text{qubits}}\rangle \\ 0, &amp;amp; \text{otherwise} \end{cases}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Building the oracle requires us to know that $\spadesuit$ is at position 5. What's the point to execute the algorithm if we have already searched for the element in order to build the oracle?&lt;/p&gt;&#xA;" OwnerUserId="1874" LastEditorUserId="1874" LastEditDate="2018-05-20T16:10:13.027" LastActivityDate="2018-08-01T15:39:51.500" Title="Grover's algorithm: where is the list?" Tags="&lt;grovers-algorithm&gt;" AnswerCount="2" CommentCount="1" FavoriteCount="3" />
  <row Id="2111" PostTypeId="1" AcceptedAnswerId="2112" CreationDate="2018-05-20T13:51:24.533" Score="14" ViewCount="1636" Body="&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Shor%27s_algorithm&quot; rel=&quot;noreferrer&quot;&gt;Shor's algorithm&lt;/a&gt; is expected to enable us to &lt;a href=&quot;https://en.wikipedia.org/wiki/Integer_factorization&quot; rel=&quot;noreferrer&quot;&gt;factor integers&lt;/a&gt; far larger than could be feasibly done on modern classical computers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;At current, only smaller integers have been factored.  For example, &lt;a href=&quot;https://physicsworld.com/a/shors-algorithm-is-implemented-using-five-trapped-ions/&quot; rel=&quot;noreferrer&quot;&gt;this paper&lt;/a&gt; discusses factorizing $15=5{\times}3$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What is in this sense the state-of-art in research? Is there any recent paper in which it says some bigger numbers have been factorized?&lt;/p&gt;&#xA;" OwnerUserId="2426" LastEditorUserId="15" LastEditDate="2018-05-20T19:03:30.223" LastActivityDate="2018-05-20T23:59:02.027" Title="What integers have been factored with Shor's algorithm?" Tags="&lt;quantum-computer&gt;&lt;shors-algorithm&gt;" AnswerCount="3" CommentCount="1" FavoriteCount="4" />
  <row Id="2112" PostTypeId="2" ParentId="2111" CreationDate="2018-05-20T14:19:25.103" Score="12" Body="&lt;p&gt;The prime factorization of 21 (7x3) seems to be the largest done to date with Shor's algorithm; it was done in 2012 as detailed in &lt;a href=&quot;http://www.nature.com/nphoton/journal/vaop/ncurrent/full/nphoton.2012.259.html&quot; rel=&quot;noreferrer&quot;&gt;this paper&lt;/a&gt;. It should be noted, however, that much larger numbers, such as 56,153 in 2014, have been factored using a minimization algorithm, as detailed &lt;a href=&quot;https://phys.org/news/2014-11-largest-factored-quantum-device.html&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;. For a convenient reference, see Table 5 of &lt;a href=&quot;https://arxiv.org/abs/1411.6758&quot; rel=&quot;noreferrer&quot;&gt;this paper&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;$$&#xA;\begin{array}{c}&#xA;  \textbf{Table 5:}~\text{Quantum factorization records} \\ \hline&#xA;  \small{&#xA;  \begin{array}{cccccc}&#xA;    \text{Number} &amp;amp; \text{# of factors} &amp;amp; \begin{array}{c}\text{# of qubits} \\ \text{needed} \end{array} &amp;amp; \text{Algorithm} &amp;amp; \begin{array}{c}\text{Year} \\ \text{implemented} \end{array} &amp;amp; \begin{array}{c}\text{Implemented} \\ \text{without prior} \\ \text{knowledge of} \\ \text{solution} \end{array} \\ \hline&#xA;  15    &amp;amp; 2 &amp;amp; 8 &amp;amp; \text{Shor} &amp;amp; 2001~\left[2\right] &amp;amp; \chi \\&#xA;        &amp;amp; 2 &amp;amp; 8 &amp;amp; \text{Shor} &amp;amp; 2007~\left[3\right] &amp;amp; \chi \\&#xA;        &amp;amp; 2 &amp;amp; 8 &amp;amp; \text{Shor} &amp;amp; 2007~\left[3\right] &amp;amp; \chi \\&#xA;        &amp;amp; 2 &amp;amp; 8 &amp;amp; \text{Shor} &amp;amp; 2009~\left[5\right] &amp;amp; \chi \\&#xA;        &amp;amp; 2 &amp;amp; 8 &amp;amp; \text{Shor} &amp;amp; 2012~\left[6\right] &amp;amp; \chi \\&#xA;   21   &amp;amp; 2 &amp;amp; 10 &amp;amp; \text{Shor} &amp;amp; 2012~\left[7\right] &amp;amp; \chi \\&#xA;   143  &amp;amp; 2 &amp;amp; 4 &amp;amp; \text{minimization} &amp;amp; 2012~\left[1\right] &amp;amp; \checkmark \\&#xA;   56153  &amp;amp; 2 &amp;amp; 4 &amp;amp; \text{minimization} &amp;amp; 2012~\left[1\right] &amp;amp; \checkmark \\ \hline&#xA;    291311  &amp;amp; 2 &amp;amp; 6 &amp;amp; \text{minimization} &amp;amp; \text{not yet} &amp;amp; \checkmark \\&#xA;    175  &amp;amp; 3 &amp;amp; 3 &amp;amp; \text{minimization} &amp;amp; \text{not yet} &amp;amp; \checkmark&#xA;  \end{array}}&#xA;\end{array}_{\Large{.}}&#xA;$$&lt;/p&gt;&#xA;" OwnerUserId="91" LastEditorUserId="2293" LastEditDate="2018-05-20T22:07:27.237" LastActivityDate="2018-05-20T22:07:27.237" CommentCount="7" />
  <row Id="2113" PostTypeId="2" ParentId="2110" CreationDate="2018-05-20T15:35:22.060" Score="5" Body="&lt;p&gt;If you have 8 items in the list (like in your card's example), then the input of the oracle is 3 (qu)bits. Number of cards in the deck (52) is irrelevant, you need 3 bits only to encode 8 cards.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can think that 3 bits encode the position in the list of the card you are searching; then you don't know the position, but the oracle knows. So if you are searching the ace of spades, then the oracle knows that the ace of spades is the 6th card (or 5th counting from zero) and implements the function&#xA;$$&#xA;f(\mathbf{x}) = \begin{cases} 1, &amp;amp; \text{if x = 5, or binary '101'} \\ 0, &amp;amp; \text{otherwise} \end{cases}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;PS: It is better to think about the Grover's algorithm differently: you have an oracle implementing a boolean function which outputs $1$ for a single combination of input bits, otherwise outputs zero, and your task is to find the combination. The problem has the same complexity as searching in an unsorted list or database, that is why the Grover's algorithm is usually described as searching in an unsorted database. But applying the algorithm to a real-world database search indeed raises questions that are beyond the algorithm itself. Grover's algorithm is just searching for what the oracle knows.&lt;/p&gt;&#xA;" OwnerUserId="2105" LastEditorUserId="2105" LastEditDate="2018-05-20T16:34:46.827" LastActivityDate="2018-05-20T16:34:46.827" CommentCount="4" />
  <row Id="2114" PostTypeId="1" AcceptedAnswerId="2116" CreationDate="2018-05-20T17:02:31.187" Score="7" ViewCount="216" Body="&lt;p&gt;$\newcommand{\Ket}[1]{\left|#1\right&amp;gt;}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I understand that in general quantum black box algorithms (such as the ones which play a part in Simon's &amp;amp; Deutsch's algorithm) implement a quantum circuit to compute some function $f\left(x\right)$ in such a way that the input is fed with trailing zero qubits, and the result is the input followed by the output, e.g:  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\Ket{x}\Ket{0} \rightarrow \Ket{x}\Ket{f(x)}\,.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is, since basically one can write the above more explicitly as:$$&#xA;\Ket{x}\otimes\Ket{0} \rightarrow \Ket{x}\otimes\Ket{f(x)}&#xA;\,,$$whether it is possible, in case $\Ket{x}$ is not a pure state but a superposition, to get an output which &quot;mixes&quot; inputs with the wrong outputs.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To clarify what I mean I'll give an example:&#xA;Suppose our input is the one qubit superposition: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\Ket{x} = \frac{\Ket{0}+\Ket{1}}{\sqrt{2}}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Will the result of the black-box circuit be the following tensor product:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;\left\lbrack\frac{\Ket{0}+\Ket{1}}{\sqrt{2}}\right\rbrack&#xA;\otimes&#xA;\left\lbrack\frac{\Ket{f(0)}+\Ket{f(1)}}{\sqrt{2}}\right\rbrack&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(Which I find confusing and unlikely)&#xA;Or, the other option which seems to be more natural:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\frac{\Ket{0}\Ket{f(0)}+\Ket{1}\Ket{f(1)}}{\sqrt{2}}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(Or perhaps both are wrong? :))&lt;/p&gt;&#xA;" OwnerUserId="2428" LastEditorUserId="15" LastEditDate="2018-05-20T20:17:41.743" LastActivityDate="2018-05-20T20:17:41.743" Title="Clarification needed regarding quantum &quot;black-box&quot; circuits" Tags="&lt;quantum-algorithms&gt;&lt;simons-algorithm&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="2115" PostTypeId="2" ParentId="2114" CreationDate="2018-05-20T17:50:48.007" Score="3" Body="&lt;p&gt;Nice question. &#xA;Your second example is correct. I will show this by using Equation 2 from &lt;a href=&quot;https://en.wikipedia.org/wiki/Kronecker_product#Properties&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$(A + B)\otimes C = A\otimes C + B\otimes C$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For your example:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\left(\frac{|0\rangle+|1\rangle}{\sqrt{2}}\right)\otimes|f(x)\rangle = \frac{|0\rangle\otimes|f(x)\rangle}{\sqrt{2}}+\frac{|1\rangle\otimes|f(x)\rangle}{\sqrt{2}} = \frac{|0\rangle\otimes|f(0)\rangle}{\sqrt{2}}+\frac{|1\rangle\otimes|f(1)\rangle}{\sqrt{2}}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can see this being done, for example, in the first line of Page 6 in these &lt;a href=&quot;https://cs.uwaterloo.ca/~watrous/LectureNotes/CPSC519.Winter2006/04.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;lecture notes&lt;/a&gt; of Prof. John Watrous.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-05-20T17:58:46.907" LastActivityDate="2018-05-20T17:58:46.907" CommentCount="0" />
  <row Id="2116" PostTypeId="2" ParentId="2114" CreationDate="2018-05-20T18:30:09.033" Score="4" Body="&lt;p&gt;It is always good to start from considering an example. Suppose you have CNOT gate; then&#xA;\begin{align}&#xA;\Ket{0}\Ket{0} \rightarrow \Ket{0}\Ket{0}\\&#xA;\Ket{1}\Ket{0} \rightarrow \Ket{1}\Ket{1}&#xA;\end{align}&#xA;By linearity&#xA;\begin{align}&#xA;\frac{1}{\sqrt{2}}(\Ket{0}\Ket{0} + \Ket{1}\Ket{0}) \rightarrow \frac{1}{\sqrt{2}}(\Ket{0}\Ket{0}+ \Ket{1}\Ket{1})&#xA;\end{align}&#xA;or&#xA;\begin{align}&#xA;\frac{1}{\sqrt{2}}(\Ket{0} + \Ket{1})\Ket{0} \rightarrow \frac{1}{\sqrt{2}}(\Ket{0}\Ket{0}+ \Ket{1}\Ket{1})&#xA;\end{align}&#xA;So your first guess is wrong, but the second guess seems to be true, and it is not hard to convince yourself that it is indeed true.&lt;/p&gt;&#xA;" OwnerUserId="2105" LastActivityDate="2018-05-20T18:30:09.033" CommentCount="1" />
  <row Id="2117" PostTypeId="2" ParentId="1796" CreationDate="2018-05-20T19:59:27.993" Score="1" Body="&lt;p&gt;Your question discusses two different algorithms in the same paragraph.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Shor's algorithm:&lt;/strong&gt; &lt;br&gt;&#xA;The computational complexity has been proven to be better than for the best &lt;strong&gt;known&lt;/strong&gt; classical algorithm, but the physical complexity of implementing it has been a bottleneck. It turns out that all implementations of Shor's algorithm until 2016 were &quot;cheating&quot; because for each number $N$, there exists a base $a$ with which Shor's algorithm can be compiled to factor $N$ with only 1 qubit and 1 classical coin flip, but to know this value of $a$ you have to know the factors of $N$. The experiments were not only &quot;designed for particular $N$&quot; as the question asks, but in many cases they were designed for a particular $a$. Unless you pick $a$ &lt;strong&gt;randomly&lt;/strong&gt; until you succeed, you are &lt;strong&gt;cheating&lt;/strong&gt;. This was explained in 2013 in the paper &lt;a href=&quot;https://arxiv.org/abs/1301.7007&quot; rel=&quot;nofollow noreferrer&quot;&gt;Pretending to factor numbers on a quantum computer&lt;/a&gt;, later published by Nature with a slightly &lt;a href=&quot;https://www.nature.com/articles/nature12290&quot; rel=&quot;nofollow noreferrer&quot;&gt;friendlier title&lt;/a&gt;. In that paper they say you need a minimum of 8 qubits to factor 15 without cheating.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In 2016 the first experiment was done where &lt;em&gt;all&lt;/em&gt; possible values of $a$ were used in factoring 15, but they didn't used the necessary 8 qubits, they used &lt;strong&gt;qubit recycling&lt;/strong&gt; to do it with 5 qubits. There is a &lt;a href=&quot;https://cstheory.stackexchange.com/questions/37113/is-the-2016-implementation-of-shors-algorithm-really-scalable&quot;&gt;discussion between Peter Shor and myself&lt;/a&gt; in the comments to my question on whether or not this qubit recycling approach is scalable. It is scalable from a computational complexity standpoint, but not from a physical complexity standpoint because you need &lt;strong&gt;&lt;em&gt;much&lt;/em&gt;&lt;/strong&gt; longer coherence times.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;So 15 is the largest number factored using Shor's algorithm, and it was done using qubit recycling which uses fewer qubits than the original algorithm, but is less scalable in terms of coherence time requirements.&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Since 15 is the smallest odd semi-prime, it is not interesting to think about factoring all numbes $&amp;lt;15$ with Shor's algorithm.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Annealing algorithm:&lt;/strong&gt; &lt;br&gt; &#xA;In the example you gave where they &lt;a href=&quot;https://phys.org/news/2014-11-largest-factored-quantum-device.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;factored 56153&lt;/a&gt;, they  did not use Shor's algorithm but an annealing algorithm. This is indeed a general approach which can factor &lt;a href=&quot;https://arxiv.org/abs/1804.02733&quot; rel=&quot;nofollow noreferrer&quot;&gt;all numbers up to 376289&lt;/a&gt; on the 2048 qubit D-Wave. Unlike Shor's algorithm there is no proof that there is a computational complexity advantage over the best known classical algorithm, but there is some weak &lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.101.220405&quot; rel=&quot;nofollow noreferrer&quot;&gt;heuristic evidence&lt;/a&gt;. There may also be some advantages in terms of physical complexity, since D-Wave machines have been &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1803/does-moores-law-apply-to-quantum-computing&quot;&gt;roughly doubling&lt;/a&gt; in number of qubits each year.  &lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-05-20T19:59:27.993" CommentCount="0" />
  <row Id="2118" PostTypeId="2" ParentId="1796" CreationDate="2018-05-20T20:23:51.553" Score="0" Body="&lt;p&gt;&lt;strong&gt;For Shor's algorthm&lt;/strong&gt;:&#xA;Every experiment has been designed for the specific number being factored. The largest number factored without cheating &lt;a href=&quot;http://science.sciencemag.org/content/351/6277/1068&quot; rel=&quot;nofollow noreferrer&quot;&gt;was 15&lt;/a&gt; which is the smallest non-trivial semi-prime on which to apply Shor's algorithm.  Major changes would be needed in the experiment (including in the number of qubits) in order to factor 21, for example. IBM's 50-qubit machine can implement Shor's algorithm on larger numbers, but the noise is so bad that you will only get the correct factors if you're very lucky, and that's why it hasn't been done yet. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;For the annealing algorithm&lt;/strong&gt;: &lt;a href=&quot;https://arxiv.org/abs/1804.02733&quot; rel=&quot;nofollow noreferrer&quot;&gt;376289 has been factored&lt;/a&gt; with D-Wave's 2048-qubit annealer, and this is &lt;em&gt;not&lt;/em&gt; a specific experiment but a general algorithm on an easily programmable machine, but we do not know how this will scale. A very crude upper limit to the number of qubits needed to factor RSA-230 is &lt;a href=&quot;https://arxiv.org/pdf/1706.08061.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;5.5 billion qubits&lt;/a&gt; (but this can be brought down significantly by better compilers), while Shor's algorithm &lt;a href=&quot;https://arxiv.org/pdf/1706.07884.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;can do it with 381 qubits&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-05-20T20:23:51.553" CommentCount="0" />
  <row Id="2119" PostTypeId="2" ParentId="2111" CreationDate="2018-05-20T21:43:08.620" Score="3" Body="&lt;p&gt;&lt;strong&gt;For Shor's algorthm&lt;/strong&gt;:&#xA;&lt;a href=&quot;http://science.sciencemag.org/content/351/6277/1068&quot; rel=&quot;nofollow noreferrer&quot;&gt;State of the art is still 15&lt;/a&gt;. In order to &quot;factor&quot; 21 in the paper Heather mentions, they had to use the fact that $21=7\times 3$  to choose their base $a$. This was explained in 2013 in the paper &lt;a href=&quot;https://arxiv.org/abs/1301.7007&quot; rel=&quot;nofollow noreferrer&quot;&gt;Pretending to factor numbers on a quantum computer&lt;/a&gt;, later published by Nature with a slightly &lt;a href=&quot;https://www.nature.com/articles/nature12290&quot; rel=&quot;nofollow noreferrer&quot;&gt;friendlier title&lt;/a&gt;. The quantum computer did not factor 21, but it verified that the factors 7 and 3 are indeed correct.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;For the annealing algorithm&lt;/strong&gt;: &lt;a href=&quot;https://arxiv.org/abs/1804.02733&quot; rel=&quot;nofollow noreferrer&quot;&gt;State of the art is 376289&lt;/a&gt;. But we do not know how this will scale. A very crude upper limit to the number of qubits needed to factor RSA-230 is &lt;a href=&quot;https://arxiv.org/pdf/1706.08061.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;5.5 billion qubits&lt;/a&gt; (but this can be brought down significantly by better compilers), while Shor's algorithm &lt;a href=&quot;https://arxiv.org/pdf/1706.07884.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;can do it with 381 qubits&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-05-20T21:43:08.620" CommentCount="2" />
  <row Id="2120" PostTypeId="2" ParentId="2111" CreationDate="2018-05-20T23:59:02.027" Score="3" Body="&lt;p&gt;The size of the number factored is not a good measure for the complexity of the factorization problem, and correspondingly the power of a quantum algorithm. The relevant measure should rather be the periodicity of the resulting function which appears in the algorithm. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is discussed in &lt;a href=&quot;https://arxiv.org/abs/1301.7007&quot; rel=&quot;nofollow noreferrer&quot;&gt;J. Smolin, G. Smith, A. Vargo: Pretending to factor large numbers on a quantum computer&lt;/a&gt;, &lt;a href=&quot;https://dx.doi.org/10.1038/nature12290&quot; rel=&quot;nofollow noreferrer&quot;&gt;Nature 499, 163-165 (2013)&lt;/a&gt;.  In particular, the authors also give an example of a number with 20000 binary digits which can be factored with a two-qubit quantum computer, with exactly the same implementation that had been used previously to factor other numbers.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;It should be noted that the &quot;manual simplifications&quot; which the authors perform to arrive at this quantum algorithm is something which has also been done e.g. for the original experiment factoring 15.&lt;/p&gt;&#xA;" OwnerUserId="491" LastActivityDate="2018-05-20T23:59:02.027" CommentCount="0" />
  <row Id="2121" PostTypeId="2" ParentId="2110" CreationDate="2018-05-21T07:09:38.107" Score="3" Body="&lt;p&gt;While it is perhaps easiest for us to think about the function of the oracle as already having computed all these values, that's not what it's doing. In the case you described, the oracle has 8 possible inputs (i.e. encoded in 3 (qu)bits), and the oracle does all the computation that you need &lt;em&gt;on the fly&lt;/em&gt;. So, the moment you try to evaluate the oracle for some value $x$, the oracle looks up (in this instance) the card that the value of $x$ corresponds to, and then checks if that card is the marked card. The idea being that each time you call the oracle, it goes through that process once. Overall, you evaluate the function a number of times that's equal to the number of times you call the oracle. The aim of any search algorithm is to call that oracle as few times as possible.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In case this sounds a little circular (given an input $x$, find which card that corresponds to), remember that your look-up table for what $x$ corresponds to what card can be &lt;em&gt;ordered&lt;/em&gt; which is a different, simpler, much faster search question.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The key differences in your example compared to a more realistic usage scenario are:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;The search space is usually massive. There's no realistic prospect of precomputing all values. Indeed, that is exactly what we're trying to avoid.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Usually, we don't actually say 'find the ace of spades'. Instead, there's an $f(x)$ that is non-trivial to evaluate to test if $x$ is the 'marked' item or not. The fact that the oracle can take quite a long time to evaluate, even for a single entry, is what makes the oracle the costly part to implement (and all other gates are given for free) and why you need to minimise the number of calls.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;So, really, the way a classical search would work on your problem is: pick an $x$ at random. Evaluate $y=f(x)$. If $y=1$, return $x$, otherwise repeat. While the &lt;em&gt;net&lt;/em&gt; effect of $f(x)$ is 'is the input $x_0$, the marked entry?', that is not the &lt;em&gt;actual&lt;/em&gt; calculation that it does.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-05-21T07:09:38.107" CommentCount="0" />
  <row Id="2122" PostTypeId="2" ParentId="2108" CreationDate="2018-05-21T07:25:19.890" Score="5" Body="&lt;p&gt;Cancel Job is only available for the IBM Q Network, not for IBM Q Experience: &lt;a href=&quot;https://github.com/QISKit/qiskit-api-py/blob/master/IBMQuantumExperience/IBMQuantumExperience.py#L795&quot; rel=&quot;noreferrer&quot;&gt;https://github.com/QISKit/qiskit-api-py/blob/master/IBMQuantumExperience/IBMQuantumExperience.py#L795&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the next weeks, we hope that it is available for IBM Q Experience too.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Regarding to the credits... we are analyzing the problem. We have refilled your credits. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you have any other issue, please post in qiskit (&lt;a href=&quot;https://qiskit.org/&quot; rel=&quot;noreferrer&quot;&gt;https://qiskit.org/&lt;/a&gt;) slack public channel :).&lt;/p&gt;&#xA;" OwnerUserId="2436" LastEditorUserId="2436" LastEditDate="2018-05-21T07:34:13.137" LastActivityDate="2018-05-21T07:34:13.137" CommentCount="0" />
  <row Id="2123" PostTypeId="2" ParentId="2106" CreationDate="2018-05-21T08:26:43.287" Score="6" Body="&lt;p&gt;The terminology of 'surface code' is a little bit variable. It might refer to a whole class of things, variants of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Toric_code&quot; rel=&quot;noreferrer&quot;&gt;Toric code&lt;/a&gt; on different lattices, or it might refer to the Planar code, the specific variant on a square lattice with open boundary conditions.&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;The Toric Code&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;I'll summarise some of the basic properties of the Toric code. Imagine a square lattice with periodic boundary conditions, i.e. the top edge is joined to the bottom edge, and the left edge is joined to the right edge. If you try this with a sheet of paper, you'll find you get a doughnut shape, or torus. On this lattice, we place a qubit on each edge of a square.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/wdBRf.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/wdBRf.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Stabilizers&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Next, we define a whole bunch of operators. For every square on the lattice (comprising 4 qubits in the middle of each edge), we write&#xA;$$&#xA;B_p=XXXX,&#xA;$$&#xA;acting a Pauli-$X$ rotation on each of the 4 qubits. The label $p$ refers to 'plaquette', and is just an index so we can later count over the whole set of plaquettes. On every vertex of the lattice (surrounded by 4 qubits), we define&#xA;$$&#xA;A_s=ZZZZ.&#xA;$$&#xA;$s$ refers to the star shape and again, will let us sum over all such terms.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We observe that all of these terms mutually commute. It's trivial for $[A_s,A_{s'}]=[B_p,B_{p'}]=0$ because Pauli operators commute with themselves and $\mathbb{I}$. More care is required with $[A_s,B_p]=0$, bot note that these two terms either have 0 or 2 sites in common, and pairs of different Pauli operators commute, $[XX,ZZ]=0$.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Codespace&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Since all these operators commute, we can define a simultaneous eigenstate of them all, a state $|\psi\rangle$ such that&#xA;$$&#xA;\forall s:A_s|\psi\rangle=|\psi\rangle\qquad\forall p:B_p|\psi\rangle=|\psi\rangle.&#xA;$$&#xA;This defines the codespace of the code. We should determine how large it is.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For an $N\times N$ lattice, there are $N^2$ qubits, so the Hilbert space dimension is $2^{N^2}$. There are $N^2$ terms $A_s$ or $B_p$, which we collectively refer to as stabilizers. Each has eigenvalues $\pm 1$ (to see, just note that $A_s^2=B_p^2=\mathbb{I}$) in equal number, and when we combine them, each halves the dimension of the Hilbert space, i.e. we would &lt;em&gt;think&lt;/em&gt; that this uniquely defines a state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, however, observe that $\prod_sA_s=\prod_pB_p=\mathbb{I}$: each qubit is included in two stars and two plaquettes. This means that one of the $A_s$ and one of the $B_p$ is linearly dependent on all the others, and does not further reduce the size of the Hilbert space. In other words, the stabilizer relations define a Hilbert space of dimension 4; the code can encode two qubits.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Logical Operators&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;How do we encode a quantum state in the Toric code? We need to know the logical operators: $X_{1,L}$, $Z_{1,L}$, $X_{2,L}$ and $Z_{2,L}$. All four must commute with all the stabilizers, and be linearly independent from them, and must generate the algebra of two qubits. Commutation of operators on the two different logical qubits:&#xA;$$&#xA;[X_{1,L},X_{2,L}]=0\quad [X_{1,L},Z_{2,L}]=0 \quad [Z_{1,L},Z_{2,L}]=0\quad [Z_{1,L},X_{2,L}]=0&#xA;$$&#xA;and anti-commutation of the two on each qubit:&#xA;$$&#xA;\{X_{1,L},Z_{1,L}\}=0\qquad\{X_{2,L},Z_{2,L}\}=0&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There's a couple of different conventions for how to label the different operators. I'll go with my favourite (which is probably the less popular):&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Take a horizontal line on the lattice. On every qubit, apply $Z$. This is $Z_{1,L}$. In fact, &lt;em&gt;any&lt;/em&gt; horizontal line is just as good.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Take a vertical line on the lattice. On every qubit, apply $Z$. This is $X_{2,L}$ (the other convention would label it as $Z_{2,L}$)&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Take a horizontal strip of qubits, each of which is in the middle of a vertical edge. On every qubit, apply $X$. This is $Z_{2,L}$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Take a vertical strip of qubits, each of which is in the middle of a horizontal edge. On every qubit, apply $X$. This is $X_{1,L}$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;You'll see that the operators that are supposed to anti-commute meet at exactly one site, with an $X$ and a $Z$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Ultimately, we define the logical basis states of the code by&#xA;$$&#xA;|\psi_{x,y}\rangle: Z_{1,L}|\psi_{x,y}\rangle=(-1)^x|\psi_{x,y}\rangle,\qquad Z_{2,L}|\psi_{x,y}\rangle=(-1)^y|\psi_{x,y}\rangle&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The distance of the code is $N$ because the shortest sequence of single-qubit operators that converts between two logical states constitutes $N$ Pauli operators on a loop around the torus.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Error Detection and Correction&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Once you have a code, with some qubits stored in the codespace, you want to keep it there. To achieve this, we need error correction. Each round of error correction comprises measuring the value of every stabilizer. Each $A_s$ and $B_p$ gives an answer $\pm 1$. This is your error syndrome. It is then up to you, depending on what error model you think applies to your system, to determine where you think the errors have occurred, and try to fix them. There's a lot of work going on into fast decoders that can perform this classical computation as efficiently as possible.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One crucial feature of the Toric code is that you do not have to identify exactly where an error has occurred to perfectly correct it; the code is &lt;em&gt;degenerate&lt;/em&gt;. The only relevant thing is that you get rid of the errors without implementing a logical gate. For example, the green line in the figure is one of the basic errors in the system, called an anyone pair. If the sequence of $X$ rotations depicted had been enacted, than the stabilizers on the two squares with the green blobs in would have given a $-1$ answer, while all others give $+1$. To correct for this, we could apply $X$ along exactly the path where the errors happened, although our error syndrome certainly doesn't give us the path information. There are many other paths of $X$ errors that would give the same syndrome. We can implement &lt;em&gt;any&lt;/em&gt; of these, and there are two options. Either, the overall sequence of $X$ rotations forms a trivial path, or one that loops around the torus in at least on direction. If it's a trivial path (i.e. one that forms a closed path that does not loop around the torus), then we have successfully corrected the error. This is at the heart of the &lt;em&gt;topological&lt;/em&gt; nature of the code; many paths are equivalent, and it all comes down to whether or not these loops around the torus have been completed.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Error Correcting Threshold&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;While the distance of the code is $N$, it is not the case that every combination of $N$ errors causes a logical error. Indeed, the vast majority of $N$ errors can be corrected. It is only once the errors become of much higher density that error correction fails. There are &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0110143&quot; rel=&quot;noreferrer&quot;&gt;interesting proofs&lt;/a&gt; that make connections to phase transitions or the random bond Ising model, that are very good at pinning down when that is. For example, if you take an error model where $X$ and $Z$ errors occur independently at random on each qubit with probability $p$, the threshold is about $p=0.11$, i.e. $11\%$. It also has a finite fault-tolerant threshold (where you allow for faulty measurements and corrections with some per-qubit error rate)&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;The Planar Code&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Details are largerly identical to the Toric code, except that the boundary conditions of the lattice are open instead of periodic. This mens that, at the edges, the stabilizers get defined slightly differently. In this case, there is only one logical qubit in the code instead of two.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-05-21T08:26:43.287" CommentCount="0" />
  <row Id="2124" PostTypeId="2" ParentId="2105" CreationDate="2018-05-21T09:40:28.593" Score="3" Body="&lt;p&gt;Since you haven't told us &lt;em&gt;how&lt;/em&gt; you've tried to do the calculation, I don't know where you're making the mistake. (I'm also unfamiliar with Quirk, which seems to be using an unusual ordering of basis elements in the output matrix. If anything looks inconsistent in the following answer, try swapping the middle two rows/columns, and adding a transpose!)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The first important thing is to not use the percentage values in the transition matrices. These correspond to probabilities, but to do any further work, we need to know about &lt;em&gt;probability amplitudes&lt;/em&gt;. So, the unitary output of your first sequence of gates is&#xA;$$&#xA;\left(&#xA;\begin{array}{cccc}&#xA; \frac{\sqrt{2+\sqrt{2}}}{2} &amp;amp; \frac{1}{4} \left(-2+\sqrt{2}\right) &amp;amp; 0 &amp;amp; -\frac{i}{2 \sqrt{2}} \\&#xA; 0 &amp;amp; \frac{1}{4} \left(2+\sqrt{2}\right) &amp;amp; -\frac{1}{2} i \sqrt{2-\sqrt{2}} &amp;amp; -\frac{i}{2 \sqrt{2}} \\&#xA; 0 &amp;amp; -\frac{i}{2 \sqrt{2}} &amp;amp; \frac{\sqrt{2+\sqrt{2}}}{2} &amp;amp; \frac{1}{4} \left(-2+\sqrt{2}\right) \\&#xA; -\frac{1}{2} i \sqrt{2-\sqrt{2}} &amp;amp; -\frac{i}{2 \sqrt{2}} &amp;amp; 0 &amp;amp; \frac{1}{4} \left(2+\sqrt{2}\right) \\&#xA;\end{array}&#xA;\right)&#xA;$$&#xA;Now we can apply the final sequence of gates; an $X$ on qubit 1, a controlled-$Y^{1/4}$ and another $X$ on qubit 1. You get the output unitary&#xA;$$&#xA;\left(&#xA;\begin{array}{cccc}&#xA; \frac{1}{4} \left(2+\sqrt{2}\right) &amp;amp; -\frac{1}{2} \sqrt{1-\frac{1}{\sqrt{2}}} &amp;amp; -\frac{i}{2 \sqrt{2}} &amp;amp;&#xA;   -\frac{1}{2} i \sqrt{\frac{1}{2} \left(2-\sqrt{2}\right)} \\&#xA; 0 &amp;amp; \frac{1}{4} \left(2+\sqrt{2}\right) &amp;amp; -\frac{1}{2} i \sqrt{2-\sqrt{2}} &amp;amp; -\frac{i}{2 \sqrt{2}} \\&#xA; -\frac{i}{2 \sqrt{2}} &amp;amp; -\frac{1}{2} i \sqrt{\frac{1}{2} \left(2-\sqrt{2}\right)} &amp;amp; \frac{1}{4} \left(2+\sqrt{2}\right)&#xA;   &amp;amp; -\frac{1}{2} \sqrt{1-\frac{1}{\sqrt{2}}} \\&#xA; -\frac{1}{2} i \sqrt{2-\sqrt{2}} &amp;amp; -\frac{i}{2 \sqrt{2}} &amp;amp; 0 &amp;amp; \frac{1}{4} \left(2+\sqrt{2}\right) \\&#xA;\end{array}&#xA;\right)&#xA;$$&#xA;The mod-square of each element is then&#xA;$$&#xA;\left(&#xA;\begin{array}{cccc}&#xA; \frac{1}{16} \left(2+\sqrt{2}\right)^2 &amp;amp; \frac{1}{8} \left(2-\sqrt{2}\right) &amp;amp; \frac{1}{8} &amp;amp; \frac{1}{8}&#xA;   \left(2-\sqrt{2}\right) \\&#xA; 0 &amp;amp; \frac{1}{16} \left(2+\sqrt{2}\right)^2 &amp;amp; \frac{1}{4} \left(2-\sqrt{2}\right) &amp;amp; \frac{1}{8} \\&#xA; \frac{1}{8} &amp;amp; \frac{1}{8} \left(2-\sqrt{2}\right) &amp;amp; \frac{1}{16} \left(2+\sqrt{2}\right)^2 &amp;amp; \frac{1}{8}&#xA;   \left(2-\sqrt{2}\right) \\&#xA; \frac{1}{4} \left(2-\sqrt{2}\right) &amp;amp; \frac{1}{8} &amp;amp; 0 &amp;amp; \frac{1}{16} \left(2+\sqrt{2}\right)^2 \\&#xA;\end{array}&#xA;\right).&#xA;$$&#xA;Numerically, these are the same as given in the question:&#xA;$$&#xA;\left(&#xA;\begin{array}{cccc}&#xA; 0.729 &amp;amp; 0.0732 &amp;amp; 0.125 &amp;amp; 0.0732 \\&#xA; 0 &amp;amp; 0.729 &amp;amp; 0.146 &amp;amp; 0.125 \\&#xA; 0.125 &amp;amp; 0.0732 &amp;amp; 0.729 &amp;amp; 0.0732 \\&#xA; 0.146 &amp;amp; 0.125 &amp;amp; 0 &amp;amp; 0.729 \\&#xA;\end{array}&#xA;\right)&#xA;$$&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-05-21T09:40:28.593" CommentCount="0" />
  <row Id="2125" PostTypeId="2" ParentId="1999" CreationDate="2018-05-21T17:39:22.773" Score="1" Body="&lt;p&gt;One of many possible constructions that gives some insight into this question, at least to me, is as follows. Using the CSD (cosine-sine decomposition), you can expand any unitary operator into a product of efficient gates V that fit nicely into a binary tree pattern. In the case of the QFT, that binary tree collapses to a single branch of the tree, all the V not in the branch are 1.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Ref:&#xA;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0411097&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Fast Fourier Transform Viewed as a Special Case of Recursive Application of Cosine-Sine Decomposition, by myself&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1974" LastEditorUserId="91" LastEditDate="2018-08-07T21:32:04.953" LastActivityDate="2018-08-07T21:32:04.953" CommentCount="2" />
  <row Id="2126" PostTypeId="1" CreationDate="2018-05-21T23:05:07.483" Score="7" ViewCount="77" Body="&lt;p&gt;One deals with the notion of superposition when studying Shor's algorithm, but how about entanglement? Where exactly does it appear in this particular circuit? I assume it is not yet present in the initial state $\left|0\right&amp;gt;\left|0\right&amp;gt;$, but how about in further process, after applying Hadamard gates, the controlled-U gates and the inverse Fourier transform? I understand that the first and second register have to be entangled, otherwise the final measurement on one of them wouldn't collapse the other one, which gives us the period (well, kind of, we need to use continuous fractions to infer it).&lt;/p&gt;&#xA;" OwnerUserId="1889" LastEditorUserId="1889" LastEditDate="2018-05-22T10:52:26.960" LastActivityDate="2018-05-22T10:52:26.960" Title="Entanglement in Shor's algorithm" Tags="&lt;quantum-entanglement&gt;&lt;shors-algorithm&gt;" AnswerCount="1" CommentCount="1" />
  <row Id="2127" PostTypeId="2" ParentId="2126" CreationDate="2018-05-21T23:56:52.823" Score="2" Body="&lt;p&gt;Your question contains the answer, as you mention the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_logic_gate#Controlled_(cX_cY_cZ)_gates&quot; rel=&quot;nofollow noreferrer&quot;&gt;controlled-U&lt;/a&gt; gate which is an entangling gate. You will see in the page I linked, that the action of c-U on $|+\rangle|0\rangle$ for example can turn the state into one which cannot be written as a product:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$|+\rangle|0\rangle = \left( \frac{|0\rangle+|1\rangle}{\sqrt{2}} \right)\otimes |0\rangle =  \left( \frac{|00\rangle+|10\rangle}{\sqrt{2}} \right)= \left( \frac{|00\rangle+|1\rangle U|&#xA;0\rangle}{\sqrt{2}} \right) = \left( \frac{|00\rangle+|1\rangle \left(u_{00}|0\rangle + u_{10}|1\rangle\right)}{\sqrt{2}} \right)$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the last step, I used the definition of $U$ from the linked &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_logic_gate#Controlled_(cX_cY_cZ)_gates&quot; rel=&quot;nofollow noreferrer&quot;&gt;controlled-U&lt;/a&gt; description:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/pYsk1.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/pYsk1.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;An example where this gate is entangling is where $u_{00}$ = 0 and $u_{10}=1$, which is just the $\rm{CNOT}$ gate. In that case we get $\frac{1}{\sqrt{2}}(|00\rangle + |11\rangle)$ which is the Bell state and is maximally entangled.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You may also be interested in this article on: &lt;a href=&quot;https://arxiv.org/pdf/quant-ph/0412140.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;Entanglement and it's role in Shor's algorithm&quot;&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-05-22T00:04:11.563" LastActivityDate="2018-05-22T00:04:11.563" CommentCount="2" />
  <row Id="2128" PostTypeId="1" CreationDate="2018-05-22T10:14:21.380" Score="6" ViewCount="88" Body="&lt;p&gt;The so called &lt;em&gt;depolarizing channel&lt;/em&gt; is the channel model that is mostly used when constructing quantum error correction codes. The action of such channel over a quantum state $\rho$ is&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\rho\rightarrow(1-p_x-p_y-p_z)\rho+p_xX\rho X+p_yY\rho Y+p_zZ\rho Z$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I was wondering which other channel models are considered in quantum communications, and how the construction of error correction codes is affected by considering such other channels.&lt;/p&gt;&#xA;" OwnerUserId="2371" LastEditorUserId="2371" LastEditDate="2018-05-31T10:15:07.937" LastActivityDate="2018-05-31T16:33:40.633" Title="Quantum Channel Models" Tags="&lt;quantum-error-correction&gt;&lt;quantum-information&gt;&lt;quantum-channel&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2129" PostTypeId="1" AcceptedAnswerId="2131" CreationDate="2018-05-22T16:22:56.337" Score="17" ViewCount="905" Body="&lt;p&gt;Is entanglement &lt;a href=&quot;https://en.wikipedia.org/wiki/Transitive_relation&quot; rel=&quot;nofollow noreferrer&quot;&gt;transitive&lt;/a&gt;, in a mathematical sense?&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;More concretely, my question is this:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Consider 3 qubits $q_1, q_2$ and $q_3$. Assume that&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$q_1$ and $q_2$ are entangled, and that&lt;/li&gt;&#xA;&lt;li&gt;$q_2$ and $q_3$ are entangled&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Then, &lt;strong&gt;are $q_1$ and $q_3$ entangled&lt;/strong&gt;? If so, why? If not, is there a concrete counterexample?&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;On my notion of entanglement: &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;qubits $q_1$ and $q_2$ are entangled, if after tracing out $q_3$, the qbits $q_1$ and $q_2$ are entangled (tracing out $q_3$ corresponds to measuring $q_3$ and discarding the result).&lt;/li&gt;&#xA;&lt;li&gt;qubits $q_2$ and $q_3$ are entangled, if after tracing out $q_1$, the qbits $q_2$ and $q_3$ are entangled.&lt;/li&gt;&#xA;&lt;li&gt;qubits $q_1$ and $q_3$ are entangled, if after tracing out $q_2$, the qbits $q_1$ and $q_3$ are entangled.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Feel free to use any other reasonable notion of entanglement (not necessarily the one above), as long as you clearly state that notion.&lt;/p&gt;&#xA;" OwnerUserId="2444" LastEditorUserId="2444" LastEditDate="2018-05-28T07:32:09.800" LastActivityDate="2018-05-28T07:32:09.800" Title="Is entanglement transitive?" Tags="&lt;qubit&gt;&lt;quantum-entanglement&gt;" AnswerCount="3" CommentCount="5" FavoriteCount="5" />
  <row Id="2130" PostTypeId="2" ParentId="2129" CreationDate="2018-05-22T18:00:17.200" Score="4" Body="&lt;p&gt;I read the following in &lt;a href=&quot;https://arxiv.org/pdf/0812.3322.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Freudenthal triple classication of three-qubit entanglement&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;Dür et al. (&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0005115&quot; rel=&quot;nofollow noreferrer&quot;&gt;Three qubits can be entangled in two inequivalent ways&lt;/a&gt;) used simple arguments concerning the conservation of ranks of reduced density matriceshere are only six three-qubit equivalence classes:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Null (The trivial zero entanglement orbit corresponding to vanishing states)&lt;/li&gt;&#xA;&lt;li&gt;Separable (Another zero entanglement orbit for completely factorisable product states)&lt;/li&gt;&#xA;&lt;li&gt;Biseparable (Three classes of bipartite entanglement: A-BC, B-AC, C-AB)&lt;/li&gt;&#xA;&lt;li&gt;W (Three-way entangled states that do not maximally&#xA;violate  Bell-type  inequalities) and&lt;/li&gt;&#xA;&lt;li&gt;GHZ (maximally  violate Bell-type inequalities)&quot; &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;which as I understand it the answer to your question is &lt;strong&gt;yes&lt;/strong&gt;: if A and B are entangled and B and C are entangled you necessarily are in one of the three-way entangled states so A and C are also entangled. &lt;/p&gt;&#xA;" OwnerUserId="1847" LastActivityDate="2018-05-22T18:00:17.200" CommentCount="0" />
  <row Id="2131" PostTypeId="2" ParentId="2129" CreationDate="2018-05-22T18:02:15.803" Score="9" Body="&lt;p&gt;TL;DR: It depends on how you choose to measure entanglement on a pair of qubits. If you trace out the extra qubits, then &quot;No&quot;. If you measure the qubits (with the freedom to choose the optimal measurement basis), then &quot;Yes&quot;.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Let $|\Psi\rangle$ be a pure quantum state of 3 qubits, labelled A, B and C. We will say that A and B are entangled if $\rho_{AB}=\text{Tr}_C(|\Psi\rangle\langle\Psi|)$ is not positive under the action of the partial transpose map. This is a necessary and sufficient condition for detecting entanglement in a two-qubit system. The partial trace formalism is equivalent to measuring qubit C in an arbitrary basis and discarding the result.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There's a class of counter-examples that show that entanglement &lt;strong&gt;is not transitive&lt;/strong&gt;, of the form&#xA;$$&#xA;|\Psi\rangle=\frac{1}{\sqrt{2}}(|000\rangle+|1\phi\phi\rangle),&#xA;$$&#xA;provided $|\phi\rangle\neq |0\rangle,|1\rangle$. If you trace out qubit $B$ or qubit $C$, you'll get the same density matrix both times:&#xA;$$&#xA;\rho_{AC}=\rho_{AB}=\frac12\left(|00\rangle\langle 00|+|1\phi\rangle\langle 1\phi|+|00\rangle\langle 1\phi|\langle\phi|0\rangle+|1\phi\rangle\langle 00|\langle0|\phi\rangle\right)&#xA;$$&#xA;You can take the partial transpose of this (taking it on the first system is the cleanest):&#xA;$$&#xA;\rho^{PT}=\frac12\left(|00\rangle\langle 00|+|1\phi\rangle\langle 1\phi|+|10\rangle\langle 0\phi|\langle\phi|0\rangle+|0\phi\rangle\langle 10|\langle0|\phi\rangle\right)&#xA;$$&#xA;Now take the determinant (which is equal to the product of the eigenvalues). You get&#xA;$$&#xA;\text{det}(\rho^{PT})=-\frac{1}{16}|\langle 0|\phi\rangle|^2(1-|\langle 0|\phi\rangle|^2)^2,&#xA;$$&#xA;which is negative, so there must be a negative eigenvalue. Thus, $(AB)$ and $(AC)$ are entangled pairs. Meanwhile&#xA;$$&#xA;\rho_{BC}=\frac12(|00\rangle\langle 00|+|\phi\phi\rangle\langle\phi\phi |).&#xA;$$&#xA;Since this is a valid density matrix, it is non-negative. However, the partial transpose is just equal to itself. So, there are no negative eigenvalues and $(BC)$ is not entangled.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Localizable Entanglement&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;One might, instead, talk about the &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0411123&quot; rel=&quot;noreferrer&quot;&gt;localizable entanglement&lt;/a&gt;. Before further clarification, this is what I thought the OP was referring to. In this case, instead of tracing out a qubit, one can measure it in a basis of your choice, and calculate the results separately for each measurement outcome. (There is later some averaging process, but that will be irrelevant to us here.) In this case, my response is specifically about pure states, not mixed states.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The key here is that there are different classes of entangled state. For 3 qubits, there are 6 different types of pure state:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;a fully separable state&lt;/li&gt;&#xA;&lt;li&gt;3 types where there is an entangled state between two parties, and a separable state on the third&lt;/li&gt;&#xA;&lt;li&gt;a W-state&lt;/li&gt;&#xA;&lt;li&gt;a GHZ state&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Any type of quantum state can be converted into one of the standard representatives of each class just by local measurements and classical communication between the parties. Note that the conditions of $(q_1,q_2)$ and $(q_2,q_3)$ being entangled remove the first 4 cases, so we only have to consider the last 2 cases, W-state and GHZ-state. Both representatives are symmetric under exchange of the particles:&#xA;$$&#xA;|W\rangle=\frac{1}{\sqrt{3}}(|001\rangle+|010\rangle+|100\rangle)\qquad |GHZ\rangle=\frac{1}{\sqrt{2}}(|000\rangle+|111\rangle)&#xA;$$&#xA;(i.e. if I swap qubits A and B, I still have the same state).&#xA;So, these representatives must have the required transitivity properties: If A and B are entangled, then B and C are entangled, as are A and C. In particular, Both of these representatives can be measured in the X basis in order to localize the entanglement. Thus, any pure state that you're given must be such that you can include the measurement to convert it into the standard representative into the measurement for localizing the entanglement, and you're done! &lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-05-24T04:00:06.790" LastActivityDate="2018-05-24T04:00:06.790" CommentCount="5" />
  <row Id="2132" PostTypeId="2" ParentId="2129" CreationDate="2018-05-22T18:07:14.737" Score="5" Body="&lt;p&gt;This isn't an answer, but instead just some background facts that are important to know about in order to avoid &quot;not even wrong&quot; territory on these types of questions.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;Entanglement&quot; is not all-or-nothing. Just saying &quot;q1 is entangled with q2 and q2 is entangled with q3&quot; is not enough information to determine the answer to questions like &quot;if I measure q3, will q1 still be entangled with q2?&quot;. Entanglement gets &lt;em&gt;complicated&lt;/em&gt; when dealing with larger systems. You really need to know the specific state, and the measurement, and whether you are permitted to condition on the result of the measurement.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It may be the case that q1,q2,q3 are entangled as a group but if you trace out any one of the qubits then the density matrix of the remaining two describes a mere classically correlated state. (E.g. this happens with GHZ states.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You should be aware of the &lt;a href=&quot;https://www.quantiki.org/wiki/monogamy-entanglement&quot; rel=&quot;nofollow noreferrer&quot;&gt;monogamy of entanglement&lt;/a&gt;. Past a certain threshold, increasing the strength of the entanglement between q1 and q2 must decrease the strength of entanglement between q1 and q3 (and equivalently q2 and q3).&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-05-22T18:09:31.550" LastActivityDate="2018-05-22T18:09:31.550" CommentCount="2" />
  <row Id="2135" PostTypeId="1" AcceptedAnswerId="2136" CreationDate="2018-05-23T15:42:16.220" Score="7" ViewCount="103" Body="&lt;p&gt;Consider the measurement of the syndrome for the standard 3-qubit code to correct bit flips:&#xA;$$&#xA;\def\place#1#2#3{\smash{\rlap{\hskip{#1px}\raise{#2px}{#3}}}}&#xA;\def\hline#1#2#3{\place{#1}{#2}{\rule{#3px}{1px}}}&#xA;\def\vline#1#2#3{\place{#1}{#2}{\rule{1px}{#3px}}}&#xA;%&#xA;\hline{30}{30}{210}&#xA;\hline{30}{60}{210}&#xA;\hline{30}{150}{210}&#xA;\hline{30}{180}{210}&#xA;\hline{30}{210}{210}&#xA;%&#xA;\vline{60}{60}{150}&#xA;\vline{90}{60}{120}&#xA;\vline{120}{30}{150}&#xA;\vline{150}{30}{120}&#xA;%&#xA;\place{46}{51}{\huge{\oplus}}&#xA;\place{76}{51}{\huge{\oplus}}&#xA;\place{106}{21}{\huge{\oplus}}&#xA;\place{136}{21}{\huge{\oplus}}&#xA;%&#xA;\place{30}{205}{\llap{Z_1}}&#xA;\place{30}{175}{\llap{Z_2}}&#xA;\place{30}{145}{\llap{Z_3}}&#xA;%&#xA;\place{241}{41}{\left. \rule{0px}{22.5px} \right\} M}&#xA;%&#xA;\phantom{\rule{280px}{225px}}_{\Large{.}}&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here $M$ is a measurement in the computational basis. This circuit measures $Z_1Z_2$ and $Z_2Z_3$ of the encoded block (i.e. the top three). My question is why measure these using ancilla qubits - why not just measure the 3 encoded qubits directly? Such a setup would mean you would not have to use c-not gates which from what I have heard are hard to implement.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(Note I have only given this 3-qubit code as an example I am interested in general syndrome measurements on general codes).&lt;/p&gt;&#xA;" OwnerUserId="2015" LastEditorUserId="1847" LastEditDate="2018-06-15T08:00:55.017" LastActivityDate="2018-06-15T08:00:55.017" Title="Why do we use ancilla qubits for error syndrome measurements?" Tags="&lt;quantum-error-correction&gt;&lt;stabilizer-code&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="2136" PostTypeId="2" ParentId="2135" CreationDate="2018-05-23T15:52:51.157" Score="6" Body="&lt;p&gt;The key point of quantum error correction is precisely &lt;strong&gt;to correct the errors without collapsing the qubits&lt;/strong&gt;, right? If we measure the encoded qubits we project the qubits to $\left|0\right&amp;gt;$ or $\left|1\right&amp;gt;$ and lose all the information in the coefficients $\alpha \left|0\right&amp;gt; + \beta \left|1\right&amp;gt;$. By measuring ancilla qubits we can know what has happened to the qubits without actually knowing the values of the qubits: this enables us to correct errors in a non-destructive way, and carry on with our quantum operation.&lt;/p&gt;&#xA;" OwnerUserId="1847" LastEditorUserId="15" LastEditDate="2018-05-24T08:43:30.087" LastActivityDate="2018-05-24T08:43:30.087" CommentCount="0" />
  <row Id="2137" PostTypeId="2" ParentId="2097" CreationDate="2018-05-23T17:59:02.893" Score="2" Body="&lt;p&gt;This is a soft answer, offered b/c I'm interested in the etymologies of terms we use in math and science.  For what it's worth:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;entanglement (n.)&lt;/strong&gt;&#xA;   1630s, &quot;that which entangles,&quot; from entangle + -ment. From 1680s as &quot;act of entangling.&quot; Foreign entanglements does not appear as such in Washington's Farewell Address (1796), though he warns against them. The phrase is found in William Coxe's 1798 memoirs of Sir Robert Walpole.&#xA;  &lt;br&gt;&lt;sub&gt;SOURCE: &lt;a href=&quot;https://www.etymonline.com/word/entanglement&quot; rel=&quot;nofollow noreferrer&quot;&gt;Online Etymological Dictionary&lt;/a&gt;&lt;/sub&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;from:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;tangle (n.)&lt;/strong&gt;&#xA;  1610s, &quot;a tangled condition, a snarl of threads,&quot; from tangle (v.). &lt;br&gt;&lt;sub&gt;SOURCE: &lt;a href=&quot;https://www.etymonline.com/word/tangle?ref=etymonline_crossreference&quot; rel=&quot;nofollow noreferrer&quot;&gt;Online Etymological Dictionary&lt;/a&gt;&lt;/sub&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I make this connection because the idea of determinacy and strings/threads goes back to at least the ancient Greek &lt;a href=&quot;https://en.wikipedia.org/wiki/Moirai&quot; rel=&quot;nofollow noreferrer&quot;&gt;Moirai&lt;/a&gt; (the Fates).&lt;/p&gt;&#xA;" OwnerUserId="2447" LastEditorUserId="2293" LastEditDate="2018-05-24T04:38:52.077" LastActivityDate="2018-05-24T04:38:52.077" CommentCount="3" />
  <row Id="2138" PostTypeId="2" ParentId="2135" CreationDate="2018-05-24T04:09:52.527" Score="5" Body="&lt;p&gt;When you say &quot;why not just measure the 3 encoded qubits directly&quot;, are you thinking that you could measure $Z_1$, $Z_2$ and $Z_3$, and that, from there, you can calculate the values $Z_1Z_2$ and $Z_2Z_3$?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is sort of true: if your only goal is to obtain the observables $Z_1Z_2$ and $Z_2Z_3$, you &lt;em&gt;could&lt;/em&gt; do this.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But that is not your end goal, which is, instead, to preserve the information encoded in the logical state. The only way you can do this is to learn nothing about the state that is encoded. Effectively, measuring in this way gives you too much information: it gives you 3 bits of information (1 bit from each measurement that you perform) when you only need 2 bits. Where does this extra bit come from? It is one bit of information about the state that you have encoded. In other words, you have measured the encoded state, destroying any superposition that you are specifically trying to use the error correcting code to protect.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-05-24T04:09:52.527" CommentCount="0" />
  <row Id="2139" PostTypeId="2" ParentId="2097" CreationDate="2018-05-24T04:22:48.923" Score="1" Body="&lt;p&gt;According to Matthias Christandl (who did some research on this to resolve a bet with Artur Ekert), while the term &quot;entanglement&quot; was first used in 1935, as already relayed in other answers, the &lt;em&gt;concept&lt;/em&gt; was discussed by Schrodinger in 1932. This &lt;a href=&quot;http://www.math.ku.dk/english/research/gamp/qit/files/entangled.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;set of slides&lt;/a&gt; (slides 3-8 in particular) from a talk reproduce part of a document that details this. The full image is also on the front of his &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0604183&quot; rel=&quot;nofollow noreferrer&quot;&gt;thesis&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-05-24T04:22:48.923" CommentCount="0" />
  <row Id="2140" PostTypeId="1" AcceptedAnswerId="2141" CreationDate="2018-05-24T07:57:15.943" Score="4" ViewCount="52" Body="&lt;p&gt;In this &lt;a href=&quot;http://faculty.cs.tamu.edu/klappi/csce640-f14/simon2.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;pdf&lt;/a&gt; for the Simon's algorithm we need $n-1$ independent $\mathbf y$ such that:&#xA;$$ \mathbf y \cdot \mathbf s=0$$&#xA;to find $\mathbf s$. On page 6 of the pdf the author writes that the probability of getting $n-1$ independent values of $\mathbf y$ in $n-1$ attempts is:&#xA;$$P_{ind}=(1-1/N(\mathbf s))(1-2/N(\mathbf s))\cdots (1-2^{n-1}/N(\mathbf s))\tag{1}$$&#xA;where $N(\mathbf s)=2^{n-1}$ if $\mathbf s \ne 0$ and $2^n$ if $\mathbf s=0$. Clearly then $P_{ind}=0$ for $\mathbf{s}\ne 0$ - which I believe to be wrong.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is therefore: Is formula (1) wrong and if so what is the correct version. If it is not wrong how do we interpret &#xA;$P_{ind}=0$ .&lt;/p&gt;&#xA;" OwnerUserId="2015" LastEditorUserId="1837" LastEditDate="2018-05-24T08:15:42.570" LastActivityDate="2018-05-25T07:00:28.307" Title="Simon's Algorithm Probability of Independence" Tags="&lt;simons-algorithm&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2141" PostTypeId="2" ParentId="2140" CreationDate="2018-05-24T08:26:57.930" Score="2" Body="&lt;p&gt;At first glance, the formula looks lightly wrong: the last term in the should only be $(1-2^{n-2}/N(s))$, giving&#xA;$$&#xA;P_{ind}=\prod_{k=1}^{n-1}\left(1-\frac{2^{k-1}}{N(s)}\right)&#xA;$$&#xA;overall. Thus every term is a half, or larger.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My reasoning is as follows: you perform a measurement and get a random outcome. The first time you do this, it can be any outcome except the all 0 string. This happens with probability $1-1/N(s)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The second time, you want any string except the all zeros, or the answer you got last time, $y_1$. Thus, the term $1-2/N(s)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The third time, you want any string except the all zeros, $y_1$, $y_2$ or $y_1\oplus y_2$. Thus, the term $1-4/N(s)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Once you have $k-1$ linearly independent strings $y_1$ to $y_{k-1}$ and you're trying top find the $k^{th}$, there are $2^{k-1}$ answers you don't want to get: the $2^{k-1}$ answers that are linearly dependent on the strings you already have (note that this counting includes the all zeros string). You keep going until the last term, $k=n-1$ because you're trying to find $n-1$ linearly independent cases.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Incidentally, this is not the way that I would ever make the argument. Who cares about the probability of needing &lt;em&gt;exactly&lt;/em&gt; $n-1$ calls? You can just keep repeating as many times as you need to in order to find $n-1$ linearly independent strings. Since we've already argued that the worst-case probability of finding a new linearly independent string is 1/2, this means that, on average, no more than $2(n-1)$ trials would be required (and actually somewhat less, because early on you're far more likely to get a hit). You could also apply a Chernoff bound to prove that the probability of needing significantly more runs than that is vanishingly small. OK, that's essentially where the solution gets to, it just feels a little excessive (to me).&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-05-25T07:00:28.307" LastActivityDate="2018-05-25T07:00:28.307" CommentCount="0" />
  <row Id="2142" PostTypeId="2" ParentId="1356" CreationDate="2018-05-24T15:37:21.293" Score="4" Body="&lt;h2&gt;Classical Version&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Think about a simple strategy of classical error correction. You've got a single bit that you want to encode,&#xA;$$&#xA;0\mapsto 00000\qquad 1\mapsto 11111&#xA;$$&#xA;I've chosen to encode it into 5 bits, but any odd number would do (the more the better). Now, let's assume some bit-flip errors have occurred, so what we have is&#xA;$$&#xA;01010.&#xA;$$&#xA;Was this originally the encoded 0 or 1? If we assume that the probability of error per bit, $p$, is less than a half, then we expect that fewer than half the bits have errors. So, we look at the number of 0s and the number of 1s. Whichever there's more of is the one that we assume is the one we started with. This is called a majority vote. There's some probability that we're wrong, but the more bits we encoded into, the smaller this probability.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;On the other hand, if we know that $p&amp;gt;\frac12$, we can still do the correction. You'd just be implementing a minority vote! The point, however, is that you have to do completely the opposite operation. There's a sharp threshold here that shows, at the very least, that you need to know which regime you're working in.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For fault-tolerance, things get messier: the $01010$ string that you got might not be what the state &lt;em&gt;actually&lt;/em&gt; is. It might be something different, still with some errors that you have to correct, but the measurements you've made in reading the bits are also slightly faulty. Crudely, you might imagine this turns the sharp transition into an ambiguous region where you don't really know what to do. Still, if error probabilities are low enough, or high enough, you can correct, you just need to know which is the case.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Quantum Version&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;In general, things get worse in the quantum regime because you have to deal with two types of errors: bit flip errors ($X$) and phase flip errors ($Z$), and that tends to make the ambiguous region bigger. I won't go further into details here. However, there's a cute argument in the quantum regime that may be illuminating.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Imagine you have the state of a single logical qubit stored in a quantum error correcting code $|\psi\rangle$ across $N$ physical qubits. It doesn't matter what that code is, this is a completely general argument. Now imagine there's so much noise that it destroys the quantum state on $\lceil N/2\rceil$ qubits (&quot;so much noise&quot; actually means that errors happen with 50:50 probability, not close to 100% which, as we've already said, can be corrected). It is impossible to correct for that error. How do I know that? Imagine I had a completely noiseless version, and I keep $\lfloor N/2\rfloor$ qubits and give the remaining qubits to you. We each introduce enough blank qubits so that we've got $N$ qubits in total, and we run error correction on them.&#xA;&lt;a href=&quot;https://i.stack.imgur.com/7BYZL.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/7BYZL.png&quot; alt=&quot;cloning demonstration&quot;&gt;&lt;/a&gt;&#xA;If it were possible to perform that error correction, the outcome would be that both of us would have the original state $|\psi\rangle$. We would have cloned the logical qubit! But cloning is impossible, so the error correction must have been impossible.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-05-26T04:26:46.040" LastActivityDate="2018-05-26T04:26:46.040" CommentCount="0" />
  <row Id="2143" PostTypeId="1" AcceptedAnswerId="2144" CreationDate="2018-05-25T10:42:39.130" Score="9" ViewCount="95" Body="&lt;p&gt;I want to be able to applied controlled versions of the $R_y$ gate (rotation around the Y axis) for real devices on the IBM Q Experience. Can this be done? If so, how?&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-05-25T11:40:54.707" Title="How can a controlled-Ry be made from cnots and rotations?" Tags="&lt;gate-synthesis&gt;&lt;ibm-q-experience&gt;&lt;controlled-gates&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2144" PostTypeId="2" ParentId="2143" CreationDate="2018-05-25T10:42:39.130" Score="4" Body="&lt;p&gt;You can make controlled $R_y$ gates from cnots and $R_y$ rotations, so they can be  be done on any pair of qubits that allows a cnot.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Two examples of controlled-Ys are shown in the image below. They are on the same circuit, one after the other.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/byHKu.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/byHKu.png&quot; alt=&quot;Two versions of a controlled-Y&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The first has qubit 1 as control and qubit 0 as target, which is easy because the cnots can be directly implemented in the right direction.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the second example, qubit 0 is control and qubit 1 is target. This is achieved by using four H gates for each cnot to effectively turn it around.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This second example can also be optimized further. There are two adjacent H gates on the top line that can be canceled. And since H anticommutes with Y, $H\,u3(\theta,0,0)\,H$ can always be replaced with $u3(-\theta,0,0)$. (Thanks to @DaftWullie for pointing these out).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/aD4eB.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/aD4eB.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The single qubit gates used are $u3(\theta,0,0)$, which are $R_y(\theta)$ rotations. The angles used are pi/2 and -pi/2 in this case. These cancel when the control is $|0\rangle$. This gives the expected effect of the controlled-Y acting trivially in this case.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When the control is $|1\rangle$, the cnots perform an X either side of the $u3(-\pi/2,0,0)$, which has the effect &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$X \, u3(\theta,0,0) \, X = u3(-\theta,0,0)$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This means that the $u3(-\pi/2,0,0)$ flips to $u3(\pi/2,0,0)$. The end effect on the control is then&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$ u3(\pi/2,0,0) \, u3(\pi/2,0,0) \, = u\, 3(\pi,0,0) \, = \, Y$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;which is a $Y$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A more general controlled $R_y$ rotation means that you want to do a fraction of a $Y$. So just reduce both angles by the corresponding fraction.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-05-25T11:40:54.707" LastActivityDate="2018-05-25T11:40:54.707" CommentCount="4" />
  <row Id="2145" PostTypeId="1" AcceptedAnswerId="2146" CreationDate="2018-05-25T14:20:59.853" Score="9" ViewCount="81" Body="&lt;p&gt;I am a bit confused about the necessity of an oracle qubit in Grover's algorithm.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is, does it depend on how you implement your oracle whether you need an oracle qubit or not? Or, it there any reason for an oracle qubit? (such as, there exist some problems that cannot be solved without an oracle qubit, or it's easier to think about the problem with an oracle qubit, or it's a convention, etc)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Many resources introduce Grover's algorithm with an oracle qubit, but I found there are some cases that you do not need an oracle qubit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, here are two implementations of Grover's algorithm in IBM Q simulator. One is using an oracle qubit, and the other is not. In both cases, I would like to find |11&gt; from a space of |00&gt;, |01&gt;, |10&gt;, and |11&gt;. In both cases, oracle successfully flips |11&gt; to -|11&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;・With an oracle qubit (&lt;a href=&quot;https://quantumexperience.ng.bluemix.net/share/code/5b0814cf77cc86003feebfcb/execution/5b0814d09568dc003aedae8c&quot; rel=&quot;noreferrer&quot;&gt;Link to IBM Q simulator&lt;/a&gt;)&#xA;&lt;a href=&quot;https://i.stack.imgur.com/LpbFo.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/LpbFo.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;・Without an oracle qubit (&lt;a href=&quot;https://quantumexperience.ng.bluemix.net/share/code/5b06c997835cd50036457e16/execution/5b06c997835cd50036457e17&quot; rel=&quot;noreferrer&quot;&gt;Link to IBM Q simulator&lt;/a&gt;)&#xA;&lt;a href=&quot;https://i.stack.imgur.com/wm8jy.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/wm8jy.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="2100" LastActivityDate="2018-05-25T14:46:03.420" Title="Grover's algorithm,: the necessity of an oracle qubit." Tags="&lt;grovers-algorithm&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2146" PostTypeId="2" ParentId="2145" CreationDate="2018-05-25T14:46:03.420" Score="5" Body="&lt;p&gt;From the perspective of defining the quantum circuit, the oracle qubit is not strictly necessary. For example, in Grover's search, you might normally define the action of the oracle as&#xA;$$&#xA;U|x\rangle|y\rangle=|x\rangle|y\oplus f(x)\rangle,&#xA;$$&#xA;where $f(x)$ returns 1 if $x$ is the marked item. However, we always use this in a particular way, inputting $(|0\rangle-|1\rangle)/\sqrt{2}$ on the oracle qubit. This has the net effect of just implementing a phase on the marked item. In other words, it is entirely equivalent to the implementation of a new unitary&#xA;$$&#xA;\tilde U|x\rangle=(-1)^{f(x)}|x\rangle&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, where it makes a difference is the practical reality. Searching for an item, we will actually need some sort of circuit that recognises the marked item, based on the input of $x$. At that point, it's far easier to think about outputting the answer onto the oracle bit, rather than somehow directly building the unitary that gives the phase without using the oracle qubit. Indeed, I suspect if I asked you to design a generic version $\tilde U$, you'd come up with $U$ with the extra qubit as the solution.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-05-25T14:46:03.420" CommentCount="3" />
  <row Id="2147" PostTypeId="1" AcceptedAnswerId="2148" CreationDate="2018-05-25T17:48:26.070" Score="9" ViewCount="88" Body="&lt;p&gt;Suppose I have a classical-classical-quantum channel $W : \mathcal{X}\times\mathcal{Y} \rightarrow \mathcal{D}(\mathcal{H})$, where $\mathcal{X},\mathcal{Y}$ are finite sets and $\mathcal{D}(\mathcal{H})$ is the set of density matrices on finite dimensional, complex Hilbert space $\mathcal{H}$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Suppose $p_x$ is the uniform distribution on $\mathcal{X}$ and $p_y$ is the uniform distribution on $\mathcal{Y}$. Further, define for distributions $p_1$ on $\mathcal{X}$ and $p_2$ on $\mathcal{Y}$, the Holveo information &#xA;$$\chi(p_1, p_2,  W) := H\left(\sum_{x,y}p_1(x)p_2(y)W(x,y)\right) - \sum_{x,y}p_1(x)p_2(y)H(W(x,y))$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;where $H$ is the von Neumann entropy. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I would like to show, for&#xA;$$ p_1 := \sup_{p}\left\{ \chi(p, p_y, W)\right\}, p_2 := \sup_{p}\left\{ \chi(p_x, p, W)\right\}$$&#xA;that,&#xA;$$\chi(p_1, p_2, W) \geq \chi(p_1, p_y, W) \text{ and } \chi(p_1, p_2, W)\geq \chi(p_x, p_2, W).$$ &lt;/p&gt;&#xA;&#xA;&lt;p&gt;So far, I'm not yet convinced that the statement is true in the first place. I haven't made much progress in proving this, but it seems like some sort of triangle inequality could verify the claim.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thanks for any suggestions regarding if the statement should hold and tips on how to prove it.&lt;/p&gt;&#xA;" OwnerUserId="509" LastActivityDate="2018-05-25T19:00:11.627" Title="Holveo Information Inequality" Tags="&lt;quantum-information&gt;" AnswerCount="1" CommentCount="1" />
  <row Id="2148" PostTypeId="2" ParentId="2147" CreationDate="2018-05-25T19:00:11.627" Score="8" Body="&lt;p&gt;It appears that the statement is not true in general. Suppose $X = Y = \{0,1\}$, $\mathcal{H}$ is the Hilbert space corresponding to a single qubit, and $W$ is defined as&#xA;\begin{align}&#xA;W(0,0) &amp;amp; = | 0 \rangle \langle 0 |,\\&#xA;W(0,1) &amp;amp; = | 1 \rangle \langle 1 |,\\&#xA;W(1,0) &amp;amp; = | 1 \rangle \langle 1 |,\\&#xA;W(1,1) &amp;amp; = \frac{1}{2} | 0 \rangle \langle 0 | + \frac{1}{2} | 1 \rangle \langle 1 |.&#xA;\end{align}&#xA;If $p_y$ is the uniform distribution, the optimal choice for $p_1$ is $p_1(0) = 1$ and $p_1(1) = 0$, which gives $\chi(p_1,p_y,W) = 1$, which is the maximum possible value. (I assume you mean to define $p_1$ and $p_2$ as the argmax of those expressions, not the supremum.) Likewise, if $p_x$ is uniform, $p_2(0) = 1$ and $p_2(1) = 0$ is optimal, and the value is the same. However, $\chi(p_1,p_2,W) = 0$, so the inequality does not hold.&lt;/p&gt;&#xA;" OwnerUserId="1764" LastActivityDate="2018-05-25T19:00:11.627" CommentCount="0" />
  <row Id="2149" PostTypeId="1" CreationDate="2018-05-25T20:59:54.013" Score="7" ViewCount="110" Body="&lt;p&gt;I am confused about what to input to Oracle in Grover's algorithm.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Don't we need to input what we are looking for and where to find what we are looking for to Oracle, in addition to the superpositioned quantum states? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, assume we have a list of people's names {&quot;Alice&quot;, &quot;Bob&quot;, &quot;Corey&quot;, &quot;Dio&quot;}, and we want to find if &quot;Dio&quot; is on the list. Then, Oracle should take $1/2(|00\rangle + |01\rangle + |10\rangle + |11\rangle)$ as an input and output $1/2(|00\rangle + |01\rangle + |10\rangle - |11\rangle)$. I kind of understand that.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But don't we also need to input the word &quot;Dio&quot; and the list {&quot;Alice&quot;, &quot;Bob&quot;, &quot;Corey&quot;, &quot;Dio&quot;} to Oracle? Otherwise, how can Oracle return output? Is it not explicitly mentioned since Oracle is a black box and we do not have to think about how to implement it?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My understanding about Oracle is,&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Oracle has the ability to recognize if the word &quot;Dio&quot; is in the list.&lt;/li&gt;&#xA;&lt;li&gt;To do so, Oracle takes the superpositioned quantum states as an input, where each quantum state represents the index of the list.&lt;/li&gt;&#xA;&lt;li&gt;So, input $|00\rangle$ to Oracle means, check if the word &quot;Dio&quot; is in the index 0 of the list and return $-|00\rangle$ if yes and return $|00\rangle$ otherwise.&lt;/li&gt;&#xA;&lt;li&gt;In our case, Oracle returns $1/2(|00\rangle + |01\rangle + |10\rangle - |11\rangle)$.&lt;/li&gt;&#xA;&lt;li&gt;But what about the list and the word?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="2100" LastActivityDate="2018-05-25T22:42:52.350" Title="Grover's algorithm: what to input to Oracle?" Tags="&lt;grovers-algorithm&gt;" AnswerCount="1" CommentCount="1" />
  <row Id="2150" PostTypeId="2" ParentId="2149" CreationDate="2018-05-25T22:42:52.350" Score="1" Body="&lt;p&gt;Although popular explanations of Grover's algorithm talk about searching over a list, in actuality you use it to search over possible inputs 0..N-1 to a function. The cost of the algorithm is $O(\sqrt{N} \cdot F)$ where $N$ is the number of inputs you want to search over and $F$ is the cost of evaluating the function. If you want that function to search over a list, you must hardcode the list into the function.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Hard coding the function to use a list of $N$ items is usually a very bad idea, because it tends to cause $F$ to equal $O(N)$. Which would make the total cost of Grover's algorithm $O(\sqrt{N} \cdot F) = O(\sqrt{N} \cdot N) = O(N^{1.5})$. Which sort of defeats the whole purpose, since $N^{1.5} &amp;gt; N$.&lt;/p&gt;&#xA;" OwnerUserId="119" LastActivityDate="2018-05-25T22:42:52.350" CommentCount="4" />
  <row Id="2151" PostTypeId="1" AcceptedAnswerId="2152" CreationDate="2018-05-26T23:24:51.823" Score="14" ViewCount="1165" Body="&lt;p&gt;In the past few days, I have been trying to collect material (mostly research papers) related to Quantum machine learning and its applications, for a summer project. Here are a few which I found interesting (from a superficial reading):&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1712.05771&quot; rel=&quot;noreferrer&quot;&gt;Unsupervised Machine Learning on a Hybrid Quantum Computer (J.S. Otterbach et al., 2017)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1307.0411&quot; rel=&quot;noreferrer&quot;&gt;Quantum algorithms for supervised and unsupervised machine learning (Lloyd, Mohseni &amp;amp; Rebentrost, 2013)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1709.08725&quot; rel=&quot;noreferrer&quot;&gt;A Machine Learning Framework to Forecast Wave Conditions (James, Zhang &amp;amp; O'Donncha 2017)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1711.11240&quot; rel=&quot;noreferrer&quot;&gt;Quantum Neuron: an elementary building block for machine learning on quantum computers (Cao, Guerreschi &amp;amp; Aspuru-Guzik, 2017)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1710.07405&quot; rel=&quot;noreferrer&quot;&gt;Quantum machine learning for quantum anomaly detection (Liu &amp;amp; Rebentrost, 2017)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;However, coming from the more &lt;em&gt;physics-y&lt;/em&gt; end of the spectrum, I don't have much &#xA;background knowledge in this area and am finding most of the specialized materials impenetrable. &lt;strong&gt;Ciliberto et al.&lt;/strong&gt;'s paper: &lt;a href=&quot;https://arxiv.org/abs/1707.08561&quot; rel=&quot;noreferrer&quot;&gt;Quantum machine learning: a classical perspective&lt;/a&gt; somewhat helped me to grasp some of the basic concepts. I'm looking for similar but &lt;strong&gt;more elaborate&lt;/strong&gt; introductory material. It would be very helpful if you could recommend textbooks, video lectures, etc. which provide a good introduction to the field of quantum machine learning. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;For instance, &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_Computation_and_Quantum_Information_(book)&quot; rel=&quot;noreferrer&quot;&gt;Nielsen and Chuang's textbook&lt;/a&gt; is a great introduction to the quantum computing and quantum algorithms in general and goes quite far in terms of introductory material (although it begins at a very basic level and covers all the necessary portions of quantum mechanics and linear algebra and even the basics of computational complexity!). Is there anything similar for quantum machine learning? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;P.S:&lt;/strong&gt; I do realize that quantum machine learning is a vast area. In case there is any confusion, I would like to point out that I'm mainly looking for textbooks/introductory papers/lectures which cover the details of the quantum analogues of classical machine learning algorithms.&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-05-26T23:35:58.810" LastActivityDate="2018-08-14T16:37:15.337" Title="Introductory material for Quantum machine learning" Tags="&lt;quantum-algorithms&gt;&lt;resource-request&gt;&lt;machine-learning&gt;" AnswerCount="2" CommentCount="1" FavoriteCount="13" />
  <row Id="2152" PostTypeId="2" ParentId="2151" CreationDate="2018-05-26T23:48:47.040" Score="10" Body="&lt;p&gt;The Nielsen and Chuang of Quantum Machine Learning is this extensive review called &quot;&lt;a href=&quot;https://www.nature.com/articles/nature23474&quot; rel=&quot;noreferrer&quot;&gt;Quantum Machine Learning&lt;/a&gt;&quot; published in Nature in 2017. The arXiv version is &lt;a href=&quot;https://arxiv.org/abs/1611.09347&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt; and has been updated as recently as 10 May 2018.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="1847" LastEditDate="2018-05-27T05:32:32.433" LastActivityDate="2018-05-27T05:32:32.433" CommentCount="5" />
  <row Id="2154" PostTypeId="1" CreationDate="2018-05-27T05:18:24.697" Score="5" ViewCount="61" Body="&lt;p&gt;Could anyone point to some references examining Bell inequality violations at large distances please?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I see many times, in pop science articles and research literature alike, that the quantum information of the entangled state is transmitted instantaneously to all components of the state. Strictly speaking, we must say that this is a theoretical prediction and provide an lower bound on the speed of information transfer from an experiment, right?&lt;/p&gt;&#xA;" OwnerUserId="1867" LastActivityDate="2018-05-28T08:25:29.327" Title="Bell Inequality violations at large distances" Tags="&lt;quantum-entanglement&gt;" AnswerCount="2" CommentCount="1" />
  <row Id="2155" PostTypeId="1" CreationDate="2018-05-27T05:41:03.770" Score="8" ViewCount="103" Body="&lt;p&gt;If I have the $X$ gate acting on a qubit and the $\lambda_6$ gate acting on a qutrit, where $\lambda_6$ is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Gell-Mann_matrices&quot; rel=&quot;nofollow noreferrer&quot;&gt;Gell-Mann matrix&lt;/a&gt;, the system is subjected to the Hamiltonian:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\lambda_6X=&#xA;\begin{pmatrix}0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0\\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0\\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1\\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0\\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0\\&#xA;0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0&#xA;\end{pmatrix}&#xA;$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In case anyone doubts this matrix, it can be generated with the following script (MATLAB/octave):&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;lambda6=[0 0 0; 0 0 1; 0 1 0];&#xA;X=      [0 1; 1 0 ];&#xA;kron(lambda6,X)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;However consider the alternative Hamiltonian:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$-\frac{1}{2}Z\lambda_1 + \frac{1}{2}\lambda_1 - \frac{1}{\sqrt{3}}X\lambda_8+\frac{1}{3}X$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;This is the exact same Hamiltonian!&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The following script proves it:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;lambda1=[0 1 0;1 0 0;0 0 0];&#xA;lambda8=[1 0 0;0 1 0;0 0 -2]/sqrt(3);&#xA;Z=      [1 0; 0 -1 ];&#xA;round(-0.5*kron(Z,lambda1)+0.5*kron(eye(2),lambda1)-(1/sqrt(3))*kron(X,lambda8)+(1/3)*kron(X,eye(3)))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;The &quot;round&quot; in the last line of code can be removed, but the format will be uglier because some of the 0's end up being around $10^{-16}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1) I thought the Pauli decomposition for two qubits is unique, why would the Pauli-GellMann decomposition of a qubit-qutrit be non-unique?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2) How would I obtain the decomposition $\lambda_6X$ from the above 6x6 matrix?&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="23" LastEditDate="2018-05-28T23:26:36.977" LastActivityDate="2018-08-09T08:51:52.183" Title="Why is the decomposition of a qubit-qutrit Hamiltonian in terms of Pauli and Gell-Mann matrices not unique?" Tags="&lt;quantum-gate&gt;&lt;gate-synthesis&gt;&lt;qudit&gt;&lt;qutrit&gt;&lt;pauli-matrices&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="2156" PostTypeId="1" CreationDate="2018-05-27T06:20:31.160" Score="5" ViewCount="33" Body="&lt;p&gt;Far from my expertise, but sheer curiosity. I've read that &lt;a href=&quot;https://en.wikipedia.org/wiki/PostBQP&quot; rel=&quot;noreferrer&quot;&gt;PostBQP&lt;/a&gt; (&quot;&lt;em&gt;a complexity class consisting of all of the computational problems solvable in polynomial time on a quantum Turing machine &lt;strong&gt;with postselection&lt;/strong&gt; and bounded error&lt;/em&gt;&quot;) is very powerful.  Still, I don't understand the practical sense of assuming you can &lt;em&gt;decide&lt;/em&gt; the value an output qubit takes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question: Have post-selection quantum computing experiments been implemented (or is it possible that they will be implemented)? &#xA;(And, if the answer is yes: how does post-selection take place in a way that practically enhances your computing power?)&lt;/p&gt;&#xA;" OwnerUserId="1847" LastActivityDate="2018-05-27T06:20:31.160" Title="Is PostBQP experimentally relevant?" Tags="&lt;experimental-results&gt;&lt;complexity-theory&gt;&lt;postbqp&gt;" AnswerCount="0" CommentCount="2" ClosedDate="2018-05-27T08:57:25.093" />
  <row Id="2157" PostTypeId="2" ParentId="2155" CreationDate="2018-05-27T09:00:13.540" Score="4" Body="&lt;p&gt;This looks essentially similar to the property of non-commutativity of the Kronecker product: $X\otimes \lambda_6\neq \lambda_6\otimes X$:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$X\otimes\lambda_6 = \begin{pmatrix}0&amp;amp;1 \\1&amp;amp;0\end{pmatrix}\otimes \begin{pmatrix}0&amp;amp;0&amp;amp;0 \\0&amp;amp;0&amp;amp;1 \\0&amp;amp;1&amp;amp;0\end{pmatrix} = &#xA;\begin{pmatrix}0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0 \\&#xA;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;1\\&#xA;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;1&amp;amp;0\\&#xA;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0\\&#xA;0&amp;amp;0&amp;amp;1&amp;amp;0&amp;amp;0&amp;amp;0\\&#xA;0&amp;amp;1&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&#xA;\end{pmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Unsurprisingly, you can't decompose $-\frac{1}{2}Z\lambda_1 + \frac{1}{2}I_2\lambda_1 - \frac{1}{\sqrt{3}}X\lambda_8+\frac{1}{3}XI_3 = \lambda_6X$ into $X\lambda_6$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, as both matrices are square, they are 'permutation similar', so that $X\otimes \lambda_6=P^T\left(\lambda_6\otimes X\right)P$ for some &lt;a href=&quot;https://en.wikipedia.org/wiki/Permutation_matrix&quot; rel=&quot;nofollow noreferrer&quot;&gt;permutation matrix&lt;/a&gt; $P$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In other words, to answer part 1, for a given permutation/ordering, the decomposition is unique, but when the ordering is changed, the matrix/Hamiltonian undergoes a rotation $\left(P^T = P^{-1}\right)$, which also changes the decomposition. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;It becomes clear what can be used to decompose a matrix of this form by splitting it into sub-matrices: by writing $$X\lambda_6 = \begin{pmatrix}A&amp;amp;B\\C&amp;amp;D\end{pmatrix},$$ where each sub-matrix $A, B, C$ and $D$ is a $3\times 3$ matrix, it becomes clear that $A=D=0$ and $B=C=\lambda_6$, which verifies $$X\lambda_6 = \begin{pmatrix}0&amp;amp;\lambda_6\\\lambda_6&amp;amp;0\end{pmatrix} = X\otimes \lambda_6$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Performing the rotation/permuting and applying the same idea gives $$M=\begin{pmatrix}0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0 \\&#xA;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0\\&#xA;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;1\\&#xA;0&amp;amp;0&amp;amp;0&amp;amp;0&amp;amp;1&amp;amp;0\\&#xA;0&amp;amp;0&amp;amp;0&amp;amp;1&amp;amp;0&amp;amp;0\\&#xA;0&amp;amp;0&amp;amp;1&amp;amp;0&amp;amp;0&amp;amp;0&#xA;\end{pmatrix} = \begin{pmatrix}A&amp;amp;B\\C&amp;amp;D\end{pmatrix},$$ which gives that $$A=0,\quad B=C=\begin{pmatrix}0&amp;amp;0&amp;amp;0\\0&amp;amp;0&amp;amp;0\\0&amp;amp;0&amp;amp;1\end{pmatrix},\quad D=\begin{pmatrix}0&amp;amp;1&amp;amp;0\\1&amp;amp;0&amp;amp;0\\0&amp;amp;0&amp;amp;0\end{pmatrix}=\lambda_1$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It follows that $B=C=\frac{1}{3}I_3-\frac{1}{\sqrt{3}}\lambda_8$, giving $$M=\begin{pmatrix}0&amp;amp;\frac{1}{3}I_3-\frac{1}{\sqrt{3}}\lambda_8\\\frac{1}{3}I_3-\frac{1}{\sqrt{3}}\lambda_8&amp;amp;\lambda_1\end{pmatrix}=\frac{1}{2}\left(I-Z\right)\otimes\lambda_1 + X\otimes\left(\frac{1}{3}I_3-\frac{1}{\sqrt{3}}\lambda_8\right).$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Changing the order of the decomposition: $$M=\begin{pmatrix}A&amp;amp;&amp;amp;B&amp;amp;&amp;amp;C\\D&amp;amp;&amp;amp;E&amp;amp;&amp;amp;F\\G&amp;amp;&amp;amp;H&amp;amp;&amp;amp;J\end{pmatrix},$$ which gives $A=B=C=D=E=G=J=0$ and $F=H=X$, in turn giving $$M=\begin{pmatrix}0&amp;amp;&amp;amp;0&amp;amp;&amp;amp;0\\0&amp;amp;&amp;amp;0&amp;amp;&amp;amp;X\\0&amp;amp;&amp;amp;X&amp;amp;&amp;amp;0\end{pmatrix}=\lambda_6\otimes X$$&lt;/p&gt;&#xA;" OwnerUserId="23" LastEditorUserId="23" LastEditDate="2018-05-28T23:16:08.140" LastActivityDate="2018-05-28T23:16:08.140" CommentCount="3" />
  <row Id="2158" PostTypeId="2" ParentId="2154" CreationDate="2018-05-27T11:11:35.373" Score="2" Body="&lt;p&gt;The largest scale Bell test done thus far is the &quot;&lt;a href=&quot;https://physics.aps.org/synopsis-for/10.1103/PhysRevLett.118.060401&quot; rel=&quot;nofollow noreferrer&quot;&gt;Cosmic Bell Test&lt;/a&gt;&quot; of 2017. It ruled out hidden variables within a distance of 600 light years from Earth.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The 16 significant Bell test experiments performed between 1972 and 2018 are listed &lt;a href=&quot;https://en.wikipedia.org/wiki/Bell_test_experiments#Notable_experiments&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt; with references to the original papers.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-05-27T11:11:35.373" CommentCount="2" />
  <row Id="2159" PostTypeId="1" AcceptedAnswerId="2160" CreationDate="2018-05-27T11:21:23.923" Score="6" ViewCount="73" Body="&lt;p&gt;The Pauli group, $P_n$, is given by&#xA;$$P_n=\{ \pm 1, \pm i\}\otimes \{ I,\sigma_x,\sigma_y,\sigma_z\}^{\otimes n}$$&#xA;Abelian subgroups of this which do not contain the element $(-1)*I$ correspond to a stabilizer group. If there are $r$ generators of one such subgroup, $\mathcal{G}$, then the $+1$ eigenstate has $2^{n-r}$ basis elements. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This then leads to the natural question of whether we have that $r\le n$ and how can it be proved (either way)? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I guess a (valid?) proof would be along the lines of that if $r \gt n$ we would have a bias of fractional dimension - this is not allowed so $r\lt n$. But if one exists I would prefer a proof considering only the group properties and not the space which it acts on.&lt;/p&gt;&#xA;" OwnerUserId="2015" LastActivityDate="2018-05-27T14:25:41.233" Title="Maximum number of Stabilizer Generators?" Tags="&lt;stabilizer-code&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2160" PostTypeId="2" ParentId="2159" CreationDate="2018-05-27T14:25:41.233" Score="3" Body="&lt;p&gt;Consider a subgroup $G $ of the Pauli group with at least one operator that acts non-trivially on some qubit.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Given any qubit $j $, for which the group contains an operator $S_j $ which acts on $j $ non-trivially, there is a Clifford group operator $C_j $ such that $C_j S_j C_j^\dagger =Z_j $, acting on qubit $j $ alone. (Why?)&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;If $G_j = \{ C_j S C_j^\dagger \,\vert\, S \in G \}$ and $G $ is abelian, then $G_j = \langle Z_j \rangle \oplus G'_j$, where $G'_j $ does not act on qubit $j $. (Why?)&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;By induction, we can transform any abelian subgroup on $n $ qubits to a group with at most $n+1$ generators, where up to $n $ of them act on a single qubit with a $Z $ operator. (And what then would the remaining one be?)&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;From this, we can prove that a stabiliser group on $n $ qubits has at most $n $ generators; and with only a little more work, we can show that a stabiliser group with $r $ generators stabilises a subspace of dimension $2^{n-r} $.&lt;/p&gt;&#xA;" OwnerUserId="124" LastActivityDate="2018-05-27T14:25:41.233" CommentCount="0" />
  <row Id="2161" PostTypeId="1" AcceptedAnswerId="2183" CreationDate="2018-05-27T14:57:49.413" Score="7" ViewCount="122" Body="&lt;p&gt;According to &lt;a href=&quot;https://arxiv.org/abs/1409.3097&quot; rel=&quot;noreferrer&quot;&gt;An introduction to quantum machine learning (Schuld, Sinayskiy &amp;amp; Petruccione, 2014)&lt;/a&gt;, Seth Lloyd et al. say in their paper: &lt;a href=&quot;https://arxiv.org/abs/1307.0411&quot; rel=&quot;noreferrer&quot;&gt;Quantum algorithms for supervised and unsupervised machine learning&lt;/a&gt; that classical information can be encoded into the norm of a quantum state $\langle x|x \rangle = |\vec{x}|^{-1}\vec{x}$. I'm not sure I understand their notation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's take a simple example. Say I want to store this array: $V = \{3,2,1,2,3,3,5,4\}$ of size $2^{3}$ in the state of an $3$-qubit quantum  system.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I can represent the state of an $3$-qubit system as: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$|\psi\rangle = a_1|000\rangle + a_2|001\rangle + a_3|010\rangle + a_4|011\rangle + a_5|100\rangle + a_6|101\rangle + a_7|110\rangle + a_8|111\rangle$ (using standard basis) where $a_i\in \Bbb C \ \forall \ 1 \leq i\leq 8$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I could represent $V$ as a vector $\vec{V} = 3 \hat{x}_1 + 2 \hat{x}_2 +... + 4 \hat{x}_8$ where $\{\hat{x}_1,\hat{x}_2,...,\hat{x}_8\}$ forms an orthonormal basis in $\Bbb R^{8}$, and write the standard Euclidean norm for it as $|\vec{V}|=\sqrt{3^2+2^2+...+4^2}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;After this, I'm confused as to how I'd get the coefficients $a_1,a_2,..,a_8$. Should I just assign $3$ to $a_1$, $2$ to $a_2$ and so on?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;But, then again&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Consider the vector $N=2^{n}$ dimensional complex vector $\vec{v}$&#xA;  with components $\{v_i=|v_i|e^{i\phi_i}\}$. Assume that&#xA;  $\{|v_i|,\phi_i\}$ are stored as floating point numbers in quantum&#xA;  random access memory. Constructing the $\log_2 N$ qubit quantum state&#xA;  $|v\rangle = |\vec{v}|^{-1/2}\vec{v}$ then takes $\mathcal{O}(\log_2&#xA; N)$ steps as long as the sub-norms are also given in the qRAM in which&#xA;  case any state can be constructed in $\mathcal{O}(\log N)$ steps.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Firstly&lt;/strong&gt;, I don't understand their notion of a $2^n$ dimensional &lt;em&gt;complex&lt;/em&gt; vector. If each of the components of their classical data array has two floating point numbers, wouldn't encoding that into a $n$-qubit quantum state be equivalent to storing a $2\times 2^{n}$ size classical array in a $n$-qubit system? Yes, I do know that $a_1,a_2,..,a_{2^n}$ are complex numbers having both magnitude and direction, and hence can store $2\times 2^{n}$ amount of classical information. But they don't mention anywhere how they will convert classical data (say in form of a $2\times 2^{n}$ array) into that form. Moreover, there seems to be a restriction that phase of a complex number $a_i$ can only range from $-\pi$ to $+\pi$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Secondly&lt;/strong&gt;, let us assume that the initial data array we wanted to store in our quantum system was actually $V=\{\{3,\phi_1\},\{2,\phi_2\},...,\{4,\phi_8\}\}$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If they define $|v\rangle$ as $|\vec{v}|^{-1/2}\vec{v}$ then $|V\rangle$ in our example would look something like $(\sqrt{3^2+2^2+...+4^2})^{-1/2}(|3e^{i\phi_1}||000\rangle + |2e^{i\phi_2}||001\rangle + ... + |4e^{i\phi_8}||111\rangle)$. But then we're losing all the information about the phases $\phi_i$, isn't it? So what was the use of starting with a &lt;em&gt;complex&lt;/em&gt; vector (having both a phase and magnitude) in the first place, when we're losing that information when converting to $|V\rangle$ anyway? Or are we writing supposed to consider $|V\rangle$ as $(\sqrt{3^2+2^2+...+4^2})^{-1/2}(3e^{i\phi_1}|000\rangle + 2e^{i\phi_2}|001\rangle + ... + 4e^{i\phi_8}|111\rangle)$?  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;It would be really helpful if someone could explain where I am going wrong using some concrete examples regarding storage of classical data in an $n$-qubit system. &lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-05-27T15:14:25.117" LastActivityDate="2018-05-29T18:02:10.733" Title="Embedding classical information into norm of a quantum state" Tags="&lt;qubit-state&gt;&lt;quantum-information&gt;&lt;machine-learning&gt;&lt;data-science&gt;" AnswerCount="1" CommentCount="2" />
  <row Id="2162" PostTypeId="5" CreationDate="2018-05-27T15:20:26.307" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-05-27T15:20:26.307" LastActivityDate="2018-05-27T15:20:26.307" CommentCount="0" />
  <row Id="2163" PostTypeId="4" CreationDate="2018-05-27T15:20:26.307" Score="0" Body="Use this tag for questions about the computational complexity class PostBQP (bounded-error quantum polynomial time with postselection). The PostBQP class encompasses computational problems which can be solved in polynomial time in a (bounded error) quantum Turing machine with the ability to condition on postselection. &quot;Bounded error&quot; implies that the algorithm is correct at least 2/3 of the time on all inputs." OwnerUserId="26" LastEditorUserId="23" LastEditDate="2018-05-27T16:26:14.907" LastActivityDate="2018-05-27T16:26:14.907" CommentCount="0" />
  <row Id="2164" PostTypeId="5" CreationDate="2018-05-27T15:25:33.230" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-05-27T15:25:33.230" LastActivityDate="2018-05-27T15:25:33.230" CommentCount="0" />
  <row Id="2165" PostTypeId="4" CreationDate="2018-05-27T15:25:33.230" Score="0" Body="Use this tag for questions related to the representation of classical data in quantum systems, and application of quantum algorithms and other quantum computing techniques aimed at improving or providing alternatives to classical data science in general. Do not use this tag for classical data science questions. Those belong to Data Science SE or Stack Overflow." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-05-27T16:29:16.967" LastActivityDate="2018-05-27T16:29:16.967" CommentCount="0" />
  <row Id="2166" PostTypeId="1" AcceptedAnswerId="2219" CreationDate="2018-05-27T15:35:53.370" Score="9" ViewCount="267" Body="&lt;p&gt;I am getting confused about Grover's algorithm and it's connection to complexity classes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Grover's algorithm finds and element $k$ in a database of $N=2^n$ (such that $f(k)=1$) of elements with $$\sim \sqrt{N}=2^{n/2}$$&#xA;calls to the oracle. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;So we have the following problem:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Problem: Find a $k$ in the database such that $f(k)=1$&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Now I am aware that this is not a desision problem and thus our normal definitions of complexity class $\text{P}$, $\text{NP}$ etc don't really apply. But I am curious to know how we would define the complexity class in such a case - and weather it is done with respect to $N$ or $n$?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Furthermore the Grover's algorithm can be used as a subroutine. I have read in several places that the Grover's algorithm does not change the complexity class a problem - is there a heuristic way to see this.&lt;/p&gt;&#xA;" OwnerUserId="2015" LastEditorUserId="1837" LastEditDate="2018-05-28T14:07:45.670" LastActivityDate="2018-06-02T06:07:11.803" Title="Grover's Algorithm and its relation to complexity classes?" Tags="&lt;complexity-theory&gt;&lt;grovers-algorithm&gt;" AnswerCount="4" CommentCount="3" FavoriteCount="1" />
  <row Id="2167" PostTypeId="2" ParentId="2166" CreationDate="2018-05-27T16:20:40.533" Score="-1" Body="&lt;p&gt;Forget about database. Grover's algorithm solves &lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_satisfiability_problem&quot; rel=&quot;nofollow noreferrer&quot;&gt;Boolean Satisfiability Problem&lt;/a&gt;, namely:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;You have a boolean circuit with $n$ inputs and a single output. The circuit outputs $1$ for a single configuration of input bits, otherwise is outputs $0$. Find the configuration of input bits.&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The problem is known to be NP-complete.&lt;/p&gt;&#xA;" OwnerUserId="2105" LastActivityDate="2018-05-27T16:20:40.533" CommentCount="3" />
  <row Id="2170" PostTypeId="2" ParentId="2154" CreationDate="2018-05-28T08:25:29.327" Score="2" Body="&lt;p&gt;I think there is a conceptual thing going on here that needs clarifying (I'll leave the experimental links to others). I presume the question is predicated on the idea that, well, measurements are made within a certain time of each other, which is compared to the distance between the places where the measurements are being made. The concern is that this only gives a bound: if information is transmitted, it happens faster than some velocity which we have now bounded.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, what one ought to do is consider what special relativity tells you: if two events are space-like separated, there is no notion of temporal ordering. Different observers, travelling at different velocities, can see the events happening in different orders (or simultaneously). So, all you need to know is that the measurement events are space-like separated (i.e. the distance between the events is larger than speed of light $\times$ time between events), and that is enough.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Also, there's a terminology issue. Bell tests do not talk about the transmission of &lt;em&gt;information&lt;/em&gt;, but the presence of &lt;em&gt;correlation&lt;/em&gt;. The term information would suggest that one party can choose some information to communicate to another party. This cannot happen faster than the speed of light. But the &quot;random decision&quot; made when a measurement is made on an entangled state is somehow resolved everywhere simultaneously, but does not communicate any information.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-05-28T08:25:29.327" CommentCount="2" />
  <row Id="2171" PostTypeId="2" ParentId="1648" CreationDate="2018-05-28T13:39:58.597" Score="3" Body="&lt;p&gt;There has been a great deal of scientific debate over evidence of quantum effects in biology due to the difficulties of reproducing scientific evidence. Some have found evidence of quantum coherence while others have argued this is not the case. &lt;a href=&quot;https://physicsworld.com/a/is-photosynthesis-quantum-ish/&quot; rel=&quot;nofollow noreferrer&quot;&gt;(Ball, 2018).&lt;/a&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The most recent research study (in Nature Chemistry, &lt;a href=&quot;https://www.nature.com/articles/s41557-018-0060-5&quot; rel=&quot;nofollow noreferrer&quot;&gt;May 2018&lt;/a&gt;) found evidence of a specific oscillating signal indicating superpositioning. The scientists found quantum effects that lasted precisely as expected based on theory and proved that these belong to energy superimposed on two molecules simultaneously. This resulted in the conclusion that biological systems exhibit the same quantum effects as non-biological systems. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;These effects have been observed in the Fenna-Matthews-Olsen reaction centre of the bacteria - Chlorobium Tepidum (Borroso-Flores, 2017).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Research evidences the dimensions and time scales of the photosynthetic energy transfer processes puts them close to the quantum/classical border. There are various explanations for this, but they seem to indicate energetically noisy quantum/classical limit is ideal for excitation energy transfer control. &lt;a href=&quot;https://www.cell.com/trends/plant-science/fulltext/S1360-1385(18)30049-9&quot; rel=&quot;nofollow noreferrer&quot;&gt;Keren 2018.&lt;/a&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Quantum Biology as Biological Semiconductors&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Such dynamics in biology rely on spin chemistry (radical pairs), and&#xA;  it is has been recognised that “Certain organic semiconductors (OLEDs)&#xA;  exhibit magnetoelectroluminescence or magnetoconductance, the&#xA;  mechanism of which shares essentially identical physics with radical&#xA;  pairs in biology”&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt; &lt;a href=&quot;https://phys.org/news/2016-06-radical-pair-analysis-hurdle-theory.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;PJ Hore (2016).&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The terms 'spin singlets' and 'triplets' are used in spintronics (in investigating semiconductors) and the term radical pairs (including spin singlets or triplets) are used to discuss spin chemistry in biology. But all the terms are describing the same phenomena (just in different disciplinary realms). Recently there has been interdisciplinary calls for the integration of spin chemistry and spintronics in recognition of this J Matysik (2017).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Biological semiconductors that have already identified by scientists include melanin and peptides, and peptides are now being explored as scaffolds for quantum computing.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;UltriaFast Electron Transfer, and Storing Electronic Spin Information in a Nuclear Spin&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;During photosynthesis, plants use electronic coherence for ultrafast&#xA;  energy and electron transfer and have selected specific vibrations to&#xA;  sustain those coherences. In this way photosynthetic energy transfer&#xA;  and charge separation have achieved their amazing efficiency. At the&#xA;  same time these same interactions are used to photoprotect the system&#xA;  against unwanted byproducts of light harvesting and charge separation&#xA;  at high light intensities&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Rienk van Grondelle.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In charge separation in photosynthetic reaction centres, triplet states can react with molecular oxygen generating destructive singlet oxygen. The triplet product yield in bacteria and plants is observed to be reduced by weak magnetic fields.  It has been suggested that this effect is due to solid-state photochemically induced dynamic nuclear polarization (photo-CIDNP), which is an efficient method of creating non-equilibrium polarization of nuclear spins by using chemical reactions, which have radical pairs as intermediates (Adriana Marais 2015).  Within biology such as mechanism could increase resistance to oxidative stress.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;It has been noted there seems to be a link between the conditions of occurrence of photo-CIDNP in reaction centres and the conditions of the unsurpassed efficient light-induced electron transfer in reaction centres. J Matysik 2009, &lt;a href=&quot;https://www.nwo.nl/en/research-and-results/research-projects/i/69/8769.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;I F Cespedes-Camacho and J Matysik 2014.&lt;/a&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;A CIDNP effect has been observed in the Fenna-Matthews-Olsen reaction centre &lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S0005272807000035&quot; rel=&quot;nofollow noreferrer&quot;&gt;(Roy et al 2006).&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A CIDNP effect has also been observed in flavin adenine dinucleotide (FAD) (&lt;a href=&quot;https://pubs.acs.org/doi/abs/10.1021/ja00200a021?journalCode=jacsat&quot; rel=&quot;nofollow noreferrer&quot;&gt;Stob 1989)&lt;/a&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;FAD is implicated in quantum effects theorised in cryptochrome and other biological redox reactions. The widely accept theory is that during response to magnetic fields, the photo-excitation of the non-covalently bound flavin adenine dinucleotide (FAD) cofactor in Cryptochrome leads to the formation of radical pairs via sequential electron transfers along the “tryptophan-triad”, a chain of three conserved tryptophan residues within the protein. This process reduces the photo-excited singlet state of the FAD to the anion radical,&#xA;In the same way that photo-CIDNP MAS NMR has provided detailed insights into photosynthetic electron transport in reaction centres, it is anticipated in a variety of applications in mechanistic studies of other photoactive proteins. It may be possible to characterize the photoinduced electron transfer process in cryptochrome Xiao-Jie (2016).&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;'until now, no CIDNP phenomenon has been observed in spintronics ,&#xA;  although the possibility of obtaining such effects has been&#xA;  mentioned “If nuclear spin resonance is found to have an impact on the&#xA;  spin-dependent electron transport due to the hyperfine interaction,&#xA;  ultimately the opposite process may become possible: storing&#xA;  electronic spin information in the nuclear spin.”&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt; &lt;a href=&quot;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5530719/&quot; rel=&quot;nofollow noreferrer&quot;&gt;J Matysik (2017).&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="2498" LastActivityDate="2018-05-28T13:39:58.597" CommentCount="1" />
  <row Id="2172" PostTypeId="1" CreationDate="2018-05-28T16:16:56.387" Score="6" ViewCount="55" Body="&lt;p&gt;The image is taken from this &lt;a href=&quot;http://www.cse.wustl.edu/~jain/cse571-07/ftp/quantum/&quot; rel=&quot;nofollow noreferrer&quot;&gt;link&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/cu3w1.gif&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/cu3w1.gif&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&#xA;Here Alice is using random bases to encode 0 or 1. After the process is completed, Bob has similarly polarized photons as Alice. These polarization can be any of the $\lvert 0 \rangle , \lvert 1 \rangle, \lvert + \rangle$ or $\lvert - \rangle$. However, how would Bob know what Alice meant for which two of these bases? Meaning, Alice might choose ${\lvert 0 \rangle, \lvert + \rangle}$ to encode a &lt;strong&gt;0&lt;/strong&gt; and ${\lvert 1 \rangle, \lvert - \rangle}$ to encode a &lt;strong&gt;1&lt;/strong&gt; or vice versa. How do they determine which polarization encodes which bits?&lt;/p&gt;&#xA;" OwnerUserId="2403" LastEditorUserId="23" LastEditDate="2018-05-28T19:40:58.443" LastActivityDate="2018-05-28T19:40:58.443" Title="BB84 Protocol Alice Choice to Bob" Tags="&lt;quantum-algorithms&gt;&lt;quantum-gate&gt;&lt;post-quantum-crypto&gt;&lt;quantum-cryptography&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2173" PostTypeId="2" ParentId="2172" CreationDate="2018-05-28T18:18:27.407" Score="4" Body="&lt;p&gt;That’s the public discussion stage: Alice and Bob can both announce which basis they chose for each round. &lt;em&gt;If&lt;/em&gt; they happened to pick the same basis on a given round, they know that (in a perfect world) their answers were the same, so they can translate them into a 0/1 value that nobody else knows. That translation is arbitrary, and they’ve probably agreed it in advance.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The natural way to do this is to associate an operator with each measurement basis, e.g. X or Z (the Pauli matrices). The measurement answers are then e.g. $(\mathbb{I}+(-1)^xX)/2$ where x is a bit value which we use as the translation.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-05-28T18:24:51.113" LastActivityDate="2018-05-28T18:24:51.113" CommentCount="2" />
  <row Id="2174" PostTypeId="1" CreationDate="2018-05-28T18:47:43.467" Score="3" ViewCount="86" Body="&lt;p&gt;I recently asked &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2166/grovers-algorithm-and-its-relation-to-complexity-classes&quot;&gt;this question&lt;/a&gt; on Grover's algorithm, and I am still fairly confused about the whole thing. Consider the following snippet from this &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1664/quantum-algorithm-sat-structure&quot;&gt;post&lt;/a&gt; (written by &lt;a href=&quot;https://quantumcomputing.stackexchange.com/users/58/didix13&quot;&gt;DIDIx13&lt;/a&gt;) which for convenience I will reproduce here:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;If you throw away the problem structure, and just consider the space of $2^n$ possible solutions, then even a quantum computer needs about $\sqrt{2^n}$ steps to find the correct one (using Grover's algorithm)&#xA;  If a quantum polynomial time algorithm for a $\text{NP}$-complete problem is ever found, it &lt;b&gt;must&lt;/b&gt; exploit the problem structure in some way. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The first line emphasis one place where I am confused: Grover's algorithm finds a solution amongst $2^n$ solutions to a problem - this is not a decisions problem alone and as mentioned in my question linked above means we cannot assign it a complexity class. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;That said Grover's algorithm can be used to solve decision problems (there seems to be a lot of talk on related questions about &quot;SAT&quot;) - but I have yet seen a &lt;strong&gt;simple&lt;/strong&gt; example of such an application. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thus my question is: Does there exist a simple example of Grover's algorithm solving a decision problem? (even better if you can provide one where the classical search is in $NP$ and another in $P$)&lt;/p&gt;&#xA;" OwnerUserId="2015" LastActivityDate="2018-06-02T06:53:58.683" Title="Example of Grover's Algorithm applied to a decision problem?" Tags="&lt;grovers-algorithm&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2175" PostTypeId="2" ParentId="2174" CreationDate="2018-05-28T19:48:33.730" Score="2" Body="&lt;p&gt;Take the problem of &lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_satisfiability_problem&quot; rel=&quot;nofollow noreferrer&quot;&gt;3-SAT&lt;/a&gt;. There is some $f(x)$ which gives outputs 0 or 1. We generally think of the case where the outputs 1 are rare, and hard to find.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;PROBLEM: Determine if there is an $x$ that satisfies $f(x)=1$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(3-SAT has a certain structure to the way the variables are evaluated based on conjunctive normal form, but that's not so important right now).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This problem is known to be NP-complete: as much as we believe NP and P are distinct, we believe this problem cannot be solved efficiently. But Grover's does help us because it gives us a square root speed-up; it searches for the items where the answer is 1.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I'm not sure if you're asking for a specific example of an $f(x)$, but one of the issues is that this complexity classification is about scaling: you need a family of functions for different sized inputs. 3-SAT is one such class. Perhaps my answer &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2185/1837&quot;&gt;here&lt;/a&gt; supplies the sorts of examples you were after?&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-06-02T06:53:58.683" LastActivityDate="2018-06-02T06:53:58.683" CommentCount="0" />
  <row Id="2176" PostTypeId="1" CreationDate="2018-05-28T20:45:15.527" Score="5" ViewCount="50" Body="&lt;p&gt;In the paper &quot;Demonstration of two-qubit algorithms with a superconducting quantum processor&quot; (L. DiCarlo et al., Nature 460, 240 (2009), &lt;a href=&quot;https://arxiv.org/pdf/0903.2030.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv&lt;/a&gt;) they demonstrate how to realize conditional phase gates with superconducting qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Specifically, they use the $|{1,1}\rangle \leftrightarrow |0, 2\rangle$ to create a conditional phase gate. I quote &quot;his  method  of  realizing  a&#xA;C-Phase gate by adiabatically using the avoided crossing between&#xA;computational and non-computational states is generally applicable&#xA;to qubit implementations with finite anharmonicity, such as trans-&#xA;mons or phase qubits&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is how this technique works, especially why it is a controlled gate. &lt;/p&gt;&#xA;" OwnerUserId="1853" LastEditorUserId="1847" LastEditDate="2018-05-29T02:33:21.577" LastActivityDate="2018-05-29T10:52:16.797" Title="Conditional Phase Gate Superconducting Qubits" Tags="&lt;quantum-gate&gt;&lt;experimental-results&gt;&lt;superconducting-quantum-computing&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2177" PostTypeId="1" CreationDate="2018-05-28T20:50:23.917" Score="10" ViewCount="701" Body="&lt;p&gt;I want to create a Toffoli gate controlled by n qubits, and implement it in QISKit. Can this be done? If so, how?&lt;/p&gt;&#xA;" OwnerUserId="2503" LastActivityDate="2018-08-07T21:09:14.453" Title="How can I implement an n-bit Toffoli gate?" Tags="&lt;quantum-gate&gt;&lt;qiskit&gt;" AnswerCount="1" CommentCount="1" FavoriteCount="2" />
  <row Id="2178" PostTypeId="2" ParentId="2177" CreationDate="2018-05-28T21:00:35.463" Score="10" Body="&lt;p&gt;A simple way to do this is illustrated in Figure 4.10 of Nielsen &amp;amp; Chuang.&#xA; &lt;a href=&quot;https://i.stack.imgur.com/lAB2Um.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/lAB2Um.png&quot; alt=&quot;n-&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Where U can be any single-qubit rotation (in this case, an X gate).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This circuit works like this:&#xA;We want to apply U to the target qubit only if the AND of all control qubits is 1. A normal Toffoli gives us the AND of 2 qubits. So by chaining a few Toffolis, we can get c1.c2.c3.c4.c5, with the catch that some &quot;work&quot; (or ancilla) qubits have been introduced to store intermediate results. After applying the final CU, we get the final result in target. Now we can clean up the intermediate work qubits by undoing their computations, returning them to the |0&gt; state.&#xA;This model of reversible computation is known as the &quot;compute-copy-uncompute&quot; method, and was first &lt;a href=&quot;http://www.cs.princeton.edu/courses/archive/fall04/cos576/papers/bennett73.html&quot; rel=&quot;noreferrer&quot;&gt;proposed by Charlie Bennett in 1973&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here is the QISKit code to construct the circuit and visualize it:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;from qiskit import QuantumRegister, QuantumCircuit&#xA;&#xA;n = 5  # must be &amp;gt;= 2&#xA;&#xA;ctrl = QuantumRegister(n, 'ctrl')&#xA;anc = QuantumRegister(n-1, 'anc')&#xA;tgt = QuantumRegister(1, 'tgt')&#xA;&#xA;circ = QuantumCircuit(ctrl, anc, tgt)&#xA;&#xA;# compute&#xA;circ.ccx(ctrl[0], ctrl[1], anc[0])&#xA;for i in range(2, n):&#xA;    circ.ccx(ctrl[i], anc[i-2], anc[i-1])&#xA;&#xA;# copy&#xA;circ.cx(anc[n-2], tgt[0])&#xA;&#xA;# uncompute&#xA;for i in range(n-1, 1, -1):&#xA;    circ.ccx(ctrl[i], anc[i-2], anc[i-1])&#xA;circ.ccx(ctrl[0], ctrl[1], anc[0])    &#xA;&#xA;from qiskit.tools.visualization import circuit_drawer&#xA;circuit_drawer(circ)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Yields:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/hiOhV.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/hiOhV.png&quot; alt=&quot;qiskit generated circuit&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="2503" LastActivityDate="2018-05-28T21:00:35.463" CommentCount="0" />
  <row Id="2181" PostTypeId="2" ParentId="2176" CreationDate="2018-05-29T10:52:16.797" Score="2" Body="&lt;p&gt;Each of the two spins, $q\in\{L,R\}$, has a bunch of energy levels $\{|n\rangle_q\}$, each at energy $\omega_{n}^q$. In other words, the basic Hamiltonian of the spins is:&#xA;$$&#xA;H=\sum_{n=0}^{N}\omega_{n}^L|n\rangle\langle n|_L+\omega_{n}^R|n\rangle\langle n|_R&#xA;$$&#xA;Written like this, the two spins are not interacting, so we won't get a two-qubit gatewithout doing something extra.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We we're talking about a qubit, we specifically focus on populating just the $|0\rangle$ and $|1\rangle$ levels of each spin. Nothing else is ever populated (hopefully). Under the Hamiltonian $H$, as basis element $|x\rangle$ for $x\in\{0,1\}^2$ acquires a phase&#xA;$$&#xA;e^{-i(\omega^L_{x_L}+\omega^R_{x_R})t}.&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In addition to this basic Hamiltonian of the spins, there is a cavity, containing photons that interact with both spins. This is what will mediate the two-qubit interaction. In effect, by manipulating the interaction parameters, we can change the energy level of the $|1\rangle_L|1\rangle_R$ state independently of the $|10\rangle$ and $|01\rangle$ states. Thus, in principle, one creates a different phase pno all 4 basis states, and these can be combined to give a controlled-phase gate.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In practice, how this works is that most of the time you want to be sat in a region of parameter space where there is no two-qubit interaction going on. At particular moments of a computation, you need to turn this interaction on. This is achieved by adiabatically varying the cavity parameters. By doing this, the populations of the qubits in the different basis states don't change, but you move to a regime where the energy levels are different, and generating the phases you need.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You'll notice I haven't mentioned the $|0,2\rangle$ level yet. In some ways this is irrelevant; everything I've said is (a sufficiently good approximation to) true. The issue is that usually, when you change the parameters, you don't get the independent control of the different energies. The place to go looking, if you want to find such independent control, is in the region of an '&lt;a href=&quot;https://en.wikipedia.org/wiki/Avoided_crossing&quot; rel=&quot;nofollow noreferrer&quot;&gt;avoided crossing&lt;/a&gt;', where the usual linear variation of energy with parameters would suggest that two energy levels should be the same (e.g. the $|11\rangle$ and $|02\rangle$ levels). The avoided crossing means that the energy takes on a quadratic form near the (not) crossing point, and it's that non-linearity that you're making use of. It also defines important constraints on the adiabatic evolution: since you do not want to populate the $|02\rangle$ level, you have to move slowly with respect to the energy gap between $|11\rangle$ and $|02\rangle$, which is comparatively small, and therefore the evolution time is quite slow.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-05-29T10:52:16.797" CommentCount="0" />
  <row Id="2182" PostTypeId="1" AcceptedAnswerId="2184" CreationDate="2018-05-29T14:59:11.487" Score="4" ViewCount="97" Body="&lt;p&gt;I know there are some &quot;quantum versions&quot; of hand-writing recognition algorithms which have been proposed using quantum neural networks. Example: &lt;a href=&quot;https://link.springer.com/article/10.1007/s100320050034&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;Recognition of handwritten numerals by Quantum Neural Network with fuzzy features&quot; (J Zhou, 1999)&lt;/a&gt;. Also, recently by Rebentrost et al.: &quot;&lt;a href=&quot;https://arxiv.org/abs/1710.03599&quot; rel=&quot;nofollow noreferrer&quot;&gt;A Quantum Hopfield Neural Network&lt;/a&gt;&quot; presents an application of their method as a genetic sequence recognizer. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;What are some other proposed applications of quantum neural networks whose given solutions &lt;strong&gt;provide considerable improvement&lt;/strong&gt; over the corresponding classical version of the neural network in terms of accuracy? Also, have any of those proposed solutions been programmed/simulated?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Please note&lt;/strong&gt; that I'm looking for research papers which specifically demonstrate some applications of quantum neural networks and which provide a significant improvement over the corresponding classical neural networks.&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-05-31T23:22:28.060" LastActivityDate="2018-05-31T23:22:28.060" Title="What are some of the interesting problems whose solutions have been proposed using quantum neural networks?" Tags="&lt;quantum-algorithms&gt;&lt;resource-request&gt;&lt;machine-learning&gt;&lt;neural-network&gt;" AnswerCount="1" CommentCount="10" FavoriteCount="1" />
  <row Id="2183" PostTypeId="2" ParentId="2161" CreationDate="2018-05-29T15:19:55.330" Score="1" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;I don't understand their notion of a $2^n$ dimensional &lt;em&gt;complex&lt;/em&gt;&#xA;  vector. If each of the components of their classical data array has&#xA;  two floating point numbers, wouldn't encoding that into a $n$-qubit&#xA;  quantum state be equivalent to storing a $2\times 2^{n}$ size&#xA;  classical array in a $n$-qubit system?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;You are absolutely correct that a $2\times 2^n$ classical array of nubers is stored in an n-qubit system. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;But they are absolutely right that the vector's dimension is $2^n$. This is because the vector has $2^n$ rows, where each entry has 2 classical numbers. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can also store the same vector in a $2\times 2^n$ array: $2^n$ rows are filled in with the real parts and $2^n$ rows by the imaginary parts, but this vector would &lt;strong&gt;&lt;em&gt;not evolve according to the Schrödinger equation&lt;/em&gt;&lt;/strong&gt;.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I hope this helps resolve this part of the question.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;But they don't mention anywhere how they will convert classical data (say in form of a $2\times 2^{n}$ array) into that form.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;You are right. &lt;strong&gt;Just as Peter Shor never mentioned anywhere how his qubits for factoring will be prepared.&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is up to the experimentalists, and it is &lt;em&gt;implementation-dependent&lt;/em&gt;. This means that for NMR qubits you'd convert the classical data into qubits differently from superconducting qubits, or ion-trap qubits, or  quantum dot qubits, etc. Therefore I do not blame Shor, or any of the 6 authors of the 2 papers you mentioned (who are all theorists by the way), for not explaining how the qubits will be prepared. &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;let us assume that the initial data array we wanted to store in our quantum system was actually $V=\{\{3,\phi_1\},\{2,\phi_2\},...,\{4,\phi_8\}\}$. If they define $|v\rangle$ as $|\vec{v}|^{-1/2}\vec{v}$ then $|V\rangle$ in our example would look something like $(\sqrt{3^2+2^2+...+4^2})^{-1/2}(|3e^{i\phi_1}||000\rangle + |2e^{i\phi_2}||001\rangle + ... + |4e^{i\phi_8}||111\rangle)$. But&#xA;  then we're losing all the information about the phases $\phi_i$, isn't&#xA;  it? So what was the use of starting with a &lt;em&gt;complex&lt;/em&gt; vector (having&#xA;  both a phase and magnitude) in the first place, when we're losing that&#xA;  information when converting to $|V\rangle$ anyway?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;You had it earlier in your question! &quot;Consider the vector $N=2^{n}$ dimensional complex vector $\vec{v}$ with components $\{v_i=|v_i|e^{i\phi_i}\}$.&quot; Therefore the vector is:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{equation}&#xA;|\vec{v}|^{-1/2}&#xA;\begin{pmatrix}|v_{1}|e^{i\phi_{1}}\\&#xA;|v_{2}|e^{i\phi_{2}}\\&#xA;\vdots\\&#xA;|v_{2^{n}}|e^{i\phi_{2^{n}}}&#xA;\end{pmatrix}&#xA;\end{equation}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Notice:&lt;br&gt;&#xA;1) There's $2^n$ entries, not $2 \times 2^n$ &lt;br&gt;&#xA;2) There is NO norm around the phases, so this is why you have lost all information about the phases, because you put extra norm symbols where they shouldn't be :) &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Or are we writing supposed to consider $|V\rangle$ as&#xA;  $(\sqrt{3^2+2^2+...+4^2})^{-1/2}(3e^{i\phi_1}|000\rangle +&#xA; 2e^{i\phi_2}|001\rangle + ... + 4e^{i\phi_8}|111\rangle)$?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Closer! The correct answer is the vector I wrote above, which can be written like this:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$|\vec{v}|^{-1/2}\left( e^{i \phi_1} |00 \cdots 00\rangle + e^{i \phi_2} |00 \cdots 01\rangle + \cdots + e^{i \phi_{N}} |1\cdots 1\rangle\right)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;For your specific example&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{equation}&#xA; \frac{3e^{i\phi_1}|000\rangle + 2e^{i\phi_8}|001\rangle + \cdots + 4e^{i\phi_8}|111\rangle}{\sqrt{77}}&#xA;\end{equation}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;The purpose of all of this is so that the sum of the squares of the coefficients is 1, which in my equation is true because the numberator is:&lt;/strong&gt;  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{equation}&#xA;\sqrt{3^2 + 2^2 + 1^2 + 2^2 + 3^2 + 3^2 + 5 ^2+ 4^2} = \sqrt{77}&#xA;\end{equation}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I hope that clears it up!&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="26" LastEditDate="2018-05-29T18:02:10.733" LastActivityDate="2018-05-29T18:02:10.733" CommentCount="6" />
  <row Id="2184" PostTypeId="2" ParentId="2182" CreationDate="2018-05-29T17:19:39.740" Score="1" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;What are some other proposed applications of quantum neural networks?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Absolutely any application of classical neural networks can be an application of quantum neural networks. There's a lot of examples beyond the two you listed. &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Also, have any of those proposed solutions been programmed/simulated?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Yes, for example Ed Farhi of MIT and Hartmut Neven of Google teamed up on a paper where an application was &lt;a href=&quot;https://arxiv.org/pdf/1802.06002.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;distinguishing digits using QNNs&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-05-29T17:19:39.740" CommentCount="3" />
  <row Id="2185" PostTypeId="2" ParentId="2166" CreationDate="2018-05-29T18:34:29.710" Score="2" Body="&lt;p&gt;All counting is done in terms of $n$, the number of bits required to describe the input.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We define the class of problems $\text{NP}$ in the following way (or, this is one way to do it):&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let $f(x)$ be a function that accepts an input $x\in\{0,1\}^n$ and returns a single bit value 0 or 1. The task is that you have to find whether a given value of $x$ returns a 1. However, there is further structure to the problem: if $f(x)=1$, you are guaranteed that there exists a proof $p_x$ (of size $m\sim\text{poly}(n)$) such that a function $g(x,p_x)=1$ only if $f(x)=1$, and the function $g(x,p_x)$ is efficiently computable (i.e. it has a running time of $\text{poly}(n)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let me give a few examples (perhaps these are what you were asking for &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/2174/1837&quot;&gt;here&lt;/a&gt;?):&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Parity: $f(x)$ answers the question 'is $x$ odd?'. This is so trivial (just take the least significant bit of $x$) that $f(x)$ is efficiently computed directly, and therefore a proof is unnecessary, $g(x,p_x)=f(x)$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Composite numbers: $f(x)$ answers the question 'is the decimal representation of $x$ a composite number?'. One possible proof in the yes direction (you only have to prove that direction) is to give a pair of factors. e.g. $x=72$, $p_x=(8,9)$. Then $g(x,p)$ simply involves multiplying together the factors and checking they are equal to $x$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Graph isomorphism: Given two graphs $G_1$ and $G_2$ (here $x$ contains the description of both graphs), $f(x)$ answers the question 'are the two graphs isomorphic?'. The proof $p_x$ is a permutation: a statement of how the vertices in $G_1$ map to those of $G_2$. The function $g(x,p_x)$ verifies that $p_x$ is a valid permutation, permutes the vertices of $G_1$ using the specified permutation, and verifies that the adjacency matrix is the same as that of $G_2$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Minesweeper_(video_game)&quot; rel=&quot;nofollow noreferrer&quot;&gt;Minesweeper&lt;/a&gt;: The old favourite game built into windows (and others) can be expressed like this. Imagine a minesweeper board that is partially uncovered, so some cells are unknown, and some cells have been uncovered to reveal how many mines are in the neighbouring cells. This is all built into the variable $x$. $f(x)$ asks the question 'is there a valid assignment of mines on the uncovered region?'. The proof, $p_x$ is simply one such assignment of mines. This is easily verified using $g(x,p_x)$ which simply ensures consistency with every known constraint.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;All of these problems are in $\text{NP}$ because they fit the definition of an efficiently verifiable solution. Some of them are known to be in $\text{P}$ as well: we've already stated that odd testing is in $\text{P}$. Composite numbers also is, because it is efficient to check if a number is prime using &lt;a href=&quot;https://en.wikipedia.org/wiki/AKS_primality_test&quot; rel=&quot;nofollow noreferrer&quot;&gt;AKS primality testing&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Graph isomorphism and minesweeper are not known to be in $\text{P}$. Indeed, minesweeper &lt;a href=&quot;http://web.mat.bham.ac.uk/R.W.Kaye/minesw/ordmsw.htm&quot; rel=&quot;nofollow noreferrer&quot;&gt;is known&lt;/a&gt; to be $\text{NP}$-complete, i.e. if it can be solved efficiently, every problem in $\text{NP}$ is in $\text{P}$. Many people suspect that $\text{P}\neq\text{NP}$, and hence Minesweeper would have instances which take longer than polynomial time to solve.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One possible way to solve an $\text{NP}$ problem is, for a fixed $x$, simply to test all possible proofs $p_x$ up to a maximum length $m=\text{poly}(n)$, and see if there's a satisfying solution, i.e. to search for a solution $g(x,p_x)=1$. Obviously, that takes time $O(2^m\text{poly}(m))$, as there are exponentially many items to search, each requiring a polynomial time to compute. This can be improved by implementing Grover's search: we just search for a solution $g(x,p_x)=1$ (i.e. the valid $p_x$ becomes the marked item), and this takes a time $O(2^{m/2}\text{poly}(m))$. This is massively faster, but does not change the assessment of whether the running time is polynomial or something worse; it has not become a polynomial time algorithm. For example, graph isomorphism would have to search over all possible permutations. Minesweeper would have to search over all possible assignments of mines on uncovered squares.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Of course, some of the time, additional structure in the problem permits different solutions that do not require the searching of all possible proofs. There, Grover's search is of less, or even no, use to us, but it might be that we can come up with a polynomial time algorithm in another way. For example, the case of composite testing: classically, finding the factors of a number appears to be hard: we can't do much better than testing all possible factors, so making use of that form of proof doesn't help much, but, as already mentioned, the question can be resolved efficiently via another route, AKS primality testing.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-05-30T08:14:21.767" LastActivityDate="2018-05-30T08:14:21.767" CommentCount="3" />
  <row Id="2186" PostTypeId="2" ParentId="2155" CreationDate="2018-05-29T19:12:14.460" Score="4" Body="&lt;p&gt;You get two decompositions for your matrix (let's call it $A$) because you are using two different operatorial bases.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the first case you are considering the matrix as acting in a space of dimension $3\times 2$, that is, using the operatorial basis $\{\lambda_i\sigma_j\}_{ij}\equiv\{\lambda_i\otimes\sigma_j\}_{ij}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In other words, you are computing the coefficients $c_{ij}=\operatorname{tr}((\lambda_i\otimes \sigma_j) A)$,&#xA;finding $c_{61}$ to be the only not vanishing term.&#xA;This decomposition will be unique, because&#xA;$\operatorname{tr}\big[ (\lambda_i\sigma_j)(\lambda_k\sigma_l) \big]=N_{ij} \delta_{ik}\delta_{jl}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;On the other hand, the second decomposition is obtained thinking of $A$ as a matrix in a space of dimensions $2\times 3$, that is, by decomposing it using the operatorial basis $\{\sigma_i\lambda_j\}_{ij}\equiv\{\sigma_i\otimes\lambda_j\}_{ij}$.&#xA;This gives you new coefficients&#xA;$d_{ij}\equiv\operatorname{tr}((\sigma_i \otimes\lambda_j) A)$, which do not have to be (and indeed are not) the same as the $c_{ij}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There is no paradox because $\{\sigma_i\otimes\lambda_j\}_{ij}$ and $\{\lambda_i\otimes\sigma_j\}_{ij}$ are two entirely different operatorial bases for a space of dimension $6$.&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-08-09T08:51:52.183" LastActivityDate="2018-08-09T08:51:52.183" CommentCount="1" />
  <row Id="2187" PostTypeId="2" ParentId="2166" CreationDate="2018-05-29T22:08:29.140" Score="2" Body="&lt;p&gt;Complexity classes are generally defined with regard to the size of the input. The relevant sizes here are $n$ (the number of qubits on which you let Grover's algorithm operate) and a number you haven't mentioned yet, call it $m$, of bits needed to describe the subroutine generally referred to as the oracle. Typically, the oracle will be efficiently implemented in a way that scales polynomially in $n$, which is the case, for example, if you encode a typical boolean satisfiability problem in the oracle.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In any case, you do not get a gain in complexity class using Grover's algorithm: It takes exponentially many quantum operations, typically $m*2^{n/2}$, to solve a problem we could brute-force in exponentially many steps, typically $m*2^{n-1}$, on a classical computer anyways. This means that problems known (e.g. EXPTIME) or suspected (e.g. NP) to take exponential runtime will still require exponential runtime.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, physicists like to appeal to the notion that this is still an exponential speed-up with no known (or indeed readily conceivable) classical equivalent. This is most apparent in the database example where the oracle function is a database lookup and Grover's algorithm can cause one to need many fewer lookups than there are data in the database. In this sense, there is still a significant advantage, although it is completely lost in the complexity class picture.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-05-29T22:08:29.140" CommentCount="2" />
  <row Id="2188" PostTypeId="1" AcceptedAnswerId="2189" CreationDate="2018-05-30T10:03:51.980" Score="5" ViewCount="48" Body="&lt;p&gt;I was working on the Grover's algorithm and the most common example is for a unitary distribution in a quantum database, for example:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$|\psi\rangle = \frac{1}{2}|00\rangle + \frac{1}{2}|01\rangle + \frac{1}{2}|10\rangle + \frac{1}{2}|11\rangle.$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is there a way to obtain arbitrary distribution (the above one is achieved by applying $H^{\otimes n}$ gates), e.g.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$|\psi\rangle = \frac{1}{3}|00\rangle + \frac{1}{4}|01\rangle + \sqrt{\frac{83}{144}}|10\rangle + \frac{1}{2}|11\rangle$&#xA;? Does the structure of Grover's algorithm differ in such a case?&lt;/p&gt;&#xA;" OwnerUserId="2098" LastActivityDate="2018-05-30T10:52:10.287" Title="How to obtain arbitrary distribution in quantum database" Tags="&lt;grovers-algorithm&gt;&lt;superposition&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2189" PostTypeId="2" ParentId="2188" CreationDate="2018-05-30T10:52:10.287" Score="4" Body="&lt;p&gt;According to this &lt;a href=&quot;https://arxiv.org/pdf/quant-ph/9807027.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;paper&lt;/a&gt;, &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;A significant conclusion from this solution is that generically the generalized algorithm also has $O(\sqrt{N/r})$ running time&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Where 'r' is the number of marked states. By &lt;strong&gt;generalized&lt;/strong&gt;, the authors meant a distribution with arbitrary complex amplitudes. So it seems to answer your question. That the modified initialization would still perform in the same way as the original one. &lt;/p&gt;&#xA;" OwnerUserId="2403" LastActivityDate="2018-05-30T10:52:10.287" CommentCount="0" />
  <row Id="2190" PostTypeId="1" AcceptedAnswerId="2191" CreationDate="2018-05-30T14:58:46.317" Score="7" ViewCount="427" Body="&lt;p&gt;I trying to do some tests in the IBM Q5 computer of IBM quantm experience for some simple error correction protocols, but as I can see, some operations between the qubits are not allowed.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, it is not possible to perform a CNOT operation with the fourth qubit or when selecting one for as the target qubit for the operation, it does not allow to use any of the other qubits as control qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I have been thinking about the fact that maybe it is because of the physical implementation of such computer, but as I do not know much about the construction of quantum computers I do not know if that might be the cause. So I am wondering if that is actually the issue, or otherwise why those operations are not allowed.&lt;/p&gt;&#xA;" OwnerUserId="2371" LastEditorUserId="409" LastEditDate="2018-05-30T16:44:56.977" LastActivityDate="2018-05-30T16:55:59.673" Title="Allowed CNOT gates for IBM Q 5 quantum computer" Tags="&lt;quantum-computer&gt;&lt;quantum-error-correction&gt;&lt;stabilizer-code&gt;&lt;ibm-q-experience&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="2191" PostTypeId="2" ParentId="2190" CreationDate="2018-05-30T15:12:22.757" Score="6" Body="&lt;p&gt;Yes, the physical implementation is the constraint. If you look at the image of the processor you'll notice the connections between qubits. This gives you an idea of how you can perform two qubit gates between particular qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here's the documentation on the Tenerife backend. In the section titled Two Qubit gates at the bottom you can read the details. Also the directions of the gates are also detailed in a log file there.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://github.com/QISKit/qiskit-backend-information/tree/master/backends/tenerife/V1&quot; rel=&quot;noreferrer&quot;&gt;https://github.com/QISKit/qiskit-backend-information/tree/master/backends/tenerife/V1&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/YCzgN.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/YCzgN.png&quot; alt=&quot;Image taken from Tenerife documention&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="54" LastEditorUserId="54" LastEditDate="2018-05-30T15:17:50.727" LastActivityDate="2018-05-30T15:17:50.727" CommentCount="0" />
  <row Id="2192" PostTypeId="1" AcceptedAnswerId="2193" CreationDate="2018-05-30T15:29:35.763" Score="6" ViewCount="60" Body="&lt;p&gt;I am thinking about the following question:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Assuming that we have some given state $\rho$ and we perform a&#xA;  measurement with $k$ outcomes on this state. Then we can describe the&#xA;  measurement in outcomes as eigenvalues of the measurable, i.e., the&#xA;  Hermitian operator that I denote by $D$, with probabilities&#xA;  $\mathrm{Tr}[D_i\rho]$, where $D_i$ are the projectors in the $i^{th}$&#xA;  eigenspace of $D$, i.e. for the eigendecomposition $D = \sum_i&#xA; \lambda_i s_i s_i^T = \sum_i \lambda_i D_i$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I was wondering if my assumption is true. If the number of (distinguishable?) outcomes for any Hermitian operator is given by $k$ i.e. then we have only $k$ non-zero eigenvalues and hence $D$ must be of rank $\leq k$?&lt;/p&gt;&#xA;" OwnerUserId="2054" LastEditorUserId="2054" LastEditDate="2018-05-31T16:55:07.497" LastActivityDate="2018-05-31T16:55:07.497" Title="Rank of a measurement" Tags="&lt;measurement&gt;" AnswerCount="1" CommentCount="2" />
  <row Id="2193" PostTypeId="2" ParentId="2192" CreationDate="2018-05-30T15:46:40.723" Score="3" Body="&lt;p&gt;You are implicitly making a specific assumption here: that the $\{D_i\}$ are rank 1 projectors.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;If&lt;/em&gt; your $\{D_i\}$ are rank-1 projectors, i.e. taking the form $D_i=s_is_i^T$, then because there is a completeness relation for measurement operators,&#xA;$$&#xA;\sum_iD_i=\mathbb{I},&#xA;$$&#xA;then you must have a number of outcomes equal to the dimension of the Hilbert space you're measuring. Call that $k$. Now, if you define $D=\sum_i\lambda_iD_i$ where the $\lambda_i$ are distinct, then $D$ must have rank either $k$ or $k-1$: if one of the $\lambda_i$ is 0, then the number of non-zero values (which is equivalent to the rank) is $k-1$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, strictly, the $D_i$ could be projectors, but not have rank 1 (in fact, they don't even have to be projectors, but we won't go there...), but instead a rank $r_i=\text{Tr}(D_i)$. In this case, either $D$ is full rank (which we'll still call $k$) or, if a particular $\lambda_j=0$, then it has rank $k-r_j$, because that's the number of non-zero eigenvalues $D$ has. Here, the number of distinguishable outcomes is potentially much smaller than the rank of $D$. All you really know is that $\text{rk}(D)\geq |\{D_i\}|-1$ (i.e. the number of measurement operators minus 1, in case one of the eigenvalues is 0). But that could be a very loose bound in some circumstances (and the bound is the opposite way round to what you were asking).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Overall, the answer is that the number of distinguishable measurement outcomes is &lt;em&gt;not&lt;/em&gt; equal to the rank of the measurement operator.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-05-30T15:46:40.723" CommentCount="0" />
  <row Id="2194" PostTypeId="2" ParentId="2190" CreationDate="2018-05-30T16:55:59.673" Score="5" Body="&lt;p&gt;The five qubit IBM devices have a ‘bow tie’ architecture, which mean that it is only possible to interact certain pairs of qubits. These are shown in the &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2191/409&quot;&gt;answer of Andrew O&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The interaction that can be performed between these pairs of qubits is a CNOT with a particular direction. However, it is possible to implement others indirectly.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, to perform a CNOT with q0 as control and q1 as target, use&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;h q[0];&#xA;h q[1];&#xA;cx q[1], q[0];&#xA;h q[1];&#xA;h q[0];&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;The above can be added in the QASM editor. Or you could do the same with the GUI: it is a CNOT with Hadamads before and after on both qubits. The Hadamards effectively reverse the CNOT direction.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-05-30T16:55:59.673" CommentCount="3" />
  <row Id="2195" PostTypeId="1" CreationDate="2018-05-31T02:58:10.137" Score="7" ViewCount="202" Body="&lt;p&gt;I have followed the installation steps, regarding QISKit working environment. For circuit visualization, I've installed latex as in addition to poppler to convert from PDF to images. Afterwards, I followed the example given &lt;a href=&quot;https://nbviewer.jupyter.org/github/QISKit/qiskit-tutorial/blob/master/reference/tools/getting_started.ipynb&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I wrote the code and after running, the program run but I didn't get the circuit visualization. I don't know what is the problem, even I have not received any error messages. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;So any ideas?&lt;/p&gt;&#xA;" OwnerUserId="2519" LastEditorUserId="26" LastEditDate="2018-05-31T05:05:18.457" LastActivityDate="2018-06-24T20:43:17.197" Title="Visualization of Quantum Circuits when using IBM QISKit" Tags="&lt;qiskit&gt;" AnswerCount="1" CommentCount="4" FavoriteCount="0" />
  <row Id="2196" PostTypeId="1" AcceptedAnswerId="2197" CreationDate="2018-05-31T14:36:20.190" Score="4" ViewCount="76" Body="&lt;p&gt;I am currently going through Nielsen's QC bible and having still some foundational / conceptual problems with the matter.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/CYOCq.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/CYOCq.png&quot; alt=&quot;Nielsen Quantum Computing&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I have tried to retrieve this $8 {\times} 8$ matrix describing the QFT of 3 qubits via Kronecker product in various attempts. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Hadamard transform can be decomposed into $H \otimes 1 \otimes 1$, and the others are fundamentally kronecker products of the 4x4 matrices of S resp. T with the 2x2 identity. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Whats wrong with my approach?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;EDIT: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$T\text{=}\left(&#xA;\begin{array}{cccccccc}&#xA; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; e^{\frac{\pi  i}{4}} &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; e^{\frac{\pi  i}{4}} \\&#xA;\end{array}&#xA;\right)$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;which is derived from $R_k = \left(&#xA;\begin{array}{cc}&#xA; 1 &amp;amp; 0 \\&#xA; 0 &amp;amp; e^{2 i \pi /2^k} \\&#xA;\end{array}&#xA;\right)$, being $S$ for $k=1$ and $T$ for $k=2$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;EDIT 2:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The controlled T-operation can be represented in computational basis as&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\left(&#xA;\begin{array}{cccc}&#xA; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; e^{2 \pi i / 2^k } \\&#xA;\end{array}&#xA;\right)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;EDIT 3: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In mathematica, one faulty calculation of mine is:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\text{SWAP}\text{=}\left(&#xA;\begin{array}{cccccccc}&#xA; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\&#xA; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\&#xA;\end{array}&#xA;\right)$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;SWAP*KroneckerProduct[IdentityMatrix[2], IdentityMatrix[2], H]&lt;em&gt;KroneckerProduct[IdentityMatrix[2], S]&lt;/em&gt;&#xA;  KroneckerProduct[ IdentityMatrix[2], H, IdentityMatrix[2]] * T &lt;em&gt;KroneckerProduct[S, IdentityMatrix[2]]&lt;/em&gt;&#xA;  KroneckerProduct[H, IdentityMatrix[2], &#xA;   IdentityMatrix[2]] // MatrixForm&lt;/p&gt;&#xA;&#xA;&lt;p&gt;which gives:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\left(&#xA;\begin{array}{cccccccc}&#xA; \frac{1}{2 \sqrt{2}} &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; -\frac{1}{2 \sqrt{2}} &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; \frac{e^{\frac{i \pi }{2}}}{2 \sqrt{2}} &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; -\frac{e^{\frac{i \pi }{2}} i^2}{2 \sqrt{2}} \\&#xA;\end{array}&#xA;\right)$&lt;/p&gt;&#xA;" OwnerUserId="2522" LastEditorUserId="2522" LastEditDate="2018-05-31T15:22:28.863" LastActivityDate="2018-05-31T15:39:09.520" Title="Example of Quantum Fourier Computation for three qubits" Tags="&lt;quantum-fourier-transform&gt;" AnswerCount="1" CommentCount="7" FavoriteCount="1" />
  <row Id="2197" PostTypeId="2" ParentId="2196" CreationDate="2018-05-31T15:39:09.520" Score="2" Body="&lt;p&gt;The tensor products for the individual gates are all being calculated correctly, and the matrices are being multiplied in the correct order. In this case, it turns out that it is a Mathematica programming error, using the * operator for element-by-element multiplication of matrices rather than matrix multiplication. The first clue was that the overall output was not even unitary, even though the individual gates seemed to be correct.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-05-31T15:39:09.520" CommentCount="0" />
  <row Id="2198" PostTypeId="1" AcceptedAnswerId="2204" CreationDate="2018-05-31T16:18:59.457" Score="9" ViewCount="104" Body="&lt;p&gt;I'm relatively new to quantum computing and my goal is to learn how to implement algorithms that I read in papers. While I have found many circuit snippets I have yet to find a repository of examples on GitHub or other places where I would go to find machine learning code.  Does an analogous quantum computing repository exist?&lt;/p&gt;&#xA;" OwnerUserId="418" LastActivityDate="2018-06-11T07:59:00.120" Title="Where can I find example circuits to learn from?" Tags="&lt;quantum-computing-models&gt;&lt;machine-learning&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="1" />
  <row Id="2199" PostTypeId="2" ParentId="2128" CreationDate="2018-05-31T16:33:40.633" Score="2" Body="&lt;p&gt;First let me mention a minor point concerning terminology. The type of channel you are suggesting is often called a &lt;em&gt;Pauli channel&lt;/em&gt;; the term &lt;em&gt;depolarizing channel&lt;/em&gt; usually refers to the case where $p_x = p_y = p_z$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Anyway, it is not really correct to say that Pauli channels are the channel model considered for quantum error correction. Standard quantum error correcting codes can protect against &lt;em&gt;arbitrary&lt;/em&gt; errors (represented by any quantum channel you might choose) so long as the errors do not affect too many qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As an example, let us consider an arbitrary single-qubit error, represented by a channel $\Phi$ mapping one qubit to one qubit. Such a channel can be expressed in Kraus form as&#xA;$$&#xA;\Phi(\rho) = A_1 \rho A_1^{\dagger} + \cdots + A_m \rho A_m^{\dagger}&#xA;$$&#xA;for some choice of Kraus operators $A_1,\ldots,A_m$. (For a qubit channel we can always take $m = 4$ if we want.) You could, for instance, choose these operators so that $\Phi(\rho) = |0\rangle \langle 0|$ for every qubit state $\rho$, you could make the error unitary, or whatever else you choose. The choice can even be adversarial, selected after you know how the code works.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Each of the Kraus operators $A_k$ can be expressed as a linear combination of Pauli operators, because the Pauli operators form a basis for the space of 2 by 2 complex matrices:&#xA;$$&#xA;A_k = a_k I + b_k X + c_k Y + d_k Z.&#xA;$$&#xA;If you now expand out the Kraus representation of $\Phi$ above, you will obtain a messy expression where $\Phi(\rho)$ looks like a linear combination of operators of the form $P_i \rho P_j$ where $i,j\in\{1,2,3,4\}$ and $P_1 = I$, $P_2 = X$, $P_3 = Y$, and $P_4 = Z$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now imagine that you have a quantum error correcting code that protects against an $X$, $Y$, or $Z$ error on one qubit. The usual way this works is that some extra qubits in the 0 state are tacked on to the encoded data and a unitary operation is performed that reversibly computes into these extra qubits a syndrome describing which error occurred, if any, and which qubit was affected. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Supposing that the arbitrary error $\Phi$ happened on the first qubit for simplicity, after the syndrome computation you will end up with a state that looks like a linear combination of terms like this:&#xA;$$&#xA;P_i |\psi\rangle \langle \psi| P_j \otimes |P_i\: \text{syndrome}\rangle\langle P_j\:\text{syndrome}|.&#xA;$$&#xA;The assumption here is that $|\psi\rangle$ represents the encoded data without any noise, $P_i$ and $P_j$ act on the first qubit, and that &quot;$P_i$ syndrome&quot; and &quot;$P_j$ syndrome&quot; refer to the standard basis states that indicate that these errors have occurred on the first qubit. (The situation is similar for the error affecting any other qubit; I'm just trying to keep the notation simple by assuming the error happened to the first qubit.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now the key is that you &lt;em&gt;measure&lt;/em&gt; the syndrome to see what error occurred, and all of the cross terms disappear because of the measurement. You are left with a probabilistic mixture of states that look like&#xA;$$&#xA;P_i |\psi\rangle \langle \psi| P_i \otimes |P_i\: \text{syndrome}\rangle\langle P_i\:\text{syndrome}|.&#xA;$$&#xA;The error is corrected and the original state is recovered. In effect, by measuring the syndrome, you &quot;project&quot; or &quot;collapse&quot; the error to something that looks like a Pauli channel.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is all described (somewhat briefly) in Section 10.2 of Nielsen and Chuang.&lt;/p&gt;&#xA;" OwnerUserId="1764" LastActivityDate="2018-05-31T16:33:40.633" CommentCount="4" />
  <row Id="2200" PostTypeId="1" CreationDate="2018-05-31T22:35:40.077" Score="6" ViewCount="218" Body="&lt;p&gt;I am trying to get used to IBM Q by implementing three qubits Grover's algorithm but having difficulty to implement the oracle.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Could you show how to do that or suggest some good resources to get used to IBM Q circuit programming?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What I want to do is to mark one arbitrary state by flipping its sign as the oracle supposed to do.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, I have&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$1/\sqrt8(|000\rangle+|001\rangle+|010\rangle+|011\rangle+|100\rangle+|101\rangle+|110\rangle+|111\rangle)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;and I want to mark $|111\rangle$ by flipping its sign to $-|111\rangle$. I somehow understand that CCZ gate would solve the problem but we do not have CCZ gate in IBM Q. The combination of some gates will act the same as CCZ but I am not sure how to do that yet. And I am also struggling for the other cases not only for $|111\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Two qubits case is simple enough for me to implement, but three qubits care is still confusing to me.&lt;/p&gt;&#xA;" OwnerUserId="2100" LastEditorUserId="55" LastEditDate="2018-06-03T16:27:33.193" LastActivityDate="2018-06-03T16:27:33.193" Title="Implementation of the oracle of Grover's algorithm on IBM Q using three qubits" Tags="&lt;quantum-gate&gt;&lt;grovers-algorithm&gt;&lt;gate-synthesis&gt;&lt;ibm-q-experience&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="0" />
  <row Id="2201" PostTypeId="1" AcceptedAnswerId="2202" CreationDate="2018-05-31T23:23:13.067" Score="7" ViewCount="75" Body="&lt;p&gt;In the paper &lt;a href=&quot;https://link.springer.com/article/10.1007%2Fs11128-017-1692-x&quot; rel=&quot;noreferrer&quot;&gt;A quantum-implementable neural network model (Chen, Wang &amp;amp; Charbon, 2017)&lt;/a&gt;, on page 18 they mention that &quot;There are 784 qurons in the input layer, where each quron is comprised of ten qubits.&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;That seems like a misprint to me. After reading the first few pages I was under the impression that they were trying to use $10$ qubits to replicate the $784$ classical neurons in the input layer. Since $2^{10}=1024&amp;gt;784$, such that each sub-state's coefficient's square is proportional to the activity of a neuron. Say the square of the coefficient of $|0000000010\rangle$ could be proportional to the activation of the $2$-nd classical neuron (considering all the $784$ neurons were labelled fom $0$ to $783$).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But if what they wrote is true: &quot;There are 784 qurons in the input layer&quot; it would mean there are $7840$ qubits in the input layer, then I'm not sure how they managed to implement their model experimentally. As of now we can properly simulate only ~$50$ qubits. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, they managed to give an error rate for $&amp;gt;7840$ qubits (see Page 21: &quot;Proposed two-layer QPNN, ten hidden qurons, five select qurons - 2.38&quot;). No idea how's they managed to get that value. Could someone please explain?&lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-06-01T01:32:50.143" Title="How did the authors manage to simulate and get the error estimate for a neural network with greater than 7840 qubits?" Tags="&lt;qubit&gt;&lt;neural-network&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2202" PostTypeId="2" ParentId="2201" CreationDate="2018-06-01T01:32:50.143" Score="2" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;As of now we can properly simulate only ~50 qubits.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;You are talking about a full quantum simulation of a vector containing $2^{50}$ elements.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In quantum neural networks and quantum annealing, we usually only need something close to the ground state (optimal value) rather than the absolute global minimum. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here is another example &lt;a href=&quot;https://journals.aps.org/pra/pdf/10.1103/PhysRevA.94.022337&quot; rel=&quot;nofollow noreferrer&quot;&gt;from 2017&lt;/a&gt; where 1000 qubits are simulated:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/rIYrQm.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/rIYrQm.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here's an example &lt;a href=&quot;https://arxiv.org/pdf/1512.02206.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;from 2015&lt;/a&gt; where 1000 qubits are simulated (it says bits rather than qubits, but they are the qubits of the D-Wave device):&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/Bm1wEm.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/Bm1wEm.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-06-01T01:32:50.143" CommentCount="3" />
  <row Id="2203" PostTypeId="1" AcceptedAnswerId="2206" CreationDate="2018-06-01T08:01:24.223" Score="5" ViewCount="41" Body="&lt;p&gt;Recently I found out the &lt;em&gt;Applications of Quantum Computing Professional Certificate Program&lt;/em&gt; that MITxPRO is offering for people interested in quantum computing. I saw that it is consisted of four courses that can be done independently or as a whole program. &lt;a href=&quot;https://mitxpro.mit.edu/courses/course-v1:MITxPRO+QCx4+2T2018/about&quot; rel=&quot;noreferrer&quot;&gt;This&lt;/a&gt; is the link for the course.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am especially interested in just the last one of such four courses, but I do not know if it would be necessary to take the other ones so that I could do such course.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;That's why I was wondering if someone here has started this course, and so if there is someone, if he could give an insight about which is the level required for taking such courses, the time required in order to complete the homework and his opinion about the course in general. Also it would be interesting to hear if you think that taking all courses should be necessary (although I am aware of the fact that just one of the courses has been given, so this would be a subjective opininon).&lt;/p&gt;&#xA;" OwnerUserId="2371" LastEditorUserId="26" LastEditDate="2018-06-01T11:42:07.490" LastActivityDate="2018-06-01T19:31:59.217" Title="Reference on MITxPRO Applications of Quantum Computing Professional Certificate Program" Tags="&lt;quantum-computer&gt;&lt;quantum-error-correction&gt;&lt;fault-tolerance&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2204" PostTypeId="2" ParentId="2198" CreationDate="2018-06-01T14:10:42.663" Score="9" Body="&lt;p&gt;I know this is not what you are asking but this paper: &lt;a href=&quot;https://arxiv.org/abs/1804.03719&quot; rel=&quot;noreferrer&quot;&gt;&#xA;Quantum Algorithm Implementations for Beginners&lt;/a&gt; explains the implementation of some machine learning algorithms. Hope this helps!&lt;/p&gt;&#xA;" OwnerUserId="2100" LastActivityDate="2018-06-01T14:10:42.663" CommentCount="1" />
  <row Id="2205" PostTypeId="2" ParentId="2200" CreationDate="2018-06-01T15:27:23.923" Score="3" Body="&lt;p&gt;I am answering my question. After some google search, I found &lt;a href=&quot;https://www.researchgate.net/figure/282611947_Fig-1-a-Schematic-circuit-of-a-half-adder-where-a-and-b-represent-inputs-and-sum-and&quot; rel=&quot;nofollow noreferrer&quot;&gt;this image&lt;/a&gt; showing CCZ gate by CNOT, T dagger, and T gate. I tried this on IBM Q and it worked. I want to explore why it works but that's another story.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For someone who is interested, here is my quantum circuit of Grover's algorithm finding |111&gt; with one iteration.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/eF896.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/eF896.png&quot; alt=&quot;Grover&amp;#39;s algorithm finding |111&amp;gt; with one iteration&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="2100" LastActivityDate="2018-06-01T15:27:23.923" CommentCount="2" />
  <row Id="2206" PostTypeId="2" ParentId="2203" CreationDate="2018-06-01T15:39:24.450" Score="4" Body="&lt;p&gt;I signed up for this series because I was interested in the 2nd and 3rd courses.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are a lot of students from different backgrounds so I think that limits the depth of what the instructors can cover. The introductory course was too easy in terms of content, however useful in the form of industry perspectives and getting to know 'who is doing what' in hardware. My fear is that the remaining courses will be a bit too simple/general.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The bulk of the time is spent watching videos. I set the speed to 1.25x or else it's just a bit too slow for me. You could complete the entire course in a weekend.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Taking all the courses is absolutely not necessary but you do get a nice certificate at the end.&lt;/p&gt;&#xA;" OwnerUserId="54" LastEditorUserId="54" LastEditDate="2018-06-01T19:31:59.217" LastActivityDate="2018-06-01T19:31:59.217" CommentCount="0" />
  <row Id="2207" PostTypeId="1" AcceptedAnswerId="2208" CreationDate="2018-06-01T17:06:43.663" Score="4" ViewCount="30" Body="&lt;p&gt;I am going through Nielsen and Chuang and am finding the chapter on error-correction particularly confusing. At the moment I am stuck on exercise 10.12 which states&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Show that the fidelity between the state $|0 \rangle$ and $\varepsilon(|0\rangle\langle0|)$ is $\sqrt{1-2p\backslash3}$, and use this to argue that the minimum fidelity for the depolarizing channel is $\sqrt{1-2p\backslash3}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As I understand $\varepsilon$ is a quantum operation and could be whatever we want as long as it fits the definition, do I assume $\varepsilon$ is the depolarizing channel or is there some general operation I don't know about.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thanks!&lt;/p&gt;&#xA;" OwnerUserId="2528" LastActivityDate="2018-06-01T17:45:44.700" Title="How to find the fidelity between two state when one is an operator?" Tags="&lt;quantum-error-correction&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2208" PostTypeId="2" ParentId="2207" CreationDate="2018-06-01T17:45:44.700" Score="2" Body="&lt;p&gt;The channel $\mathcal{E}$ is explicitly defined in the preceding paragraph as being the depolarising channel. Thus, all you need to calculate is&#xA;$$&#xA;F=\sqrt{\langle 0|\mathcal{E}(|0\rangle\langle 0|)|0\rangle}.&#xA;$$&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-01T17:45:44.700" CommentCount="0" />
  <row Id="2209" PostTypeId="1" AcceptedAnswerId="2214" CreationDate="2018-06-01T20:25:26.947" Score="6" ViewCount="127" Body="&lt;p&gt;I am interested in a quantum algorithm that has the following characteristics:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;output = 2n bits OR 2 sets of n bits (e.g. 2 x 3 bits)&lt;/li&gt;&#xA;&lt;li&gt;the number of 1-bits in the first set of n-bits must be equal to the number of 1-bits in the second set. E.g. correct output =  &lt;code&gt;0,0,0, 0,0,0&lt;/code&gt; (both 3-bit sets have zero 1-bits); &lt;code&gt;1,0,0, 0,1,0&lt;/code&gt; (both 3-bit sets have one 1-bit); &lt;code&gt;1,1,0, 0,1,1&lt;/code&gt; (both 3-bit sets have two 1-bit)&lt;/li&gt;&#xA;&lt;li&gt;Each time the quantum algorithm runs it must randomly return one of the possible solutions.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Any idea how I can best implement such an algorithm on a quantum computer ?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;FYI I have tried the following algorithm (where n = 2 ) but it missed the 2 answers 0110 and 1001:&#xA;&lt;a href=&quot;https://i.stack.imgur.com/bR70C.jpg&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/bR70C.jpg&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="2529" LastActivityDate="2018-06-04T09:15:44.350" Title="How to create a quantum algorithm that produces 2 n-bit sequences with equal number of 1-bits?" Tags="&lt;quantum-algorithms&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="0" />
  <row Id="2210" PostTypeId="1" AcceptedAnswerId="2221" CreationDate="2018-06-01T20:40:29.040" Score="3" ViewCount="104" Body="&lt;p&gt;I work on a &lt;a href=&quot;https://www.edx.org/course/quantum-information-science-ii-part-1&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Information Science II: Quantum states, noise and error correction&lt;/a&gt; MOOC by Prof. Aram Harrow, and I do not understand which property of tensor products is used in one of the transitions in the videos.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's consider an isometry $V: A \to B \otimes E$ ($E$ is a subspace to be thrown away at the end).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's fix and orthonormal basis $\{ |e\rangle \}$ in $E$ and partially expand the isometry $V$ as $V = \sum_e V_e \otimes |e\rangle$, where each $V_e$ is a linear operator from $A$ to $B$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Stinespring form of a quantum operation is a partial trace applied after an isometry: $N(\rho) = \mathrm{tr}_E [V \rho V^\dagger]$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, if we expand that with our representation of $V$, we get&#xA;$$&#xA;N(\rho) = \mathrm{tr}_E \left[&#xA;\sum_{e_1} \sum_{e_2}&#xA;\left( V_{e_1} \otimes |e_1\rangle \right)&#xA;\rho &#xA;\left( V_{e_2}^\dagger \otimes \langle e_2| \right)&#xA;\right].&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is how to get from here to the next step&#xA;$$&#xA;N(\rho) = \mathrm{tr}_E \left[&#xA;\sum_{e_1} \sum_{e_2}&#xA;(V_{e_1} \rho V_{e_2}^\dagger) \otimes |e_1 \rangle \langle e_2|&#xA;\right]?&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(BTW, eventually, we end up with the Kraus operator decomposition of a channel: $N(\rho) = \sum_e V_e \rho V_e^\dagger$.)&lt;/p&gt;&#xA;" OwnerUserId="528" LastEditorUserId="528" LastEditDate="2018-06-08T19:33:04.397" LastActivityDate="2018-06-10T21:14:38.180" Title="Tensor product properties used to obtain Kraus operator decomposition of a channel" Tags="&lt;tensor-product&gt;" AnswerCount="1" CommentCount="1" />
  <row Id="2211" PostTypeId="1" AcceptedAnswerId="2213" CreationDate="2018-06-01T20:54:15.730" Score="8" ViewCount="156" Body="&lt;p&gt;I am confused about how to understand the $Z$ gate in a Bloch sphere.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Considering the matrix $Z = \begin{pmatrix} &#xA;1 &amp;amp; 0 \\&#xA;0 &amp;amp; -1 &#xA;\end{pmatrix}$ it is understandable that $Z|0\rangle = |0\rangle$ and $Z|1\rangle = -|1\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is explained &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/tutorial?sectionId=beginners-guide&amp;amp;page=005-Single-Qubit_Gates~2F006-Summary_of_quantum_gates&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt; that $Z$ gate is $\pi$ rotation around the $Z$ axis. Then, how should I understand $Z|1\rangle = -|1\rangle$? Since $|1\rangle$ is the south pole, I feel it is natural to think that $\pi$ rotation around the $Z$ axis does not do anything.&lt;/p&gt;&#xA;" OwnerUserId="2100" LastEditorUserId="26" LastEditDate="2018-06-02T17:56:31.650" LastActivityDate="2018-06-03T06:03:45.017" Title="How to think about the Z gate in a Bloch sphere?" Tags="&lt;quantum-gate&gt;&lt;bloch-sphere&gt;" AnswerCount="3" CommentCount="0" FavoriteCount="1" />
  <row Id="2212" PostTypeId="1" CreationDate="2018-06-01T21:53:42.130" Score="3" ViewCount="101" Body="&lt;h1&gt;Puzzle&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;I have the following puzzle for which I would like to create a quantum algorithm.&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;There are 2 players that need to complete 3 tasks as fast as possible.&lt;/li&gt;&#xA;&lt;li&gt;There are 3 different types of tasks ( &lt;code&gt;A, B, C&lt;/code&gt; )&lt;/li&gt;&#xA;&lt;li&gt;There are 3 different types of tools (&lt;code&gt;a, b, c&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;li&gt;Each player will only get 2 tools (they might get the same tool twice)&lt;/li&gt;&#xA;&lt;li&gt;Tool a will make that the player can finish task &lt;code&gt;A&lt;/code&gt; 10 minutes faster than without tool &lt;code&gt;a&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;Tool &lt;code&gt;b&lt;/code&gt; will make that the player can finish task &lt;code&gt;B&lt;/code&gt; 10 minutes faster than without tool &lt;code&gt;b&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;Tool &lt;code&gt;c&lt;/code&gt; will make that the player can finish task &lt;code&gt;C&lt;/code&gt; 10 minutes faster than without tool &lt;code&gt;c&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;The output of the quantum algorithm must be  (a) a random combination of the 3 tasks (the same task might appear multiple times) and (b) a random assignment of 2 tools to each of the 2 players but it should also remain a fair competition (in other words one player will not gain more time in total thanks to the set of tools he got).&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;So a possible outcome of the quantum algorithm: &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Tasks &lt;code&gt;A, A, C&lt;/code&gt;  (note that same task can appear multiple times) and &lt;/li&gt;&#xA;&lt;li&gt;Player one gets tools &lt;code&gt;a,b&lt;/code&gt; &lt;/li&gt;&#xA;&lt;li&gt;Player two gets tools &lt;code&gt;a,a&lt;/code&gt; (although he gets 2 &lt;code&gt;a&lt;/code&gt; tools - he can only use one tool at a time - so the 2nd &lt;code&gt;a&lt;/code&gt; tool would not give any benefits)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;So, in this case, both players will equally benefit  (= 20 minutes) thanks to tool &lt;code&gt;a&lt;/code&gt; and the 2 tasks &lt;code&gt;A, A&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So how would you implement such a problem in a &lt;strong&gt;quantum algorithm&lt;/strong&gt;?&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h1&gt;Generalized Puzzle&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Of course this puzzle can be further generalized as:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;each player has to complete &lt;code&gt;n&lt;/code&gt; tasks (and not 3)&lt;/li&gt;&#xA;&lt;li&gt;instead of 3 different types of tasks (&lt;code&gt;A, B, C&lt;/code&gt;) and 3 corresponding different types of tools (&lt;code&gt;a, b, c&lt;/code&gt;), there are &lt;code&gt;t&lt;/code&gt; different types of tasks with corresponding tools giving them a 10 minute performance benefit.&lt;/li&gt;&#xA;&lt;li&gt;each player gets &lt;code&gt;k&lt;/code&gt; tools instead of 2.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;I don't need an answer on this generalized puzzle !  I am more than happy to get an answer on the simple puzzle.&lt;/p&gt;&#xA;" OwnerUserId="2529" LastEditorUserId="2529" LastEditDate="2018-06-04T07:31:38.573" LastActivityDate="2018-06-04T07:31:38.573" Title="Algorithm to allocate tasks and tools fairly to 2 players" Tags="&lt;quantum-algorithms&gt;" AnswerCount="0" CommentCount="10" FavoriteCount="5" />
  <row Id="2213" PostTypeId="2" ParentId="2211" CreationDate="2018-06-01T22:31:25.070" Score="5" Body="&lt;p&gt;The way to think about the Bloch sphere is in terms of the density matrix for the state. $Z$ acting on either $|0\rangle\langle 0|$ or $|1\rangle\langle 1|$ does nothing, as is true for any diagonal density matrix. To see the effect of the rotation, you need to look at how any non-diagonal density matrix is changed by $Z$, such as $|+\rangle\langle +|$.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-01T22:31:25.070" CommentCount="0" />
  <row Id="2214" PostTypeId="2" ParentId="2209" CreationDate="2018-06-01T22:49:32.400" Score="1" Body="&lt;p&gt;There are probably better ways than this, but here’s one you could try:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Start as you have done, with Hadamards on every qubit of the first register, then controlled nots between matching pairs of qubits across the two registers. This creates a uniform superposition of terms $|x\rangle|x\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now you need to somehow perform a random permutation on the second register. Introduce $\binom{n}2$ ancillary qubits. Apply Hadamard on each, and use each qubit to control the application of a swap between a different pair of qubits on the second register. Then forget about the ancillary qubits, and just measure the first two registers. (I’m guessing this gives you a sufficiently random permutation.)&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-06-02T09:52:03.173" LastActivityDate="2018-06-02T09:52:03.173" CommentCount="4" />
  <row Id="2215" PostTypeId="2" ParentId="2211" CreationDate="2018-06-01T22:52:10.667" Score="1" Body="&lt;p&gt;As per &lt;a href=&quot;https://en.wikipedia.org/wiki/Bloch_sphere#Definition&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wikipedia&lt;/a&gt;, we can write any pure state as $$|\psi\rangle = \cos\left( \frac{\theta}{2} \right) |0 \rangle + e^{i \phi}  \sin\left( \frac{\theta}{2} \right) |1 \rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Where $\theta$ and $\phi$ are the angles on the Bloch sphere:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://upload.wikimedia.org/wikipedia/commons/6/6b/Bloch_sphere.svg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/6/6b/Bloch_sphere.svg/237px-Bloch_sphere.svg.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Almost any point on the surface (i.e. pure state) has a unique representation in terms of the angles, except for the poles. Just like on the Earth the South Pole has no well-defined longitude (any longitude works the same), for the $|1 \rangle$ state any phase $\phi$ means the same thing. The “latitude” $\theta$ is here $\pi$, let's plug that into the equation:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$|1\rangle = \cos\left( \frac{\pi}{2} \right) |0 \rangle + e^{i \phi}  \sin\left( \frac{\pi}{2} \right) |1 \rangle = $$&#xA;$$ = 0 + e^{i \phi} |1 \rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you are familiar with Euler's identity, you will probably recognise $e^{i \phi}$ as a rotation in the complex plane. In particular, since $Z$ is a rotation for $\phi = \pi$, we get the famous $e^{i \pi} = -1$, finally arriving at $|1 \rangle = - |1 \rangle$.&lt;/p&gt;&#xA;" OwnerUserId="580" LastActivityDate="2018-06-01T22:52:10.667" CommentCount="3" />
  <row Id="2217" PostTypeId="2" ParentId="2211" CreationDate="2018-06-02T01:03:18.030" Score="4" Body="&lt;p&gt;$|1\rangle$ and $-|1\rangle$ are assigned to the same point on the Bloch sphere because they are equal &lt;em&gt;up to global phase&lt;/em&gt;. Algebraically: $|1\rangle \equiv -|1\rangle$ where $\equiv$ means &quot;equal up to global phase&quot;. Meaning there is some $\theta$ such that $-|1\rangle = e^{i \theta} |1\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The thing that is confusing you is that, despite the fact that $|0\rangle \equiv Z |0\rangle$ and $|1\rangle \equiv Z |1\rangle$, this is not true for linear combinations of the two. For example, $Z |+\rangle \not\equiv Z |+\rangle$ even though $|+\rangle = \frac{1}{\sqrt{2}}|0\rangle + \frac{1}{\sqrt{2}}|1\rangle$.&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-06-03T06:03:45.017" LastActivityDate="2018-06-03T06:03:45.017" CommentCount="0" />
  <row Id="2219" PostTypeId="2" ParentId="2166" CreationDate="2018-06-02T06:07:11.803" Score="3" Body="&lt;h2&gt;Summary&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;There is a theory of complexity of search problems (also known as relation problems). This theory includes classes called &lt;a href=&quot;https://en.wikipedia.org/wiki/FP_(complexity)&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;strong&gt;FP&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/FNP_(complexity)&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;strong&gt;FNP&lt;/strong&gt;&lt;/a&gt;, and &lt;a href=&quot;https://complexityzoo.uwaterloo.ca/Complexity_Zoo:F#fbqp&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;strong&gt;FBQP&lt;/strong&gt;&lt;/a&gt; which are effectively about solving search problems with different sorts of resources.&lt;/li&gt;&#xA;&lt;li&gt;From search problems, you can also define decision problems, which allows you to relate search problems to the usual classes &lt;strong&gt;P&lt;/strong&gt;, &lt;strong&gt;NP&lt;/strong&gt;, and &lt;strong&gt;BQP&lt;/strong&gt;.&lt;/li&gt;&#xA;&lt;li&gt;Whether you consider the search version of the decision version of the problem, the way that you consider the input to the Unstructured Search problem will determine what upper bounds you can put on its complexity.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;The complexity of relation problems&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;As you note, Grover's problem solves a &lt;em&gt;search&lt;/em&gt; problem, which in the complexity literature is sometimes also known as a &lt;em&gt;relation&lt;/em&gt; problem. That is, it is a problem of the following sort:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;em&gt;The structure of a general search problem.&lt;/em&gt;&lt;br&gt; Given an input $x$ and a binary relation $R$, find a $y$ such that $R(x,y)$ holds.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The complexity classes &lt;a href=&quot;https://en.wikipedia.org/wiki/FP_(complexity)&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;strong&gt;FP&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/FNP_(complexity)&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;strong&gt;FNP&lt;/strong&gt;&lt;/a&gt; are defined in terms of such problems, where in particular one is interested in the case where $y$ has length at most a polynomial function of the length of $x$, and where the relation $R(x,y)$ can itself be computed in an amount of time bounded by some polynomial in the length of $(x,y)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In particular: the example of the 'database search' problem for which Grover's Search is usually applied can be described as follows.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;Unstructured Search.&lt;/strong&gt; &lt;br&gt;&#xA;  Given an input oracle $\mathcal O: \mathcal H_2^{\otimes m+1} \!\to \mathcal H_2^{\otimes m+1}$ such that $\mathcal O \lvert a \rangle \lvert b \rangle = \lvert a \rangle \lvert b \oplus f(a) \rangle$ for some function $f: \{0,1\}^m \to \{0,1\}$, find a $y$ such that $\mathcal O&#xA; \lvert y \rangle \lvert 0 \rangle = \lvert y \rangle \lvert 1&#xA; \rangle$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Here, the oracle itself is the input to the problem: it plays the role of $x$, and the relation which we are computing is&#xA;$$ R(\mathcal O,y) \;\;\equiv\;\; \Bigl[\mathcal O&#xA; \lvert y \rangle \lvert 0 \rangle = \lvert y \rangle \lvert 1&#xA; \rangle\Bigr] \;\;\equiv\;\; \Bigl[ f(y) = 1 \Bigr].$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Suppose that, instead of an oracle, we are provided with a specific input $x$ which describes how the function $f$ is to be computed, we can then consider which complexity class this problem belongs to. &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2187/124&quot;&gt;As &lt;code&gt;pyramids&lt;/code&gt; indicates&lt;/a&gt;, the appropriate complexity class we obtain depends on how the input is provided.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Suppose that the input function is provided as an database (as the problem is sometimes described), where each entry to the database has some length $\ell$. If $n$ is the length of the string $x$ used to describe &lt;em&gt;the entire database&lt;/em&gt;, then the database has $N = n\big/\ell$ entries. It is then possible to exhaustively search the entire database by querying each of the $N$ entries in sequence, and stop if we find an entry $y$ such that $f(y) = 1$. Supposing that each query to the database takes something like $O(\log N) \subseteq O(\log n)$ time, this procedure halts in time $O(N \log N) \subseteq O(n \log n)$, so that the problem is in &lt;strong&gt;FP&lt;/strong&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Assuming that the database-lookup can be done in coherent superposition, Grover's algorithm allows this problem is in &lt;a href=&quot;https://complexityzoo.uwaterloo.ca/Complexity_Zoo:F#fbqp&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;strong&gt;FBQP&lt;/strong&gt;&lt;/a&gt;. However, as &lt;strong&gt;FP&lt;/strong&gt;&amp;nbsp;&amp;subseteq;&amp;nbsp;&lt;strong&gt;FBQP&lt;/strong&gt;, the classical exhaustive search also proves that this problem is in &lt;strong&gt;FBQP&lt;/strong&gt;. All that we obtain (up to log factors) is a quadratic speed-up due to a savings in the number of database queries.&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Suppose that the input function is described succinctly, by a polynomial-time algorithm that takes a specification $x \in \{0,1\}^n$ and an argument $y \in \{0,1\}^m$ and computes $\mathcal O : \mathcal H_2^{m+1} \!\to \mathcal H_2^{m+1}\!$ on a standard basis state $\lvert y \rangle\lvert b \rangle$, where $m$ may be much larger than $\Omega(\log n)$. An example would be where $x$ specifies the CNF form of some boolean function $f: \{0,1\}^m \to \{0,1\}$ for $m \in O(n)$, in which case we may efficiently evaluate $f(y)$ on an input $y \in \{0,1\}^m$ and thereby efficiently evaluate $\mathcal O$ on standard basis states. This puts the problem in &lt;strong&gt;FNP&lt;/strong&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Given a procedure to evaluate $f(y)$ from $(x,y)$ in time $O(p(n))$ for $n = \lvert x \rvert$, Grover's algorithm solves the problem of Unstructured Search for $\mathcal O$ in time $O(p(n) \sqrt{2^m})$ $\subseteq O(p(n) \sqrt{2^n})$. This is not polynomial in $n$, and so does not suffice to put this problem in &lt;strong&gt;FBQP&lt;/strong&gt;: we only obtain a quadratic speedup &amp;mdash; though this is still a potentially huge savings of computation time, assuming that the advantage provided by Grover's algorithm is not lost to the overhead required for fault-tolerant quantum computation.&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;In both cases, the complexity is determined in terms of the length $n$ of the string $x$ *which specifies how to compute the oracle $\mathcal O$. In the case that $x$ represents a look-up table, we have $N = n\big/\ell$, in which case the performance as a function of $N$ is similar to the performance as a function of $n$; but in the case that $x$ succinctly specifies $\mathcal O$, and $N \in O(2^{n/2})$, the big-picture message that Grover's solves the problem in $O(\sqrt N)$ queries obscures the finer-grained message that this algorithm is still exponential-time for a quantum computer.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Decision complexity from relation problems&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;There is a straightforward way to get decision problems from relation problems, which is well-known from the theory of &lt;a href=&quot;https://en.wikipedia.org/wiki/NP-completeness&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;strong&gt;NP&lt;/strong&gt;-complete&lt;/a&gt; problems: to turn the search problem to a question of the existence of a valid solution.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;em&gt;The decision version of a general search problem.&lt;/em&gt;&lt;br&gt; Given an input $x$ and an binary relation $R$, determine whether $\exists y: R(x,y)$ holds.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The complexity class &lt;a href=&quot;https://en.wikipedia.org/wiki/NP_(complexity)&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;strong&gt;NP&lt;/strong&gt;&lt;/a&gt; can essentially be defined in terms of such problems, when the relationship $R$ is efficiently computable: the most famous &lt;strong&gt;NP&lt;/strong&gt;-complete problems (CNF-SAT, HAMCYCLE, 3-COLOURING) are about the mere existence of a valid solution to an efficiently verifiable relationship problem. This switch from producing solutions to simply asserting the existence of solutions is also what allows us to describe versions of integer factorisation which are in &lt;strong&gt;BQP&lt;/strong&gt; (by asking whether &lt;em&gt;there exist&lt;/em&gt; non-trivial factors, rather than asking &lt;em&gt;for the values&lt;/em&gt; of non-trivial factors).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the case of Unstructured Search, again which complexity class best describes the problem depends on how the input is structured. Determining &lt;em&gt;whether there exists&lt;/em&gt; a solution to a relationship problem may be reduced to &lt;em&gt;finding and verifying&lt;/em&gt; a solution to that problem. Thus in the case that the input is a string $x$ specifying the oracle as a look-up table, the problem of unstructured search is in &lt;strong&gt;P&lt;/strong&gt;; and more generally if $x$ specifies an efficient means of evaluating the oracle, the problem is in &lt;strong&gt;NP&lt;/strong&gt;. It is also possible that there is a way of determining &lt;em&gt;whether there exists&lt;/em&gt; a solution to Unstructured Search which does so without actually finding a solution, though it is not clear in general how to do so in a way which would provide an advantage over actually finding a solution.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Oracle complexity&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;I have conspicuously been shifting from talking about the oracle $\mathcal O$, to ways that an input $x$ can be used to specify (and evaluate) the oracle $\mathcal O$. But of course, the main way in which we consider Grover's algorithm is as an oracle result in which evaluating the oracle takes a single time-step and requires no speficiation. How do we consider the complexity of the problem in this case?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In this case, we are dealing with a &lt;em&gt;relativised&lt;/em&gt; model of computation, in which evaluating this one specific oracle $\mathcal O$ (which, remember, is the input to the problem) is a primitive operation. This oracle is defined on all input sizes: to consider the problem for searching on strings of length $n$, you must specify that you are considering how the oracle $\mathcal O$ acts on inputs of length $n$, which again would be done by considering the length of a boolean string $x$ taken as input. In this case, the way in which we would present the problem might be as follows.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;Unstructured Search relative to Oracle $\mathcal O$.&lt;/strong&gt; &lt;br&gt; Given an input $x = 11\cdots 1$ of length $n$, &lt;/p&gt;&#xA;  &#xA;  &lt;ul&gt;&#xA;  &lt;li&gt;&lt;p&gt;find a $y \in \{0,1\}^n$ (relation problem) or&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;determine whether there exists a $y \in \{0,1\}^n$ (decision problem)&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;/ul&gt;&#xA;  &#xA;  &lt;p&gt;such that $\mathcal O \lvert y \rangle \lvert 0 \rangle = \lvert y \rangle \lvert 1 \rangle$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;This problem is in $\mathsf{NP}^{\mathcal O}$ (for the decision problem) or $\mathsf{FNP}^{\mathcal O}$ (for the relation problem), depending on which version of the problem you wish to consider. Because Grover's algorithm is not a polynomial-time algorithm, this problem is not known to be in $\mathsf{BQP}^{\mathcal O}$ or $\mathsf{FBQP}^{\mathcal O}$. In fact, we can say something stronger, as we will soon see.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The reason why I brushed over the actual, oracle-based description of Unstructured Search was in order to touch on your point of complexity, and in particular to touch on the question of &lt;em&gt;input size&lt;/em&gt;. The complexity of problems are largely governed by how the inputs are specified: as a succinct specification (in the case of how a function is specified in CNF-SAT), as an explicit specification (in the case of a look-up table for a function), or even as an integer specified in unary, i.e. as the length of a string of 1s as above (as in &quot;Unstructured Search relative to Oracle $\mathcal O$&quot; above).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As we can see from the latter case, if we treat the input only as an oracle, the situation looks a bit un-intuitive, and it certainly makes it impossible to talk about the ways that the &quot;database&quot; can be realised. But one virtue of considering the relativised version of the problem, with an actual oracle, is that we can prove things which otherwise we have no idea how to prove. If we could prove that the decision version of the succinct unstructured search problem was in &lt;strong&gt;BQP&lt;/strong&gt;, then we would stand to realise an enormous breakthrough in practical computation; and if we could prove that the decision problem was not actually in &lt;strong&gt;BQP&lt;/strong&gt;, then we would have shown that &lt;strong&gt;P &amp;ne; PSPACE&lt;/strong&gt;, which would be an enormous breakthrough in computational complexity. We don't know how to do either. But for the relativised problem, we can show that there are oracles $\mathcal O$ for which the decision version of &quot;Unstructured Search relative to $\mathcal O$&quot; is in $\mathsf{NP}^{\mathcal O}$ but not in $\mathsf{BQP}^{\mathcal O}$. This allows us to show that while quantum computing is potentially powerful, there are reasons to expect that &lt;strong&gt;BQP&lt;/strong&gt; probably doesn't contain &lt;strong&gt;NP&lt;/strong&gt;, and that the relation version of Unstructured Search in particular is unlikely to be contained in &lt;strong&gt;FBQP&lt;/strong&gt; without imposing strong constraints on how the input is represented.&lt;/p&gt;&#xA;" OwnerUserId="124" LastActivityDate="2018-06-02T06:07:11.803" CommentCount="0" />
  <row Id="2221" PostTypeId="2" ParentId="2210" CreationDate="2018-06-02T17:36:45.990" Score="2" Body="&lt;p&gt;As pointed out in a comment, what you wrote as $\rho$ should more precisely be written as $\rho\otimes\mathbb 1$ (although the Kraus operator decomposition can be obtained similarly with any initial ancilla state, in which case you have $\rho\otimes|\phi\rangle\!\langle\phi|$).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The standard &lt;a href=&quot;https://en.wikipedia.org/wiki/Tensor_product#Tensor_product_of_linear_maps&quot; rel=&quot;nofollow noreferrer&quot;&gt;algebraic properties of tensor product spaces&lt;/a&gt; then tell you that&#xA;$$(A\otimes B)(C\otimes D)=(AC)\otimes(BD),$$&#xA;from which you immediately get your result.&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="528" LastEditDate="2018-06-10T21:14:38.180" LastActivityDate="2018-06-10T21:14:38.180" CommentCount="2" />
  <row Id="2222" PostTypeId="1" CreationDate="2018-06-03T12:42:06.163" Score="12" ViewCount="180" Body="&lt;p&gt;I am interested in a quantum algorithm that gets as input an n-bit sequence and that produces as output a reshuffled (permuted) version of this n-bit sequence.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;E.g. if the input is 0,0,1,1 (so n=4 in this case) then the possible answers are:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;0,0,1,1&lt;/li&gt;&#xA;&lt;li&gt;0,1,0,1&lt;/li&gt;&#xA;&lt;li&gt;0,1,1,0&lt;/li&gt;&#xA;&lt;li&gt;1,0,0,1&lt;/li&gt;&#xA;&lt;li&gt;1,0,1,0&lt;/li&gt;&#xA;&lt;li&gt;1,1,0,0&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Note that only one output should be generated which is randomly chosen among all possible valid outputs. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;How can this best be implemented in a &lt;strong&gt;quantum algorithm&lt;/strong&gt; ?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A solution for this is already proposed as part of one of the answers for &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2209/how-to-create-a-quantum-algorithm-that-produces-2-n-bit-sequences-with-equal-num&quot;&gt;How to create a quantum algorithm that produces 2 n-bit sequences with equal number of 1-bits?&lt;/a&gt;.  But the problem with this solution is that this requires about $\binom{n}2$ help qubits which becomes rapidly huge if n is big.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Please, do not provide a classical algorithm without any explanation of how the steps of the classical algorithm can be mapped to a universal quantum computer.&lt;/li&gt;&#xA;&lt;li&gt;for me there are 2 good ways to interpret &lt;em&gt;&quot;randomly chosen among all possible good outputs&quot;&lt;/em&gt;:  (1) each possible good output has equal chance of being chosen. (2) every possible good output has a chance &gt; 0 of being chosen.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="2529" LastEditorUserId="2529" LastEditDate="2018-06-05T11:20:08.193" LastActivityDate="2018-06-06T21:28:39.913" Title="How to permute (reshuffle) an n-bit input?" Tags="&lt;quantum-algorithms&gt;" AnswerCount="3" CommentCount="9" FavoriteCount="2" />
  <row Id="2223" PostTypeId="1" AcceptedAnswerId="2224" CreationDate="2018-06-03T14:47:45.380" Score="7" ViewCount="73" Body="&lt;p&gt;During the classical pre-processing stage of Simon's algorithm, we repeat the quantum operations $n-1$ times to get&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;\begin{alignat}{7}&#xA;y_{1} \cdot s &amp;amp; \phantom{\vdots} =~ &amp;amp;&amp;amp; 0 \\ y_{2} \cdot s &amp;amp; \phantom{\vdots}=~ &amp;amp;&amp;amp; 0 \\ &amp;amp; \phantom{=} \vdots \\ y_{n-1} \cdot s &amp;amp; \phantom{\vdots}=~ &amp;amp;&amp;amp; 0 ~,&#xA;\end{alignat}&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;where $s$ is the period while $y_{i}$ are the linearly independent measurement outcomes of the quantum process. But, shouldn't we be requiring $n$ equations to get the value of $s$ as it is an unknown with $n$ variables? I wonder if this is because a system of $n$ equations will admit only the trivial solution of all $0$s. Is there a mathematical reasoning to elucidate this? How exactly would we uniquely solve for $n$ variables with $n-1$ equations?&lt;/p&gt;&#xA;" OwnerUserId="1351" LastEditorUserId="15" LastEditDate="2018-06-04T00:04:00.997" LastActivityDate="2018-06-04T00:04:00.997" Title="Simon's algorithm: Number of equations" Tags="&lt;quantum-algorithms&gt;&lt;simons-algorithm&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2224" PostTypeId="2" ParentId="2223" CreationDate="2018-06-03T18:18:36.747" Score="4" Body="&lt;p&gt;Imagine for a moment that $y_1,\ldots,y_{n-1}$ are linearly independent vectors in $\mathbb{R}^n$. There would then be a one-dimension subspace of vectors $s$ satisfying the $n-1$ equations you listed.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The situation is the same here, except that the field of real numbers is replaced by the finite field $\mathbb{F}_2$ with elements 0 and 1. The same linear algebra as in the real number case works in this case, and we again obtain a one-dimensional subspace of possible solutions $s$. This time, however, because there are only two elements of $\mathbb{F}_2$, this one-dimensional subspace includes only two elements: the all-zero vector and some nonzero vector $s$. Naturally we disregard the all-zero vector and take the nonzero vector $s$ as our solution.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note also that if you did add another equation, $y_n\cdot s = 0$ for some $y_n$, then $y_n$ would have to be a linear combination of $y_1,\ldots,y_{n-1}$, for otherwise the only solution would be $s = (0,\ldots,0)$. So, you would not obtain any additional information about $s$ by adding an additional equation.&lt;/p&gt;&#xA;" OwnerUserId="1764" LastActivityDate="2018-06-03T18:18:36.747" CommentCount="0" />
  <row Id="2225" PostTypeId="1" CreationDate="2018-06-04T01:53:47.593" Score="6" ViewCount="171" Body="&lt;p&gt;This is probably just a misunderstanding on my part, but everything I've seen on what quantum computers do thus far seems to suggest that the actual process of reading the entangled qubits would be equivalent to reading the value of a plate opposing a subdivided plate in a plate capacitor while the setting of initial qubits would be the equivalent of assigning a voltage to each subdivided plate.  E.g. in this image:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/HparW.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/HparW.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You would be able to read the voltage on the red plate after setting independent voltages from a known range representing 0 at the low and 1 at the high on the 4 separate subdivisions of the opposing plate, then rounding off at some particular voltage to get a zero or one out of it for those 4 bits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is this wrong?  If so, how does it differ from actual quantum computing?&lt;/p&gt;&#xA;" OwnerUserId="2538" LastActivityDate="2018-07-08T01:31:24.907" Title="What's the difference between a set of qubits and a capacitor with a subdivided plate?" Tags="&lt;qubit&gt;&lt;quantum-gate&gt;" AnswerCount="2" CommentCount="1" />
  <row Id="2226" PostTypeId="2" ParentId="2225" CreationDate="2018-06-04T03:40:23.367" Score="5" Body="&lt;p&gt;Your capacitors cannot be in the state $\frac{1}{\sqrt{2}}\left(|00\rangle + |11\rangle\right)$, but qubits can.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's say $|0\rangle$ is 0$\,$V and $|1\rangle$ is 1$\,$V.&lt;br&gt;&#xA;If you have 2 bits we can have $|00\rangle$,$|01\rangle$,$|10\rangle$,$|11\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But the state: $\frac{1}{\sqrt{2}}\left(|00\rangle + |11\rangle\right)$, is in a superposition of two of these cases. The bit values can be (0,0) &lt;strong&gt;&lt;em&gt;or&lt;/em&gt;&lt;/strong&gt; (1,1). Either case is equally possible, until a measurement is made (think Schrödinger's cat: you don't know if it's alive or dead until you open the box).&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-07-08T01:31:24.907" LastActivityDate="2018-07-08T01:31:24.907" CommentCount="15" />
  <row Id="2227" PostTypeId="1" CreationDate="2018-06-04T05:46:40.623" Score="5" ViewCount="134" Body="&lt;p&gt;I have been reading the paper &lt;a href=&quot;https://link.springer.com/article/10.1007%2Fs11128-017-1692-x&quot; rel=&quot;nofollow noreferrer&quot;&gt;A quantum-implementable neural network model (Chen et al., 2017)&lt;/a&gt; for a few days now, but failed to understand how exactly their algorithm offers a speedup over the classical neural network models.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In particular I'm confused about what they mean by and what they are trying to do with quantum multiplexers. They haven't even defined it properly.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here's the relevant paragraph:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;One of the most interesting points of QPNN is that we can use quantum parallelism to combine several basic networks at the same time. To achieve this purpose, only $n$ qubits are needed in a control layer to perform the following quantum multiplexer as shown in Fig. $5$.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;$$\left( \begin{array}{ccc} U_1 \\ &amp;amp; \ddots \\ &amp;amp;&amp;amp; U_{2^n} \end{array} \right) \tag{13}$$&#xA;  &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/o5wqX.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/o5wqX.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;where $U_i$ represents the dynamics of the $i$th basic network. Moreover $2^{n}$ different quantum gates $\left\{P^{(i)}|i=1, \dots ,2^{n}\right\}$ can also be applied on the output layer of each &lt;strong&gt;basic network&lt;/strong&gt; respectively.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Questions:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;What does $i^{\text{th}}$ &lt;strong&gt;basic network&lt;/strong&gt; mean in this context?&lt;/li&gt;&#xA;&lt;li&gt;What is quantum multiplexer and how exactly is it helping in this context? What is meant by the matrix shown in $(13)$?  (I read a few papers on quantum multiplexers which say that they are basically used to transfer information contained by several qubits as information in a qudit. But no idea how that is relevant &lt;em&gt;here&lt;/em&gt;.)&lt;/li&gt;&#xA;&lt;li&gt;What do they mean by &quot;we can use quantum&#xA;parallelism to combine several basic networks at the same time&quot;?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="26" LastEditorUserId="15" LastEditDate="2018-06-05T03:57:57.047" LastActivityDate="2018-07-13T14:44:00.237" Title="What do &quot;$i$-th basic network&quot;, &quot;quantum multiplexers&quot; and &quot;quantum parallelism&quot; mean in this context? How are they beneficial?" Tags="&lt;machine-learning&gt;&lt;neural-network&gt;&lt;quantum-multiplexer&gt;&lt;quantum-parallelism&gt;" AnswerCount="0" CommentCount="2" />
  <row Id="2228" PostTypeId="1" AcceptedAnswerId="2235" CreationDate="2018-06-04T06:48:49.567" Score="9" ViewCount="313" Body="&lt;p&gt;I would like to simulate a quantum algorithm where one of the steps is &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_logic_gate#Square_root_of_Swap_gate_(%E2%88%9AS)&quot; rel=&quot;noreferrer&quot;&gt;&quot;Square root of Swap gate&quot;&lt;/a&gt; between 2 qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;How can I implement this step using the &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/editor&quot; rel=&quot;noreferrer&quot;&gt;IBM composer&lt;/a&gt;?&lt;/p&gt;&#xA;" OwnerUserId="2529" LastEditorUserId="2293" LastEditDate="2018-06-04T16:59:38.323" LastActivityDate="2018-06-06T11:13:48.823" Title="How to implement the &quot;Square root of Swap gate&quot; on the IBM Q (composer)?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-gate&gt;&lt;ibm-q-experience&gt;" AnswerCount="3" CommentCount="3" />
  <row Id="2229" PostTypeId="2" ParentId="2209" CreationDate="2018-06-04T06:50:14.190" Score="0" Body="&lt;p&gt;I know we already have an answer here, but going back to the problem specification, there's a much simpler way to achieve this if the only thing that's important is the output, comprising a binary string. All the protocol actually has to do is:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Select an $n$-bit string, $x\in\{0,1\}^n$ at random. If you don't want to trust classical randomness, use $n$ qubits, starting in $|0\rangle$, with Hadamard acting on them, and measure in the computational basis. In fact, just use 1 qubit, and repeat the same thing $n$ times with it.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Let $w_x$ be the Hamming weight of $x$ (i.e. the number of 1s). Select a random $y\in\{0,1\}^n$ such that $w_y=w_x$. There are several ways you might do this, but, for example, use $m=\lceil\log_2\binom{n}{w_x}\rceil$ bits. Generate an answer $z\in\{0,1\}^m$ uniformly at random (i.e. $p_z=1/2^m$). $\binom{n}{w_x}$ of these strings $z$ can be mapped onto a suitable $y$. If a given answer cannot, just keep choosing a random $z$ until it can. On average, you won't need more than 2 gos.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Give the answer $x,y$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-06-04T09:15:44.350" LastActivityDate="2018-06-04T09:15:44.350" CommentCount="1" />
  <row Id="2230" PostTypeId="1" CreationDate="2018-06-04T09:13:08.030" Score="5" ViewCount="96" Body="&lt;p&gt;In order to rotate about an axis of the Bloch sphere we ususally use pulses e.g. in trapped ion quantum computing or superconducting qubits. Let's say we have rotation around the x-axis. What do I have to change in order to be able to rotate around the y-axis or the z-axis? I assume it has something to do with the phase but I could not find a good reference for how this works.&lt;/p&gt;&#xA;" OwnerUserId="1853" LastActivityDate="2018-06-04T09:13:08.030" Title="Rotating about the y- or z-axis of the Bloch sphere" Tags="&lt;quantum-gate&gt;&lt;experimental-results&gt;&lt;superconducting-quantum-computing&gt;" AnswerCount="0" CommentCount="5" FavoriteCount="1" />
  <row Id="2232" PostTypeId="2" ParentId="2222" CreationDate="2018-06-04T12:45:25.967" Score="0" Body="&lt;p&gt;A quantum computer can do classical computations. &#xA;The optimal algorithm would be to:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Pick any bit (the fastest one you can get access to). &lt;/li&gt;&#xA;&lt;li&gt;Find a bit that has the opposite value (if in step 1 you got a 0, find a 1)&lt;/li&gt;&#xA;&lt;li&gt;Switch them (0 becomes 1 and 1 becomes 0).&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Step 2 involves searching through an $N$ bit string which using classical operations takes $\mathcal{O}(N)$ operations, but if you can get the $n^{\textrm{th}}$ bit value by evaluating a function, you may be able to use Grover's quantum algorithm to find the opposite bit with $\mathcal{O}\left(\sqrt{N}\right)$ operations.  &lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-06-04T12:45:25.967" CommentCount="1" />
  <row Id="2233" PostTypeId="2" ParentId="2222" CreationDate="2018-06-04T14:54:28.543" Score="4" Body="&lt;p&gt;It could be done with $\lceil\log n\rceil$ additional qubits along these lines:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;ol&gt;&#xA;  &lt;li&gt;&lt;p&gt;Transform the additional qubits so that they encode a number&#xA;  $k\in\{0,\ldots,n-1\}$ chosen uniformly at random.&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Cyclically shift the input qubits $k$ times.&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Let the last of the original input qubits be fixed as an output and recurse on the remaining $n-1$ of them.&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;This is a classical algorithm, but you can run it on a quantum computer of course, as Norbert has suggested in a comment. (The aspect of the question that is adamant about the algorithm being quantum is still not clear to me, so if running a classical algorithm such as the one I have suggested on a quantum computer is not sufficient, it would be helpful for the question to be clarified.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that because the question asks for a random output, the algorithm is going to have to generate entropy at some point, presumably through measurements or performing other non-unitary operations on qubits (such as initializing them). In the algorithm above, it is the first step that generates entropy: regardless of the state of the additional qubits before the operation in step 1 is performed, they should have the state&#xA;$$&#xA;\frac{1}{n} \sum_{k = 0}^{n-1} \lvert k \rangle \langle k \rvert&#xA;$$&#xA;after step 1 is performed (with $k$ encoded in binary, let's say).&lt;/p&gt;&#xA;" OwnerUserId="1764" LastActivityDate="2018-06-04T14:54:28.543" CommentCount="5" />
  <row Id="2234" PostTypeId="2" ParentId="2228" CreationDate="2018-06-04T16:49:54.507" Score="0" Body="&lt;p&gt;Every 2-qubit gate has a &quot;Paulinomial decomposition&quot; which means it can be written as a polynomial of Pauli matrices.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For the gate you want:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$&#xA;\sqrt{ \mbox{SWAP} } = &#xA;\begin{bmatrix} &#xA;1  &amp;amp;  0  &amp;amp;  0  &amp;amp;  0  \\&#xA;0  &amp;amp;  \frac{1}{{2}} (1+i)  &amp;amp;  \frac{1}{{2}} (1-i)  &amp;amp;  0  \\&#xA;0  &amp;amp;  \frac{1}{{2}} (1-i)  &amp;amp;  \frac{1}{{2}} (1+i)  &amp;amp;  0  \\&#xA;0  &amp;amp;  0  &amp;amp;  0  &amp;amp;  1 \\&#xA;\end{bmatrix} = \frac{1-i}{4}\left(X_1X_2+Y_1Y_2+Z_1Z_2\right) +\frac{3+i}{2}I,&#xA;$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;where $X_i$ is an $X$ gate applied to the $i^\textrm{th}$ qubit.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-06-04T16:59:17.920" LastActivityDate="2018-06-04T16:59:17.920" CommentCount="10" />
  <row Id="2235" PostTypeId="2" ParentId="2228" CreationDate="2018-06-04T22:42:34.260" Score="9" Body="&lt;p&gt;Here is &lt;a href=&quot;http://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22QFT2%22%5D%2C%5B%22inputA2%22%2C1%2C%22%2B%3DA2%22%5D%2C%5B%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22X%5E-%C2%BD%22%2C%22%E2%80%A2%22%5D%2C%5B%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22%E2%80%A6%22%5D%2C%5B%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22H%22%5D%2C%5B%22Z%5E%C2%BC%22%2C%22Z%5E-%C2%BC%22%5D%2C%5B%22H%22%2C%22H%22%5D%2C%5B%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22H%22%2C%22H%22%5D%2C%5B%22Z%5E-%C2%BC%22%5D%2C%5B%22H%22%5D%2C%5B%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22Z%5E-%C2%BD%22%2C%22Z%5E%C2%BD%22%5D%5D%7D&quot; rel=&quot;noreferrer&quot;&gt;a SQRT(SWAP) construction&lt;/a&gt; which only requires CNOTs in one direction, Hadamards, S gates ($Z^{\frac{1}{2}}$), inverse S gates ($Z^{-\frac{1}{2}}$), T gates ($Z^{\frac{1}{4}}$) and inverse T gates ($Z^{-\frac{1}{4}}$):&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/oIKp0.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/oIKp0.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You should be able to encode it directly into the composer.&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-06-06T11:13:48.823" LastActivityDate="2018-06-06T11:13:48.823" CommentCount="16" />
  <row Id="2236" PostTypeId="2" ParentId="2228" CreationDate="2018-06-04T23:22:16.143" Score="2" Body="&lt;p&gt;What you want to do is a rotation on the subspace spanned by $|01\rangle$ and $|10\rangle$ which rotates it by $\sqrt{X}$.  To this end, you can first do a CNOT, which maps this subspace to $\{|01\rangle,|11\rangle\}$.  Now you need to do the $\sqrt{X}$ rotation on the first qubit, conditioned on the second qubit being one.  Implementing controlled-$U$ gates using CNOTs is a standard construction, which can be found in a range of places, see e.g. &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9503016&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/quant-ph/9503016&lt;/a&gt;. Depending how you do this step, you might have to fix the &quot;global&quot; phase of the 1st qubit (given the 2nd is $|1\rangle$).  Finally, you need to undo the CNOT.&lt;/p&gt;&#xA;" OwnerUserId="491" LastActivityDate="2018-06-04T23:22:16.143" CommentCount="5" />
  <row Id="2237" PostTypeId="2" ParentId="2225" CreationDate="2018-06-05T09:46:35.167" Score="1" Body="&lt;p&gt;It looks like you are asking about the possibility of encoding the mathematics of quantum states &amp;amp; measurement into some kind of analog device. And yes, I think this is possible. This reminds me of how people study &lt;a href=&quot;https://en.wikipedia.org/wiki/Analog_models_of_gravity&quot; rel=&quot;nofollow noreferrer&quot;&gt;analog models of gravity&lt;/a&gt;. The one problem I can see with this is that it will not scale very well as you increase the number of entangled quantum systems. Eg. for every extra qubit added to a system you &lt;em&gt;double&lt;/em&gt; the number of dimensions. So for 10 qubits you would need a capacitor plate with 1024 subdivisions, and so on. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In summary, what you are proposing is to simulate a quantum system with an analog computer. We already do this with digital computers, but it just doesn't scale.&lt;/p&gt;&#xA;" OwnerUserId="263" LastActivityDate="2018-06-05T09:46:35.167" CommentCount="0" />
  <row Id="2238" PostTypeId="1" AcceptedAnswerId="2241" CreationDate="2018-06-05T09:59:30.530" Score="7" ViewCount="118" Body="&lt;p&gt;I am learning how to program the IBM Q Experience quantum computers in order to learn more about how does it work and in order to perform some experiments in it. By doing so I was wondering what are the most advanced things that have been done in such computers that actually are an advance for quantum technologies.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;More specfically, I am interested in what have been done in quantum error correction code implementation and testing in those, and if some papers about those implementations and techniques used are available.&lt;/p&gt;&#xA;" OwnerUserId="2371" LastEditorUserId="409" LastEditDate="2018-06-05T13:13:26.667" LastActivityDate="2018-06-05T13:13:32.973" Title="Practical Implementations of QECCs in IBM Q Experience" Tags="&lt;quantum-computer&gt;&lt;quantum-error-correction&gt;&lt;resource-request&gt;&lt;ibm-q-experience&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="2239" PostTypeId="2" ParentId="2222" CreationDate="2018-06-05T11:57:34.807" Score="3" Body="&lt;p&gt;Note: this answer assumes you want the permutation to be &lt;em&gt;coherent&lt;/em&gt;, i.e. you want $\frac{1}{\sqrt{3}} ( |001\rangle + |010\rangle + |100\rangle)$ instead of a 1/3 chance of $001$, a 1/3 chance of $010$, and a 1/3 chance of $100$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Be careful how you specify this task, because it could very easily be impossible due to reversibility constraints. For example, for the input $|001\rangle$ you want to output the GHZ state $\left| {3 \atop 1} \right\rangle = \frac{1}{\sqrt{3}} (|001\rangle + |010\rangle + |100\rangle)$. But if you also want to output the GHZ state for the input $|010\rangle$ and $|100\rangle$, that won't work. You can't send multiple input states to the same output state (without decoherence). As long as you say &quot;I only care about sorted-ascending inputs like 0000111 but not 1110000 or 0010110; you can do whatever you want with those&quot;, this will be fine.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One trick to producing a quantum permutation of a sorted input is to first prepare a &quot;permutation state&quot; by applying a sorting network to a list of seed values each in a uniform superposition. The sorting network will output qubits holding the sorted seeds, but also qubits holding the sorting network comparisons. The permutation state is just the comparison qubits. To apply it to your input, you simply run the input through the sorting network in reverse. Note that there are some tricky details here; see the paper &quot;&lt;a href=&quot;https://arxiv.org/abs/1711.10460&quot; rel=&quot;nofollow noreferrer&quot;&gt;Improved Techniques for Preparing Eigenstates of Fermionic Hamiltonians&lt;/a&gt;&quot;. You would have to generalize this technique to work on inputs with repeated values, instead of only unique values.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You may also want to look into &quot;&lt;a href=&quot;https://arxiv.org/abs/1410.3941&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum compression&lt;/a&gt;&quot;, which is very closely tied to the $\left| {n \atop k} \right\rangle$ states (uniform superpositions of all $n$-bit states with $k$ bits set) that you want to produce. The main difference is that you would run the quantum compression circuit in reverse, and it expects a number encoding &quot;how many ones are there?&quot; instead of &quot;give me a state with the correct number of ones&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I guess what I'm saying is that producing these kinds of states is more complicated than you might have expected. I think the reason it is complicated is because the magnitude of the amplitudes in your outputs depend on the computational basis state of your input. For example, for $|0001\rangle$ you want an output which is a superposition of four classical states, so you have a prefactor of $\frac{1}{\sqrt{4}}$ hidden inside $\left| {4 \atop 1} \right\rangle$. But for $|0011\rangle$ the desired output has six classical states and so $\left| {4 \atop 2} \right\rangle$ hides a prefactor of $\frac{1}{\sqrt{6}}$.&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-06-05T12:17:39.020" LastActivityDate="2018-06-05T12:17:39.020" CommentCount="2" />
  <row Id="2240" PostTypeId="2" ParentId="2238" CreationDate="2018-06-05T12:12:11.340" Score="2" Body="&lt;p&gt;You might find the paper &lt;a href=&quot;https://arxiv.org/abs/1708.02297&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;Automated Error Correction in IBM Quantum Computer and Explicit Generalization&quot; (2017)&lt;/a&gt; by Panigrahi et al. relevant. As for &quot;&lt;em&gt;what are the most advanced things that have been done in such computers that actually are an advance for quantum technologies&lt;/em&gt;&quot;,  if you search a bit on &lt;a href=&quot;https://arxiv.org/search/?searchtype=author&amp;amp;query=Panigrahi%2C+P+K&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv&lt;/a&gt; you'll find quite a few relevant papers published by them. One such recent example which I personally had found quite interesting is: &quot;&lt;a href=&quot;https://arxiv.org/abs/1806.00781&quot; rel=&quot;nofollow noreferrer&quot;&gt;Application of quantum scrambling in Rydberg atom on IBM quantum computer&quot; (2018)&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;&lt;strong&gt;Disclosure&lt;/strong&gt;: I'm currently an undergraduate member of Prof. Panigrahi's group.&lt;/sup&gt;&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-06-05T12:29:49.077" LastActivityDate="2018-06-05T12:29:49.077" CommentCount="0" />
  <row Id="2241" PostTypeId="2" ParentId="2238" CreationDate="2018-06-05T13:13:32.973" Score="4" Body="&lt;p&gt;The publicly available IBM devices don't yet have the connectivity to realize quantum error correcting codes that both detect and correct a full set of quantum errors. But we can certainly do proof-of-principle experiments on the tools and techniques required. Here are the experiments I know of&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Error correction experiments done (or doable) on a 5 qubit device:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1410.6419&quot; rel=&quot;nofollow noreferrer&quot;&gt;Detecting arbitrary quantum errors via stabilizer measurements on a sublattice of the surface code&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1705.08957&quot; rel=&quot;nofollow noreferrer&quot;&gt;Is error detection helpful on IBM 5Q chips?&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1705.09259&quot; rel=&quot;nofollow noreferrer&quot;&gt;Experimental demonstration of fault-tolerant state preparation with superconducting qubits&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1709.01866&quot; rel=&quot;nofollow noreferrer&quot;&gt;Protecting quantum memories using coherent parity check codes&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Error correction experiments on the 16 qubit device.&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1709.00990&quot; rel=&quot;nofollow noreferrer&quot;&gt;A repetition code of 15 qubits&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;Disclosure: The last one is mine.&lt;/sup&gt;&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-06-05T13:13:32.973" CommentCount="1" />
  <row Id="2242" PostTypeId="1" CreationDate="2018-06-05T14:22:02.553" Score="8" ViewCount="86" Body="&lt;p&gt;I was wondering if there is a way to compose a program with multiple quantum circuits without having the register reinitialized at $0$ for each circuit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Specifically, I would like run a second quantum circuit after running the first one, as in this example: &lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;qp = QuantumProgram()&#xA;qr = qp.create_quantum_register('qr',2)&#xA;cr = qp.create_classical_register('cr',2)&#xA;&#xA;qc1 = qp.create_circuit('B1',[qr],[cr])&#xA;qc1.x(qr)&#xA;&#xA;qc1.measure(qr[0], cr[0])&#xA;qc1.measure(qr[1], cr[1])&#xA;&#xA;qc2 = qp.create_circuit('B2', [qr], [cr])&#xA;qc2.x(qr)&#xA;qc2.measure(qr[0], cr[0])&#xA;qc2.measure(qr[1], cr[1])&#xA;&#xA;#qp.add_circuit('B1', qc1)&#xA;#qp.add_circuit('B2', qc2)&#xA;&#xA;pprint(qp.get_qasms())&#xA;&#xA;result = qp.execute()&#xA;&#xA;print(result.get_counts('B1'))&#xA;print(result.get_counts('B2'))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Unfortunately, what I get is the same result for the two runs (i.e. a count of &lt;code&gt;11&lt;/code&gt; for the &lt;code&gt;B1&lt;/code&gt; and &lt;code&gt;B2&lt;/code&gt; instead of &lt;code&gt;11&lt;/code&gt; and &lt;code&gt;00&lt;/code&gt; for the second, as if &lt;code&gt;B2&lt;/code&gt; is run on a completely new state initialized on &lt;code&gt;00&lt;/code&gt; after &lt;code&gt;B1&lt;/code&gt;. &lt;/p&gt;&#xA;" OwnerUserId="1644" LastEditorUserId="26" LastEditDate="2018-06-05T15:25:06.693" LastActivityDate="2018-06-27T02:33:58.860" Title="Composing multiple quantum circuits in single quantum program in QISKit" Tags="&lt;quantum-algorithms&gt;&lt;qiskit&gt;" AnswerCount="2" CommentCount="3" FavoriteCount="1" />
  <row Id="2243" PostTypeId="2" ParentId="2242" CreationDate="2018-06-05T17:49:18.653" Score="0" Body="&lt;p&gt;Once you do a measurement, the wavefunction of the quantum state/register collapses and it loses its quantum nature. It doesn't make sense to apply another circuit on it. &lt;/p&gt;&#xA;" OwnerUserId="2527" LastActivityDate="2018-06-05T17:49:18.653" CommentCount="3" />
  <row Id="2244" PostTypeId="1" CreationDate="2018-06-05T21:39:37.367" Score="12" ViewCount="165" Body="&lt;p&gt;In &lt;a href=&quot;https://en.wikipedia.org/wiki/Boson_sampling&quot; rel=&quot;noreferrer&quot;&gt;boson sampling&lt;/a&gt;, if we start with 1 photon in each of the first $M$ modes of an interferometer, the probability of detecting 1 photon in each output mode is: $|\textrm{Perm}(A)|^2$, where the columns and rows of $A$ are the first $M$ columns of the interferometer's unitary matrix $U$, and all of its rows.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This makes it look like for any unitary $U$, we can construct the appropriate interferometer, construct the matrix $A$, and calculate the absolute value of the permanent of $A$ by taking the square root of the probability of detecting one photon in each mode (which we get from the boson sampling experiment). &lt;strong&gt;&lt;em&gt;Is this true, or is there some catch?&lt;/em&gt;&lt;/strong&gt; People have told me that you can't actually get information about a permanent from boson sampling.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Also, what happens to the rest of the columns of $U$: How exactly is it that the experimental outcome only depends on the first $M$ columns of $U$ and all of its rows, but not at all on the other columns of $U$? &lt;strong&gt;&lt;em&gt;Those columns of $U$ do  not affect the outcome of the experiment in the first $M$ modes at all?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-06-05T23:04:22.917" LastActivityDate="2018-08-16T09:03:56.637" Title="Is it possible to &quot;calculate&quot; the absolute value of a permanent using Boson Sampling?" Tags="&lt;quantum-information&gt;&lt;classical-computing&gt;&lt;optical-quantum-computing&gt;&lt;boson-sampling&gt;&lt;photonics&gt;" AnswerCount="2" CommentCount="1" />
  <row Id="2245" PostTypeId="2" ParentId="2244" CreationDate="2018-06-06T05:18:04.480" Score="6" Body="&lt;p&gt;It appears to be true, up to a point. As I read Scott Aaronson's &lt;a href=&quot;https://arxiv.org/abs/1011.3245?context=cs&quot; rel=&quot;noreferrer&quot;&gt;paper&lt;/a&gt;, it says that if you start with 1 photon in each of the first $M$ modes of an interferometer, and find the probability $P_S$ that a set $s_i$ photons is output in each mode $i\in\{1,\ldots, N\}$ where $\sum_is_i=M$, is&#xA;$$&#xA;P_s=\frac{|\text{Per(A)}|^2}{s_1!s_2!\ldots s_M!}.&#xA;$$&#xA;So, indeed, if you take a particular instance where $s_i=0$ or 1 for every possible output, then, yes the probability is equal to the permanent of $A$, where $A$ is the first $M$ columns of $U$ and a specific subset of $M$ rows specified by the locations $s_i=1$. So, this is not quite as specified in the question: it is not all rows, but only some subset, so that $A$ is a square matrix, corresponding to the bits that the experiment &quot;sees&quot;, i.e. the input rows and output rows. The photons never populate anything else, and so are blind to the other elements of the unitary matrix $U$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This should be fairly obvious. Let's say I have some $3\times 3$ matrix $V$. If I start in some basis state $|0\rangle$ and find its product, $V|0\rangle$, then knowing that tells me very little about the outputs $V|1\rangle$ and $V|2\rangle$, aside from what can be said from the knowledge that $V$ is unitary, and hence columns and rows are orthonormal.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The issue that one must be careful of is the accuracy: you run this once and all you get is a single sample according to the probability distribution $P_s$. You run this a few times, and you start to build up information about the different probabilities. You run this enough times, and you can get an arbitrarily accurate answer, but how many is enough? There are two different ways that you can measure the error in an estimate of a value $p$. You can demand either an additive error $p\pm\epsilon$ or a multiplicative error, $p(1\pm\epsilon)$. Since we expect that a typical probability will be exponentially small in $n+m$, the multiplicative error demands far greater accuracy, which cannot be achieved efficiently via sampling. On the other hand, the additive error approximation can be achieved.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;While a multiplicative error is what people &lt;em&gt;usually&lt;/em&gt; want to calculate, the additive error can also be an interesting entity. For example, in the evaluation of the &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0511096&quot; rel=&quot;noreferrer&quot;&gt;Jones polynomial&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Aaronson points us back further in time for where this connection between Boson sampling and the Permanent was first made:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;It has been known since work by &lt;a href=&quot;https://link.springer.com/article/10.1007/BF02781659&quot; rel=&quot;noreferrer&quot;&gt;Caianiello&lt;/a&gt; in 1953 (if not earlier) that the amplitudes for $n$-boson processes can be written as the permanents of $n\times n$ matrices.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Instead, their main contribution&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;is to prove a connection between the ability of classical computers to solve the approximate&#xA;  BosonSampling problem and their ability to approximate the permanent&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;i.e. to understand the approximation problem associated with, e.g. finite sampling, and to describe the computational complexity consequences associated: that we believe such a thing is hard to evaluate classically.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-06-07T06:54:08.290" LastActivityDate="2018-06-07T06:54:08.290" CommentCount="9" />
  <row Id="2246" PostTypeId="2" ParentId="2244" CreationDate="2018-06-06T10:56:51.540" Score="5" Body="&lt;p&gt;You cannot &lt;em&gt;efficiently&lt;/em&gt; recover the absolute values of the amplitudes, but if you allow for arbitrary many samples, then you can estimate them to whatever degree of accuracy you like.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;More specifically, if the input state is a single photon in each of the first $n$ modes, and one is willing to draw an arbitrary number of samples from the output, then it is in principle possible to estimate the permanent of $A$ to whatever degree of accuracy one likes, by counting the fraction of the times the $n$ input photons come out in the first $n$ different output ports.&#xA;It is to be noted though that this does not really have much to do with BosonSampling, as the hardness result holds in the regime of the number of modes much larger than the number of photons, and it's about the efficiency of the sampling.&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;BosonSampling&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;I'll try a very brief introduction to what boson sampling is, but it should be noted that I cannot possibly do a better job at this than Aaronson himself, so it's probably a good idea to have a look at the related blog posts of his (e.g. &lt;a href=&quot;https://www.scottaaronson.com/blog/?p=473&quot; rel=&quot;nofollow noreferrer&quot;&gt;blog/?p=473&lt;/a&gt; and &lt;a href=&quot;https://www.scottaaronson.com/blog/?p=1177&quot; rel=&quot;nofollow noreferrer&quot;&gt;blog/?p=1177&lt;/a&gt;), and links therein.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;BosonSampling is a &lt;em&gt;sampling&lt;/em&gt; problem. This can be a little bit confusing in that people are generally more used to think of problems having definite answers.&#xA;A sampling problem is different in that the solution to the problem is &lt;em&gt;a set of samples&lt;/em&gt; drawn from some probability distribution.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Indeed, the problem a boson sampler solves is that of &lt;em&gt;sampling&lt;/em&gt; from a specific probability distribution. More specifically, &lt;em&gt;sampling&lt;/em&gt; from the probability distribution of the possible outcome (many-boson) states.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Consider as a simple example a case with 2 photons in 4 modes, and let's say we fix the input state to be $(1,1,0,0)\equiv|1,1,0,0\rangle$ (that is, a single photon in each of the two first two input modes).&#xA;Ignoring the output states with more than one photon in each mode, there are $\binom{4}{2}=6$ possible output two-photon states:&#xA;$(1,1,0,0), (1,0,1,0), (1,0,0,1), (0,1,1,0), (0,1,0,1)$ and $(0,0,1,1)$.&#xA;Let us denote for convenience with $o_i, i=1,.,6$ the $i$-th one (so, for example, $o_2=(1,0,1,0)$).&#xA;Then, a possible solution to BosonSampling could be the series of outcomes:&#xA;$$o_1, o_4, o_2, o_2, o_5.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To make an analogy to a maybe more familiar case, it's like saying that we want to sample from a Gaussian probability distribution.&#xA;This means that we want to find a sequence of numbers which, if we draw enough of them and put them into a histogram, will produce something close to a Gaussian.&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;Computing permanents&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;It turns out that the probability amplitude of a given input state $|\boldsymbol r\rangle$ to a given output state $|\boldsymbol s\rangle$ is (proportional to) the &lt;a href=&quot;https://en.wikipedia.org/wiki/Permanent_(mathematics)&quot; rel=&quot;nofollow noreferrer&quot;&gt;permanent&lt;/a&gt; of a suitable matrix built out of the unitary matrix characterizing the (single-boson) evolution.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;More specifically, if $\boldsymbol R$ denotes the &lt;em&gt;mode assignment list&lt;/em&gt;${}^{(1)}$ associated to $|\boldsymbol r\rangle$, $\boldsymbol S$ that of $|\boldsymbol s\rangle$, and $U$ is the unitary matrix describing the evolution, then the probability amplitude $\mathcal A(\boldsymbol r\to\boldsymbol s)$ of going from $|\boldsymbol r\rangle$ to $|\boldsymbol s\rangle$ is given by&#xA;$$\mathcal A(\boldsymbol r\to\boldsymbol s) =&#xA;\frac{1}{\sqrt{\boldsymbol r!\boldsymbol s!}} \operatorname{perm} U[\boldsymbol R|\boldsymbol S],&#xA;$$&#xA;with $U[\boldsymbol R|\boldsymbol S]$ denoting the matrix built by taking from $U$ the rows specified by $\boldsymbol R$ and the columns specified by $\boldsymbol S$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thus, considering the fixed input state $|\boldsymbol r_0\rangle$, the probability distribution of the possible outcomes is given by the probabilities&#xA;$$p_{\boldsymbol s} = \frac{1}{\boldsymbol r_0! \boldsymbol s!} \lvert&#xA;\operatorname{perm}U[\boldsymbol R|\boldsymbol S]&#xA;\rvert^2.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;BosonSampling is the problem of drawing &quot;points&quot; according to this distribution.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;This is not the same as computing the probabilities $p_s$&lt;/em&gt;&lt;/strong&gt;, or even computing the permanents themselves.&#xA;Indeed, &lt;a href=&quot;https://en.wikipedia.org/wiki/Boson_sampling#The_complexity_of_the_problem&quot; rel=&quot;nofollow noreferrer&quot;&gt;computing the permanents of complex matrices is hard&lt;/a&gt;, and it is not expected even for quantum computers to be able to do it efficiently.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The gist of the matter is that &lt;em&gt;sampling from a probability distribution&lt;/em&gt; is in general easier than &lt;em&gt;computing the distribution itself&lt;/em&gt;.&#xA;While a naive way to sample from a distribution is to compute the probabilities (if not already known) and use those to draw the points, there might be smarter ways to do it.&#xA;A boson sampler is something that is able to draw points according to a specific probability distribution, &lt;strong&gt;&lt;em&gt;even though the probabilities making up the distribution itself are not known&lt;/em&gt;&lt;/strong&gt; (or better said, not efficiently computable).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Furthermore, while it may look like the ability to efficiently &lt;em&gt;sample&lt;/em&gt; from a distribution should translate into the ability of efficiently estimating the underlying probabilities, this is not the case as soon as there are exponentially many possible outcomes.&#xA;This is indeed the case of boson sampling with uniformly random unitaries (that is, the original setting of BosonSampling), in which there are $\binom{m}{n}$ possible $n$-boson in $m$-modes output states (again, neglecting states with more than one boson in some mode). For $m\gg n$, this number increases exponentially with $n$.&#xA;This means that, in practice, you would need to draw an exponential number of samples to even have a decent chance of seeing a single outcome more than once, let alone estimate with any decent accuracy the probabilities themselves (it is important to note that this is not the core reason for the hardness though, as the exponential number of possible outcomes could be overcome with smarter methods).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In some particular cases, it is possible to efficiently estimate the permanent of matrices using a boson sampling set-up. This will only be feasible if one of the submatrices has a large (i.e. not exponentially small) permanent associated with it, so that the input-output pair associated with it will happen frequently enough for an estimate to be feasible in polynomial time. This is a very atypical situation, and will not arise if you draw unitaries at random. For a trivial example, consider matrices that are very close to identity - the event in which all photons come out in the same modes they came in will correspond to a permanent which can be estimated experimentally. Besides only being feasible for some particular matrices, a careful analysis of the statistical error incurred in evaluating permanents in this way shows that this is not more efficient than known classical algorithms for approximating permanents (technically, within a small additive error) ${}^{(2)}$.&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;Columns involved&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Let $U$ be the unitary describing the one-boson evolution.&#xA;Then, basically by definition, the output amplitudes describing the evolution of a &lt;em&gt;single&lt;/em&gt; photon entering in the $k$-th mode are in the $k$-th column of $U$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The unitary describing the evolution of the &lt;em&gt;many-boson&lt;/em&gt; states, however, is not actually $U$, but a bigger unitary, often denoted by $\varphi_n(U)$, whose elements are computed from permanents of matrices built out of $U$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Informally speaking though, if the input state has photons in, say, the first $n$ modes, then naturally only the first $n$ columns of $U$ must be necessary (and sufficient) to describe the evolution, as the other columns will describe the evolution of photons entering in modes that we are not actually using.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;(1) This is just another way to describe a many-boson state. Instead of characterizing the state as the list of &lt;em&gt;occupation numbers&lt;/em&gt; for each mode (that is, number of bosons in first mode, number in second, etc.), we characterize the states by naming the mode occupied by each boson.&#xA;So, for example, the state $(1, 0, 1, 0)$ can be equivalently written as $(1, 3)$, and these are two equivalent ways to say that there is one boson in the first and one boson in the third mode.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(2): S. Aaronson and T. Hance. &quot;Generalizing and Derandomizing Gurvits's Approximation Algorithm for the Permanent&quot;. &lt;a href=&quot;https://eccc.weizmann.ac.il/report/2012/170/&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://eccc.weizmann.ac.il/report/2012/170/&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-08-16T09:03:56.637" LastActivityDate="2018-08-16T09:03:56.637" CommentCount="7" />
  <row Id="2247" PostTypeId="2" ParentId="2004" CreationDate="2018-06-06T12:50:33.920" Score="2" Body="&lt;p&gt;Grover's algorithm is used extensively in quantum cryptography as well. It can be used to solve problems such as the Transcendental Logarithm Problem, Polynomial Root Finding Problem etc.&lt;/p&gt;&#xA;" OwnerUserId="2556" LastActivityDate="2018-06-06T12:50:33.920" CommentCount="2" />
  <row Id="2248" PostTypeId="1" CreationDate="2018-06-06T13:08:27.133" Score="7" ViewCount="176" Body="&lt;p&gt;D-Wave makes use of a $(n,k=4)$-Chimera structured graph in their computers. Meaning a $n\times n$ grid of unit cells, with each unit cell consisting of a complete bipartite graph on $2k=8$ nodes ($4$ for each side), also called $K_{4,4}$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Why did D-Wave chose $k=4$? An argument given is that this non-planar structure allows for an embedding of many interesting problems. However, $K_{3,3}$ is also a non-planar graph. So why not choose $k=3$? Additionally, increasing $k$ seems to me as one of the easiest ways to increase the number of qubits your problem has. So why not use $k=5,6,\dots$? &lt;/p&gt;&#xA;" OwnerUserId="2005" LastEditorUserId="2293" LastEditDate="2018-06-06T23:41:54.180" LastActivityDate="2018-06-09T17:18:07.370" Title="Why did D-Wave choose the Chimera graph the way they did?" Tags="&lt;architecture&gt;&lt;d-wave&gt;&lt;chimera&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="2250" PostTypeId="2" ParentId="2248" CreationDate="2018-06-06T17:43:10.373" Score="2" Body="&lt;p&gt;You are right that $K_{3,3}$ is non-planar, but as you said yourself, a larger $k$ is much better. If they could do $K_{1000,1000}$ that would be nice, because each qubit could be coupled to 1002 qubits (1000 within the $K_{1000,1000}$ and two to the neighboring cells). Instead D-Wave is limited to problems which can be embedded such that each qubit couples to at most 6 other qubits. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The reason they don't have larger $k$ is for physical reasons. It is harder to couple a qubit to 1002 qubits than it is to couple it to 6 qubits. It is also harder to couple a qubit to 6 qubits vs 5 qubits, but they found that it was easy enough to go to $k=4$, so they were not limited to $K_{3,3}$.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-06-06T23:42:56.120" LastActivityDate="2018-06-06T23:42:56.120" CommentCount="4" />
  <row Id="2251" PostTypeId="1" AcceptedAnswerId="2253" CreationDate="2018-06-06T19:10:05.423" Score="5" ViewCount="169" Body="&lt;p&gt;How would you check if 2 qubits are orthogonal with respect to each other?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I need to know this to solve this problem:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;You are given $2$ quantum bits:$$&#xA;\begin{align}&#xA;|u_1\rangle &amp;amp;= \cos\left(\frac{x}{2}\right) |0\rangle + \sin\left(\frac{x}{2}\right)e^{in} |1\rangle \tag{1}  \\[2.5px]&#xA;|u_2\rangle &amp;amp;= \cos\left(\frac{y}{2}\right) |0\rangle + \sin\left(\frac{y}{2}\right)e^{im} |1\rangle \tag{2}&#xA;\end{align}&#xA;$$where $m-n = \pi$ and $x+y=\pi$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="2559" LastEditorUserId="15" LastEditDate="2018-06-07T09:19:20.723" LastActivityDate="2018-06-07T13:51:46.873" Title="How to check if 2 quantum bits are orthogonal?" Tags="&lt;qubit&gt;" AnswerCount="4" CommentCount="4" />
  <row Id="2252" PostTypeId="2" ParentId="2251" CreationDate="2018-06-06T19:32:59.777" Score="3" Body="&lt;p&gt;In order to check if two qubits are orthogonal, you should check that the inner product between them equals zero. This can be written like&#xA;$\langle u_1|u_2\rangle=0$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Knowing that $\langle 0|0\rangle=1$, $\langle 0|1\rangle=0$, $\langle 1|0\rangle=0$ and $\langle 1|1\rangle=1$ it should be easy to solve the problem by yourself.&lt;/p&gt;&#xA;" OwnerUserId="2371" LastActivityDate="2018-06-06T19:32:59.777" CommentCount="2" />
  <row Id="2253" PostTypeId="2" ParentId="2251" CreationDate="2018-06-07T06:14:27.243" Score="3" Body="&lt;p&gt;Keep in mind that $|0\rangle$ and $|1\rangle$ are &lt;a href=&quot;https://en.wikipedia.org/wiki/Orthonormality&quot; rel=&quot;nofollow noreferrer&quot;&gt;orthonormal&lt;/a&gt; basis vectors of a two-dimensional complex vector space (over the field of complex numbers). To check whether $|u_1\rangle$ and $|u_2\rangle$ are orthogonal you'll have to check whether the standard inner product $\langle u_1|u_2\rangle$ is $0$. Here $\langle u_1|$ refers to the bra vector corresponding to the ket vector $|u_1\rangle$. In matrix notation that would simply mean that $\langle u_1|$ is the complex conjugate transpose a.k.a Hermitian conjugate of $|u_1\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In your case:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$|u_1\rangle = \cos(\frac{x}{2}) \begin{bmatrix} 1 \\ 0 \end{bmatrix} + (\sin(\frac{x}{2}))e^{in} \begin{bmatrix} 0 \\ 1 \end{bmatrix}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;and &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$|u_2\rangle = \cos(\frac{y}{2}) \begin{bmatrix} 1 \\ 0 \end{bmatrix} + (\sin(\frac{y}{2}))e^{im} \begin{bmatrix} 0 \\ 1 \end{bmatrix}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, you'll find $\langle u_1|$ to be:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\cos(\frac{x}{2}) \begin{bmatrix} 1 &amp;amp; 0 \end{bmatrix} + (\sin(\frac{x}{2}))e^{-in} \begin{bmatrix} 0 &amp;amp; 1 \end{bmatrix}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, simply carry out the multiplication of the matrices $\langle u_1|$ and $ |u_2\rangle$. If it turns out to be $0$, they're orthogonal. Or else they're not orthogonal.&lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-06-07T06:14:27.243" CommentCount="0" />
  <row Id="2254" PostTypeId="2" ParentId="2251" CreationDate="2018-06-07T07:08:53.297" Score="3" Body="&lt;p&gt;Instead of doing matrix calculation you can also map those qubits to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bloch_sphere&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bloch sphere&lt;/a&gt;.  A Bloch sphere is a unit 2-sphere, with antipodal points corresponding to a pair of mutually orthogonal state vectors.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So if you can show that the 2 points are antipodal on a Bloch sphere, then you have proven that they are orthogonal.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The nice thing is that your qubits are already expressed in a way that can easily be mapped on the bloch sphere (x, y, n and m correspond to the angles on the Bloch sphere).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So giving the angles it is easy to determine if they are antipodal as in that case the corresponding angles must differ with $\pi + n.2\pi$ where n is a positive or negative natural number (note that in case $\theta =0 + n\pi$ is a special case as in that case we should ignore angle $\psi$).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the question it is already stated that the angles m and n differ with $\pi$ so we only need to look at the angles x and y and so we can conclude that only under the following condition will the above 2 qubits be orthogonal&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$y-x = { \pi + n (2 \pi)}$  where $n$ is a positive or negative natural number &lt;strong&gt;[1]&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;As $x+y= \pi$ (see question) and &lt;strong&gt;[1]&lt;/strong&gt; : then only the following x and y combinations will give orthogonal qubits.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$2y = \pi +  \pi + n (2 \pi)$ which can be simplified as $y = n\pi$ where n is a positive or negative natural number and in that case $x=\pi - n\pi$  (e.g. when $y=0$ en $x=\pi$ we get 2 orthogonal qubits).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="2529" LastEditorUserId="2529" LastEditDate="2018-06-07T08:10:51.813" LastActivityDate="2018-06-07T08:10:51.813" CommentCount="0" />
  <row Id="2255" PostTypeId="1" AcceptedAnswerId="2256" CreationDate="2018-06-07T11:22:53.247" Score="5" ViewCount="89" Body="&lt;p&gt;I'm currently reading &lt;em&gt;Quantum Computation and Quantum Information&lt;/em&gt; and I'm not sure if I correctly understand this exercise (on page 57) :&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Exercise 1.2: Explain how a device which, upon input of one of two non-orthogonal quantum states $\left|\psi\right&amp;gt;$ or $\left|\phi\right&amp;gt;$ correctly identified the state, could be used to build a device which cloned the states $\left|\psi\right&amp;gt;$ and $\left|\phi\right&amp;gt;$, in violation of the no-cloning theorem. Conversely, explain how a device for cloning could be used to distinguish non-orthogonal quantum states.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The first part seems fairly straightforward to me : once the state has been identified as $|\psi\rangle$ or $|\phi\rangle$, just prepare an identical state through whatever means we have available, effectively cloning the original state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For the converse, I've not been able to achieve better than this :&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Clone the state to be identified $n$ times&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Perform a measurement on each of the copies in the basis $(|\psi\rangle, |\psi'\rangle)$, where $|\psi'\rangle$ is a state orthogonal to $|\psi\rangle$&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;If one of the measurements yields $|\psi'\rangle$, then we know for certain that the original state is $|\phi\rangle$&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;If all of the measurements yield $|\psi\rangle$, we can claim that the original state is $|\psi\rangle$ with a probability of error equal to : $|\langle\psi|\phi\rangle|^{2n}$, which can be made arbitrarily small by increasing $n$&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;However, the way the exercise is worded makes me think that there must be some deterministic way of distinguishing between $|\psi\rangle$ and $|\phi\rangle$ given a cloning machine. Is this indeed the case?&lt;/p&gt;&#xA;" OwnerUserId="2563" LastActivityDate="2018-06-07T11:53:35.610" Title="No-cloning theorem and distinguishing between two non-orthogonal quantum states" Tags="&lt;qubit&gt;&lt;qubit-state&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2256" PostTypeId="2" ParentId="2255" CreationDate="2018-06-07T11:42:51.893" Score="3" Body="&lt;p&gt;That's the way that I would initially go about answering the question.  There are, however, a few tweaks you could make.&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;Definitive Answer&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;As you point out, the annoying feature is that you can never be definitive about having the state  $|\psi\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are a couple of ways that you might avoid that pitfall.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The first option is to have two different measurement bases that you pick between. The first is as you specified. The second is the complementary view where you use $(|\phi\rangle,|\phi'\rangle)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The second option is to introduce a POVM. (I don't have my copy of Nielsen and Chuang to hand, and don't remember if they've been introduced at this point.) POVMs can have more than 2 measurement operators, and are often quite good at saying &quot;the state was definitely not $|x\rangle$&quot;, so you could make one operator that says &quot;the state definitely was not $|\psi\rangle$&quot;, another that says &quot;definitely not $|\phi\rangle$&quot; and a third just for the sake of completeness.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Both options are variants on a theme, and technically you might still have to run both forever before you get a definitive answer, but the expected number of trials is finite.&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;Better Outcome Probabilities&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;You can actually pick a better measurement basis than the one you described so that you can come to a conclusion faster (but certainly does not give you a definitive answer). Try to think about the two states $|\psi\rangle$ and $|\phi\rangle$ on the Bloch sphere. You can always find a plane passing through both points and the centre of the sphere. On this plane, there is a circle, with two points corresponding to the two states. Draw lines joining these points to the centre. Next, construct a diameter of the circle which makes equal angles with the two lines you've just drawn. This would define the measurement basis that tells you absolutely nothing about which of the two states you have. But, if you construct the diameter that is perpendicular to that line, this is the one that, at least in a single shot, has the maximum probability of distinguishing between the two states.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here's a picture. $|\Psi\rangle$ is one of the two basis states that you want for the measurement, and remember that the angle $\theta$ can be related to $|\langle\psi|\phi\rangle|$.&#xA;&lt;a href=&quot;https://i.stack.imgur.com/hTyeQ.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/hTyeQ.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It might be worth then calculating if you have $k$ copies of each state, whether a joint measurement constructed in this way can perform better than the individual measurement repeated $k$ times.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-06-07T11:53:35.610" LastActivityDate="2018-06-07T11:53:35.610" CommentCount="0" />
  <row Id="2257" PostTypeId="2" ParentId="2251" CreationDate="2018-06-07T13:51:46.873" Score="5" Body="&lt;p&gt;The answers given so far assume that classical descriptions of the two qubits' states are given (e.g. x and y are provided in the problem's statement). Interestingly, even if the two states are unknown to you, the overlap of the two qubits' states can be evaluated with a simple quantum circuit, provided you have access to pairs of qubits in these states. The circuit is known as a SWAP test, and can be found in Fig. 1 of this reference &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0102001&quot; rel=&quot;noreferrer&quot;&gt;1&lt;/a&gt;, where apparently it was first proposed.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0102001&quot; rel=&quot;noreferrer&quot;&gt;1&lt;/a&gt; Buhrman et al., &quot;Quantum fingerprinting&quot;. &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0102001&quot; rel=&quot;noreferrer&quot;&gt;https://arxiv.org/abs/quant-ph/0102001&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="2558" LastActivityDate="2018-06-07T13:51:46.873" CommentCount="0" />
  <row Id="2258" PostTypeId="1" AcceptedAnswerId="2259" CreationDate="2018-06-07T15:03:24.000" Score="4" ViewCount="128" Body="&lt;p&gt;I would like to simulate the 4 &lt;a href=&quot;https://en.wikipedia.org/wiki/Bell_state&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;Bell States&quot;&lt;/a&gt; on the &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/editor&quot; rel=&quot;nofollow noreferrer&quot;&gt;IBM composer&lt;/a&gt;?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;How can I best implement those 4 Bell states using the existing set of gates ?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here below you see the definition of the 4 Bell states.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/zj9KFm.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/zj9KFm.jpg&quot; alt=&quot;The 4 bell states&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The first bell state can be easily implemented on the composer through a Hadamard gate and a CNOT gate as follows:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/WaV9Y.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/WaV9Y.jpg&quot; alt=&quot;first Bell state&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;but how can I implement the other 3 bell states ?&lt;/p&gt;&#xA;" OwnerUserId="2529" LastEditorUserId="26" LastEditDate="2018-06-07T15:10:26.870" LastActivityDate="2018-06-07T16:09:17.680" Title="How to implement the 4 Bell states on the IBM Q (composer)?" Tags="&lt;quantum-computer&gt;&lt;quantum-gate&gt;&lt;quantum-entanglement&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="2259" PostTypeId="2" ParentId="2258" CreationDate="2018-06-07T15:32:40.460" Score="3" Body="&lt;p&gt;Remember that the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_logic_gate#Hadamard_(H)_gate&quot; rel=&quot;nofollow noreferrer&quot;&gt;Hadamard (&lt;strong&gt;H&lt;/strong&gt;) gate&lt;/a&gt; maps $|0\rangle$ to $\frac{|0\rangle+|1\rangle}{\sqrt{2}}$ and $|1\rangle$ to $\frac{|0\rangle-|1\rangle}{\sqrt{2}}$, while the &lt;a href=&quot;https://en.wikipedia.org/wiki/Controlled_NOT_gate&quot; rel=&quot;nofollow noreferrer&quot;&gt;CNOT gate&lt;/a&gt; has the following conversion table:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/n46Eg.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/n46Eg.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, you can use the same circuit:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/khkyU.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/khkyU.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;but begin in the states $|01\rangle$, $|10\rangle$ and $|11\rangle$ to get the other three Bell states (you can easily convert to these states from $|00\rangle$ using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_logic_gate#Pauli-X_gate_(=_NOT_gate)&quot; rel=&quot;nofollow noreferrer&quot;&gt;Pauli-X gate&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/NjrYpm.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/NjrYpm.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Source: &lt;a href=&quot;http://www-bcf.usc.edu/~tbrun/Course/lecture11.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Todd Brun's lecture notes, Part-11&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-06-07T16:06:59.920" LastActivityDate="2018-06-07T16:06:59.920" CommentCount="0" />
  <row Id="2260" PostTypeId="2" ParentId="2258" CreationDate="2018-06-07T15:34:34.157" Score="3" Body="&lt;p&gt;One of the possible solutions:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$|\Phi^+\rangle = \textrm{CNOT} \cdot  H_1  |00 \rangle$&lt;br&gt;&#xA;$|\Phi^-\rangle = Z_1 |\Phi^+\rangle = Z_1 \cdot \textrm{CNOT} \cdot  H_1  |00 \rangle$&lt;br&gt; &#xA;$|\Psi^+\rangle = X_2 |\Phi^+\rangle = X_2 \cdot \textrm{CNOT} \cdot  H_1  |00 \rangle$&lt;br&gt;&#xA;$|\Psi^-\rangle = Z_1 |\Psi^+\rangle = Z_1 \cdot X_2 \cdot \textrm{CNOT} \cdot  H_1  |00 \rangle$&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Where $Z_i$ and $X_i$ act on the $i^\textrm{th}$ qubit.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;So here is $|\Phi^-\rangle$:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/Qnu9Q.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/Qnu9Q.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Here is $|\Psi^+\rangle$:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/w8nYA.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/w8nYA.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;And here is $|\Psi^-\rangle$:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/SGnAU.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/SGnAU.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Another solution is:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$|\Phi^+\rangle = \textrm{CNOT} \cdot  H_1  |00 \rangle$&lt;br&gt;&#xA;$|\Phi^-\rangle = X_1 \cdot \textrm{CNOT} \cdot  H_1  |00 \rangle$&lt;br&gt; &#xA;$|\Psi^+\rangle = X_2 \cdot \textrm{CNOT} \cdot  H_1  |00 \rangle$&lt;br&gt; &#xA;$|\Psi^-\rangle = X_1 X_2\cdot \textrm{CNOT} \cdot  H_1  |00 \rangle$&lt;br&gt; &lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-06-07T16:09:17.680" LastActivityDate="2018-06-07T16:09:17.680" CommentCount="4" />
  <row Id="2261" PostTypeId="1" CreationDate="2018-06-07T18:45:24.193" Score="5" ViewCount="327" Body="&lt;p&gt;I have just started to learn about quantum computing, and I know a little bit about qubits. What is a resource where I can learn a basic quantum algorithm and the concepts behind how it works?&lt;/p&gt;&#xA;" OwnerUserId="2566" LastEditorUserId="2293" LastEditDate="2018-06-12T15:34:32.030" LastActivityDate="2018-07-13T14:54:27.753" Title="Resources for quantum algorithm basics" Tags="&lt;quantum-algorithms&gt;&lt;qubit&gt;&lt;quantum-programming&gt;&lt;resource-request&gt;" AnswerCount="1" CommentCount="10" FavoriteCount="4" />
  <row Id="2262" PostTypeId="2" ParentId="2261" CreationDate="2018-06-07T19:13:54.610" Score="4" Body="&lt;p&gt;Most textbooks and lecture courses start with solving the Deutsch problem using quantum computing. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Parts 1 to 4 of John Watrous's lecture notes will describe the concepts, starting from basics. By the end of lecture 4, you will have learned how a quantum computer can solve the Deutsch problem with fewer operations than a classical computer would need:&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://cs.uwaterloo.ca/~watrous/LectureNotes/CPSC519.Winter2006/01.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Lecture 1: Overview of quantum information&#xA;&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://cs.uwaterloo.ca/~watrous/LectureNotes/CPSC519.Winter2006/02.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Lecture 2: Overview of quantum information (continued)&#xA;&lt;/a&gt; &lt;br&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://cs.uwaterloo.ca/~watrous/LectureNotes/CPSC519.Winter2006/03.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Lecture 3: Superdense coding, quantum circuits, and partial measurements&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://cs.uwaterloo.ca/~watrous/LectureNotes/CPSC519.Winter2006/04.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Lecture 4: Quantum Teleportation; Deutsch’s Algorithm&lt;/a&gt;&lt;br&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="26" LastEditDate="2018-07-13T14:54:27.753" LastActivityDate="2018-07-13T14:54:27.753" CommentCount="5" />
  <row Id="2263" PostTypeId="1" CreationDate="2018-06-07T23:14:06.640" Score="8" ViewCount="376" Body="&lt;p&gt;The Bell state $|\Phi^{+}\rangle = \frac{1}{\sqrt{2}}(|00\rangle + |11\rangle )$ is an entangled state. But why is that the case? How do I mathematically prove that?&lt;/p&gt;&#xA;" OwnerUserId="72" LastActivityDate="2018-06-08T06:59:45.030" Title="How do I show that a two-qubit state is an entangled state?" Tags="&lt;quantum-entanglement&gt;&lt;tensor-product&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="2264" PostTypeId="2" ParentId="2263" CreationDate="2018-06-07T23:14:06.640" Score="8" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;&lt;/p&gt;&#xA;  &#xA;  &lt;hr&gt;&#xA;  &#xA;  &lt;p&gt;A two-qubit state $|\psi\rangle \in \mathbb{C}^4$ is an entangled state if and only if there &lt;strong&gt;not&lt;/strong&gt; exist two one-qubit states $|a\rangle = \alpha |0\rangle + \beta |1\rangle \in \mathbb{C}^2$ and $|b\rangle = \gamma |0\rangle + \lambda |1\rangle \in \mathbb{C}^2$ such that $|a\rangle \otimes |b\rangle = |\psi\rangle$, where $\otimes$ denotes the &lt;em&gt;tensor product&lt;/em&gt; and $\alpha, \beta, \gamma, \lambda \in \mathbb{C}$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;So, to show that the Bell state $|\Phi^{+}\rangle = \frac{1}{\sqrt{2}}(|00\rangle + |11\rangle )$ is an entangled state, we simply have to show that there exist no two one-qubit states $|a\rangle$ and $|b\rangle$ such that $|\Phi^{+}\rangle = |a\rangle \otimes |b\rangle$. &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;Proof&lt;/strong&gt;&lt;/p&gt;&#xA;  &#xA;  &lt;hr&gt;&#xA;  &#xA;  &lt;p&gt;Suppose that &lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;\begin{align}&#xA;|\Phi^{+}\rangle &#xA;&amp;amp;= |a\rangle \otimes |b\rangle \\&#xA;&amp;amp;= \left( \alpha |0\rangle + \beta |1\rangle \right) \otimes \left( \gamma |0\rangle + \lambda |1\rangle \right)&#xA;\end{align}&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;We can now simply apply the distributive property to obtain&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;\begin{align}&#xA;|\Phi^{+}\rangle &#xA;&amp;amp;= \cdots \\&#xA;&amp;amp;= \left( \alpha \gamma  |00\rangle +  \alpha \lambda |01\rangle + \beta \gamma |10\rangle + \beta \lambda |11\rangle \right)&#xA;\end{align}&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;This must be equal to $\frac{1}{\sqrt{2}}(|00\rangle + |11\rangle )$, that is, we must find coefficients $\alpha$, $\beta$, $\gamma$ and $\lambda$, such that &lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;\begin{align}&#xA;\frac{1}{\sqrt{2}}(|00\rangle + |11\rangle ) &#xA;&amp;amp;= \left( \alpha \gamma  |00\rangle +  \alpha \lambda |01\rangle + \beta \gamma |10\rangle + \beta \lambda |11\rangle \right)&#xA;\end{align}&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Observe that, in the expression $\alpha \gamma  |00\rangle +  \alpha \lambda |01\rangle + \beta \gamma |10\rangle + \beta \lambda |11\rangle$, we want to keep both $|00\rangle$ and $|11\rangle$. Hence, $\alpha$ and $\gamma$, which are the coefficients of $|00\rangle$, cannot be zero; in other words, we must have $\alpha \neq 0$ and $\gamma \neq 0$. Similarly, $\beta$ and $\lambda$, which are the complex numbers multiplying $|11\rangle$ cannot be zero, i.e. $\beta \neq 0$ and $\lambda \neq 0$. So, all complex numbers $\alpha$, $\beta$, $\gamma$ and $\lambda$ must be different from zero.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;But, to obtain the Bell state $|\Phi^{+}\rangle$, we want to get rid of $|01\rangle$ and $|10\rangle$. So, one of the numbers (or both) multiplying $|01\rangle$ (and $|10\rangle$)  in the expression $\alpha \gamma  |00\rangle +  \alpha \lambda |01\rangle + \beta \gamma |10\rangle + \beta \lambda |11\rangle $, i.e. $\alpha$ and $\lambda$ (and, respectively, $\beta$ and $\gamma$), must be equal to zero. But we have just seen that $\alpha$, $\beta$, $\gamma$ and $\lambda$ must all be different from zero. So, we cannot find a combination of complex numbers  $\alpha$, $\beta$, $\gamma$ and $\lambda$ such that &lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;\begin{align}&#xA;\frac{1}{\sqrt{2}}(|00\rangle + |11\rangle ) &#xA;&amp;amp;= \left( \alpha \gamma  |00\rangle +  \alpha \lambda |01\rangle + \beta \gamma |10\rangle + \beta \lambda |11\rangle \right)&#xA;\end{align}&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;In other words, we are not able to express $|\Phi^{+}\rangle$ as a tensor product of two one-qubit states. Therefore, $|\Phi^{+}\rangle$ is a entangled state. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;We can perform a similar proof for other Bell states or, in general, if we want to prove that a state is entangled.&lt;/p&gt;&#xA;" OwnerUserId="72" LastEditorUserId="72" LastEditDate="2018-06-07T23:19:16.430" LastActivityDate="2018-06-07T23:19:16.430" CommentCount="0" />
  <row Id="2265" PostTypeId="2" ParentId="2248" CreationDate="2018-06-08T01:07:57.253" Score="2" Body="&lt;p&gt;user1271772's answer is entirely correct. I was going to comment with additional information to help answer nippon's question, but I just created this account and apparently there's a reputation requirement before adding comments.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;D-Wave's superconducting flux qubits are niobium metal loops that form a &quot;hash symbol&quot; made of two flat layers that have been stretched out and laid parallel. One layer is 90-degrees rotated from the other. When you move charge (current) in a loop it produces a magnetic field perpendicular to the plane of the loop. When you move a magnetic field through a charge-carrying loop it induces motion in the charge (current). But the amount of induction is partly determined by the size of the overlapping area (not linearly, since perfect overlap doesn't mean perfect induction, and non-overlapping adjacent wires still do it) so you can't currently usefully overlap 1000x1000 because the influence on each neighbor would be small. Stacking more layers is hard for the same reason wireless charging only just started to not suck.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The D-Wave uses Niobium loops interspersed with these amazing little quantum-permeable membrane slices called Josephson Junctions (that won their discoverer a Nobel before he went a little wacky) cooled to just above 0 kelvin, so they can hold a charge with zero resistance. Basic quantum computing hardware generally has to be robust to decoherence, which means it can't interact much with the outside environment (should be its own Hamiltonian). There's already a ton of control hardware and stuff that has to go into keeping it all stable. Every time they move the machine they have to recalibrate it (at least with the DW2) and a new random arrangement of like 90% of the qubits will work until it's calibrated again. So it's actually a harder problem than just fitting to a chimera graph. Needs to be a readily radiation-hardenable system of some kind, e.g. a neural network.&lt;/p&gt;&#xA;" OwnerUserId="2567" LastEditorUserId="2567" LastEditDate="2018-06-09T17:18:07.370" LastActivityDate="2018-06-09T17:18:07.370" CommentCount="3" />
  <row Id="2266" PostTypeId="2" ParentId="2263" CreationDate="2018-06-08T05:18:39.287" Score="5" Body="&lt;p&gt;A two qudit &lt;em&gt;pure&lt;/em&gt; state is separable if and only if it can be written in the form $$|\Psi\rangle=|\psi\rangle|\phi\rangle$$ for arbitrary single qudit states $|\psi\rangle$ and $|\phi\rangle$. Otherwise, it is entangled.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To determine if the pure state is entangled, one &lt;em&gt;could&lt;/em&gt; try a brute force method of attempting to find satisfying states $|\psi\rangle$ and $|\phi\rangle$, as in &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2264/1837&quot;&gt;this&lt;/a&gt; answer. This is inelegant, and hard work in the general case. A more straightforward way to prove whether this pure state is entangled is the calculate the reduced density matrix $\rho$ for one of the qudits, i.e. by tracing out the other. The state is separable if and only if $\rho$ has rank 1. Otherwise it is entangled. Mathematically, you can test the rank condition simply by evaluating $\text{Tr}(\rho^2)$. The original state is separable if and only if this value is 1. Otherwise the state is entangled.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, imagine one has a pure separable state $|\Psi\rangle=|\psi\rangle|\phi\rangle$. The reduced density matrix on $A$ is&#xA;$$&#xA;\rho_A=\text{Tr}_B(|\Psi\rangle\langle\Psi|)=|\psi\rangle\langle\psi|,&#xA;$$&#xA;and&#xA;$$&#xA;\text{Tr}(\rho_A^2)=\text{Tr}(|\psi\rangle\langle\psi|\cdot |\psi\rangle\langle\psi|)=\text{Tr}(|\psi\rangle\langle\psi|)=1.&#xA;$$&#xA;Thus, we have a separable state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Meanwhile, if we take $|\Psi\rangle=\frac{1}{\sqrt{2}}(|00\rangle+|11\rangle)$, then&#xA;$$&#xA;\rho_A=\text{Tr}_B(|\Psi\rangle\langle\Psi|)=\frac12\left(|0\rangle\langle 0|+|1\rangle\langle 1|\right)=\frac12\mathbb{I}&#xA;$$&#xA;and&#xA;$$&#xA;\text{Tr}(\rho_A^2)=\frac14\text{Tr}(\mathbb{I}\cdot\mathbb{I})=\frac12&#xA;$$&#xA;Since this value is not 1, we have an entangled state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you wish to know about detecting entanglement in pure states, this is less straightforward, but for two qubits there is a necessary and sufficient condition for separability: &lt;a href=&quot;https://en.wikipedia.org/wiki/Peres%E2%80%93Horodecki_criterion&quot; rel=&quot;noreferrer&quot;&gt;positivity under the partial transpose operation&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-06-08T06:59:45.030" LastActivityDate="2018-06-08T06:59:45.030" CommentCount="1" />
  <row Id="2267" PostTypeId="1" AcceptedAnswerId="2274" CreationDate="2018-06-08T09:03:47.183" Score="6" ViewCount="88" Body="&lt;p&gt;I am looking for an implementation using the quantum gates provided by the &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/editor&quot; rel=&quot;nofollow noreferrer&quot;&gt;IBM composer&lt;/a&gt; of the following quantum function:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;input $2n$ qubits&lt;/li&gt;&#xA;&lt;li&gt;output $2n$ qubits wherein $50\%$ of the cases the state of the $2$ sets of $n$ qubits are swapped and in the other $50\%$ of the cases the state of the $2n$ qubits remain unchanged.  With swapped I mean that qubit $q[i]$ will get the state of qubit $q[n+i]$ and qubit $q[n+i]$ will get the state of $q[i]$.  Note also that all the qubits must be swapped or not.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;E.g. $n=3$: If input $|000111\rangle$ then output in 50% of the cases is  $|000111\rangle$ and in the other 50% of the cases is  $|111000\rangle$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We have already a solution when $n=1$ in the following StackOverflow question: &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2228/how-to-implement-the-square-root-of-swap-gate-on-the-ibm-q-composer&quot;&gt;How to implement the &quot;Square root of Swap gate&quot; on the IBM Q (composer)?&lt;/a&gt; &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;but how can we do that when $n&amp;gt;1$?&lt;/p&gt;&#xA;" OwnerUserId="2529" LastEditorUserId="26" LastEditDate="2018-06-11T06:03:40.983" LastActivityDate="2018-06-11T06:03:40.983" Title="How to implement a Square root of Swap gate that swaps 2n-qubits on the IBM Q (composer)?" Tags="&lt;quantum-computer&gt;&lt;quantum-algorithms&gt;&lt;quantum-gate&gt;" AnswerCount="1" CommentCount="1" />
  <row Id="2268" PostTypeId="1" AcceptedAnswerId="2269" CreationDate="2018-06-08T10:15:20.497" Score="6" ViewCount="212" Body="&lt;p&gt;Let's say two qubits are both in $|+\rangle$ state. We need to find $a_1$, $a_2$, $a_3$, and $a_4$ in  $|\phi\rangle = a_1|00\rangle + a_2|01\rangle + a_3|10\rangle + a_4|11\rangle$, how do we find these amplitudes? How do we do it in general case, when each of the qubits are not necessarily in $|+\rangle$ state, but in some $|?\rangle$ state?&lt;/p&gt;&#xA;" OwnerUserId="2559" LastEditorUserId="2559" LastEditDate="2018-06-08T10:19:46.123" LastActivityDate="2018-06-08T10:21:58.023" Title="How to calculate the state given by two qubits?" Tags="&lt;qubit&gt;&lt;qubit-state&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2269" PostTypeId="2" ParentId="2268" CreationDate="2018-06-08T10:21:58.023" Score="3" Body="&lt;p&gt;Start by writing out what the $|+\rangle$ state actually is:&#xA;$$&#xA;|+\rangle=\frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)&#xA;$$&#xA;So, two qubits in the state $|+\rangle$ are in the state&#xA;$$&#xA;|+\rangle|+\rangle=\frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)\otimes \frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)&#xA;$$&#xA;You then need to expand this out, making use of the distributivity of the tensor product, and match up with the specified form of $|\phi\rangle$. Since this sounds a bit like a homework problem, I'm not going to do that for you explicitly. (If you've tried something and got stuck, show us what you tried!)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The general case is absolutely equivalent, you just replace $|+\rangle|+\rangle$ with something like&#xA;$$&#xA;(b_0|0\rangle+b_1|1\rangle)\otimes (b_2|0\rangle+b_3|1\rangle)&#xA;$$&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-08T10:21:58.023" CommentCount="3" />
  <row Id="2270" PostTypeId="1" AcceptedAnswerId="2271" CreationDate="2018-06-08T12:29:33.077" Score="7" ViewCount="646" Body="&lt;p&gt;Let's say we have a circuit with $2$ Hadamard gates:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/hbZaJ.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/hbZaJ.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's take the $|00\rangle$ state as input. The vector representation of $|00\rangle$ state is $[1 \ 0 \ 0 \ 0]$, but this is the representation of $2$ qubits and H accepts just $1$ qubit, so should we apply the first &lt;strong&gt;H&lt;/strong&gt; gate to $[1 \ 0]$ and the second &lt;strong&gt;H&lt;/strong&gt; gate to $[0 \ 0]$? Or should we input $[1 \ 0]$ in each &lt;strong&gt;H&lt;/strong&gt; gate, because we are applying &lt;strong&gt;H&lt;/strong&gt; gates to just one qubit of state $|0\rangle$ each time?&lt;/p&gt;&#xA;" OwnerUserId="2559" LastEditorUserId="26" LastEditDate="2018-06-08T12:46:37.270" LastActivityDate="2018-06-08T13:51:39.860" Title="How to input 2 qubits in 2 Hadamard gates?" Tags="&lt;qubit&gt;&lt;quantum-gate&gt;&lt;qubit-state&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="2" />
  <row Id="2271" PostTypeId="2" ParentId="2270" CreationDate="2018-06-08T12:40:54.223" Score="7" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Or should we input $[1 \ 0]$ in each H gate, because we are applying H&#xA;  gates to just qubit of state $|0\rangle$ each time?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Yes, when you have a two-qubit state (say you label the two qubits as $A$ and $B$ respectively), you need to apply the two Hadamard gates separately on each qubit's state. The final state will be the tensor product of the two &quot;transformed&quot; single-qubit states.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If your input is $|0\rangle_A\otimes|0\rangle_B$, the output will simply be $$\left(\frac{|0\rangle+|1\rangle}{\sqrt{2}}\right)_A\otimes\left(\frac{|0\rangle+|1\rangle}{\sqrt{2}}\right)_B$$&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Alternative:&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;If the two input qubits are &lt;em&gt;entangled&lt;/em&gt;, the above method won't work since you won't be able to represent the input state as a tensor product of the states of the two qubits. So, I'm outlining a more general method here.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When two gates are in parallel, like in your case, you can consider the &lt;a href=&quot;https://en.wikipedia.org/wiki/Tensor_product#Tensor_product_of_linear_maps&quot; rel=&quot;noreferrer&quot;&gt;tensor product&lt;/a&gt; of the two gates and apply &lt;em&gt;that&lt;/em&gt; on the 2-qubit state vector. You'll end up with the same result.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\frac{1}{\sqrt{2}}\begin{bmatrix}1&amp;amp;1\\1&amp;amp;-1\\ \end{bmatrix} \otimes \frac{1}{\sqrt{2}}\begin{bmatrix}1&amp;amp;1\\1&amp;amp;-1\\ \end{bmatrix} = \frac{1}{2}\begin{bmatrix}1&amp;amp;1&amp;amp;1&amp;amp;1\\1&amp;amp;-1&amp;amp;1&amp;amp;-1\\1&amp;amp;1&amp;amp;-1&amp;amp;-1\\1&amp;amp;-1&amp;amp;-1&amp;amp;1 \end{bmatrix}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, on applying this matrix on the 2-qubit state $\begin{bmatrix}1\\0\\0\\0\end{bmatrix}$ you get:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\frac{1}{2}\begin{bmatrix}1&amp;amp;1&amp;amp;1&amp;amp;1\\1&amp;amp;-1&amp;amp;1&amp;amp;-1\\1&amp;amp;1&amp;amp;-1&amp;amp;-1\\1&amp;amp;-1&amp;amp;-1&amp;amp;1 \end{bmatrix} \begin{bmatrix}1\\0\\0\\0\end{bmatrix}=\begin{bmatrix}1/2\\1/2\\1/2\\1/2\end{bmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;which is equivalent to $$\left(\frac{|0\rangle+|1\rangle}{\sqrt{2}}\right)_A\otimes\left(\frac{|0\rangle+|1\rangle}{\sqrt{2}}\right)_B$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Justification&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Tensor_product#Tensor_product_of_linear_maps&quot; rel=&quot;noreferrer&quot;&gt;Tensor product of linear maps&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The tensor product also operates on linear maps between vector spaces.&#xA;  Specifically, given two linear maps $S : V \to X$ and $T : W \to Y$&#xA;  between vector spaces, the tensor product of the two linear maps $S$&#xA;  and $T$ is a linear map $(S\otimes T)(v\otimes w) = S(v) \otimes T(w)$&#xA;  defined by $(S\otimes T)(v\otimes w) = S(v) \otimes T(w)$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Thus, $$(\mathbf H|0\rangle_A) \otimes (\mathbf H|0\rangle_B) = (\mathbf H\otimes \mathbf H)(|0\rangle_A \otimes |0\rangle_B)$$&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-06-08T13:51:39.860" LastActivityDate="2018-06-08T13:51:39.860" CommentCount="3" />
  <row Id="2272" PostTypeId="2" ParentId="2270" CreationDate="2018-06-08T12:46:27.070" Score="3" Body="&lt;p&gt;It's the second option. So, you would apply both Hardmard gates to the state $|0\rangle$, to obtain two $\frac{1}{\sqrt{2}} \left (|0\rangle + |1\rangle \right)$. Therefore, the final two-qubit state would be &lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{align}&#xA;\frac{1}{\sqrt{2}} \left (|0\rangle + |1\rangle \right) \otimes \frac{1}{\sqrt{2}} \left (|0\rangle + |1\rangle \right) &#xA;&amp;amp;= &#xA;\frac{1}{2} \left( |00\rangle + |01\rangle + |10\rangle + |11\rangle\right)&#xA;\end{align}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We can easily verify that this is a valid quantum state by checking the normalization condition.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{align}&#xA;\left| \frac{1}{2} \right|^2 + \left| \frac{1}{2} \right|^2 + \left| \frac{1}{2} \right|^2 + \left| \frac{1}{2} \right|^2&#xA;&amp;amp;=  \frac{1}{4} + \frac{1}{4} + \frac{1}{4} + \frac{1}{4} \\&#xA;&amp;amp;= 1&#xA;\end{align}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In general, in this context, it's more intuitive if you use Dirac's bra-ket notation (i.e. use $|00 \rangle$ instead of the column vector $(1, 0, 0, 0)^T$).  Then, if you have to apply a gate to a subset of the qubits, you can proceed in an analogous way as I did above.&lt;/p&gt;&#xA;" OwnerUserId="72" LastActivityDate="2018-06-08T12:46:27.070" CommentCount="0" />
  <row Id="2274" PostTypeId="2" ParentId="2267" CreationDate="2018-06-08T17:16:12.843" Score="3" Body="&lt;p&gt;A general trick for smoothing a big discrete operation into a continuous operation is to apply the phase estimation algorithm, then apply a phase gradient to the phase register, then uncompute the phase estimation. For example, see &lt;a href=&quot;http://algassert.com/post/1710&quot; rel=&quot;nofollow noreferrer&quot;&gt;this blog post on computing the fractional fourier transform&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Because the swap operation has exactly two eigenvalues (+1 and -1), the phase estimation is extremely simple. It only requires a single phase estimation qubit. The &lt;a href=&quot;http://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B1%2C%22H%22%2C1%2C%22H%22%2C1%2C1%2C%22H%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C%22Density3%22%2C1%2C1%2C%22Density3%22%5D%2C%5B%5D%2C%5B%5D%2C%5B%22H%22%5D%2C%5B%22%E2%80%A2%22%2C%22Swap%22%2C1%2C1%2C%22Swap%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C%22Swap%22%2C1%2C1%2C%22Swap%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C%22Swap%22%2C1%2C1%2C%22Swap%22%5D%2C%5B%22H%22%5D%2C%5B%22Z%5Et%22%5D%2C%5B%22H%22%5D%2C%5B%22%E2%80%A2%22%2C%22Swap%22%2C1%2C1%2C%22Swap%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C%22Swap%22%2C1%2C1%2C%22Swap%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C%22Swap%22%2C1%2C1%2C%22Swap%22%5D%2C%5B%22H%22%5D%2C%5B1%2C%22Density3%22%2C1%2C1%2C%22Density3%22%5D%5D%7D&quot; rel=&quot;nofollow noreferrer&quot;&gt;resulting circuit&lt;/a&gt; looks like this:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/fkufk.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/fkufk.png&quot; alt=&quot;Big sqrt swap&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that the top qubit should start and end in the 0 state. You can continuously vary how much swappery there is by varying the angle of the Z rotation in the middle.&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-06-08T23:00:28.160" LastActivityDate="2018-06-08T23:00:28.160" CommentCount="2" />
  <row Id="2275" PostTypeId="1" CreationDate="2018-06-09T10:00:22.750" Score="7" ViewCount="88" Body="&lt;p&gt;Suppose we have a qutrit with the state vector $|\psi\rangle = a_0|0\rangle + a_1|1\rangle + a_2|2\rangle$, and we want to project its state onto the subspace having the basis $\{|0\rangle,|2\rangle\}$, I know the projection operator would be written like: $1|0\rangle \langle0| + 0|1\rangle\langle 1| + 1|2\rangle\langle2|$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I'm having a few confusions here. Does $|0\rangle \langle 0|$ represent a tensor product between $[1 \ 0 \ 0]^{T}$ and $[1 \ 0 \ 0]$ ? Or is it just matrix multiplication? Also, I thought that we must always be able to write a projection operator in the form $|\phi\rangle \langle \phi|$ where $|\phi\rangle$ is a possible state of a qutrit. But how to represent $1|0\rangle \langle0| + 0|1\rangle\langle 1| + 1|2\rangle\langle2|$ in the form $|\phi\rangle \langle \phi|$?&lt;/p&gt;&#xA;" OwnerUserId="2582" LastEditorUserId="26" LastEditDate="2018-06-09T11:27:56.120" LastActivityDate="2018-06-12T06:52:33.563" Title="Confusion regarding projection operator" Tags="&lt;tensor-product&gt;&lt;qutrit&gt;&lt;projection-operator&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="2276" PostTypeId="1" AcceptedAnswerId="2277" CreationDate="2018-06-09T11:31:49.837" Score="6" ViewCount="104" Body="&lt;p&gt;Let's say we have the following quantum circuit:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/PE2iq.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/PE2iq.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's say we input the state $|00\rangle$ . Both of the $H$ gates produce the output $1/\sqrt{2}$, but which one of the following $2$ vectors is the input of $\operatorname{CNOT}$ gate:&#xA;$1: [1/\sqrt{2}, \ 1/\sqrt{2}, \ 1/\sqrt{2}, \ 1/\sqrt{2}]$ or&#xA;$2: [1/2, \ 1/2, \ 1/2, \ 1/2]$?&#xA;Also, after applying a $2$ qubit gate (in this case $\operatorname{CNOT}$) how do we find out what to input in the following single qubit gates (in this case two $H$ gates)?&#xA;Note that I gave this example for simplicity, a general answer will also be accepted.&lt;/p&gt;&#xA;" OwnerUserId="2559" LastEditorUserId="26" LastEditDate="2018-06-09T14:00:54.420" LastActivityDate="2018-06-09T14:00:54.420" Title="How to apply single and two qubit gates to 2 qubits multiple times?" Tags="&lt;qubit&gt;&lt;quantum-gate&gt;&lt;circuit-model&gt;&lt;quantum-state&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="2" />
  <row Id="2277" PostTypeId="2" ParentId="2276" CreationDate="2018-06-09T13:17:41.473" Score="4" Body="&lt;p&gt;&lt;strong&gt;Step 1&lt;/strong&gt; (application of two hadamard gates): &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$|0\rangle_A \otimes |0\rangle_B \to \left(\frac{|0\rangle + |1\rangle}{\sqrt{2}}\right)_A\otimes\left(\frac{|0\rangle + |1\rangle}{\sqrt{2}}\right)_B$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is equivalent to the state vector: $\begin{bmatrix}1/2\\1/2\\1/2\\1/2\end{bmatrix}$, which will act as the input for your CNOT gate.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Step 2&lt;/strong&gt;: (application of CNOT)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's remind ourselves what the CNOT gate does:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/id9mg.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/id9mg.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So clearly, &#xA;$$\left(\frac{|0\rangle + |1\rangle}{\sqrt{2}}\right)_A\otimes\left(\frac{|0\rangle + |1\rangle}{\sqrt{2}}\right)_B = \frac{1}{2}(|00\rangle + |01\rangle + |10\rangle + |11\rangle)$$ $$\to \frac{1}{2}(|00\rangle + |01\rangle + |11\rangle + |10\rangle) = \left(\frac{|0\rangle + |1\rangle}{\sqrt{2}}\right)_A\otimes\left(\frac{|0\rangle + |1\rangle}{\sqrt{2}}\right)_B$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Step 3:&lt;/strong&gt; (re-application of two Hadamard gates)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\left(\frac{|0\rangle + |1\rangle}{\sqrt{2}}\right)_A\otimes\left(\frac{|0\rangle + |1\rangle}{\sqrt{2}}\right)_B \to |0\rangle_A \otimes |0\rangle_B$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here, we used that fact that the Hadamard gate maps the state $\dfrac{|0\rangle + |1\rangle}{\sqrt{2}}$ to the state $|0\rangle$, for each qubit. You basically need to input the vector $\begin{bmatrix}1/\sqrt{2}\\1/\sqrt{2}\end{bmatrix}$ into the two Hadamard gates at the end. Find the state transformation on each qubit. From there you can construct the state vector for the final 2-qubit state. The final answer will be $\begin{bmatrix}1 \\ 0 \\ 0 \\ 0\end{bmatrix}$. Clearly, we end up with the same 2-qubit state which we started with.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Exercise&lt;/strong&gt;: Carry out steps $2$ and $3$ using the matrix notation. Also, check &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2271/26&quot;&gt;this&lt;/a&gt; related answer.&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-06-09T13:25:43.617" LastActivityDate="2018-06-09T13:25:43.617" CommentCount="0" />
  <row Id="2278" PostTypeId="1" AcceptedAnswerId="2279" CreationDate="2018-06-09T13:27:41.053" Score="6" ViewCount="167" Body="&lt;p&gt;My idea was to apply $Z$ operator , which leads us back to the point where we started from, and also show that after applying the $Z$ operator just  we are not at the same point where we started (this is for showing that we are not rotating by a multiple of $360^{\circ}$). Is this the correct proof? What about the general case, where we want to find out through how many degrees a given operator rotates the points?&lt;/p&gt;&#xA;" OwnerUserId="2559" LastEditorUserId="26" LastEditDate="2018-06-09T13:54:59.127" LastActivityDate="2018-06-09T14:52:25.940" Title="How to prove that Z operator rotates points on Bloch sphere about Z axis through 180°?" Tags="&lt;quantum-gate&gt;&lt;bloch-sphere&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="2279" PostTypeId="2" ParentId="2278" CreationDate="2018-06-09T13:45:31.693" Score="6" Body="&lt;p&gt;The Pauli-$Z$ gate maps $|0\rangle$ to $|0\rangle$ and $|1\rangle$ to $-|1\rangle$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;For Bloch sphere representation, state of a qubit is written like (look at my &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1629/alternative-to-bloch-sphere-to-represent-a-single-qubit/1633#1633&quot;&gt;previous answer&lt;/a&gt; for a detailed explanation)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$|\psi\rangle = \cos(\theta/2)|0\rangle + e^{i\phi}\sin(\theta/2)|1\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Apply the Pauli-$Z$ gate on this and you get:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$|\psi'\rangle = \cos(\theta/2)|0\rangle + (-1)e^{i\phi}\sin(\theta/2)|1\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$=\cos(\theta/2)|0\rangle + e^{i(\phi+\pi)}\sin(\theta/2)|1\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thus, the angle $\phi$ changes by $\pi$. We can call $\phi + \pi$ as $\phi'$ now.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Remind yourself what the Bloch sphere looks like:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/BBEUG.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/BBEUG.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Clearly, from the diagram, if the angle $\phi$ is changed by $\pi$, it will imply that the state of the qubit has been rotated about the Z-axis by $180$ degrees.&lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-06-09T13:45:31.693" CommentCount="0" />
  <row Id="2280" PostTypeId="2" ParentId="2275" CreationDate="2018-06-09T14:21:04.037" Score="7" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;em&gt;Does $|0\rangle\langle0|$ represent a tensor product or is it just matrix multiplication?&lt;/em&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;You can think of $|0\rangle\langle0|$ as tensor product of $|0\rangle$ and $\langle0|$, or equivalently as the matrix multiplication (more precisely, &lt;a href=&quot;https://math.stackexchange.com/a/203950/173147&quot;&gt;Kronecker product&lt;/a&gt;) of the vectors representing them.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;em&gt;Also, I thought that we must always be able to write a projection operator in the form |ϕ⟩⟨ϕ|&lt;/em&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Not necessarily.&#xA;A projector will have that form if and only if it projects onto a one-dimensional space (that is, it projects onto a pure state).&#xA;More general projections, like the one you mention, do not have this feature, and that is totally fine.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Indeed, also the identity matrix is a (trivial) projection, and it certainly cannot be written as $|\psi\rangle\langle\psi|$ for any pure state $|\psi\rangle$.&lt;/p&gt;&#xA;" OwnerUserId="55" LastActivityDate="2018-06-09T14:21:04.037" CommentCount="1" />
  <row Id="2281" PostTypeId="2" ParentId="2278" CreationDate="2018-06-09T14:52:25.940" Score="1" Body="&lt;p&gt;One can more generally show that $R_z(\theta)=e^{-i \theta Z/2}=\cos(\theta/2)-iZ\sin(\theta/2)$ rotates points on the Bloch sphere by an angle $\theta$ around the $z$-axis, &#xA;and note that $Z=i R_z(\pi)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let $|\psi\rangle$ be an arbitrary pure state. The coordinates of the point representing $|\psi(\theta)\rangle\equiv R_z(\theta)|\psi\rangle$ on the Bloch sphere are&#xA;$$x(\theta)=\langle\psi(\theta)|X|\psi(\theta)\rangle, \\ y(\psi)=\langle\psi(\theta)|Y|\psi(\theta)\rangle, \\&#xA;z(\psi)=\langle\psi(\theta)|Z|\psi(\theta)\rangle.$$&#xA;That this point follows a circular trajectory around the $z$-axis when $\theta$ goes from $0$ to $2\pi$,&#xA;can be seen by direct calculation as follows:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{align}&#xA;x(\theta) &amp;amp;=\langle\psi\rvert R_z(-\theta)\,X\,R_z(\theta)\lvert\psi\rangle =&#xA;\cos\theta\,x(0) + \sin\theta\,y(0), \\&#xA;y(\theta) &amp;amp;=\langle\psi\rvert R_z(-\theta)\,Y\,R_z(\theta)\lvert\psi\rangle =&#xA;-\sin\theta\,x(0) + \cos\theta\,y(0), \\&#xA;z(\theta) &amp;amp;= z(0).&#xA;\end{align}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that the same is true more generally for &lt;em&gt;mixed&lt;/em&gt; states: the point representing $\rho(\theta)\equiv R_z(\theta)\rho R_z(\theta)^\dagger$ in the Bloch sphere is&#xA;$$\newcommand{\Tr}{\operatorname{Tr}}&#xA;x(\theta)=\Tr(X\rho(\theta)), \\&#xA;y(\theta)=\Tr(Y\rho(\theta)), \\&#xA;z(\theta)=\Tr(Z\rho(\theta)),$$&#xA;and one can show by direct calculation that this point evolves similarly to the pure case.&lt;/p&gt;&#xA;" OwnerUserId="55" LastActivityDate="2018-06-09T14:52:25.940" CommentCount="0" />
  <row Id="2282" PostTypeId="1" AcceptedAnswerId="2285" CreationDate="2018-06-10T12:34:51.797" Score="27" ViewCount="5800" Body="&lt;p&gt;Is it because we don't know exactly how to create quantum computers (and how they must work), or do we know how to create it in theory, but don't have the tools to actually execute it in practice? Is it a mix of the above two? Any other reasons?&lt;/p&gt;&#xA;" OwnerUserId="2559" LastActivityDate="2018-06-12T20:30:27.347" Title="Why is it harder to build quantum computers than classical computers?" Tags="&lt;quantum-computer&gt;&lt;quantum-information&gt;&lt;classical-computing&gt;" AnswerCount="6" CommentCount="6" FavoriteCount="9" />
  <row Id="2283" PostTypeId="1" CreationDate="2018-06-10T15:10:33.250" Score="7" ViewCount="50" Body="&lt;p&gt;During a description of &lt;strong&gt;zero-dimensional self-dual&lt;/strong&gt; $\text{GF}(4)$ &lt;strong&gt;quantum codes&lt;/strong&gt; in &lt;em&gt;&quot;On self-dual quantum codes, graphs, and Boolean functions&quot;&lt;/em&gt; by L.E. Danielsen, it states:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;A zero-dimensional stabilizer code with high distance represents a single quantum state which is robust to error, sometimes called a &lt;em&gt;stabilizer state&lt;/em&gt;. Codes of higher dimension can be constructed from zero-dimensional quantum codes...&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;My question has two parts:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Firstly, I am confused by what is meant here by a &quot;single quantum state&quot;. To my understanding, the passage seems to confuse the encoded 0-dimensional qubit state (which is robust to Pauli error), i.e. a single &quot;qubit&quot; state, with the single &quot;stabilizer&quot; state which is represented by the generators of the code (which is not robust to error, as a single Hadamard on any qubit would be sufficient to take it to a completely different stabilizer state). Is this the case, or am I misunderstanding something here?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Secondly, what form do these constructions take in practice? Is this simply achieved by not enforcing one of the stabilizer's generators, or are there other more general methods? Furthermore, if there are multiple construction methods, what are their advantages or disadvantages (both in the codes they create and/or the complexity of the construction)?&lt;/p&gt;&#xA;" OwnerUserId="391" LastEditorUserId="391" LastEditDate="2018-06-11T06:47:37.050" LastActivityDate="2018-06-11T08:45:34.513" Title="Zero-distance self-dual GF(4) quantum codes and constructing k &gt; 0 codes from them" Tags="&lt;quantum-error-correction&gt;&lt;stabilizer-code&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2284" PostTypeId="1" AcceptedAnswerId="2287" CreationDate="2018-06-10T16:39:21.193" Score="4" ViewCount="158" Body="&lt;p&gt;I know that 2 qubits are entangled if it is impossible to represent their joint state as a tensor product. But when we are given a joint state, how can we tell if it is possible to represent it as a tensor product?&#xA;For example, I am asked to tell if the qubits are entangled for each of the following situations: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\begin{align}&#xA;\left| 01 \right&amp;gt;\\&#xA;\frac 12(\left| 00  \right&amp;gt; + i\left| 01  \right&amp;gt; - i\left| 10  \right&amp;gt; +  i\left| 11  \right&amp;gt; )\\&#xA;\frac 12(\left| 00 \right&amp;gt; - \left| 11  \right&amp;gt;)\\&#xA;\frac 12(\left| 00  \right&amp;gt; + \left| 01  \right&amp;gt; +i\left| 10  \right&amp;gt; +  \left| 11  \right&amp;gt; )  \end{align}$$   &lt;/p&gt;&#xA;" OwnerUserId="2559" LastEditorUserId="26" LastEditDate="2018-06-11T06:09:43.597" LastActivityDate="2018-07-13T14:47:24.620" Title="How to check if 2 qubits are entangled?" Tags="&lt;qubit&gt;&lt;quantum-entanglement&gt;&lt;qubit-state&gt;&lt;quantum-state&gt;" AnswerCount="2" CommentCount="3" FavoriteCount="1" ClosedDate="2018-06-10T19:23:27.910" />
  <row Id="2285" PostTypeId="2" ParentId="2282" CreationDate="2018-06-10T17:11:54.527" Score="32" Body="&lt;p&gt;We know exactly, in theory, how to construct a quantum computer. But that is intrinsically more difficult than to construct a classical computer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In a classical computer, you do not have to use a single particle to encode bits. Instead, you might say that anything less than a billion electrons is a 0 and anything more than that is a 1, and aim for, say, two billion of electrons to encode a 1 normally. That makes you inherently fault-tolerant: Even if there are hundreds of millions of electrons more or less than expected, you will still get the correct classification as a digital 0 or a 1.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In a quantum computer, this trick is not possible due to the non-cloning theorem: You cannot trivially employ more than one particle to encode a qubit (quantum bit). Instead, you must make all your gates operate so well that they are not just accurate to the single particle level but even to a tiny fraction of how much they act on a single particle (to the so-called quantum-error correction threshold). This is much more challenging than to get gates accurate merely to within hundreds of millions of electrons.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Meanwhile we do have the tools to, just barely, make quantum computers with the required level of accuracy. But nobody has, as of yet, managed to make a big one meaning one that can accurately operate on the perhaps hundred of thousands of physical qubits needed to implement a hundred or so logical qubits to then be undeniably in the realm where the quantum computer beats classical computers at select problems (quantum supremacy).&lt;/p&gt;&#xA;" OwnerUserId="1039" LastEditorUserId="1039" LastEditDate="2018-06-10T19:00:35.420" LastActivityDate="2018-06-10T19:00:35.420" CommentCount="3" />
  <row Id="2286" PostTypeId="2" ParentId="2284" CreationDate="2018-06-10T18:12:31.430" Score="3" Body="&lt;p&gt;It is done for a specific state (a Bell state) &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2263/how-do-i-show-that-a-two-qubit-state-is-an-entangled-state&quot;&gt;here&lt;/a&gt;, and the same procedure can be used for any other two-qubit state.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-07-13T14:47:24.620" LastActivityDate="2018-07-13T14:47:24.620" CommentCount="0" />
  <row Id="2287" PostTypeId="2" ParentId="2284" CreationDate="2018-06-10T18:13:30.203" Score="2" Body="&lt;p&gt;If you are given a general 2-qubit state $a \mid 00 \rangle + b \mid 01 \rangle + c \mid 10 \rangle + d \mid 11 \rangle$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If it is unentangled, then the coefficients are that of $(\alpha \mid 0 \rangle + \beta \mid 1 \rangle)(\gamma\mid 0 \rangle + \delta \mid 1 \rangle)$ for some $\alpha .. \delta$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;\alpha \gamma = a\\&#xA;\alpha \delta = b\\&#xA;\beta \gamma = c\\&#xA;\beta \delta = d&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You want to know if those 4 equations are solvable for a given $a,b,c,d$. This question becomes&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;ad - bc = 0&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;so if $ad-bc=0$, then you can solve for $\alpha .. \delta$. You don't need to solve for them, you just need to need to know if it is possible.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The generalization for qudits with potentially different values of $d_1$ and $d_2$ are the quadratic polynomials that cut out the &lt;a href=&quot;https://en.wikipedia.org/wiki/Segre_embedding&quot; rel=&quot;nofollow noreferrer&quot;&gt;Segre embedding&lt;/a&gt; as a zero locus.&lt;/p&gt;&#xA;" OwnerUserId="434" LastActivityDate="2018-06-10T18:13:30.203" CommentCount="2" />
  <row Id="2288" PostTypeId="2" ParentId="2282" CreationDate="2018-06-10T22:04:44.807" Score="10" Body="&lt;p&gt;There's many reasons, both in theory and implementation, that make quantum computers much harder to build.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The simplest might be this: while it is easy to build machines that exhibit classical behaviour, demonstrations of quantum behaviour require really cold and really precisely controlled machines. The thermodynamic conditions of the quantum regime are just hard to access. When we finally do achieve a quantum system, it's hard to keep it isolated from the environment which seeks to decohere it and make it classical again. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Scalability is a big issue. The bigger our computer, the harder it is to keep quantum. The phenomena that promise to make quantum computers really powerful, like entanglement, require the qubits can interact with eachother in a controlled way. Architectures that allow this control are hard to engineer, and hard to scale. Nobody's agreed on a design!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As @pyramids points out, the strategies we use to correct errors in classical machines usually involve cloning information, which is forbidden by quantum information theory. While we have some strategies to mitigate errors in clever quantum ways, they require that are qubits are already pretty noise-free and that we have lots of them. If we can't improve our engineering past some threshold, we can't employ these strategies - they make things worse!&lt;/p&gt;&#xA;" OwnerUserId="2591" LastActivityDate="2018-06-10T22:04:44.807" CommentCount="1" />
  <row Id="2289" PostTypeId="1" CreationDate="2018-06-10T23:24:42.037" Score="5" ViewCount="81" Body="&lt;p&gt;I've accidentally written a procedure which appears to compute both outputs of a long-running function $f: \{0,1\} \to \{1...n\}$ using one run of $f$ plus $\mathcal{O}(n)$ time. I thought this couldn't be done. Where's the bug in my &quot;perpetuum mobile&quot;? If I'm wrong, what's the name of this technique?&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Initialize with $\sum_ic_i|i\rangle_x$, with $c_0$ initially, say, $\sqrt½$, and the invariant $\sum_ic_i^2 = 1$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Compute $f(x)$, producing: $\sum_ic_i|i\rangle_x|f_i\rangle$ (1). We never evaluate $f$ again, and our goal is to extract these $f_i$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Produce:&#xA;$$&#xA;\sqrt½\sum_ic_i|i\rangle_x|f_i\rangle(|i^{|a|}\rangle_a|f_i\rangle_b+2^{-|a+b|/2}\sum_{rs}|r\rangle_a|s\rangle_b)&#xA;$$&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Measure and discard the $a$ and $b$ registers, getting (1) with $c_0^2 \in \{1/(2+2^{|a|+|b|}), ½, 1-1/(2+2^{|a|+|b|})\}$, and in all probability we know which.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Use amplitude amplification, where the good and bad subspaces are distinguished using the $x$ qubit, to get $c_0^2$ between ⅛ and ⅞.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Repeat the last 3 *s a bunch of times.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;In all probability, we've measured $f_0$ and $f_1$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="2592" LastEditorUserId="2592" LastEditDate="2018-06-11T12:51:16.463" LastActivityDate="2018-06-11T13:51:22.320" Title="How does this parallel computation scheme fail?" Tags="&lt;quantum-algorithms&gt;" AnswerCount="2" CommentCount="4" />
  <row Id="2290" PostTypeId="2" ParentId="2282" CreationDate="2018-06-11T03:59:31.360" Score="0" Body="&lt;p&gt;I have to disagree with the idea that the no-cloning theorem make error correction with repetition codes difficult. Given that your inputs are provided in the computational basis (i.e. you inputs are not arbitrary superpositions, which is almost always the case, especially when you're solving a classical problem e.g.  Schor's algorithm), you can clone them with controlled-Not gates, run your computation in parallel on all the copies, and then correct errors. The only trick is to make sure you don't do a measurement during error-correction (except possible of the syndrome), and to do this all you have to do is continue to make use quantum gates.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Error correction for quantum computers is not much more difficult than for classical computers. Linearity takes can of most of the perceived difficulties.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I'd also like to mention that there are much more efficient schemes for quantum error correction than repetition codes. And that you need two pauli-matrices to generate the rest, so you need two types of repetition codes if you're going to go for the inefficient, but conceptually simple repetition code route (one for bit-flips and one for phase flips).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quantum error correction shows that linear increase in the number of physical qubits per logical qubit improves the error rate exponentially, just as it does in the classical case.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Still, we're nowhere near 100 physical qubits. This is the real problem. We need to be able to glue a lot more semi-accurate qubits together before any of this starts to matter.&lt;/p&gt;&#xA;" OwnerUserId="2595" LastEditorUserId="2595" LastEditDate="2018-06-11T14:06:38.463" LastActivityDate="2018-06-11T14:06:38.463" CommentCount="2" />
  <row Id="2291" PostTypeId="2" ParentId="2289" CreationDate="2018-06-11T06:56:46.657" Score="1" Body="&lt;p&gt;There's quite a lot that doesn't make sense in your described protocol, at least to me! It would be a lot clearer in terms of bras and kets. Let me try to translate, and you can comment to try and get us one the same page...&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Let $|x\rangle=(|0\rangle+|1\rangle)/\sqrt{2}$&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Compute $f(x)$, so you have $(|0\rangle|f(0)\rangle+|1\rangle|f(1)\rangle)/\sqrt{2}$&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Let $|m\rangle=(|0\rangle+|1\rangle)/\sqrt{2}$, so that we have an overall state&#xA;$$&#xA;(|0\rangle_m|000\ldots 0\rangle_a|f(0)\rangle_b+|1\rangle_m|111\ldots 1\rangle_a|f(1)\rangle_b)/\sqrt{2}&#xA;$$&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Measure the $a$ and $b$ registers.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;What I don't understand: you've defined $|x\rangle$ but never used it. You've initialised the registers $a$ and $b$, but overwritten them immediately (so why did you initialise them?). What amplitude is it that you think you want to amplify?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;With 50:50 probability, you either get $|0\rangle_m|000\ldots 0\rangle_a|f(0)\rangle_b$ or $|1\rangle_m|111\ldots 1\rangle_a|f(1)\rangle_b$. So, to get both values, you repeat until you've got both values. That requires a few runs. At best it takes 2, but you'd be better off just evaluating $f(0)$ and $f(1)$ by using two runs.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Update after question revision:&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;There are still issues with the description of the protocol: what is $d$, and how do you produce such a state with $d\neq0$? Surely you're better off just leaving $d=0$?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, i think we're now getting to the point of main misunderstanding, which is counting the circuit complexity. Every time you produce the state&#xA;$$&#xA;|\Psi_f\rangle=\sqrt½\sum_ic_i|i\rangle_x|f(i)\rangle(|i^{|a|}\rangle_a|f(i)\rangle_b+d\sum_{rs}|r\rangle_a|s\rangle_b)&#xA;$$&#xA;you have to evaluate the function $f(x)$. If that is the costly function to evaluate, you have to count the number of repetitions. You say &quot;Repeat the last 3 *s a bunch of times.&quot;, so that costs you a bunch of function evaluations, while just evaluating $f(0)$ and $f(1)$ costs you exactly 2 function evaluations. Moreover, to get 2 answers out, you must repeat your procedure at least twice, so you can never even get lucky and beat the naive classical case sometimes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that if you want to be able to copy the state $|\Psi_f\rangle$, then for all different functions $f(x)$, those states must be orthogonal. However, consider two different functions: $f(0)=f(1)=0$ and $g(0)=0,g(1)=1$. We have that $\langle\Psi_f|\Psi_g\rangle\neq 0$.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-06-11T09:28:25.580" LastActivityDate="2018-06-11T09:28:25.580" CommentCount="7" />
  <row Id="2292" PostTypeId="1" AcceptedAnswerId="2374" CreationDate="2018-06-11T07:07:03.777" Score="11" ViewCount="175" Body="&lt;p&gt;There are many fairly standard quantum algorithms that can all be understood within a very similar framework, from Deutsch's algorithm Simon's problem, Grover's search, Shor's algorithm and so on.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One algorithm that seems to be completely different is the algorithm for evaluating the &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0511096&quot; rel=&quot;nofollow noreferrer&quot;&gt;Jones Polynomial&lt;/a&gt;. Moreover, it seems like this is a crucial algorithm to understand in the sense that it is a &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0001108&quot; rel=&quot;nofollow noreferrer&quot;&gt;BQP-complete&lt;/a&gt; problem: it exhibits the full power of a quantum computer. Also, for a variant of the problem, it's &lt;a href=&quot;https://arxiv.org/abs/0707.2831&quot; rel=&quot;nofollow noreferrer&quot;&gt;DQC-1 complete&lt;/a&gt;, i.e. it exhibits the full power of &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9802037&quot; rel=&quot;nofollow noreferrer&quot;&gt;one clean qubit&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0511096&quot; rel=&quot;nofollow noreferrer&quot;&gt;Jones Polynomial algorithm&lt;/a&gt; paper presents the algorithm in a very different way to the other quantum algorithms. Is there a more similar/familiar way that I can understand the algorithm (specifically, the unitary $U$ in the DQC-1 variant, or just the whole circuit in the BQP-complete variant)?&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-06-15T13:26:44.420" LastActivityDate="2018-06-17T23:52:35.393" Title="Jones Polynomial" Tags="&lt;quantum-algorithms&gt;&lt;circuit-model&gt;&lt;bqp&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="2293" PostTypeId="2" ParentId="2283" CreationDate="2018-06-11T08:27:48.367" Score="1" Body="&lt;p&gt;For the first part of the question, I think that with &quot;single quantum state&quot;, the author is referring to the encoded quantum state, which will be an state formed by $n$-qubits. Such state is called stabilizer state because the encoding operation takes the input state, in this case $|0\rangle^{\otimes n}$, and takes it to a state in the codespace defined by the stabilizers. This code space is defined to be the $+1$ simultaneous eigenspace of the stabilizer operators, and in general has dimension $2^k$, so as in this case $k=0$, the dimension of this codespace will be $1$. Consequently, the author is trying to state that such zero-dimensional stabilizer codes refer to the basis of such $1$ dimensional subspace, which will be just a single quantum state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Also the author says that such state is robust to errors because an stabilizer error correction code is being applied to the state, and so errors will be correctable. Obviously a Hadamard gate would change the encoded state, but I think that with robust, the author is trying to say that the state can be corrected after the appearance of Pauli errors, that is $\{X,Y,Z\}^{\otimes n}$ operators applied to the state. This robustness obviously comes from the fact that an error-correction code is being applied to the $n$-ancilla qubit input state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then this codes would be obtainded by finding such encoding operator that would take the input $n$-state to the $+1$ simultaneous eigenspace that the $n$ stabilizer generators define (Note that in general ${n-k}$ generators are needed and that here $k=0$). I don't know what do you exactly want to say with the frase &quot;enforcing one of the stabilizer's generators&quot;. To find out the encoder unitary, most of the times, combinations of so-called Clifford gates are used, there are differents methods and algorithms in literature that are useful for finding the exact combination.&lt;/p&gt;&#xA;" OwnerUserId="2371" LastEditorUserId="2371" LastEditDate="2018-06-11T08:45:34.513" LastActivityDate="2018-06-11T08:45:34.513" CommentCount="2" />
  <row Id="2294" PostTypeId="2" ParentId="2282" CreationDate="2018-06-11T08:33:23.620" Score="1" Body="&lt;p&gt;One important point is that quantum computers contain classical computers. So it must be at least as hard to build a quantum computer as it is a classical computer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For a concrete illustration, it's worth thinking about universal gate sets. In classical computation, you can create any circuit you want via the combination of just a single type of gate. Often people talk about the NAND gate, but for the sake of this argument, it's easier to talk about the Toffoli gate (also known as the controlled-controlled-not gate). Every classical (reversible) circuit can be written in terms of a whole bunch of Toffolis. An arbitrary quantum computation can be written as a combination of two different types of gate: the Toffoli and the Hadamard.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This has immediate consequences. Obviously, if you're asking for two different things, one of which does not exist in classical physics, that must be harder than just making the one thing that does exist in classical physics. Moreover, making use of the Hadamard means that the sets of possible states you have to consider are no longer orthogonal, so you cannot simply look at the state and determine how to proceed. This is particularly relevant to the Toffoli, because it becomes harder to implement as a result: before, you could safely measure the different inputs and, dependent upon their values, do something to the output. But if the inputs are not orthogonal (or even if they are, but in an unknown basis!) you cannot risk measuring them because you will destroy the states, specifically, you destroy the superpositions that are the whole thing that's making quantum computation different from classical computation.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-11T08:33:23.620" CommentCount="2" />
  <row Id="2295" PostTypeId="1" AcceptedAnswerId="2325" CreationDate="2018-06-11T08:34:07.303" Score="6" ViewCount="58" Body="&lt;p&gt;In &lt;em&gt;On the classification of all self-dual additive codes over $\textrm{GF}(4)$ of length up to 12&lt;/em&gt; by Danielsen and Parker, they state: &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Two self-dual additive codes over $\textrm{GF}(4)$, $C$ and $C^\prime$, are equivalent if and only if the codewords of $C$ can be mapped onto the codewords of $C^\prime$ by a map that preserves self-duality. Such a map must consist of a permutation of coordinates (columns of the generator matrix), followed by multiplication of coordinates by nonzero elements from $\textrm{GF}(4)$, followed by possible conjugation of coordinates.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;with the previous definition &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Conjugation of $x \in \textrm{GF}(4)$ is defined by $\bar{x} = x^2$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I am confused what &quot;conjugation of coordinates&quot; means in this context. To me &quot;coordinates&quot; would normally refers to the code matrix's columns, or equivalently the quantum code's qubits. However, here it seems to be referring to the alphabet of the code, or equivalently the Pauli operators of the code's stabilizer generators. If this is the case, what operation does &quot;conjugation of coordinates&quot; represent with respect to the code's stabilizer generators?&lt;/p&gt;&#xA;" OwnerUserId="391" LastActivityDate="2018-06-13T09:19:46.773" Title="What does &quot;conjugation of coordinates&quot; mean with respect to GF(4) (quantum) codes" Tags="&lt;quantum-error-correction&gt;&lt;stabilizer-code&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2296" PostTypeId="1" AcceptedAnswerId="2297" CreationDate="2018-06-11T10:28:40.287" Score="5" ViewCount="104" Body="&lt;p&gt;I came across with a problem that involves $2$ quantum trits in state $\left| 22 \right&amp;gt;.$ What is it's tensor product interpretation and a matrix interpretation?&lt;/p&gt;&#xA;" OwnerUserId="2559" LastEditorUserId="2559" LastEditDate="2018-06-11T11:04:57.900" LastActivityDate="2018-06-11T11:04:57.900" Title="What is the $\left| 22\right&gt;$ state?" Tags="&lt;qubit&gt;&lt;qubit-state&gt;&lt;quantum-state&gt;" AnswerCount="1" CommentCount="3" />
  <row Id="2297" PostTypeId="2" ParentId="2296" CreationDate="2018-06-11T10:49:55.480" Score="5" Body="&lt;p&gt;It is worth emphasising that the stuff that you write inside a ket is completely arbitrary. It's just a label you're attaching to something, so it should have a proper definition somewhere. Now, usually, we're talking about quantum spins with a certain size of Hilbert space, say $d$. &lt;em&gt;Probably&lt;/em&gt; here you're talking $d\geq 3$, and perhaps specifically $d=3$. Then, one set of basis states is often written as $|i\rangle$ for $i=0,1,\ldots d-1$. You can choose to represent these as vectors $(0,0,\ldots,0,1,0,0,\ldots 0)$ where the 1 is the $i+1$th entry, and there are $d$ entries. So, I guess you're talking about&#xA;$$&#xA;|2\rangle\equiv\left(\begin{array}{c} 0 \\ 0 \\ 1 \end{array}\right)&#xA;$$&#xA;The tensor product $|2\rangle\otimes|2\rangle$ then has the standard meaning.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-11T10:49:55.480" CommentCount="0" />
  <row Id="2298" PostTypeId="1" CreationDate="2018-06-11T11:18:19.460" Score="5" ViewCount="61" Body="&lt;p&gt;One of the main ideas introduced in Giovannetti &lt;em&gt;et al.&lt;/em&gt; 2007 &#xA;(&lt;a href=&quot;https://arxiv.org/abs/0708.1879&quot; rel=&quot;noreferrer&quot;&gt;0708.1879&lt;/a&gt;) is the so-called &lt;em&gt;bucket-brigade&lt;/em&gt; (q)RAM architecture.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The authors state (first paragraph, second column, first page, in v2) that this new (at the time) (q)RAM architecture &lt;em&gt;reduces the number of switches that must be thrown during a RAM call, quantum or classical, from $O(N^{1/d})$ to $O(\log N)$&lt;/em&gt;, where $N=2^n$ is the number of memory slots in the RAM and $d$ is the dimension of the lattice that, according to the authors, conventional RAM architectures use for memory retrieval.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The conventional architecture they have in mind essentially consists in retrieving the information using a tree structure, like the one they present in their Fig. 1 (here reproduced):&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/foz0w.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/foz0w.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;They say that this scheme requires to throw $O(N)$ switches for each memory call, but I don't understand why is this the case.&#xA;From the above, it would seem that one just needs to throw $O(\log_2(N))$ &#xA;switches, one per bifurcation, to get from the top to the bottom.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I understand that in the quantum case, with this protocol, we would end up with a state correlated with all of the $N$ switches, but they seem to be stating that even in the classical case one needs to activate them all.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In other words, is the advantage of the bucket-brigade approach only in the higher error resilience in the quantum case, or would it also be classically advantageous, compared with the conventional approaches?&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-06-11T11:35:02.850" LastActivityDate="2018-06-18T13:26:25.050" Title="Are bucket-brigate (q)RAM architectures also advantageous in the classical case?" Tags="&lt;quantum-memory&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="2299" PostTypeId="1" AcceptedAnswerId="2300" CreationDate="2018-06-11T13:08:53.187" Score="11" ViewCount="649" Body="&lt;p&gt;If a circuit takes more than one qubit as its input and has quantum gates which take different numbers of qubits as their input, how would we interpret this circuit as a matrix?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here is a toy example:$$&#xA;\def\place#1#2#3{\smash{\rlap{\hskip{#1px}\raise{#2px}{#3}}}}&#xA;\def\hline#1#2#3{\place{#1}{#2}{\rule{#3px}{1px}}}&#xA;\def\vline#1#2#3{\place{#1}{#2}{\rule{1px}{#3px}}}&#xA;%&#xA;\hline{  0}{ 50}{200}&#xA;\hline{  0}{100}{200}&#xA;%&#xA;\vline{100}{ 50}{ 50}&#xA;%&#xA;\place{ 95}{ 95}{\large{\bullet}}&#xA;\place{ 77}{ 46}{\gt}&#xA;\place{ 86}{ 41}{\huge{\oplus}}&#xA;%&#xA;\place{ 23}{ 96}{\gt}&#xA;\place{ 35}{ 88}{\rule{27px}{27px}}&#xA;\place{ 37}{ 90}{\color{white}{\rule{23px}{23px}}}&#xA;\place{ 41}{ 94}{\large{\textsf{H}}}&#xA;%&#xA;\place{123}{ 96}{\gt}&#xA;\place{135}{ 88}{\rule{27px}{27px}}&#xA;\place{137}{ 90}{\color{white}{\rule{23px}{23px}}}&#xA;\place{141}{ 94}{\large{\textsf{H}}}&#xA;%&#xA;\place{197}{ 46}{\blacktriangleright}&#xA;\place{197}{ 96}{\blacktriangleright}&#xA;%&#xA;\phantom{\rule{210px}{125px}}&#xA;$$&lt;/p&gt;&#xA;" OwnerUserId="2559" LastEditorUserId="1847" LastEditDate="2018-06-12T14:33:48.420" LastActivityDate="2018-07-24T17:58:40.527" Title="How to interpret a quantum circuit as a matrix?" Tags="&lt;qubit&gt;&lt;quantum-gate&gt;&lt;circuit-model&gt;&lt;quantum-state&gt;&lt;matrix-representation&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="3" />
  <row Id="2300" PostTypeId="2" ParentId="2299" CreationDate="2018-06-11T13:37:10.290" Score="15" Body="&lt;h2&gt;Specific Circuit&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;The first gate is a Hadamard gate which is normally represented by $$\frac{1}{\sqrt{2}}\begin{bmatrix}1&amp;amp;1\\1&amp;amp;-1\end{bmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, since we're only applying it to the first qubit, we use a kronecker product on it (this confused me so much when I was starting out - I had no idea how to scale gates; as you can imagine, it's rather important), so we do $H\otimes I$, where $I$ is the 2x2 identity matrix. This produces&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\frac{1}{\sqrt{2}}\begin{bmatrix}1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0\\0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1\\ 1 &amp;amp; 0 &amp;amp; -1 &amp;amp; 0 \\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; -1\end{bmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Next we have a CNOT gate. This is normally represented by &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\begin{bmatrix}1&amp;amp;0&amp;amp;0&amp;amp;0\\0&amp;amp;1&amp;amp;0&amp;amp;0\\0&amp;amp;0&amp;amp;0&amp;amp;1\\0&amp;amp;0&amp;amp;1&amp;amp;0\end{bmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is the right size for two qubits, so we don't need to scale using kronecker products. We then have another hadamard gate, which scales the same was as the first. To find the overall matrix for the circuit, then, we multiply them all together:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\frac{1}{\sqrt{2}}\begin{bmatrix}1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0\\0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1\\ 1 &amp;amp; 0 &amp;amp; -1 &amp;amp; 0 \\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; -1\end{bmatrix}\begin{bmatrix}1&amp;amp;0&amp;amp;0&amp;amp;0\\0&amp;amp;1&amp;amp;0&amp;amp;0\\0&amp;amp;0&amp;amp;0&amp;amp;1\\0&amp;amp;0&amp;amp;1&amp;amp;0\end{bmatrix}\frac{1}{\sqrt{2}}\begin{bmatrix}1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0\\0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1\\ 1 &amp;amp; 0 &amp;amp; -1 &amp;amp; 0 \\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; -1\end{bmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;and get&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\frac{1}{2}\begin{bmatrix}1&amp;amp;1&amp;amp;1&amp;amp;-1\\1&amp;amp;1&amp;amp;-1&amp;amp;1\\1&amp;amp;-1&amp;amp;1&amp;amp;1\\-1&amp;amp;1&amp;amp;1&amp;amp;1\end{bmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(if python multiplied correctly =) We would then multiply this by our original qubit state, and get our result.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Generalization&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;So basically, you go through each gate one by one, take the base representation, and scale them appropriately using kronecker products with identity matrices. Then you multiply all the matrices together in the order they are applied. Be sure to do this such that if you wrote out the multiplication, the very first gate is on the far right; as arriopolis points out, this is a common mistake. Matrices are not commutative! If you don't know the base representation of a matrix, check first &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_gates&quot; rel=&quot;noreferrer&quot;&gt;wikipedia's article on quantum gates&lt;/a&gt; which has a lot.&lt;/p&gt;&#xA;" OwnerUserId="91" LastEditorUserId="91" LastEditDate="2018-06-12T13:22:05.087" LastActivityDate="2018-06-12T13:22:05.087" CommentCount="4" />
  <row Id="2301" PostTypeId="2" ParentId="2289" CreationDate="2018-06-11T13:51:22.320" Score="0" Body="&lt;p&gt;Ampltiude amplification seems to require both that it is easy to judge between good and bad (which is easy enough if one goes by the $x$ qubit), and that it is easy to get to one's starting point, which in this case requires evaluating $f$.&lt;/p&gt;&#xA;" OwnerUserId="2592" LastActivityDate="2018-06-11T13:51:22.320" CommentCount="0" />
  <row Id="2302" PostTypeId="1" AcceptedAnswerId="2304" CreationDate="2018-06-11T15:16:39.920" Score="7" ViewCount="238" Body="&lt;p&gt;What does it mean to measure a qubit (or multiple qubits) in standard basis?&lt;/p&gt;&#xA;" OwnerUserId="2559" LastActivityDate="2018-06-11T16:06:29.290" Title="Measuring in standard basis meaning" Tags="&lt;qubit&gt;&lt;qubit-state&gt;&lt;measurement&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="2303" PostTypeId="2" ParentId="2302" CreationDate="2018-06-11T15:19:41.880" Score="3" Body="&lt;p&gt;You define the projectors&#xA;$$&#xA;P_0=|0\rangle\langle 0|=\left(\begin{array}{cc} 1 &amp;amp; 0 \\ 0 &amp;amp; 0 \end{array}\right)\qquad P_1=|1\rangle\langle 1|=\left(\begin{array}{cc} 0 &amp;amp; 0 \\ 0 &amp;amp; 1 \end{array}\right).&#xA;$$&#xA;For any state $|\psi\rangle$, the probability of getting answer $x$ is $p_x=\langle\psi|P_x|\psi\rangle$ and, after the measurement, the qubit is in the state $|x\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you want to measure multiple (say $n$) qubits in the standard basis, you can take arbitrary tensor products of the single-qubit terms,&#xA;$$&#xA;P_x=|x\rangle\langle x|=\bigotimes_{i=1}^nP_{x_i}&#xA;$$&#xA;for $x\in\{0,1\}^n$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Where you have to be a little more careful is if you're measuring only a subset of qubits. Then, the probability is still $p_x=\langle\psi|P_x|\psi\rangle$, but the output state is $P_x|\psi\rangle/\sqrt{p_x}$, which could still be a superposition of multiple basis states (all those for which the measured qubits correspond to $x$).&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-11T15:19:41.880" CommentCount="0" />
  <row Id="2304" PostTypeId="2" ParentId="2302" CreationDate="2018-06-11T15:45:44.460" Score="6" Body="&lt;p&gt;A $1$-qubit system, in general, can be in a state $a|0\rangle+b|1\rangle$ where $|0\rangle$ and $|1\rangle$ are basis vectors of a two dimensional complex vector space. The &lt;strong&gt;standard basis&lt;/strong&gt; for measurement here is $\{|0\rangle,|1\rangle\}$. When you are measuring in this basis, with $\frac{|a|^2}{|a|^2+|b|^2}\times 100\%$ probability you will find that the state after measurement is $|0\rangle$ and with $\frac{|b|^2}{|a|^2+|b|^2}\times 100\%$ you'll find that the state after measurement is $|1\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But you could carry out the measurement in some other basis too, say $\{\frac{|0\rangle+|1\rangle}{\sqrt{2}},\frac{|0\rangle-|1\rangle}{\sqrt{2}}\}$, but that wouldn't be the &lt;strong&gt;standard basis&lt;/strong&gt;.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;Exercise&lt;/strong&gt;: Express $a|0\rangle+b|1\rangle$ in the form $c(\frac{|0\rangle+|1\rangle}{\sqrt{2}})+d(\frac{|0\rangle-|1\rangle}{\sqrt{2}})$&#xA;  where $a,b,c,d\in\Bbb C$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;If you measure in the basis the probability of ending in the state $\frac{|0\rangle+|1\rangle}{\sqrt{2}}$ after a measurement is $\frac{|c|^2}{|c|^2+|d|^2}\times 100\%$ and probability of ending in the state $\frac{|0\rangle-|1\rangle}{\sqrt{2}}$ is $\frac{|d|^2}{|c|^2+|d|^2}\times 100\%$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Similarly, for a $2$-qubit system the standard basis would $\{|00\rangle,|01\rangle,|10\rangle,|11\rangle\}$ and its general state can be expressed as $\alpha|00\rangle + \beta|01\rangle + \gamma|10\rangle + \delta|11\rangle$. When you measure this in the standard basis you can easily see that the probability of ending up in the state (say) $|00\rangle$ will be $\frac{|\alpha|^2}{|\alpha|^2+|\beta|^2+|\gamma|^2+|\delta|^2}\times 100\%$. Similarly you can deduce the probabilities for the other states.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You should be able to extrapolate this same logic to general $n$-qubit states, now. Feel free to ask questions in the comments.&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-06-11T16:06:29.290" LastActivityDate="2018-06-11T16:06:29.290" CommentCount="0" />
  <row Id="2305" PostTypeId="2" ParentId="2292" CreationDate="2018-06-11T17:09:30.193" Score="2" Body="&lt;p&gt;You have mentioned five papers in the question, but one paper that remains unmentioned is the &lt;a href=&quot;https://arxiv.org/abs/0909.1550&quot; rel=&quot;nofollow noreferrer&quot;&gt;experimental implementation in 2009&lt;/a&gt;. Here you will find the actual circuit that was used to evaluate a Jones polynomial:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/TgewZ.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/TgewZ.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This might be the closest you will get to a &quot;more familiar&quot; presentation of the algorithm, as interest in the Jones polynomial and in DQC-1 have decayed a bit since 2009.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;More details on this experiment can be found in Gina Passante's &lt;a href=&quot;https://uwspace.uwaterloo.ca/handle/10012/6594&quot; rel=&quot;nofollow noreferrer&quot;&gt;thesis&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-06-14T20:00:36.673" LastActivityDate="2018-06-14T20:00:36.673" CommentCount="2" />
  <row Id="2306" PostTypeId="1" AcceptedAnswerId="2307" CreationDate="2018-06-11T20:18:39.413" Score="8" ViewCount="107" Body="&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1803.11173&quot; rel=&quot;nofollow noreferrer&quot;&gt;Here&lt;/a&gt; the authors argue that the efforts of creating a scalable quantum neural network using a set of parameterized gates are deemed to fail for a large number of qubits. This is due to the fact that, due to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Levi%27s_lemma&quot; rel=&quot;nofollow noreferrer&quot;&gt;Levy's Lemma&lt;/a&gt;, the gradient of a function in high dimensional spaces is almost zero everywhere. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I was wondering if this argument can be also applied to other hybrid quantum-classical optimization methods, like &lt;strong&gt;VQE&lt;/strong&gt; (Variational Quantum Eigensolver) or &lt;strong&gt;QAOA&lt;/strong&gt; (Quantum Approximate Optimization Algorithm). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;What do you think?&lt;/p&gt;&#xA;" OwnerUserId="1644" LastEditorUserId="26" LastEditDate="2018-06-12T05:33:26.817" LastActivityDate="2018-06-12T05:33:26.817" Title="Barren plateaus in quantum neural network training landscapes" Tags="&lt;quantum-algorithms&gt;&lt;quantum-speedup&gt;&lt;neural-network&gt;&lt;optimization&gt;" AnswerCount="1" CommentCount="5" />
  <row Id="2307" PostTypeId="2" ParentId="2306" CreationDate="2018-06-12T00:47:44.990" Score="3" Body="&lt;p&gt;&lt;strong&gt;First&lt;/strong&gt;: The paper references [&lt;a href=&quot;http://www.math.univ-toulouse.fr/~ledoux/Villani2.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;37&lt;/a&gt;] for Levy's Lemma, but you will find no mention of &quot;Levy's Lemma&quot; in [37]. You will find it called &quot;Levy's Inequality&quot;, which is called Levy's Lemma in &lt;a href=&quot;http://www.mpmueller.net/seminar/talk7.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;this&lt;/a&gt;, which is &lt;em&gt;not&lt;/em&gt; cited in the paper you mention.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Second&lt;/strong&gt;: There is an easy proof that this claim is false for VQE. In quantum chemistry we optimize the parameters of a wavefunction ansatz $|\Psi(\vec{p})\rangle$ in order to get the lowest (i.e. most accurate) energy. The energy is evaluated by:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;E_{\vec{p}} = \frac{\left\langle \Psi(\vec{p})\right|H\left|\Psi(\vec{p})\right\rangle}{\left\langle\Psi(\vec{p}) \right|\left.\Psi(\vec{p}) \right\rangle}. &#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;VQE just means we use a quantum computer to evaluate this energy, and a classical computer to choose how to improve the parameters in $\vec{p}$ so that the energy will be lower in the next quantum iteration. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;So whether or not the &quot;gradient will be will be 0 almost everywhere when the number of parameters in $\vec{p}$ is large&quot; does not depend at all on whether we are using VQE (on a quantum computer) or just running a standard quantum chemistry program (like &lt;a href=&quot;https://en.wikipedia.org/wiki/Gaussian_(software)&quot; rel=&quot;nofollow noreferrer&quot;&gt;Gaussian&lt;/a&gt;) on a classical computer. Quantum chemists typically variationally optimize the above energy with up to $10^{10}$ parameters in $\vec{p}$, and the only reason we don't go beyond that is because we run out of RAM, not because the energy landscape starts to become flat. In this paper you can see at the end of the abstract that they calculated the energy for a wavefunction with about &lt;a href=&quot;https://arxiv.org/pdf/1707.04346.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;$10^{12}$ parameters&lt;/a&gt;, where the parameters are coefficients of Slater determinants. It is generally known that the energy landscape is not so flat (like it would be if the gradient were 0 almost everywhere) even when there's a trillion parameters or even more.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;: The application of Levy's Lemma is going to depend on the particular energy landscape that you have, which will depend on both  $H$ and your ansatz $|\Psi(\vec{p})\rangle$. In the case of their particular implementation of QNN's, they have found an application of Levy's Lemma to be appropriate. In the case of VQE, we have a counter-example to the claim that Levy's Lemma &quot;always&quot; applies. The counter example where Levy's Lemma does not apply is when $H$ is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Molecular_Hamiltonian&quot; rel=&quot;nofollow noreferrer&quot;&gt;molecular Hamiltonian&lt;/a&gt; and $|\Psi\rangle$ is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Configuration_interaction&quot; rel=&quot;nofollow noreferrer&quot;&gt;CI&lt;/a&gt; wavefunction.  &lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-06-12T00:47:44.990" CommentCount="0" />
  <row Id="2308" PostTypeId="2" ParentId="2275" CreationDate="2018-06-12T06:52:33.563" Score="1" Body="&lt;p&gt;A projection operator $P$ has two key properties:&#xA;$$&#xA;P^\dagger=P\qquad P^2=P&#xA;$$&#xA;A particularly simple instance of a projection operator is a rank 1 projector, $P=|\phi\rangle\langle\phi|$, which you can easily see satisfies the two properties given that $|\phi\rangle$ is a normalised state, so $\langle\phi|\phi\rangle=1$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To see what rank the projector is, simply evaluate $\text{rank}(P)=\text{Tr}(P)$. In your state example of $P=|0\rangle\langle 0|+|2\rangle\langle 2|$, you can see that the rank is 2, so it cannot be written as a rank 1 projector $|\phi\rangle\langle\phi|$.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-12T06:52:33.563" CommentCount="0" />
  <row Id="2309" PostTypeId="2" ParentId="2282" CreationDate="2018-06-12T07:57:06.303" Score="0" Body="&lt;h1&gt;Ultimate Black Box&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;A quantum computer is by definition the ultimate black box. You feed in an input and you get a process, which produces an output.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Any attempt to open up the black box, will result in the process not happening.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Any engineer would tell you that would hinder any design process. Even the smallest design flaw would takes months of trial and error to trace down.&lt;/p&gt;&#xA;" OwnerUserId="2622" LastActivityDate="2018-06-12T07:57:06.303" CommentCount="0" />
  <row Id="2310" PostTypeId="1" AcceptedAnswerId="2314" CreationDate="2018-06-12T09:48:37.680" Score="11" ViewCount="1108" Body="&lt;p&gt;Given a $2$ qubit-system and thus $4$ possible measurements results in the basis $\{|00\rangle$, $|01\rangle$, $|10\rangle$, $|11\rangle\}$, how can I prepare the state, where:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;only $3$ of these $4$ measurement results are possible (say, $|00\rangle$, $|01\rangle$, $|10\rangle$)?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;these measurements are equally likely? (like Bell state but for $3$ outcomes)&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="2624" LastEditorUserId="55" LastEditDate="2018-06-12T14:01:22.067" LastActivityDate="2018-06-12T14:01:22.067" Title="How can I build a circuit to generate an equal superposition of 3 outcomes for 2 qubits?" Tags="&lt;qubit-state&gt;&lt;measurement&gt;&lt;circuit-model&gt;&lt;superposition&gt;" AnswerCount="3" CommentCount="5" FavoriteCount="3" />
  <row Id="2312" PostTypeId="2" ParentId="2310" CreationDate="2018-06-12T12:28:49.647" Score="6" Body="&lt;p&gt;I'll tell you how to create &lt;em&gt;any&lt;/em&gt; two qubit pure state you might ever be interested in. Hopefully you can use it to generate the state you want.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Using a single qubit rotation followed by a cnot, it is possible to create states of the form&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ \alpha \, |0\rangle \otimes |0\rangle + \beta \, |1\rangle \otimes |1\rangle .$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then you can apply an arbitrary unitary, $U$, to the first qubit. This rotates the $|0\rangle$ and $|1\rangle$ states to new states that we'll call $|a_0\rangle$ and $|a_1\rangle$,&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$U |0\rangle = |a_0\rangle, \,\,\, U |1\rangle = |a_1\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Our entangled state is then&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\alpha \, |a_0\rangle \otimes |0\rangle + \beta \, |a_1\rangle \otimes |1\rangle .$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We can similarly apply a unitary to the second qubit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$V |0\rangle = |b_0\rangle, \,\,\, V |1\rangle = |b_1\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;which gives us the state&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\alpha \, |a_0\rangle \otimes |b_0\rangle + \beta \, |a_1\rangle \otimes |b_1\rangle .$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Due to the Schmidt decomposition, it is possible to express any pure state of two qubits in the form above. This means that any pure state of two qubits, including the one you want, can be created by this procedure. You just need to find the right rotation around the x axis, and the right unitaries $U$ and $V$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To find these, you first need to get the reduced density matrix for each of your two qubits. The eigenstates for the density matrix of your first qubit will be your $|a_0\rangle$ and $|a_1\rangle$. The eigenstates for the second qubit will be $|b_0\rangle$ and $|b_1\rangle$. You'll also find that $|a_0\rangle$ and $|b_0\rangle$ will have the same eigenvalue, which is $\alpha^2$. The coefficient $\beta$ can be similarly derived from the eigenvalues of $|a_1\rangle$ and $|b_1\rangle$.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-06-12T12:28:49.647" CommentCount="0" />
  <row Id="2313" PostTypeId="2" ParentId="2310" CreationDate="2018-06-12T12:30:27.517" Score="3" Body="&lt;p&gt;Here is how you might go about &lt;em&gt;designing&lt;/em&gt; such a circuit.$\def\ket#1{\lvert#1\rangle}$&#xA;Suppose that you would like to produce the state $\ket{\psi} = \tfrac{1}{\sqrt 3} \bigl( \ket{00} + \ket{01} + \ket{10} \bigr)$. Note the normalisation of ${\small 1}/\small \sqrt 3$, which is necessary for $\ket{\psi}$ to be a unit vector.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we want to consider a straightforward way to realise this state, we might want to think in terms of the first qubit being a control, which determines whether the second qubit should be in the state $\ket{+} = \tfrac{1}{\sqrt 2}\bigl(\ket{0}+\ket{1}\bigr)$, or in the state $\ket{0}$, by using some conditional operations. This motivates considering the decomposition&#xA;$$ \ket{\psi} \;=\; \tfrac{\sqrt 2}{\sqrt 3}\ket{0}\ket{+} \;+\; \tfrac{1}{\sqrt 3}\ket{1}\ket{0}.$$&#xA;Taking this view it makes sense to consider preparing $\ket{\psi}$ as follows:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Prepare two qubits in the state $\ket{00}$.&lt;/li&gt;&#xA;&lt;li&gt;Rotate the first qubit so that it is in the state $\tfrac{\sqrt 2}{\sqrt 3}\ket{0} + \tfrac{1}{\sqrt 3}\ket{1}$.&lt;/li&gt;&#xA;&lt;li&gt;Apply a coherently controlled operation on the two qubits which, when the first qubit is in the state $\ket{0}$, performs a Hadamard on the second qubit.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Which specific operations you would apply to realise these transformations &amp;mdash; &lt;em&gt;i.e.&lt;/em&gt;&amp;nbsp;which single-qubit transformation would be most suitable for step&amp;nbsp;2, and how you might decompose the two-qubit unitary in step&amp;nbsp;3 into CNOTs and Pauli rotations &amp;mdash; is a simple exercise. (Hint: use the fact that both $X$ and the Hadamard are self-inverse to find as simple a decomposition as possible in step&amp;nbsp;3.)&lt;/p&gt;&#xA;" OwnerUserId="124" LastActivityDate="2018-06-12T12:30:27.517" CommentCount="0" />
  <row Id="2314" PostTypeId="2" ParentId="2310" CreationDate="2018-06-12T12:46:05.623" Score="9" Body="&lt;p&gt;Break the problem in parts. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Say we have already sent $\mid 00 \rangle$ to $\frac{1}{\sqrt{3}} \mid 00 \rangle + \frac{\sqrt{2}}{\sqrt{3}}\mid 01 \rangle$. We can send that to $\frac{1}{\sqrt{3}} \mid 00 \rangle + (\frac{1}{2} (1+i))\frac{\sqrt{2}}{\sqrt{3}}\mid 01 \rangle + (\frac{1}{2} (1-i))\frac{\sqrt{2}}{\sqrt{3}}\mid 10 \rangle$ by a $\sqrt{SWAP}$. That satisfies you're requirements with all probabilities $\frac{1}{3}$ but with different phases. If you want use phase shift gates on each to get the phases you want like if you want to make them all equal.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now how do we get from $\mid 00 \rangle$ to $\frac{1}{\sqrt{3}} \mid 00 \rangle + \frac{\sqrt{2}}{\sqrt{3}}\mid 01 \rangle$? If it was $\frac{1}{\sqrt{2}} \mid 00 \rangle + \frac{1}{\sqrt{2}}\mid 01 \rangle$, we could do a Hadamard on the second qubit. It is not a easy with this but we can still use a unitary only on the second qubit. That is done by a rotation operator purely on the second qubit by factoring as &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$Id \otimes U : \; \mid 0 \rangle \otimes (\mid 0 \rangle) \to &#xA;\mid 0 \rangle \otimes (\frac{1}{\sqrt{3}} \mid 0 \rangle + \frac{\sqrt{2}}{\sqrt{3}} \mid 1 \rangle)&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;U = \begin{pmatrix}&#xA;\frac{1}{\sqrt{3}} &amp;amp; \frac{\sqrt{2}}{\sqrt{3}} &amp;amp; \\&#xA;\frac{\sqrt{2}}{\sqrt{3}} &amp;amp; -\frac{1}{\sqrt{3}} &amp;amp; \\&#xA;\end{pmatrix}&#xA;$$ works. Decompose this into more basic gates if you need to.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In total we have:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;\mid 00 \rangle \to \frac{1}{\sqrt{3}} \mid 00 \rangle + \frac{\sqrt{2}}{\sqrt{3}}\mid 01 \rangle\\&#xA;\to \frac{1}{\sqrt{3}} \mid 00 \rangle + (\frac{1}{2} (1+i))\frac{\sqrt{2}}{\sqrt{3}}\mid 01 \rangle + (\frac{1}{2} (1-i))\frac{\sqrt{2}}{\sqrt{3}}\mid 10 \rangle\\&#xA;\to \frac{1}{\sqrt{3}} \mid 00 \rangle + \frac{e^{i \theta_1}}{\sqrt{3}}\mid 01 \rangle + \frac{e^{i \theta_2}}{\sqrt{3}}\mid 10 \rangle&#xA;$$&lt;/p&gt;&#xA;" OwnerUserId="434" LastActivityDate="2018-06-12T12:46:05.623" CommentCount="5" />
  <row Id="2315" PostTypeId="5" CreationDate="2018-06-12T19:02:10.137" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-06-12T19:02:10.137" LastActivityDate="2018-06-12T19:02:10.137" CommentCount="0" />
  <row Id="2316" PostTypeId="4" CreationDate="2018-06-12T19:02:10.137" Score="0" Body="For questions about Pauli matrices in general or Pauli gates in particular, as relevant to quantum computing and/or quantum information theory. The Pauli matrices are a set of three 2 × 2 complex matrices which are Hermitian and unitary. The three Pauli gates are: Pauli-X gate, Pauli-Y gate &amp; Pauli-Z gate. X = {{0,1},{1,0}}; Y = {{0,-i},{i,0}}; Z = {{1,0},{0,-1}}." OwnerUserId="2293" LastEditorUserId="26" LastEditDate="2018-07-15T13:27:06.120" LastActivityDate="2018-07-15T13:27:06.120" CommentCount="0" />
  <row Id="2317" PostTypeId="1" CreationDate="2018-06-12T20:23:53.247" Score="8" ViewCount="63" Body="&lt;p&gt;In [1], the problem of simulating a Hamiltonian using repeated applications of a different set of Hamiltonians is discussed.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In particular, let $A$ and $B$ be a pair of Hermitian operators, and let $\mathcal L$ be the algebra generated from $A, B$ through repeated commutation $^{\mathbf{(\dagger)}}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The author then asks (first paragraph of third page) what  is $\mathcal L$ for an arbitrary pair of observables $A$ and $B$, and argues that $\mathcal L$ is the space of all Hermitian matrices, unless (quoting from the paper) &lt;em&gt;both $e^{iA t}$ and $e^{iB t}$ lie in an $n$-dimensional unitary representation of some Lie group other than $U(n)$&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I'm not too familiar with the theory of Lie algebras, so this statement is quite cryptic for me.&#xA;How can this be shown more explicitly?&#xA;Equivalently, is there a more direct way to show this fact?&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;$(\dagger)$: More explicitly, this is the vector space spanned by $A, B, i[A,B], [A,[A,B]], ...$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[1] Lloyd 1995, &lt;em&gt;Almost Any Quantum Logic Gate is Universal&lt;/em&gt;, &lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.75.346&quot; rel=&quot;noreferrer&quot;&gt;Link to PRL&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-06-12T21:07:54.603" LastActivityDate="2018-06-13T05:17:06.980" Title="Why does (almost) every pair of Hamiltonians generate, through repeated commutation, the whole space of Hermitian matrices?" Tags="&lt;simulation&gt;" AnswerCount="1" CommentCount="2" />
  <row Id="2318" PostTypeId="2" ParentId="2282" CreationDate="2018-06-12T20:30:27.347" Score="2" Body="&lt;p&gt;Simpler answer: All quantum computers are classical computers too, if you limit their gate set to only classical gates such as $X$, which is the NOT gate. Every time you build a quantum computer, you're also building a classical computer, so you can prove mathematically that building a quantum computer must be at least as hard as building a classical computer. &lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-06-12T20:30:27.347" CommentCount="0" />
  <row Id="2319" PostTypeId="2" ParentId="2317" CreationDate="2018-06-12T20:58:43.877" Score="3" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;I'm not too familiar with the theory of Lie algebras, so this&#xA;  statement is quite cryptic for me. How can this be shown more&#xA;  explicitly? Equivalently, is there a more direct way to show this&#xA;  fact?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;At around the same time, David Deutsch &lt;em&gt;et al&lt;/em&gt;. proved the same thing in this paper: &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9505018&quot; rel=&quot;nofollow noreferrer&quot;&gt;Universality in Quantum Computation (1995)&lt;/a&gt;, but without ever using the word &quot;algebra&quot; or &quot;Lie&quot; in the whole paper. The proof starts on page 3 and the main point is at Eq. 9, which is the same equation that appears in Seth Lloyd's paper, but here it is explained without reference to &quot;Lie algebras&quot;. Eq. 9 is an application of what in physics we often just call the &quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/Lie_product_formula&quot; rel=&quot;nofollow noreferrer&quot;&gt;Trotter splitting&lt;/a&gt;&quot;. It was written down almost 100 years earlier by Sophus Lie, but you do not need to know anything about Lie Algebras or even vector spaces in order to apply the formula as done in Eq. 9.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="26" LastEditDate="2018-06-13T05:17:06.980" LastActivityDate="2018-06-13T05:17:06.980" CommentCount="2" />
  <row Id="2320" PostTypeId="1" AcceptedAnswerId="2322" CreationDate="2018-06-12T21:10:13.010" Score="8" ViewCount="82" Body="&lt;p&gt;If this isn't known, would they theoretically be? I'm particularly interested in knowing whether a QC would be faster at evaluating the fitness function of the possible solutions than a classical machine &lt;/p&gt;&#xA;" OwnerUserId="2637" LastEditorUserId="26" LastEditDate="2018-06-13T05:39:39.603" LastActivityDate="2018-06-13T15:31:08.753" Title="Are Genetic Programming runtimes faster on QCs than on classical computers?" Tags="&lt;quantum-speedup&gt;&lt;applications&gt;" AnswerCount="1" CommentCount="1" />
  <row Id="2321" PostTypeId="1" CreationDate="2018-06-12T23:55:01.523" Score="8" ViewCount="90" Body="&lt;p&gt;As the title suggests, I want to know what the applicability of quantum network coding is, besides the EPR pair construction between distant pairs of 'Users-Targets'. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Can quantum network coding be used for computation?&lt;/p&gt;&#xA;" OwnerUserId="2422" LastEditorUserId="26" LastEditDate="2018-06-13T05:07:30.753" LastActivityDate="2018-06-13T16:53:00.130" Title="What is the applicability of quantum network coding?" Tags="&lt;quantum-computer&gt;&lt;quantum-entanglement&gt;&lt;superdense-coding&gt;" AnswerCount="1" CommentCount="5" FavoriteCount="1" />
  <row Id="2322" PostTypeId="2" ParentId="2320" CreationDate="2018-06-13T00:22:01.660" Score="3" Body="&lt;p&gt;There are &lt;a href=&quot;https://arxiv.org/abs/cs/0403003&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum algorithms for genetic programming&lt;/a&gt; which would theoretically have advantages over the corresponding classical genetic programming algorithms &lt;em&gt;but&lt;/em&gt; you would need a full-fledged quantum computer with more qubits than any quantum computer we currently have, in order to observe such an advantage.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-06-13T15:31:08.753" LastActivityDate="2018-06-13T15:31:08.753" CommentCount="0" />
  <row Id="2323" PostTypeId="2" ParentId="2321" CreationDate="2018-06-13T06:46:45.823" Score="4" Body="&lt;p&gt;Network coding &amp;mdash; both classical network coding, and quantum network coding &amp;mdash; is an approach to distributing information by performing simple operations at nodes in a network, acting on input signals and transmitting the outputs to other nodes. To put it another way, network coding is an approach to distributing information using a communications network if we treat it as a logical circuit, albeit where the 'gates' performed at each node may be a bit more powerful than just AND, OR, CNOT, or the like.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In principle, we can use the setting of network coding to perform non-trivial computations by an appropriate choice of operations (gates) at the nodes. Network coding does not usually allow the freedom to also choose the structure of the network itself (&lt;em&gt;i.e.&lt;/em&gt; the circuit topology), as this is usually given as an input parameter to a given network coding problem. But there will still be some range of computations which a given network can admit, not all of which will serve merely to distribute information. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the particular case of quantum network coding, the detail that things are to be done in a distributed  (and presumably coherent) manner does add wrinkles to how you can manage to accomplish things. However, if we allow classical communication between nodes in the network as well &amp;mdash; either allowing classical messages to move both forward and backward within the coding network or in an all-to-all manner &amp;mdash; then you can perform coherent quantum network coding for the &lt;em&gt;k&lt;/em&gt;-pairs problem &#xA;&lt;strong&gt;[1]&lt;/strong&gt; or an arbitrary network coding problem &lt;strong&gt;[2]&lt;/strong&gt; respectively, provided that a classical network protocol exists for the same problem in the same network: and furthermore, the way this is done can be seen to essentially be &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1347/124&quot;&gt;Measurement Based Quantum Computation&lt;/a&gt; (MBQC), as Martin Roeteller and I showed &lt;strong&gt;[3]&lt;/strong&gt;. Conversely, it is fairly clear that for any MBQC procedure, there is a corresponding coding network topology which allows that procedure to be realised.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It follows that, while the details are a bit pickier than in the classical case, quantum network coding can be viewed as a setting in which to do universal computation, specifically via MBQC, at least so long as auxiliary classical communication is allowed (with somewhat fewer constraints than on quantum communication).&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;[1]&lt;/strong&gt; &lt;em&gt;Constructing Quantum Network Coding Schemes from Classical Nonlinear Protocols&lt;/em&gt;. Kobayashi &lt;em&gt;et al.&lt;/em&gt; (2010). [&lt;a href=&quot;https://arxiv.org/abs/1012.4583&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv:1012.4583&lt;/a&gt;]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;[2]&lt;/strong&gt; &lt;em&gt;General Scheme for Perfect Quantum Network Coding with Free Classical Communication&lt;/em&gt;. Kobayashi &lt;em&gt;et al.&lt;/em&gt; (2009). [&lt;a href=&quot;https://arxiv.org/abs/0908.1457&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv:0908.1457&lt;/a&gt;]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;[3]&lt;/strong&gt; &lt;em&gt;Quantum linear network coding as one-way quantum computation.&lt;/em&gt; de&amp;nbsp;Beaudrap &amp;amp; Roetteler (2014). [&lt;a href=&quot;https://arxiv.org/abs/1403.3533&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv:1403.3533&lt;/a&gt;]&lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-06-13T16:53:00.130" LastActivityDate="2018-06-13T16:53:00.130" CommentCount="4" />
  <row Id="2324" PostTypeId="1" AcceptedAnswerId="2328" CreationDate="2018-06-13T08:57:25.770" Score="8" ViewCount="554" Body="&lt;p&gt;I have some perplexity concerning the concept of phase estimation: by definition, given a unitary operator $U$ &lt;em&gt;and&lt;/em&gt; an eigenvector $|u\rangle$ with related eigenvalue $\text{exp}(2\pi i \phi)$, the phase estimation allows to find the value of $\phi$.&#xA;This would mean that I would be able to determine an eigenvalue of a certain matrix &lt;em&gt;given&lt;/em&gt; that I know already one of its eigenvectors? But isn't the fact that needing an eigenvector beforehand would quite reduce the usefulness of the phase estimation itself?&lt;/p&gt;&#xA;" OwnerUserId="2648" LastEditorUserId="26" LastEditDate="2018-06-13T09:59:37.100" LastActivityDate="2018-06-13T10:43:17.927" Title="What is the actual power of Quantum Phase Estimation?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-speedup&gt;&lt;complexity-theory&gt;" AnswerCount="2" CommentCount="2" />
  <row Id="2325" PostTypeId="2" ParentId="2295" CreationDate="2018-06-13T09:19:46.773" Score="2" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;I am confused what &quot;conjugation of coordinates&quot; means in this context.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://math.stackexchange.com/a/234871/510296&quot;&gt;Conjugating&lt;/a&gt; coordinates of $\mathcal C$ is equivalent to setting some diagonal elements of Γ to 1. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Read &quot;&lt;a href=&quot;https://arxiv.org/abs/math/0504522&quot; rel=&quot;nofollow noreferrer&quot;&gt;Theorem 12, on page 8 and 9&lt;/a&gt;&quot; for an understanding of the usage, this is further explained on page 15 (last paragraph):&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;As mentioned before, the set of self-dual linear codes over GF(4) is a subset of the self-dual additive codes of Type II. Note that &lt;strong&gt;conjugation of single coordinates does not preserve the linearity of a code&lt;/strong&gt;. It was shown by Van den Nest $^{[25]}$ that the code $\mathcal C$ generated by a matrix of the form Γ + $ωI$ can not be linear. However, &lt;strong&gt;if there is a linear code equivalent to $\mathcal C$, it can be found by conjugating some coordinates. Conjugating coordinates of $\mathcal C$ is equivalent to setting some diagonal elements of Γ to 1&lt;/strong&gt;. Let $A$ be a binary diagonal matrix such that Γ + $A$ + $ωI$ generates a linear code. Van den Nest $^{[25]}$ proved that $\mathcal C$ is equivalent to a linear code if and only if there exists such a matrix $A$ that satisfies Γ$^2$ + $A$Γ + Γ$A$ + Γ + $I$ = $0$. A similar result was found by Glynn et al. $^{[12]}$. Using this method, it is easy to check whether the LC orbit of a given graph corresponds to a linear code. However, self-dual linear codes over GF(4) have already been classified up to length 16, and we have not found a way to extend this result using the graph approach.&quot;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;References:&#xA;[12] D. G. Glynn, T. A. Gulliver, J. G. Maks, M. K. Gupta, The geometry of additive quantum codes, submitted to Springer-Verlag, 2004.&lt;/code&gt; &lt;a href=&quot;https://www.researchgate.net/publication/230899738_The_geometry_of_additive_quantum_codes&quot; rel=&quot;nofollow noreferrer&quot;&gt;Book&lt;/a&gt; &lt;code&gt;&#xA;[25] M. Van den Nest, Local Equivalence of Stabilizer States and Codes, Ph.D. thesis, K. U. Leuven, Leuven, Belgium, May 2005.&lt;/code&gt; &lt;a href=&quot;ftp://ftp.esat.kuleuven.be/pub/SISTA/ida/reports/05-99.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;.PDF&lt;/a&gt; (English starts on page 22)&lt;/p&gt;&#xA;" OwnerUserId="278" LastActivityDate="2018-06-13T09:19:46.773" CommentCount="1" />
  <row Id="2326" PostTypeId="2" ParentId="1952" CreationDate="2018-06-13T09:42:50.000" Score="1" Body="&lt;p&gt;A couple papers are out there on algorithms which can be constructed using reverse annealing, &lt;a href=&quot;http://iopscience.iop.org/article/10.1088/1367-2630/aa59c4/meta&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://iopscience.iop.org/article/10.1088/1367-2630/aa59c4/meta&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/abs/1609.05875&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/1609.05875&lt;/a&gt; (it is worth pointing out previous somewhat related closed system work: &lt;a href=&quot;https://link.springer.com/article/10.1007/s11128-010-0168-z&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://link.springer.com/article/10.1007/s11128-010-0168-z&lt;/a&gt;). As far as experimental results, I think the only ones publicly visible at the time of writing are the white paper given in the previous post. However, there will be some new work presented at AQC 2018 (&lt;a href=&quot;https://ti.arc.nasa.gov/events/aqc-18/&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://ti.arc.nasa.gov/events/aqc-18/&lt;/a&gt;) in late June and these talks are usually put online a few months after the conference.&lt;/p&gt;&#xA;" OwnerUserId="2649" LastActivityDate="2018-06-13T09:42:50.000" CommentCount="0" />
  <row Id="2327" PostTypeId="2" ParentId="2324" CreationDate="2018-06-13T10:04:16.787" Score="6" Body="&lt;p&gt;Sometimes, you might know the eigenvector, and the computational question that you want to answer is what the eigenvalue is. For example, any function evaluation $f(x)$ defined by the action of a $U$&#xA;$$&#xA;U:|x\rangle|y\rangle\mapsto|x\rangle|y\oplus f(x)\rangle&#xA;$$for $x\in\{0,1\}^n$, $y\in\{0,1\}$ has well defined eigenvectors,&#xA;$$&#xA;|x\rangle(|0\rangle\pm|1\rangle)/\sqrt{2},&#xA;$$&#xA;but whether the eigenvalue is $\pm 1$ is absolutely vital: that is essentially the question being asked in things like Deutsch's algorithm, Deutsch-Jozsa, Simon's algorithm, Bernstein-Vazirani etc. It's also the way that the oracle for quantum search is often constructed.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In a slightly more generalised setting (that applies, for example, to Shor's algorithm), you might not need to find a specific eigenvalue, but a random choice from some subset will do. So it might be that there's a standard state (e.g. $|00\ldots 01\rangle$) that has support on all of the eigenvectors from which you want to pick an eigenvalue randomly, but you have no idea what the individual eigenvectors are, but you can run phase estimation with that input, and you'll be just fine.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-13T10:04:16.787" CommentCount="0" />
  <row Id="2328" PostTypeId="2" ParentId="2324" CreationDate="2018-06-13T10:25:15.997" Score="6" Body="&lt;p&gt;If you don't supply a $|u\rangle$ as an input, there are two possible things you might want to get out:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;The $\varphi$ for a randomly chosen (but unknown) eigenstate $|u\rangle$;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Both $\varphi$ and $|u\rangle$ for one or more eigenstates.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Let's first look at 1. Since eigenstates form a complete basis, any input state you use can be interpreted as a superposition of the eigenstates of $U$. Due to the linearity of quantum mechanics, the algorithm would then run for all these states at once. Then at the end, when you measure the output, it will randomly collapse to a given instance. This means that you'll be given a $\varphi$ for a randomly chosen eigenstate, but you won't know which it is. The existing phase estimation algorithm therefore can supply us with the first possible application.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The second application is something we can't do with standard phase estimation, but let's consider it hypothetically. Any algorithm that could do this would be giving us an eigenstate $|u\rangle$ as part of the output. So if you want to actually know what $|u\rangle$ is, you'd have to do tomography on the output. Since tomography is inefficient, there would probably be better ways to go about doing this.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-06-13T10:43:17.927" LastActivityDate="2018-06-13T10:43:17.927" CommentCount="0" />
  <row Id="2329" PostTypeId="1" AcceptedAnswerId="2331" CreationDate="2018-06-13T10:37:20.920" Score="8" ViewCount="72" Body="&lt;p&gt;If we start with a Hamiltonian $H(t_i)$, and with our qubits prepared in the ground state of this, and then slowly change this to a Hamiltonian $H(t_i)$, the final state of our qubits should be the ground state of the new Hamiltonian. This is due to the adiabatic theorem, and is the basis of quantum annealing.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But what if it's not the ground state we want? Suppose we start with the first excited state of $H(t_i)$. Does the process give us the first excited state of $H(t_f)$? What about for other states?&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-06-13T15:18:46.847" Title="Can quantum annealing find excited states?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-annealing&gt;&lt;adiabatic-model&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2331" PostTypeId="2" ParentId="2329" CreationDate="2018-06-13T15:18:46.847" Score="4" Body="&lt;p&gt;&lt;strong&gt;In Practice:&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quantum annealing almost always gives excited states in practice. To get the exact ground state at the end, you need the adiabatic passage to be &lt;strong&gt;perfect&lt;/strong&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The closest thing to a perfect adiabatic passage is probably &lt;a href=&quot;https://arxiv.org/abs/1706.08061&quot; rel=&quot;nofollow noreferrer&quot;&gt;this recent paper&lt;/a&gt; where they get the ground state with 0.975 fidelity, but this is for 3 qubits with a very simple Hamiltonian (see Eq. 5).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However in the D-Wave machine with 2000 qubits there's $2^{2000}-1$ excited states and much higher likelihood that many of them will be near the ground state. Almost every problem D-Wave has worked on recently seeks an approximate solution, not the absolute global minimum.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;In Theory:&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;What if my annealer is &lt;strong&gt;perfect&lt;/strong&gt; and we &lt;em&gt;can&lt;/em&gt; stay in the true &lt;s&gt;ground&lt;/s&gt; initial state the whole time? Yes it should be possible to prove the adiabatic theorem for any &lt;em&gt;initial&lt;/em&gt; state, not just the &lt;em&gt;ground&lt;/em&gt; state, but how are you going to initialize the system in some particular excited state? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;There is indeed a technique for doing &quot;constrained&quot; annealing described &lt;a href=&quot;https://arxiv.org/pdf/1508.04212.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;. The idea is to use a driver Hamiltonian that commutes with the constraints (see the paragraph above Eq. 2)!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;More generally you can adiabatically evolve along a particular symmetry sector. For example if the ground state of a molecular Hamiltonian is a singlet state, but you are only interested in a triplet (excited) state, as long as you start with a state that has triplet symmetry and your driver Hamiltonian conserves spin, you can prove a generalization of the &quot;basic&quot; adiabatic theorem that states that you will remain in the triplet state if you evolve slowly enough. &lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-06-13T15:18:46.847" CommentCount="0" />
  <row Id="2332" PostTypeId="2" ParentId="2298" CreationDate="2018-06-13T18:29:51.953" Score="2" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;They say that this scheme requires to throw $O(N)$ switches for each memory call, but I don't understand why is this the case.&#xA;  From the above, it would seem that one just needs to throw $O(\log_2(N))$ &#xA;  switches, one per bifurcation, to get from the top to the bottom.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;It seems to me that $n= \log_2 N$ is the length of the address register: the number of times that you have to say left or right to reach a given node.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The number of 'switches' is the amount of hardware required to realize the full graph. For the classical case, this means transistors. From the paper:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;An electronic implementation requires placing one transistor in each&#xA;  of the two paths following each node in the graph. Each address bit&#xA;  controls all the transistors in one of the graph levels: it activates&#xA;  all the transistors in the left paths if it has value 0, or all the&#xA;  transistors in the right paths if it has value 1&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The number of transistors required for the bottom level of the graph is $O(N)$. This then decreases exponentially as you go up the graph. So the total number is also $O(N)$. All are active, since each address bit activates all the transistors in a given level.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;In other words, is the advantage of the bucket-brigade approach only in the higher error resilience in the quantum case, or would it also be classically advantageous, compared with the conventional approaches?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I think that it would indeed work in classical RAM, but the hardware constraints didn't supply the 'evolutionary pressure' required for it to be develiped and implemented. The quantum need to hide from errors is the main motivation.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-06-13T18:29:51.953" CommentCount="1" />
  <row Id="2333" PostTypeId="1" AcceptedAnswerId="2335" CreationDate="2018-06-14T01:59:39.580" Score="9" ViewCount="178" Body="&lt;p&gt;Tried asking &lt;a href=&quot;https://physics.stackexchange.com/questions/411518/generlization-of-quantum-xnor-gate&quot;&gt;here&lt;/a&gt; first, since a similar question had been asked on that site. Seems more relevant for this site however.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is my current understanding that a quantum XOR gate is the CNOT gate. Is the quantum XNOR gate a CCNOT gate? &lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-07-10T23:34:17.363" LastActivityDate="2018-07-10T23:34:17.363" Title="Quantum XNOR Gate Construction" Tags="&lt;quantum-gate&gt;&lt;universal-gates&gt;&lt;gate-synthesis&gt;&lt;controlled-gates&gt;" AnswerCount="2" CommentCount="1" />
  <row Id="2334" PostTypeId="2" ParentId="2333" CreationDate="2018-06-14T03:25:12.173" Score="4" Body="&lt;p&gt;The quantum XNOR is not a CCNOT. CCNOT would take 3 bits as input, whereas XOR, XNOR, and CNOT take in only 2 bits or qubits as input.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The reason why we say the XOR can be thought of as a CNOT is explained &lt;a href=&quot;https://physics.stackexchange.com/questions/71949/quantum-xor-how-do-you-generalize-it&quot;&gt;here&lt;/a&gt;, and the same reasoning can be used to construct the (2 qubit) XNOR.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-06-14T13:50:46.347" LastActivityDate="2018-06-14T13:50:46.347" CommentCount="0" />
  <row Id="2335" PostTypeId="2" ParentId="2333" CreationDate="2018-06-14T07:30:32.720" Score="6" Body="&lt;p&gt;Any classical one-bit function $f:x\mapsto y$ where $x\in\{0,1\}^n$ is an $n$-bit input and $y\in\{0,1\}$ is an $n$-bit output can be written as a reversible computation,&#xA;$$&#xA;f_r:(x,y)\mapsto (x,y\oplus f(x))&#xA;$$&#xA;(Note that any function of $m$ outputs can be written as just $m$ separate 1-bit functions.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A quantum gate implementing this is basically just the quantum gate corresponding to the reversible function evaluation. If you simply write out the truth table of the function, each line corresponds to a row of the unitary matrix, and the output tells you which column entry contains a 1 (all other entries contain 0).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the case of XNOR, we have the standard truth table, and the reversible function truth table&#xA;$$&#xA;\begin{array}{c|c}&#xA;x &amp;amp; f(x) \\&#xA;\hline&#xA;00 &amp;amp; 1 \\&#xA;01 &amp;amp; 0 \\&#xA;10 &amp;amp; 0 \\&#xA;11 &amp;amp; 1&#xA;\end{array}&#xA;\qquad&#xA;\begin{array}{c|c}&#xA;(x,y) &amp;amp; (x,y\oplus f(x)) \\&#xA;\hline&#xA;000 &amp;amp; 001 \\&#xA;001 &amp;amp; 000 \\&#xA;010 &amp;amp; 010 \\&#xA;011 &amp;amp; 011 \\&#xA;100 &amp;amp; 100 \\&#xA;101 &amp;amp; 101 \\&#xA;110 &amp;amp; 111 \\&#xA;111 &amp;amp; 110&#xA;\end{array}&#xA;$$&#xA;Thus, the unitary matrix is&#xA;$$&#xA;U=\left(\begin{array}{cccccccc}&#xA;0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA;1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\&#xA;\end{array}\right).&#xA;$$&#xA;This can easily be decomposed in terms of a couple of controlled-not gates and a bit flip or two.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The method that I just outlined gives you a very safe way of making the construction that works for any $f(x)$, but it does not perfectly reconstruct the correspondence between XOR and controlled-not. For that, we need to assume a little bit more about the properties of the function $f(x)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Assume that we can decompose the input $x$ into $a,b$ such that $a\in\{0,1\}^{n-1}$ and $b\in \{0,1\}$ such that for all values of $a$, the values of $f(a,b)$ are distinct for each $b$. In this case, we can define the reversible function evaluation as $$f:(a,b)\mapsto(a,f(a,b)).$$ This means that we're using 1 fewer bits than the previous construction, but from here on the technique can be repeated.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, let's go back to the truth table for XNOR.&#xA;$$&#xA;\begin{array}{c|c}&#xA;ab &amp;amp; f(a,b) \\&#xA;\hline&#xA;00 &amp;amp; 1 \\&#xA;01 &amp;amp; 0 \\&#xA;10 &amp;amp; 0 \\&#xA;11 &amp;amp; 1&#xA;\end{array}&#xA;$$&#xA;We can see that, for example, when we fix $a=0$, the two outputs are $1,0$, hence distinct. Similarly for fixing $a=1$. Thus, we can proceed with the reversible function construction&#xA;$$&#xA;\begin{array}{c|c}&#xA;ab &amp;amp; af(a,b) \\&#xA;\hline&#xA;00 &amp;amp; 01 \\&#xA;01 &amp;amp; 00 \\&#xA;10 &amp;amp; 10 \\&#xA;11 &amp;amp; 11&#xA;\end{array}&#xA;$$&#xA;and this gives us a unitary&#xA;$$&#xA;U=\left(\begin{array}{cccc}&#xA;0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\&#xA;1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1&#xA;\end{array}\right)&#xA;$$&#xA;You can easily check that this is the same as $\text{cNOT}\cdot(\mathbb{1}\otimes X)$.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-14T07:30:32.720" CommentCount="1" />
  <row Id="2336" PostTypeId="1" AcceptedAnswerId="2337" CreationDate="2018-06-14T09:00:43.927" Score="7" ViewCount="344" Body="&lt;p&gt;What conditions must a matrix hold to be considered a valid density matrix?&lt;/p&gt;&#xA;" OwnerUserId="2559" LastActivityDate="2018-06-14T11:09:23.980" Title="How to check if a matrix is a valid density matrix?" Tags="&lt;qubit-state&gt;&lt;density-matrix&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="2337" PostTypeId="2" ParentId="2336" CreationDate="2018-06-14T09:02:30.920" Score="6" Body="&lt;p&gt;If a matrix has unit trace and if it is positive semi-definite (and Hermitian) then it is a valid density matrix. More specifically check if the matrix is Hermitian; find the eigenvalues of the matrix , check if they are non-negative and add up to $1$.&lt;/p&gt;&#xA;" OwnerUserId="2663" LastEditorUserId="2663" LastEditDate="2018-06-14T09:32:44.373" LastActivityDate="2018-06-14T09:32:44.373" CommentCount="6" />
  <row Id="2338" PostTypeId="1" AcceptedAnswerId="2339" CreationDate="2018-06-14T09:13:00.990" Score="6" ViewCount="87" Body="&lt;p&gt;If we are given a state of a qubit, how do we construct its density matrix?&lt;/p&gt;&#xA;" OwnerUserId="2559" LastActivityDate="2018-06-14T18:01:27.697" Title="How to find a density matrix of a qubit?" Tags="&lt;qubit&gt;&lt;qubit-state&gt;&lt;density-matrix&gt;" AnswerCount="1" CommentCount="1" FavoriteCount="1" />
  <row Id="2339" PostTypeId="2" ParentId="2338" CreationDate="2018-06-14T09:14:48.063" Score="5" Body="&lt;p&gt;If you're given $|\psi\rangle$, just calculate $\rho=|\psi\rangle\langle\psi|$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, $|\psi\rangle=\cos\theta|0\rangle+\sin\theta e^{i\phi}|1\rangle$, then $\langle\psi|=\cos\theta\langle 0|+\sin\theta e^{-i\phi}\langle 1|$. This means that&#xA;$$&#xA;\rho=\left(\begin{array}{c} \cos\theta\\ \sin\theta e^{i\phi}\end{array}\right)\cdot \left(\begin{array}{cc} \cos\theta &amp;amp;&amp;amp; \sin\theta e^{-i\phi}\end{array}\right)=\left(\begin{array}{cc}&#xA;\cos^2\theta &amp;amp; \cos\theta\sin\theta e^{-i\phi} \\ \cos\theta\sin\theta e^{i\phi} &amp;amp; \sin^2\theta&#xA;\end{array}\right).&#xA;$$&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-14T09:14:48.063" CommentCount="0" />
  <row Id="2340" PostTypeId="2" ParentId="2073" CreationDate="2018-06-14T09:57:09.610" Score="0" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;So my question is whether such a proof exists for the case where there is no initial entanglement.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The answer to this is no. As mentioned in the paper, if the subsystem is separable from the rest of the universe  then a global unitary evolution will act as a CPTP map on the subsystem. You can verify this explicitly by writing down an unentagled pure state, evolving it by a unitary and then tracing out one part. This calculation is done explicitly in Chapter 8 of Nielsen and Chuang.&lt;/p&gt;&#xA;" OwnerUserId="2663" LastActivityDate="2018-06-14T09:57:09.610" CommentCount="0" />
  <row Id="2341" PostTypeId="2" ParentId="2336" CreationDate="2018-06-14T11:09:23.980" Score="3" Body="&lt;p&gt;Suppose someone has prepared your quantum system in one of an orthogonal set of states $\{|\psi_j\rangle\}$. You don't know which of these states they've prepared it in, but you do know that they prepared state $|\psi_j\rangle$ with probability $p_j$. Your system is then described by the density matrix,&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\rho = \sum_j \, p_j \, |\psi_j\rangle \langle\psi_j|$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are some properties that will apply to any density matrix of this form. &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Clearly it is diagonalizable, since it is explicitly written in terms of its eigenvalues $p_j$ and eigenstates $|\psi_j\rangle$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Since the $|\psi_j\rangle \langle\psi_j|$ are Hermitian, and since probabilities are real numbers, the density matrix is Hermitian.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Since probabilities are all either zero or positive, the density matrix is positive semidefinite.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Since all probabilities must sum to 1, and the trace is a sum of eigenvalues, the density matrix must have a trace of 1.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;These are exactly the properties required of all density matrices. Hopefully this derivation of them gives a bit of understanding of why they are required.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-06-14T11:09:23.980" CommentCount="3" />
  <row Id="2342" PostTypeId="1" CreationDate="2018-06-14T12:54:01.257" Score="8" ViewCount="113" Body="&lt;p&gt;As stated in the question, I have found in several papers (e.g. &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9706062&quot; rel=&quot;nofollow noreferrer&quot;&gt;1&lt;/a&gt;, &lt;a href=&quot;http://www.ucw.cz/~robert/papers/andor-siamjc.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;2&lt;/a&gt;) that in order to perform a quantum walk on a given tree it is necessary to add some nodes to the root $r$, say $r^{'}$ and $r^{&quot;}$. Why are they needed?&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;References:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Farhi E., &quot;&lt;em&gt;Quantum computation and decision trees&lt;/em&gt;&quot;.&#xA;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/9706062&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/quant-ph/9706062&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Ambainis A., &quot;&lt;em&gt;Any AND-OR formula of size N can be evaluated in time&lt;/em&gt; $N^{1/2+o(1)}$ &lt;em&gt;on a quantum computer&lt;/em&gt;&quot;. &lt;a href=&quot;http://www.ucw.cz/~robert/papers/andor-siamjc.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://www.ucw.cz/~robert/papers/andor-siamjc.pdf&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="2648" LastEditorUserId="55" LastEditDate="2018-07-05T09:40:57.953" LastActivityDate="2018-07-05T09:40:57.953" Title="Quantum Walk: Why the need of adding &quot;tail&quot; nodes to the root?" Tags="&lt;quantum-algorithms&gt;&lt;complexity-theory&gt;&lt;quantum-walks&gt;" AnswerCount="0" CommentCount="5" FavoriteCount="1" />
  <row Id="2343" PostTypeId="1" AcceptedAnswerId="2345" CreationDate="2018-06-14T16:48:47.380" Score="14" ViewCount="2274" Body="&lt;p&gt;Quantum computing allows us to encrypt information in a different way compared to what we use today, but quantum computers are much more powerful than today's computers. So if we manage to build quantum computers (hence use quantum cryptography), will the so called &quot;hackers&quot; have more or less chances of &quot;hacking&quot; into the systems? Or is it impossible to determine it?&lt;/p&gt;&#xA;" OwnerUserId="2559" LastActivityDate="2018-06-15T05:14:03.040" Title="Is quantum cryptography safer than classical cryptography?" Tags="&lt;quantum-computer&gt;&lt;quantum-algorithms&gt;&lt;classical-computing&gt;&lt;cryptography&gt;&lt;quantum-cryptography&gt;" AnswerCount="2" CommentCount="1" FavoriteCount="5" />
  <row Id="2345" PostTypeId="2" ParentId="2343" CreationDate="2018-06-14T18:05:13.387" Score="13" Body="&lt;p&gt;If you are talking specifically about quantum key distribution (quantum cryptography being an umbrella term that could apply to lots of stuff), then once we have a quantum key distribution scheme, this is theoretically perfectly secure. Rather than computational security that much of current cryptography is based on, quantum key distribution is perfectly secure.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;That said, it is only perfectly secure subject to certain assumptions relating mainly to lab security. These same assumptions are essentially present in the classical case as well, just that because the quantum experiments are a lot more fiddly, it might be harder to be completely on top of all the possible attacks. Realistically, these are already the directions in which cryptography is attacked, rather than trying to brute force a crack. For example, exploits relying on a bad implementation of a protocol (rather than the protocol itself being flawed).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What quantum crypto, or post quantum crypto, is aiming to do is sidestep the loss of computational security implied by a quantum computer. It will never avoid these implementation issues.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In a completely shameless plug, you might be interested in my &lt;a href=&quot;https://vimeo.com/quantummechanic/qkdintro&quot; rel=&quot;noreferrer&quot;&gt;introduction to quantum cryptography video&lt;/a&gt;. It talks a little about this computational vs perfect security question (although doesn't really talk about possible hacks of QKD).&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-06-15T05:14:03.040" LastActivityDate="2018-06-15T05:14:03.040" CommentCount="2" />
  <row Id="2346" PostTypeId="1" AcceptedAnswerId="2350" CreationDate="2018-06-14T18:17:04.917" Score="6" ViewCount="99" Body="&lt;p&gt;There is an excellent &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1654/how-do-i-add-11-using-a-quantum-computer/1656&quot;&gt;answer&lt;/a&gt; to &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1654/how-do-i-add-11-using-a-quantum-computer/1656&quot;&gt;How do I add 1+1 using a quantum computer?&lt;/a&gt; that shows constructions of the half and full adders. In the answer, there is a source for the &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0410184v1&quot; rel=&quot;nofollow noreferrer&quot;&gt;QRCA&lt;/a&gt;. I have also looked at &lt;a href=&quot;https://pdfs.semanticscholar.org/presentation/4758/ba24724e378caad94ab1d083ab8392df9e48.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;this presentation&lt;/a&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am still left with these questions:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;What does a truth table for a QRCA look like? &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;What would a unitary matrix for a QRCA be? &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;What would a circuit diagram for a QRCA look like? (There is an example of a 6-bit circuit in the arXiv paper)&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-06-16T21:18:11.600" LastActivityDate="2018-06-16T21:18:11.600" Title="Quantum Ripple Carry Adder Construction" Tags="&lt;quantum-gate&gt;&lt;universal-gates&gt;&lt;gate-synthesis&gt;&lt;controlled-gates&gt;" AnswerCount="1" CommentCount="4" />
  <row Id="2347" PostTypeId="1" AcceptedAnswerId="2348" CreationDate="2018-06-14T18:55:38.513" Score="6" ViewCount="91" Body="&lt;p&gt;What is the motivation behind density matrices? And, what is the difference between the density matrices of pure states and density matrices of mixed states?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;This is a self-answered sequel to &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1365/whats-the-difference-between-a-pure-and-mixed-quantum-state&quot;&gt;What&amp;#39;s the difference between a pure and mixed quantum state?&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2338/how-to-find-a-density-matrix-of-a-qubit&quot;&gt;How to find a density matrix of a qubit?&lt;/a&gt; You're welcome to write alternate answers. &lt;/sup&gt;&lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-06-15T07:13:25.923" Title="Density matrices for pure states and mixed states" Tags="&lt;qubit-state&gt;&lt;quantum-state&gt;&lt;density-matrix&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="2348" PostTypeId="2" ParentId="2347" CreationDate="2018-06-14T18:55:38.513" Score="2" Body="&lt;h2&gt;The motivation behind density matrices&lt;sup&gt;[1]&lt;/sup&gt;:&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;In quantum mechanics, the state of a quantum system is represented by a state vector, denoted $|\psi\rangle$ (and pronounced &lt;a href=&quot;https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;em&gt;ket&lt;/em&gt;&lt;/a&gt;). A quantum system with a state vector $|\psi\rangle$ is called a &lt;em&gt;pure state&lt;/em&gt;. However, it is also possible for a system to be in a &lt;a href=&quot;https://en.wikipedia.org/wiki/Statistical_ensemble&quot; rel=&quot;nofollow noreferrer&quot;&gt;statistical ensemble&lt;/a&gt; of different state vectors. For example, there may be a $50\%$ probability that the state vector is $|\psi_1\rangle$ and a $50\%$ chance that the state vector is $|\psi_2\rangle$. This system would be in &lt;em&gt;mixed state&lt;/em&gt;. The density matrix is especially useful for mixed states, because any state, pure or mixed, can be characterized by a single density matrix. &#xA;A mixed state is different from a quantum superposition. The probabilities in a mixed state are classical probabilities (as in the probabilities one learns in classical probability theory/statistics), unlike the quantum probabilities in a quantum superposition. In fact, a quantum superposition of pure states is another pure state, for example, $\frac{|0\rangle + |1\rangle}{\sqrt{2}}$ . In this case, the coefficients $\frac{1}{\sqrt {2}}$ are not probabilities, but rather probability amplitudes.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;strong&gt;Example: light polarization&lt;/strong&gt;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;An example of pure and mixed states is light polarization. Photons can have two &lt;a href=&quot;https://en.wikipedia.org/wiki/Circular_polarization&quot; rel=&quot;nofollow noreferrer&quot;&gt;helicities&lt;/a&gt;, corresponding to two orthogonal quantum states, $|R\rangle$ (right &lt;a href=&quot;https://en.wikipedia.org/wiki/Circular_polarization&quot; rel=&quot;nofollow noreferrer&quot;&gt;circular polarization&lt;/a&gt;) and $|L\rangle$ (left &lt;a href=&quot;https://en.wikipedia.org/wiki/Circular_polarization&quot; rel=&quot;nofollow noreferrer&quot;&gt;circular polarization&lt;/a&gt;). A photon can also be in a superposition state, such as $\frac{|R\rangle + |L\rangle}{\sqrt{2}}$(vertical polarization) or $\frac{|R\rangle - |L\rangle}{\sqrt{2}}$(horizontal polarization). More generally, it can be in any state $\alpha|R\rangle + \beta |L\rangle$ (with $|\alpha|^2+|\beta|^2=1$) corresponding to &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_polarization&quot; rel=&quot;nofollow noreferrer&quot;&gt;linear&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Circular_polarization&quot; rel=&quot;nofollow noreferrer&quot;&gt;circular&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptical_polarization&quot; rel=&quot;nofollow noreferrer&quot;&gt;elliptical&lt;/a&gt; polarization. If we pass $\frac{|R\rangle + |L\rangle}{\sqrt{2}}$ polarized light through a &lt;a href=&quot;https://en.wikipedia.org/wiki/Polarizer#Circular_polarizers&quot; rel=&quot;nofollow noreferrer&quot;&gt;circular polarizer&lt;/a&gt; which allows either only $|R\rangle$ polarized light, or only $|L\rangle$ polarized light, the intensity would be reduced by half in both cases.  This may make it &lt;em&gt;seem&lt;/em&gt; like half of the photons are in state $|R\rangle$ and the other in state $|L\rangle$. But this is not correct: Both $|R\rangle$ and $|L\rangle$ are partly absorbed by a vertical &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_polarizer&quot; rel=&quot;nofollow noreferrer&quot;&gt;linear polarizer&lt;/a&gt;, but the $\frac{|R\rangle+|L\rangle}{\sqrt 2}$ light will pass through that polarizer with no absorption whatsoever.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, &lt;a href=&quot;https://en.wikipedia.org/wiki/Unpolarized_light&quot; rel=&quot;nofollow noreferrer&quot;&gt;unpolarized light&lt;/a&gt; such as the light from an &lt;a href=&quot;https://en.wikipedia.org/wiki/Incandescent_light_bulb&quot; rel=&quot;nofollow noreferrer&quot;&gt;incandescent light bulb&lt;/a&gt; is different from any state like $\alpha|R\rangle + \beta|L\rangle$ (linear, circular or elliptical polarization). Unlike linearly or elliptically polarized light, it passes through the polarizer with $50\%$ intensity loss whatever the orientation of the polarizer; and unlike circularly polarized light, it cannot be made linearly polarized with any &lt;a href=&quot;https://en.wikipedia.org/wiki/Waveplate&quot; rel=&quot;nofollow noreferrer&quot;&gt;wave plate&lt;/a&gt; because randomly oriented polarization will emerge from a wave plate with random orientation. Indeed, unpolarized light cannot be described as &lt;em&gt;any&lt;/em&gt; state of the form $\alpha |R\rangle + \beta |L\rangle$ in a definite sense. However, unpolarized light can be described with ensemble averages, e.g. that each photon is either $|R\rangle$ with $50\%$ probability or $|L\rangle$ with $50\%$ probability. The same behaviour would occur if each photon was either vertically polarized with $50\%$ probability or horizontally polarized with $50\%$ probability.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Therefore, unpolarized light cannot be described by any pure state but can be described as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Statistical_ensemble_(mathematical_physics)&quot; rel=&quot;nofollow noreferrer&quot;&gt;statistical ensemble&lt;/a&gt; of pure states in at least two ways (the ensemble of half left and half right circularly polarized, or the ensemble of half vertically and half horizontally linearly polarized). These two ensembles are completely indistinguishable experimentally, and therefore they are considered the same mixed state. One of the advantages of the density matrix is that there is just one density matrix for each mixed state, whereas there are many statistical ensembles of pure states for each mixed state. Nevertheless, the density matrix contains all the information necessary to calculate any measurable property of the mixed state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Where do mixed states come from? To answer that, consider how to generate unpolarized light. One way is to use a system in &lt;a href=&quot;https://en.wikipedia.org/wiki/Thermal_equilibrium&quot; rel=&quot;nofollow noreferrer&quot;&gt;thermal equilibrium&lt;/a&gt;, a statistical mixture of enormous numbers of &lt;a href=&quot;https://en.wikipedia.org/wiki/Microstate_(statistical_mechanics)&quot; rel=&quot;nofollow noreferrer&quot;&gt;microstates&lt;/a&gt;, each with a certain probability (the &lt;a href=&quot;https://en.wikipedia.org/wiki/Boltzmann_distribution&quot; rel=&quot;nofollow noreferrer&quot;&gt;Boltzmann factor&lt;/a&gt;), switching rapidly from one to the next due to &lt;a href=&quot;https://en.wikipedia.org/wiki/Thermal_fluctuations&quot; rel=&quot;nofollow noreferrer&quot;&gt;thermal fluctuations&lt;/a&gt;. Thermal randomness explains why an &lt;a href=&quot;https://en.wikipedia.org/wiki/Incandescent_light_bulb&quot; rel=&quot;nofollow noreferrer&quot;&gt;incandescent light bulb&lt;/a&gt;, for example, emits unpolarized light. A second way to generate unpolarized light is to introduce uncertainty in the preparation of the system, for example, passing it through a &lt;a href=&quot;https://en.wikipedia.org/wiki/Birefringence&quot; rel=&quot;nofollow noreferrer&quot;&gt;birefringent crystal&lt;/a&gt; with a rough surface, so that slightly different parts of the beam acquire different polarizations. A third way to generate unpolarized light uses an EPR setup: A radioactive decay can emit two photons travelling in opposite directions, in the quantum state $\frac{|R,L\rangle + |L,R\rangle}{\sqrt{2}}$. The two photons together are in a pure state, but if you only look at one of the photons and ignore the other, the photon behaves just like unpolarized light.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;More generally, mixed states commonly arise from a statistical mixture of the starting state (such as in thermal equilibrium), from uncertainty in the preparation procedure (such as slightly different paths that a photon can travel), or from looking at a subsystem entangled with something else.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Obtaining the density matrix&lt;sup&gt;[2]&lt;/sup&gt;:&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;As mentioned before, a system can be in a statistical ensemble of different state vectors. Say there is $p_1$ probability that the state vector is $|\psi_1\rangle$ and $p_2$ probability that the state vector is $|\psi_2\rangle$ are the corresponding classical probabilities of each state being prepared. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Say, now we want to find the &lt;a href=&quot;https://en.wikipedia.org/wiki/Expectation_value_(quantum_mechanics)&quot; rel=&quot;nofollow noreferrer&quot;&gt;expectation value&lt;/a&gt; of an operator $\hat{O}$. It is given as:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\langle \hat{O} \rangle = p_1\langle \psi_1 \lvert \hat{O} \lvert \psi_1 \rangle + p_2\langle \psi_2 \lvert \hat{O} \lvert \psi_2 \rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that $\langle \psi_1 \lvert \hat{O} \lvert \psi_1 \rangle$ and $p_2\langle \psi_2 \lvert \hat{O} \lvert \psi_2 \rangle$ are scalars, and &lt;a href=&quot;https://en.wikipedia.org/wiki/Trace_(linear_algebra)&quot; rel=&quot;nofollow noreferrer&quot;&gt;trace&lt;/a&gt; of scalars are scalars too. Thus, we can write the above expression as:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\langle \hat{O} \rangle = Tr(p_1\langle \psi_1 \lvert \hat{O} \lvert \psi_1 \rangle) + Tr(p_2\langle \psi_2 \lvert \hat{O} \lvert \psi_2 \rangle)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Trace_(linear_algebra)#Properties&quot; rel=&quot;nofollow noreferrer&quot;&gt;cyclic invariance and linearity properties of the trace&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ \langle \hat{O} \rangle = p_1Tr(\hat{O} \lvert \psi_1 \rangle \langle \psi_1 \lvert) + p_2Tr(\hat{O} \lvert \psi_2 \rangle \langle \psi_2 \lvert)$$ &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$= Tr(\hat{O} (p_1 \lvert \psi_1 \rangle \langle \psi_1 \lvert) + p_2 \lvert \psi_2 \rangle \langle \psi_2 \lvert)) = Tr(\hat{O} \rho)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;where $\rho$ is what we call the density matrix. The density operator contains all the information needed to calculate an expectation value for the experiment.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thus, basically the density matrix $\rho$ is &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$p_1 \lvert \psi_1 \rangle \langle \psi_1 \lvert + p_2 \lvert \psi_2 \rangle \langle \psi_2 \lvert$$ in this case. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can obviously extrapolate this logic for when more than just two state vectors are possible for a system, with different probabilities.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Calculating the density matrix:&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Let's take an example, as follows.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/NwULz.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/NwULz.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the above image, the incandescent light bulb $1$ emits completely random polarized photons $2$ with mixed state density matrix.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As mentioned before, an unpolarized light can be explained with an ensemble average i.e. say each photon is either $|R\rangle$ or $|L\rangle$ with $50%$ probability for each. Another possible ensemble average is: each photon is either $\frac{|R\rangle+|L\rangle}{\sqrt 2}$ or $\frac{|R\rangle - |L\rangle}{\sqrt 2}$ with $50\%$ probability for each. There are lots of other possibilities too. Try to come up with some yourself. The point to note is that the density matrix for all these possible ensembles will be exactly the same. And this is exactly the reason why density matrix decomposition into pure states is not unique. Let's check:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Case 1&lt;/strong&gt;: $50\%$ $|R\rangle$ &amp;amp; $50\%$ $|L\rangle$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\rho_{\text{mixed}} = 0.5 |R\rangle \langle R| + 0.5 |L\rangle \langle L|$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, in the basis $\{|R\rangle, |L\rangle\}$, $|R\rangle$ can be denoted as $\begin{bmatrix} 1 \\ 0 \end{bmatrix}$ and $|L\rangle$ can be denoted as $\begin{bmatrix} 0 \\ 1 \end{bmatrix}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\therefore 0.5 \left(\begin{bmatrix} 1 \\ 0 \end{bmatrix} \otimes \begin{bmatrix} 1 &amp;amp; 0 \end{bmatrix}\right) + 0.5 \left(\begin{bmatrix} 0 \\ 1 \end{bmatrix} \otimes \begin{bmatrix} 0 &amp;amp; 1 \end{bmatrix}\right)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$= 0.5 \begin{bmatrix} 1 &amp;amp; 0 \\ 0 &amp;amp; 0 \end{bmatrix} + 0.5\begin{bmatrix} 0 &amp;amp; 0 \\ 0 &amp;amp; 1 \end{bmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$= \begin{bmatrix} 0.5 &amp;amp; 0 \\ 0 &amp;amp; 0.5 \end{bmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Case 2&lt;/strong&gt;: $50\%$ $\frac{|R\rangle + |L\rangle}{\sqrt 2}$ &amp;amp; $50\%$ $\frac{|R\rangle - |L\rangle}{\sqrt 2}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\rho_{\text{mixed}} = 0.5 \left(\frac{|R\rangle + |L\rangle}{\sqrt 2}\right)\otimes \left(\frac{\langle R| + \langle L|}{\sqrt 2}\right) + 0.5 \left(\frac{|R\rangle - |L\rangle}{\sqrt 2}\right)\otimes \left(\frac{\langle R| - \langle L|}{\sqrt 2}\right)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the basis $\{\frac{|R\rangle + |L\rangle}{\sqrt 2}, \frac{|R\rangle - |L\rangle}{\sqrt 2}\}$, $\frac{|R\rangle + |L\rangle}{\sqrt 2}$ can be denoted as $\begin{bmatrix} 1 \\ 0 \end{bmatrix}$ and $\frac{|R\rangle - |L\rangle}{\sqrt 2}$ can be denoted as $\begin{bmatrix} 0 \\ 1 \end{bmatrix}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\therefore 0.5 \left(\begin{bmatrix} 1 \\ 0 \end{bmatrix} \otimes \begin{bmatrix} 1 &amp;amp; 0 \end{bmatrix}\right) + 0.5 \left(\begin{bmatrix} 0 \\ 1 \end{bmatrix} \otimes \begin{bmatrix} 0 &amp;amp; 1 \end{bmatrix}\right)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$= 0.5 \begin{bmatrix} 1 &amp;amp; 0 \\ 0 &amp;amp; 0 \end{bmatrix} + 0.5\begin{bmatrix} 0 &amp;amp; 0 \\ 0 &amp;amp; 1 \end{bmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$= \begin{bmatrix} 0.5 &amp;amp; 0 \\ 0 &amp;amp; 0.5 \end{bmatrix}$$&#xA;Thus, we can clearly see that we get the same density matrices in both case 1 and case 2.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, after passing through the vertical plane polarizer (3), the remaining photons are all &lt;strong&gt;vertically polarized&lt;/strong&gt; (4) and have pure state density matrix:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\rho_{\text{pure}} = 1 \left(\frac{|R\rangle + |L\rangle}{\sqrt 2}\right)\otimes \left(\frac{\langle R| + \langle L|}{\sqrt 2}\right) + 0 \left(\frac{|R\rangle - |L\rangle}{\sqrt 2}\right)\otimes \left(\frac{\langle R| - \langle L|}{\sqrt 2}\right) $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the basis $\{\frac{|R\rangle + |L\rangle}{\sqrt 2}, \frac{|R\rangle - |L\rangle}{\sqrt 2}\}$, $|R\rangle$ can be denoted as $\begin{bmatrix} 1 \\ 0 \end{bmatrix}$ and $|L\rangle$ can be denoted as $\begin{bmatrix} 0 \\ 1 \end{bmatrix}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\therefore 1 \left(\begin{bmatrix} 1 \\ 0 \end{bmatrix} \otimes \begin{bmatrix} 1 &amp;amp; 0 \end{bmatrix}\right) + 0 \left(\begin{bmatrix} 0 \\ 1 \end{bmatrix} \otimes \begin{bmatrix} 0 &amp;amp; 1 \end{bmatrix}\right)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$= 1 \begin{bmatrix} 1 &amp;amp; 0 \\ 0 &amp;amp; 0 \end{bmatrix} + 0\begin{bmatrix} 0 &amp;amp; 0 \\ 0 &amp;amp; 1 \end{bmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$= \begin{bmatrix} 1 &amp;amp; 0 \\ 0 &amp;amp; 0 \end{bmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;The single qubit case:&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;If your system contains just a &lt;em&gt;single qubit&lt;/em&gt; and you're &lt;em&gt;know&lt;/em&gt; that its state $|\psi\rangle = \alpha|0\rangle + \beta|1\rangle$ (where $|\alpha|^2+|\beta|^2$) then you are already sure that the 1-qubit system has the state $|\psi\rangle$ with probability $1$!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In this case, the density matrix will simply be:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\rho_{\text{pure}} = 1|\psi\rangle \langle \psi|$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you're using the orthonormal basis $\{\alpha|0\rangle + \beta|1\rangle,\beta^*|0\rangle - \alpha^*|1\rangle\}$, &lt;/p&gt;&#xA;&#xA;&lt;p&gt;the density matrix will simply be:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\begin{bmatrix} 1 &amp;amp; 0 \\ 0 &amp;amp; 0 \end{bmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is very similar to 'case 2' above, so I didn't show the calculations. You can ask questions in the comments if this portion seems unclear.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, you could also use the $\{|0\rangle,|1\rangle\}$ basis as &lt;a href=&quot;https://quantumcomputing.stackexchange.com/users/1837/daftwullie&quot;&gt;@DaftWullie&lt;/a&gt; did in their &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2339/26&quot;&gt;answer&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the general case for a 1-qubit state, the density matrix, in the $\{|0\rangle,|1\rangle\}$ basis would be:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\rho = 1(\alpha |0\rangle + \beta |1\rangle) \otimes (\alpha^* \langle 0| + \beta^* \langle 1|)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$= \begin{bmatrix} \alpha \\ \beta \end{bmatrix} \otimes \begin{bmatrix} \alpha^* &amp;amp; \beta^* \end{bmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$= \begin{bmatrix} \alpha\alpha^* &amp;amp; \alpha\beta^* \\ \beta\alpha^* &amp;amp; \beta\beta^* \end{bmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Notice that this matrix $\rho$ is idempotent i.e. $\rho = \rho^2$. This is an important property of the density matrices of a pure state and helps us to distinguish them from density matrices of mixed states. &lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;strong&gt;Obligatory exercises:&lt;/strong&gt;&lt;/h2&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; Show that density matrices of pure states can be diagonalized to the form $\text{diag}(1,0,0,...)$.&lt;br&gt;&#xA;  &lt;strong&gt;2.&lt;/strong&gt; Prove that density matrices of pure states are idempotent.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Sources &amp;amp; References&lt;/strong&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;[1]&lt;/strong&gt;: &lt;a href=&quot;https://en.wikipedia.org/wiki/Density_matrix&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://en.wikipedia.org/wiki/Density_matrix&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;[2]&lt;/strong&gt;: &lt;a href=&quot;https://physics.stackexchange.com/a/158290&quot;&gt;https://physics.stackexchange.com/a/158290&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Image Credits&lt;/strong&gt;: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;User &lt;a href=&quot;https://commons.wikimedia.org/wiki/User:Kaidor&quot; rel=&quot;nofollow noreferrer&quot;&gt;Kaidor&lt;/a&gt;&#xA;on &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Polarimeter_(Optical_rotation).svg&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wikimedia&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-06-14T19:03:59.543" LastActivityDate="2018-06-14T19:03:59.543" CommentCount="4" />
  <row Id="2349" PostTypeId="2" ParentId="2073" CreationDate="2018-06-14T19:43:07.113" Score="1" Body="&lt;p&gt;There are two possible answers. &lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Let's say the universe evolves from $t=0$ to $t_f$ then the unitary evolution $U$ from $0$ to $t_f$ induces a CP evolution on the subsystem. To see this, note that the composition of CP maps is CP. Now,  the reduced (system) evolution is $Tr_E U\rho_s\otimes\rho_E U^\dagger$ which is a composition of the map $\rho_s\rightarrow \rho_s\otimes\rho_E$ (which is CP), unitary evolution, and partial trace (again CP). So overall it is CP.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;See theorem 5.4 in &lt;a href=&quot;https://cs.uwaterloo.ca/~watrous/LectureNotes/CS766.Fall2011/05.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;John Watrous's lecture notes&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that this extends to multiple systems since each would just involve a different partial trace. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Take the dynamics between $t_i&amp;gt;t_0$ and $t_f$, this might not be CP (or even linear!), which is why NCP maps (and similarly non-linear maps) can be physical. However, this is a slightly tricky subject since it is unclear how you would go about constructing the map. For example, different ways of doing process tomography could lead to different results. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="1864" LastActivityDate="2018-06-14T19:43:07.113" CommentCount="0" />
  <row Id="2350" PostTypeId="2" ParentId="2346" CreationDate="2018-06-14T22:27:24.210" Score="4" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;What does a truth table for a QRCA look like?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;You don't want to know. It will be a gigantic complicated table that provides no insight whatsoever. At the very least you need to use boolean algebra instead of a table, but even that will be cumbersome and will require many intermediate values that ultimately are just a less-visual way of describing an addition circuit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If it helps, here is the set of equations for a simpler operation, an increment operation. The equations define how each output bit can be computed from the input bits:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$o_0 = i_0 \oplus 1$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$o_1 = i_1 \oplus i_0$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$o_2 = i_2 \oplus (i_0 \land i_1)$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\vdots$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$o_n = i_n \oplus {\Large{\land}}_{k=0}^{n-1} i_k$&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;What would a unitary matrix for a QRCA be?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;It's a permutation matrix.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As a starting point, here is the permutation matrix corresponding to a 2-bit increment:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\text{Inc}_2 = \begin{bmatrix}&#xA;&amp;amp;&amp;amp;&amp;amp;1\\&#xA;1&amp;amp;&amp;amp;&amp;amp;\\&#xA;&amp;amp;1&amp;amp;&amp;amp;\\&#xA;&amp;amp;&amp;amp;1&amp;amp;\\&#xA;\end{bmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;and a 3-bit increment:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\text{Inc}_3 = \begin{bmatrix}&#xA;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;1\\&#xA;1&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;\\&#xA;&amp;amp;1&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;\\&#xA;&amp;amp;&amp;amp;1&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;\\&#xA;&amp;amp;&amp;amp;&amp;amp;1&amp;amp;&amp;amp;&amp;amp;&amp;amp;\\&#xA;&amp;amp;&amp;amp;&amp;amp;&amp;amp;1&amp;amp;&amp;amp;&amp;amp;\\&#xA;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;1&amp;amp;&amp;amp;\\&#xA;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;1&amp;amp;\\&#xA;\end{bmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I suspect you see the pattern. Just start with an identity matrix and shift it down by 1 (with the bottom row wrapping around to the top). To add 2, instead of adding 1 (i.e. incrementing) you would just shift down by 2 instead of by 1.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In an addition circuit, the amount of shifting depends on the other input. So you end up with a series of sub-matrices with increasingly-shifted diagonals:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\text{Add}_2 = \begin{bmatrix}&#xA;\begin{bmatrix}&#xA;1&amp;amp;&amp;amp;&amp;amp;\\&#xA;&amp;amp;1&amp;amp;&amp;amp;\\&#xA;&amp;amp;&amp;amp;1&amp;amp;\\&#xA;&amp;amp;&amp;amp;&amp;amp;1\\&#xA;\end{bmatrix}&#xA;\\&amp;amp;&#xA;\begin{bmatrix}&#xA;&amp;amp;&amp;amp;&amp;amp;1\\&#xA;1&amp;amp;&amp;amp;&amp;amp;\\&#xA;&amp;amp;1&amp;amp;&amp;amp;\\&#xA;&amp;amp;&amp;amp;1&amp;amp;\\&#xA;\end{bmatrix}&#xA;\\&amp;amp;&amp;amp;&#xA;\begin{bmatrix}&#xA;&amp;amp;&amp;amp;1&amp;amp;\\&#xA;&amp;amp;&amp;amp;&amp;amp;1\\&#xA;1&amp;amp;&amp;amp;&amp;amp;\\&#xA;&amp;amp;1&amp;amp;&amp;amp;\\&#xA;\end{bmatrix}&#xA;\\&amp;amp;&amp;amp;&amp;amp;&#xA;\begin{bmatrix}&#xA;&amp;amp;1&amp;amp;&amp;amp;\\&#xA;&amp;amp;&amp;amp;1&amp;amp;\\&#xA;&amp;amp;&amp;amp;&amp;amp;1\\&#xA;1&amp;amp;&amp;amp;&amp;amp;\\&#xA;\end{bmatrix}&#xA;\end{bmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;What would a circuit diagram for a QRCA look like?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There are many possible constructions. &lt;a href=&quot;https://arxiv.org/abs/1706.07884&quot; rel=&quot;nofollow noreferrer&quot;&gt;Here&lt;/a&gt; is one that works entirely inline:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/iLBct.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/iLBct.png&quot; alt=&quot;addition circuit&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can &lt;a href=&quot;http://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22Counting5%22%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%22X%22%5D%2C%5B%22Chance5%22%2C1%2C1%2C1%2C1%2C%22Chance5%22%5D%2C%5B%22X%22%2C%22X%22%2C%22X%22%2C%22X%22%2C%22%E2%80%A2%22%2C%22X%22%2C%22X%22%2C%22X%22%2C%22X%22%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22Swap%22%2C1%2C1%2C1%2C%22Swap%22%2C%22%E2%80%A2%22%5D%2C%5B1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B1%2C%22Swap%22%2C1%2C1%2C%22Swap%22%2C1%2C%22%E2%80%A2%22%5D%2C%5B1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C%22Swap%22%2C1%2C%22Swap%22%2C1%2C1%2C%22%E2%80%A2%22%5D%2C%5B1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C%22Swap%22%2C%22Swap%22%2C1%2C1%2C1%2C%22%E2%80%A2%22%5D%2C%5B1%2C1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C%22Swap%22%2C%22Swap%22%2C1%2C1%2C1%2C%22%E2%80%A2%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C%22Swap%22%2C1%2C%22Swap%22%2C1%2C1%2C%22%E2%80%A2%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C1%2C%22X%22%5D%2C%5B1%2C%22Swap%22%2C1%2C1%2C%22Swap%22%2C1%2C%22%E2%80%A2%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C1%2C1%2C%22X%22%5D%2C%5B%22Swap%22%2C1%2C1%2C1%2C%22Swap%22%2C%22%E2%80%A2%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C1%2C%22X%22%5D%2C%5B%22X%22%2C%22X%22%2C%22X%22%2C%22X%22%2C%22%E2%80%A2%22%2C%22X%22%2C%22X%22%2C%22X%22%2C%22X%22%2C%22X%22%5D%2C%5B%22Chance5%22%2C1%2C1%2C1%2C1%2C%22Chance5%22%5D%5D%7D&quot; rel=&quot;nofollow noreferrer&quot;&gt;play with this construction in Quirk&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="119" LastActivityDate="2018-06-14T22:27:24.210" CommentCount="1" />
  <row Id="2351" PostTypeId="2" ParentId="2343" CreationDate="2018-06-14T22:48:26.933" Score="6" Body="&lt;p&gt;Most attacks &lt;em&gt;now&lt;/em&gt; on classical computers don't actually break the encryption, they trick the systems / communication protocols into using it in a weak way, or into exposing information via side channels or directly (via exploits like buffer overflows).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Or they trick &lt;em&gt;humans&lt;/em&gt; into doing something (social engineering).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I.e. currently you don't attack the crypto itself (because things like AES or RSA are &lt;em&gt;very&lt;/em&gt; well tested), you attack the system built around it and the people using it.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;All of these avenues of attack will sill be present when computers communicate via quantum encryption.  However, with quantum encryption theoretically giving perfect security instead of just computational security, tricking a system into weakening its encryption (by using weak keys or wrong keys or keys you already know) shouldn't be a problem.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Possibly there will be weaknesses that systems need to avoid in quantum crypto, especially practical implementations that work over imperfect channels.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;TL:DR: When quantum computers can practically attack RSA and the world switches over to quantum crypto for communication without a pre-shared secret, we'll be back in the same situation we are now: the crypto itself is not the weakest link.&lt;/p&gt;&#xA;" OwnerUserId="2433" LastEditorUserId="2433" LastEditDate="2018-06-14T23:22:19.177" LastActivityDate="2018-06-14T23:22:19.177" CommentCount="2" />
  <row Id="2352" PostTypeId="1" AcceptedAnswerId="2573" CreationDate="2018-06-15T01:30:20.270" Score="6" ViewCount="176" Body="&lt;p&gt;After getting help here with &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2333/quantum-xnor-gate-construction&quot;&gt;XNOR&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2346/quantum-ripple-carry-adder-construction&quot;&gt;RCA&lt;/a&gt; gates I decided to dive into XOR Swaps &amp;amp; XOR linked lists. I was able to find &lt;a href=&quot;http://algassert.com/post/1717&quot; rel=&quot;nofollow noreferrer&quot;&gt;this&lt;/a&gt; explanation for quantum XOR Swapping which seems sufficient for the time being. I am not able to find any information on &lt;em&gt;quantum XOR linked lists&lt;/em&gt; however (Google returns &quot;no results&quot;). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;How would a quantum &lt;a href=&quot;https://wikipedia.org/wiki/XOR_linked_list&quot; rel=&quot;nofollow noreferrer&quot;&gt;XOR linked list&lt;/a&gt; be expressed?&lt;/strong&gt;&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-08-31T02:24:17.733" LastActivityDate="2018-08-31T02:24:17.733" Title="Quantum XOR Linked List Construction" Tags="&lt;quantum-gate&gt;&lt;universal-gates&gt;&lt;gate-synthesis&gt;&lt;controlled-gates&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2353" PostTypeId="1" AcceptedAnswerId="2356" CreationDate="2018-06-15T06:10:22.577" Score="5" ViewCount="63" Body="&lt;p&gt;I would like to implement a quantum program on the &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/editor&quot; rel=&quot;nofollow noreferrer&quot;&gt;IBM Composer&lt;/a&gt; with following characteristics:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;The output is the observed value of 3 qubits&lt;/li&gt;&#xA;&lt;li&gt;Only one of the 3 qubits should be observed as $1$, the 2 others should be $0$&lt;/li&gt;&#xA;&lt;li&gt;The probability that a qubit is observed as $1$ is $1/3$&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;So the 3 possible outputs of this circuit are: $|100\rangle$,$|010\rangle$,$|001\rangle$ (all 3 having equality probability of being outputted)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So how can we best implement such a circuit on the IBM Composer ?&lt;/p&gt;&#xA;" OwnerUserId="2529" LastEditorUserId="2371" LastEditDate="2018-06-15T09:22:43.763" LastActivityDate="2018-06-15T18:36:25.960" Title="How to implement a random selection of one of the 3 qubits on the IBM Q (composer)?" Tags="&lt;quantum-computer&gt;&lt;quantum-algorithms&gt;&lt;quantum-gate&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2354" PostTypeId="2" ParentId="2347" CreationDate="2018-06-15T07:13:25.923" Score="1" Body="&lt;h1&gt;Motivation&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;The motivation behind density matrices is to represent a lack of knowledge about the state of a given quantum system, encapsulating within a single description of this system all the possible outcomes of measurement results, given what we know about the system. The density matrix representation has the added advantage of getting rid of any issues associated with global phases because&#xA;$$&#xA;|\phi\rangle\langle\phi|=(e^{i\varphi}|\phi\rangle)(e^{-i\varphi}\langle\phi|).&#xA;$$&#xA;The lack of knowledge might arise in a variety of ways:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;A subjective lack of knowledge - a referee prepares for you one of a set of states $\{|\phi_i\rangle\}$ with probability $p_i$, but you don't know which. Even if they know which $|\phi_j\rangle$ they prepared, since you do not, you have to describe it based upon what you know of the possible set of states and their corresponding probabilities, $\rho=\sum_ip_i|\phi_i\rangle\langle \phi_i|$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;An objective lack of knowledge - if the quantum system is part of a larger entangled state, it is impossible to describe the system as a pure state, but all possible outcomes of measurements are described by the density matrix obtained by $\rho=\text{Tr}_B(\rho_{AB})$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;It is interesting, however, that the objective lack of knowledge can become subjective - a second party can perform operations on the rest of the entangled state. They can know the measurement results etc. but if they don't pass those on, the person holding the original quantum system has no new knowledge, and so describes their system using the same density matrix as before, but it is now a subjective description.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is also important to note that choosing a particular way of representing the density matrix, for example, $\rho=\sum_ip_i|\phi_i\rangle\langle \phi_i|$, is a very subjective choice. It may be motivated by a particular preparation procedure, but mathematically, any description that gives the same matrix is equivalent. For example, on a single qubit, $\rho=\frac12\mathbb{I}$ is known as the maximally mixed state. Due to the completeness relation of a basis, this can be represented as a 50:50 mixture or two orthogonal states using &lt;em&gt;any&lt;/em&gt; 1-qubit basis.&#xA;$$&#xA;\frac12\mathbb{I}=\frac12|0\rangle\langle 0|+\frac12|1\rangle\langle 1|=\frac12|+\rangle\langle +|+\frac12|-\rangle\langle -|.&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;Pure and Mixed States&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;The difference between the density matrix of a pure state and a mixed state is straightforward - the pure state is a special case which can be written in the form $\rho=|\psi\rangle\langle\psi |$, while a mixed state cannot be written in this form. Mathematically, this means that the density matrix of a pure state has rank 1, while a mixed state has rank greater than 1. The best way of calculating this is via $\text{Tr}(\rho^2)$: $\text{Tr}(\rho^2)=1$ implies a pure state, otherwise it's mixed. To see this, recall that $\text{Tr}(\rho)=1$, meaning that all the eigenvalues sum to 1. Also, $\rho$ is positive semi-definite, so all the eigenvalues are real and non-negative. So, if $\rho$ is rank 1, the eigenvalues are $(1,0,0,\ldots ,0)$, and their sum-square is clearly 1. The sum-square of any other set of non-negative numbers that sum to 1 must be less than 1.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The pure state corresponds to perfect knowledge of the system, although the fun bit about quantum mechanics is that this does not imply full knowledge of the possible measurement outcomes. Mixed states represent some imperfect knowledge, whether that's knowledge of the preparation, or knowledge of a larger Hilbert space.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;That the mixed state description is much richer can be seen from the Bloch sphere picture on a single qubit: the pure states are all those on the surface of the sphere, while the mixed states are all those contained within the volume. In terms of parameter counting, instead of two parameters, you need three, the extra one corresponding to the length of the Bloch vector.&#xA;$$&#xA;\rho=\frac{\mathbb{I}+r\underline{n}\cdot\underline{\sigma}}{2},&#xA;$$&#xA;where $\underline{n}$ is a 3-element unit vector, $\underline{\sigma}$ is a vector of the Pauli matrices, and $r=1$ for a pure state, and $0\leq r&amp;lt;1$ for a mixed state.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-15T07:13:25.923" CommentCount="0" />
  <row Id="2355" PostTypeId="1" AcceptedAnswerId="2360" CreationDate="2018-06-15T11:23:18.600" Score="7" ViewCount="162" Body="&lt;p&gt;I was wondering if something like this is possible in QISKit: let's say we have two registers containing target and ancilla qubits:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$a_0$ -------------------&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$a_1$-------------------- &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\vdots$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$a_4$ ------------------&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$t_0$ ------------------&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$t_1$ ------------------&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\vdots$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$t_4$ ------------------&lt;/p&gt;&#xA;&#xA;&lt;p&gt;These two registers are stored in one quantum register &lt;code&gt;qr&lt;/code&gt;. So to access $a_0$ we would type &lt;code&gt;qr[0]&lt;/code&gt;, to access $a_1$ - &lt;code&gt;qr[1]&lt;/code&gt;, ..., for $t_5$ - &lt;code&gt;qr[9]&lt;/code&gt;. We can pass this quantum register as an argument to some function:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;foo(qr, ...)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;What I want to do is to interleave the ancilla and target qubits:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$a_0$ -------------------&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$t_0$-------------------- &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\vdots$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$a_i$ ------------------&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$t_i$ ------------------&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\vdots$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$a_4$ ------------------&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$t_4$ ------------------&lt;/p&gt;&#xA;&#xA;&lt;p&gt;so to access $a_0$ I would type &lt;code&gt;qr[0]&lt;/code&gt;, for $t_1$ - &lt;code&gt;qr[1]&lt;/code&gt; and so on. Finally, I would like to pass such &lt;code&gt;changed&lt;/code&gt; quantum register &lt;code&gt;qr'&lt;/code&gt; again as an argument to some function&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;foo(qr', ...)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;and in this function I would like to use these changed indices. Is this possible? Other solution I figured out was to pass array of indices for ancilla and target qubits, but I would like to avoid that. Another option would be to use &lt;code&gt;swap&lt;/code&gt; gates on these qubits&lt;/p&gt;&#xA;" OwnerUserId="2098" LastEditorUserId="26" LastEditDate="2018-06-15T15:45:25.337" LastActivityDate="2018-08-07T21:15:27.453" Title="Changing indices of qubits in QISKit" Tags="&lt;qubit&gt;&lt;quantum-programming&gt;&lt;ibm-q-experience&gt;&lt;qiskit&gt;" AnswerCount="1" CommentCount="2" />
  <row Id="2356" PostTypeId="2" ParentId="2353" CreationDate="2018-06-15T12:17:38.853" Score="4" Body="&lt;p&gt;The pure quantum state that satisfies your conditions  is the &lt;a href=&quot;https://en.wikipedia.org/wiki/W_state&quot; rel=&quot;nofollow noreferrer&quot;&gt;W state&lt;/a&gt; in three qubits,&#xA;$$ \frac{1}{\sqrt{3}} \left(|001\rangle + |010\rangle  + |100\rangle \right) $$ &lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can look at this &lt;a href=&quot;https://physics.stackexchange.com/questions/311743/quantum-circuit-for-a-w-state&quot;&gt;answer&lt;/a&gt; for a high level circuit to construct this. The first gate in that circuit is a single  qubit gate that effects the transformation,&#xA;$$ |0 \rangle \rightarrow \frac{1}{\sqrt{3}} |1 \rangle +  \sqrt{\frac{2}{3}} | 0\rangle .$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This you can implement in the composer as a $U_3$ gate with an appropriate value of theta.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Next you will need a controlled H gate between the first and second qubits, and a Toffoli gate. To implement them in the composer you can use the circuits given  &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/proxy/tutorial/full-user-guide/004-Quantum_Algorithms/061-Basic_Circuit_Identities_and_Larger_Circuits.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;&#xA;. The control gates in the &lt;a href=&quot;https://physics.stackexchange.com/questions/311743/quantum-circuit-for-a-w-state&quot;&gt;answer&lt;/a&gt; have the control qubits flipped (the controls are triggered by $0$ and not $1$ ). So you will need to sandwich your control qubits in the composer between $X$ gates to get the desired circuit. As you can see, constructing this from scratch in the composer is rather tedious.&lt;/p&gt;&#xA;" OwnerUserId="2663" LastEditorUserId="23" LastEditDate="2018-06-15T18:36:25.960" LastActivityDate="2018-06-15T18:36:25.960" CommentCount="2" />
  <row Id="2357" PostTypeId="2" ParentId="2058" CreationDate="2018-06-15T12:39:07.157" Score="1" Body="&lt;p&gt;The situation of non-completely positive maps (or more generally non-linear maps)  is  controversial partly due to the precise definition of &lt;a href=&quot;https://arxiv.org/abs/1212.4387&quot; rel=&quot;nofollow noreferrer&quot;&gt;how you should construct the map&lt;/a&gt;. But it is easy to come up with an example of something that would seem to be NCP or even not linear. &lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Non linear map. &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Consider a preparation device that can create a qubit in an arbitrary state $\rho$ (this device has 3 dials). Now let this device be constructed so that it also prepares a second state $\rho$ in the environment. I.e, you think you prepared a one qubit state $\rho$ but actually you prepared a two qubit state $\rho\otimes\rho$. The second qubit is the environment (which you cannot access), so if you perform tomography on your qubit, everything seems ok. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;No imagine that you also have the following black box - it has (as far as you can tell) one input and two outputs. In reality (unknown to you) it has two inputs and two outputs and it simply spits out both the system qubit and the environement qubit. As far as you can tell, this black box is a cloning machine, violating linearity.  &lt;/p&gt;&#xA;&#xA;&lt;ol start=&quot;2&quot;&gt;&#xA;&lt;li&gt;NCP&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Similar to the idea above, but the preparation device prepares $\rho\otimes\rho^T$ (clearly this could be done in the lab). The black box will now be a one rail box (one qubit input one qubit output as far as the user is concerned), which swaps the system and environement. To you, it seems like a trasposition map.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that both preparation devices are physical, but the way you construct the map might depend on how you use them. In the example above I assumed that a mixed state $\rho$ would only be constructed by using the three dials in the machine. In principle, I could try to construct a mixed state by flipping coins and preparing pure states with the right probability. Tomorgraphy would show that the processes are equivalent, but the environment would be different, and the map you would construct for the black boxes would be different. &lt;/p&gt;&#xA;" OwnerUserId="1864" LastActivityDate="2018-06-15T12:39:07.157" CommentCount="0" />
  <row Id="2358" PostTypeId="1" AcceptedAnswerId="2361" CreationDate="2018-06-15T18:02:17.510" Score="13" ViewCount="116" Body="&lt;p&gt;It has been proven that adiabatic quantum computing is equivalent to &quot;standard&quot;, or gate-model quantum computing. Adiabatic computing, however, shows promises for optimisation problems, where the objective is to minimise (or maximise) a function which is in some way related to the problem – that is, finding the instance that minimises (or maximises) this function immediately solves the problem.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, it seems to me that Grover's algorithm can essentially do the same: by searching over the solution space, it will find one solution (possibly out of many solutions) that satisfies the oracle criterion, which in this case equates to the optimality condition, in time $O(\sqrt N)$, where $N$ is the size of the solution space.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This algorithm has been shown to be optimal: as Bennett et al. (1997) put it, &quot;the class $\rm NP$ cannot be solved on a quantum Turing machine in time $o(2^{n/2})$&quot;. In my understanding, this means there is no way to construct any quantum algorithm that finds a solution by searching through the space faster than $O(\sqrt N)$, where $N$ scales with the problem size.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So my question is: while adiabatic quantum computing is often presented as being superior when it comes to optimisation problems, can it really be faster than $O(\sqrt N)$? If yes, this seems to contradict the optimality of Grover's algorithm, since any adiabatic algorithm can be simulated by a quantum circuit. If not, what is the point of developing adiabatic algorithms, if they are never going to be faster than something we can systematically construct with circuits? Or is there something wrong with my understanding?&lt;/p&gt;&#xA;" OwnerUserId="2687" LastEditorUserId="2687" LastEditDate="2018-06-15T23:34:50.730" LastActivityDate="2018-06-16T17:51:37.903" Title="Can adiabatic quantum computing be faster than Grover's algorithm?" Tags="&lt;quantum-computer&gt;&lt;grovers-algorithm&gt;&lt;adiabatic-model&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="2" />
  <row Id="2360" PostTypeId="2" ParentId="2355" CreationDate="2018-06-16T00:33:19.747" Score="4" Body="&lt;p&gt;The relationship between your indices can be captured by a map:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\{0: 0, 1: 2, 2: 4, 3: 6, 4: 8, 5: 1, 6: 3, 7: 5, 8: 7, 9: 9\}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can then use this to specify where operations get applied to in a register. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here is a simple code in QISKit (generalizes to arbitrary register length):&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;from qiskit import * &#xA;from qiskit.tools.visualization import *&#xA;&#xA;# build a register with k targets and k ancillas &#xA;k = 5&#xA;qr = QuantumRegister(2*k)&#xA;circ = QuantumCircuit(qr)&#xA;&#xA;# apply cx between ancillas and targets&#xA;for i in range(k):&#xA;    circ.cx(qr[i], qr[i+k])&#xA;&#xA;circuit_drawer(circ)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/mPrEbm.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/mPrEbm.png&quot; alt=&quot;original&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# specify the desired interleaving&#xA;# {0: 0, 1: 2, 2: 4, 3: 6, 4: 8, 5: 1, 6: 3, 7: 5, 8: 7, 9: 9}&#xA;new_qubit_map = {i: 2*i if i &amp;lt; k else 2*(i-k)+1 for i in range(len(qr))}&#xA;&#xA;# create the same circuit, but with the new interleaving&#xA;circ_2 = QuantumCircuit(qr)&#xA;for i in range(k):&#xA;    circ_2.cx(qr[new_qubit_map[i]], qr[new_qubit_map[i+k]])&#xA;&#xA;circuit_drawer(circ_2)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/hMtgDm.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/hMtgDm.png&quot; alt=&quot;interleaved&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="2503" LastEditorUserId="26" LastEditDate="2018-06-17T06:23:10.790" LastActivityDate="2018-06-17T06:23:10.790" CommentCount="0" />
  <row Id="2361" PostTypeId="2" ParentId="2358" CreationDate="2018-06-16T00:52:06.510" Score="5" Body="&lt;p&gt;Good question. For unstructured search, adiabatic quantum computation indeed gives the exact same $\sqrt{N}$ speedup that the standard gate-based Grover's algorithm does, as proven in &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0107015&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt; important paper by Roland and Cerf. This agrees with the equivalence between adiabatic and gate-based quantum computation that you mentioned.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(One minor correction to your question: you're correct that in the setup for the oracle-search problem, you need to frame your search query as a yes/no question that the oracle can answer. But the question isn't actually taken to be &quot;does $x$ extremize the function $f(x)$?&quot;, as you proposed. Instead, it's &quot;is $f(x)$ less than or equal to $M$?&quot; See slides 9 and 10 &lt;a href=&quot;https://courses.csail.mit.edu/6.006/spring11/lectures/lec25.pdf&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;. That's because an oracle for the latter question is considered a more realistic model for a physical setup, where it's conceivable that one could directly compute or measure $f(x)$ for a given $x$, but $f(x) - f_\text{min}$.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Nevertheless, there are two potential advantages to adiabatic QC, both of which are difficult to study theoretically. The first is practical: actually building large coherent quantum circuits is a whole lot harder that just drawing them in a journal article. Even though adiabatic QC doesn't have any &lt;em&gt;fundamental&lt;/em&gt; advantage over the traditional setup, it might be much easier to implement experimentally.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Secondly, the same huge caveat applies to AQC as to the standard Grover's algorithm: it only applies to &lt;em&gt;unstructured&lt;/em&gt; or &quot;black-box&quot; search, where we complete ignore any correlations between the answers that the oracle gives when fed in &quot;similar&quot; or &quot;related&quot; queries. Any actual search problem that we care about will by definition have some structure to it, although this structure may be far too complicated for us to analyze. For example, if we think of the function to be extremized as an energy landscape, it seems reasonable that the system can more easily tunnel between &quot;nearby&quot; local minima than between &quot;faraway&quot; ones.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So to really rigorously compare the relative benefits of the adiabatic vs. gate-based setups in a real experiment, you'd need to &quot;overcome the relativization barrier&quot; and consider the structure of the specific function that you're trying to extremize, which is usually &lt;em&gt;really&lt;/em&gt; hard to do. This makes it very difficult to draw general conclusions about the two approach's relative advantages in the real world. It's also why it's so hard to prove unconditional complexity separations theoretically. For all we know, for real-world rather than oracle problems, quantum computers might be able to give exponential speedups - possibly even for NP-complete problems, which would imply that &lt;strong&gt;NP&lt;/strong&gt; $\subset$ &lt;strong&gt;BQP&lt;/strong&gt;, although this is considered very unlikely.&lt;/p&gt;&#xA;" OwnerUserId="551" LastEditorUserId="551" LastEditDate="2018-06-16T01:23:49.073" LastActivityDate="2018-06-16T01:23:49.073" CommentCount="4" />
  <row Id="2363" PostTypeId="1" AcceptedAnswerId="2364" CreationDate="2018-06-16T09:45:44.200" Score="6" ViewCount="112" Body="&lt;p&gt;Moore's law states that computer power doubles in every 18 months (more formally: &quot;the number of transistors in a dense integrated circuit doubles about every two years.&quot;). Statistics suggest that this observation should be correct, but aren't quantum computers much more powerful than just double-powered classical computers? More interesting question is, is there even a way to improve the power of quantum computers?&lt;/p&gt;&#xA;" OwnerUserId="2559" LastEditorUserId="26" LastEditDate="2018-07-14T18:31:01.127" LastActivityDate="2018-07-14T18:31:26.323" Title="Will Moore's Law be no longer effective once quantum computers are created?" Tags="&lt;quantum-computer&gt;&lt;experimental-results&gt;&lt;classical-computing&gt;&lt;scalability&gt;" AnswerCount="3" CommentCount="0" FavoriteCount="1" ClosedDate="2018-06-17T17:05:54.210" />
  <row Id="2364" PostTypeId="2" ParentId="2363" CreationDate="2018-06-16T17:31:36.700" Score="3" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;but aren't quantum computers much more powerful than just&#xA;  double-powered classical computers?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Yes. A universal quantum computer with only 100 qubits (12.5 quantum bytes) can find the ground state of a matrix with $2^{200} = 10^{60}$ elements. Assuming Moore's Law could continue forever (which is not true due to physical limitations), it would take longer than the age of the universe (13.5 billion years) for the &quot;doubling of transistors every 18 months&quot; to bring classical computers to what a quantum computer with one quantum gigabyte can do, for certain problems. &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;More interesting question is, is there even a way to improve the power of&#xA;  quantum computers?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There have been proposals for exploiting certain types of phenomena that would lead to devices even more powerful than quantum computers, but in all cases quantum computers would be a special case of such devices (just like classical computers are a special case of quantum computers, they are quantum computers that just only use classical gates and inputs that are not in any superposition). It is hard enough to build a quantum computer, so building the more generalized devices would be even harder.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="26" LastEditDate="2018-07-14T18:31:26.323" LastActivityDate="2018-07-14T18:31:26.323" CommentCount="2" />
  <row Id="2365" PostTypeId="2" ParentId="2358" CreationDate="2018-06-16T17:51:37.903" Score="0" Body="&lt;p&gt;Adiabatic quantum computation cannot do &lt;strong&gt;&lt;em&gt;anything&lt;/em&gt;&lt;/strong&gt; faster than circuit-based quantum computation from a computational complexity perspective. This is because there is a mathematical proof that circuit-based quantum computation can efficiently simulate adiabatic quantum computation [see section 5 of &lt;a href=&quot;https://arxiv.org/pdf/quant-ph/0001106.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;this paper&lt;/a&gt;]. &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;can it really be faster than $\mathcal{O}(\sqrt{N})$?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The answer is no. This is because if AQC could do it in, say, $\mathcal{O}(\log{N})$, then circuit-based QC could also do it in $\mathcal{O}(\log{N})$ by the algorithm in section 5 of the paper I linked above. This would violate the optimality of $\mathcal{O}(\sqrt{N})$ for unstructured search.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-06-16T17:51:37.903" CommentCount="0" />
  <row Id="2366" PostTypeId="1" CreationDate="2018-06-16T21:50:42.390" Score="8" ViewCount="123" Body="&lt;p&gt;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1863/2645&quot;&gt;This answer&lt;/a&gt; cites &lt;a href=&quot;https://arxiv.org/abs/1804.05979&quot; rel=&quot;noreferrer&quot;&gt;a paper&lt;/a&gt;&lt;sup&gt;[$\dagger$]&lt;/sup&gt; which purposes a quantum blockchain using entanglement in time. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;The weakness is that the research only presents a conceptual design.&quot; - QComp2018&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;How could a quantum blockchain which leverages time entanglement be realized?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Resources:&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1705.09258&quot; rel=&quot;noreferrer&quot;&gt;Quantum Secured Blockchain&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.researchgate.net/publication/299749136_Quantum_Bitcoin_An_Anonymous_and_Distributed_Currency_Secured_by_the_No-Cloning_Theorem_of_Quantum_Mechanics&quot; rel=&quot;noreferrer&quot;&gt;Quantum Bitcoin&lt;/a&gt;: An Anonymous and Distributed Currency Secured by the No-Cloning Theorem of Quantum Mechanics&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;[$\dagger$]: &lt;em&gt;Quantum Blockchain using entanglement in time&lt;/em&gt; Rajan &amp;amp; Visser (2018)&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-07-03T06:50:44.553" LastActivityDate="2018-07-03T06:50:44.553" Title="Time Entangled Quantum Blockchain" Tags="&lt;quantum-algorithms&gt;&lt;cryptography&gt;&lt;post-quantum-crypto&gt;&lt;cryptocurrency&gt;" AnswerCount="0" CommentCount="1" />
  <row Id="2367" PostTypeId="2" ParentId="2363" CreationDate="2018-06-17T05:18:19.923" Score="1" Body="&lt;p&gt;The quantum equivalent of Moore's Law is Rose's Law which states that &quot;the number of qubits in a scalable quantum computing architecture should double every year.&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The prediction was made by Geordie Rose of D-Wave circa 2003. See D-Wave's &lt;a href=&quot;https://www.dwavesys.com/tutorials/background-reading-series/introduction-d-wave-quantum-hardware#h2-9&quot; rel=&quot;nofollow noreferrer&quot;&gt;Future of Hardware&lt;/a&gt;, &lt;a href=&quot;http://www.33rdsquare.com/2012/10/roses-law-for-quantum-computers.html/&quot; rel=&quot;nofollow noreferrer&quot;&gt;this article&lt;/a&gt; or &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1916/2645&quot;&gt;this amazing answer&lt;/a&gt; for more info.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My understanding is that a quantum computer can make $2^n$ computations per step where n is the number of qubits. With the number of qubits doubling every year this means the computational power of quantum computers will accelerate &lt;em&gt;very quickly&lt;/em&gt;.&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-06-17T06:05:46.710" LastActivityDate="2018-06-17T06:05:46.710" CommentCount="0" />
  <row Id="2368" PostTypeId="2" ParentId="2363" CreationDate="2018-06-17T05:52:09.527" Score="1" Body="&lt;p&gt;Moore's law is not a fundamental law of the nature. It is just a heuristic mentioned by Moore to show the growing importance of computer technology. You should never take it granted and there is nothing wrong if the actual trend doesn't follow Moore's law. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Secondly, Quantum computers give speed up in only certain kinds of computations. You cannot expect it to give exponential speed up for every classical algorithm. So it is inappropriate to compare a QC with a Classical computer. Classical computers are going to stay even after QC become commercially viable.&lt;/p&gt;&#xA;" OwnerUserId="2384" LastActivityDate="2018-06-17T05:52:09.527" CommentCount="1" />
  <row Id="2370" PostTypeId="1" AcceptedAnswerId="2379" CreationDate="2018-06-17T16:47:27.217" Score="12" ViewCount="85" Body="&lt;h2&gt;Background&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;The Toffoli gate is a 3-input, 3-output classical logic gate. It sends $(x, y, a)$ to $(x, y, a \oplus (x \cdot y))$. It is significant in that it is universal for reversible (classical) computation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Popescu-Rohrlich box is the simplest example of a non-signaling correlation. It takes a pair of inputs $(x, y)$ and outputs $(a, b)$ satisfying $x \cdot y = a \oplus b$ such that $a$ and $b$ are both uniform random variables. It is universal for &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0506180&quot; rel=&quot;noreferrer&quot;&gt;a certain class of&lt;/a&gt; (&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0701142&quot; rel=&quot;noreferrer&quot;&gt;but not all&lt;/a&gt;) non-signaling correlations.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To my eye, these two objects look extremely similar, especially if we augment the PR box by having it output $(x, y, a, b) = (x, y, a, a \oplus (x \cdot y))$. This 2-input, 4-output PR box &quot;is&quot; the 3-input, 3-output Toffoli gate but with the third input replaced by a random output. But I've been unable to locate any references that relate them.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Question&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;What is the relationship between the Toffoli gate and the Popescu-Rohrlich box? Is there something like a correspondence between reversible classical circuits and (a certain class of?) non-signaling correlations that maps one to the other?&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Observations&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Specifying a non-signaling correlation requires not just a function but also an assignment of each input and output to a party that controls it. A PR box is no longer non-signaling if we allow Alice to enter both inputs and Bob to read both outputs. Or in our &quot;augmented&quot; PR-box, if Alice inputs $x$, she must also be the one who reads the copy of $x$. So it seems nontrivial to determine, for a general circuit (with some inputs possibly replaced by random outputs), all the ways inputs and outputs can be assigned to parties such that communication is not possible.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;We can apply the above procedure any logic gate, including irreversible ones. For instance, we can take AND and replace one of the inputs by a random output, and get a function one input $x$ and a pair $(a, x \cdot a)$ where $a$ is a uniform random variable. However, $x \cdot a$ is $0$ conditioned on $x = 0$, so the only way this can be non-signaling is if Alice, who inputs $x$, receives $x \cdot a$. But this procedure can already be reproduced classically with a shared source of randomness. So I would expect that including irreversible gates does not expand the class of non-signaling correlations one can construct.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="2547" LastActivityDate="2018-06-18T13:00:08.743" Title="What is the relationship between the Toffoli gate and the Popescu-Rohrlich box?" Tags="&lt;quantum-information&gt;&lt;non-locality&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="2371" PostTypeId="1" AcceptedAnswerId="2535" CreationDate="2018-06-17T17:08:26.247" Score="8" ViewCount="205" Body="&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/C10k_problem&quot; rel=&quot;nofollow noreferrer&quot;&gt;C10k Problem&lt;/a&gt; is a classical computing problem whose name (C10k) is a numeronym for concurrently handling ten thousand connections.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;How could a quantum network be constructed to handle 10,000 clients concurrently?&lt;/strong&gt;&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-06-25T09:20:28.490" LastActivityDate="2018-06-29T20:22:51.223" Title="How could a quantum network be constructed to handle 10,000 clients concurrently?" Tags="&lt;quantum-algorithms&gt;&lt;architecture&gt;&lt;many-body-systems&gt;&lt;quantum-networks&gt;&lt;quantum-communication&gt;" AnswerCount="2" CommentCount="5" FavoriteCount="1" />
  <row Id="2372" PostTypeId="1" CreationDate="2018-06-17T17:55:12.897" Score="11" ViewCount="261" Body="&lt;p&gt;I'm fairly confused about how Grover's algorithm could be used in practice and I'd like to ask help on clarification through an example.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's assume an $N=8$ element database that contains colors Red, Orange, Yellow, Green, Cyan, Blue, Indigo and Violet, and not necessarily in this order. My goal is to find Red in the database.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The input for Grover's algorithm is $n = \log_2(N=8) = 3$ qubits, where the 3 qubits encode the indices of the dataset. My confusion comes here (might be confused about the premises so rather say confusion strikes here) that, as I understand, the oracle actually searches for one of the indices of the dataset (represented by the superposition of the 3 qubits), and furthermore, the oracle is &quot;hardcoded&quot; for which index it should look for.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My questions are:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;What do I get wrong here?&lt;/li&gt;&#xA;&lt;li&gt;If the oracle is really looking for one of the indices of the database, that would mean we know already which index we are looking for, so why searching?&lt;/li&gt;&#xA;&lt;li&gt;Given the above conditions with the colors, could someone point it out if it is possible with Grover's to look for Red in an unstructured dataset? &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;There are implementations for Grover's algorithm with an oracle for $n=3$ searching for |111&gt;, e.g. (or see an R implementation of the same oracle below): &#xA;&lt;a href=&quot;https://i.stack.imgur.com/eF896.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/eF896.png&quot; alt=&quot;Oracle for 111&quot;&gt;&lt;/a&gt;&#xA;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2205&quot;&gt;https://quantumcomputing.stackexchange.com/a/2205&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Again, my confusion is, given I do not know the position of $N$ elements in a dataset, the algorithm requires me to search for a string that encodes the position of $N$ elements. How do I know which position I should look for when the dataset is unstructured?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;R code:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt; #START&#xA; a = TensorProd(TensorProd(Hadamard(I2),Hadamard(I2)),Hadamard(I2))&#xA; # 1st CNOT&#xA; a1= CNOT3_12(a)&#xA; # 2nd composite&#xA; # I x I x T1Gate&#xA; b = TensorProd(TensorProd(I2,I2),T1Gate(I2)) &#xA; b1 = DotProduct(b,a1)&#xA; c = CNOT3_02(b1)&#xA; # 3rd composite&#xA; # I x I x TGate&#xA; d = TensorProd(TensorProd(I2,I2),TGate(I2))&#xA; d1 = DotProduct(d,c)&#xA; e = CNOT3_12(d1)&#xA; # 4th composite&#xA; # I x I x T1Gate&#xA; f = TensorProd(TensorProd(I2,I2),T1Gate(I2))&#xA; f1 = DotProduct(f,e)&#xA; g = CNOT3_02(f1)&#xA; #5th composite&#xA; # I x T x T&#xA; h = TensorProd(TensorProd(I2,TGate(I2)),TGate(I2))&#xA; h1 = DotProduct(h,g)&#xA; i = CNOT3_01(h1)&#xA; #6th composite&#xA; j = TensorProd(TensorProd(I2,T1Gate(I2)),I2)&#xA; j1 = DotProduct(j,i)&#xA; k = CNOT3_01(j1)&#xA; #7th composite&#xA; l = TensorProd(TensorProd(TGate(I2),I2),I2)&#xA; l1 = DotProduct(l,k)&#xA; #8th composite&#xA; n = TensorProd(TensorProd(Hadamard(I2),Hadamard(I2)),Hadamard(I2))&#xA; n1 = DotProduct(n,l1)&#xA; n2 = TensorProd(TensorProd(PauliX(I2),PauliX(I2)),PauliX(I2))&#xA; a = DotProduct(n2,n1)&#xA; #repeat the same from 2st not gate&#xA; a1= CNOT3_12(a)&#xA; # 2nd composite&#xA; # I x I x T1Gate&#xA; b = TensorProd(TensorProd(I2,I2),T1Gate(I2))&#xA; b1 = DotProduct(b,a1)&#xA; c = CNOT3_02(b1)&#xA; # 3rd composite&#xA; # I x I x TGate&#xA; d = TensorProd(TensorProd(I2,I2),TGate(I2))&#xA; d1 = DotProduct(d,c)&#xA; e = CNOT3_12(d1)&#xA; # 4th composite&#xA; # I x I x T1Gate&#xA; f = TensorProd(TensorProd(I2,I2),T1Gate(I2))&#xA; f1 = DotProduct(f,e)&#xA; g = CNOT3_02(f1)&#xA; #5th composite&#xA; # I x T x T&#xA; h = TensorProd(TensorProd(I2,TGate(I2)),TGate(I2))&#xA; h1 = DotProduct(h,g)&#xA; i = CNOT3_01(h1)&#xA; #6th composite&#xA; j = TensorProd(TensorProd(I2,T1Gate(I2)),I2)&#xA; j1 = DotProduct(j,i)&#xA; k = CNOT3_01(j1)&#xA; #7th composite&#xA; l = TensorProd(TensorProd(TGate(I2),I2),I2)&#xA; l1 = DotProduct(l,k)&#xA; #8th composite&#xA; n = TensorProd(TensorProd(PauliX(I2),PauliX(I2)),PauliX(I2))&#xA; n1 = DotProduct(n,l1)&#xA; n2 = TensorProd(TensorProd(Hadamard(I2),Hadamard(I2)),Hadamard(I2))&#xA; n3 = DotProduct(n2,n1)&#xA; result=measurement(n3)&#xA; plotMeasurement(result)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/zJBT3.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/zJBT3.png&quot; alt=&quot;Image2&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="2698" LastActivityDate="2018-07-24T10:41:41.260" Title="Grover's algorithm: a real life example?" Tags="&lt;grovers-algorithm&gt;" AnswerCount="2" CommentCount="2" FavoriteCount="3" />
  <row Id="2373" PostTypeId="2" ParentId="2372" CreationDate="2018-06-17T20:06:47.840" Score="3" Body="&lt;p&gt;This is already partially discussed in &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/2110/55&quot;&gt;this related question&lt;/a&gt;, but I'll try here to address more specifically some of the issues you rise.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Generally speaking, Grover's algorithm rests upon the assumption that one is able to perform a &lt;em&gt;querying&lt;/em&gt; operation of the form $$|i\rangle\mapsto(-1)^{f(x_i)}|i\rangle,$$ where $i$ is the index in the database, and $x_i$ whatever information the database attaches to $i$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can think of $f(x_i)$ as &quot;&lt;em&gt;asking a question about $x_i$&lt;/em&gt;&quot;. For example, &quot;&lt;em&gt;is $x_i$ a prime number?&lt;/em&gt;&quot;, or &quot;&lt;em&gt;does $x_i$ have property $P$&lt;/em&gt;?&quot;, where $P$ could mean &quot;being red&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is important to note that $f$ could be asking a question which does not fully characterize $x_i$. This means that after I run the algorithm and retrieve $i$, and thus $x_i$ with it, I also gain knowledge which was not used to build the oracle.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, in many proof of principle implementations of Grover's algorithm, like the one you show, this is not the case.&#xA;Indeed, in these demonstrations the question that is being asked is &quot;trivial&quot;, in the sense that $x_i=i$, and the question is of the form &quot;&lt;em&gt;is $x_i$ equal to 3&lt;/em&gt;?&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In such a case, the algorithm is indeed not particularly useful in that the answer has to be hardcoded into the oracle, but this needs not be the case in general.&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-07-24T10:41:41.260" LastActivityDate="2018-07-24T10:41:41.260" CommentCount="2" />
  <row Id="2374" PostTypeId="2" ParentId="2292" CreationDate="2018-06-17T23:52:35.393" Score="3" Body="&lt;p&gt;This answer is more or less a summary of the Aharonov-Jones-Landau paper you linked to, but with everything not directly related to defining the algorithm removed. Hopefully this is useful.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Aharonov-Jones-Landau algorithm approximates the Jones polynomial of the plat closure of a braid $\sigma$ at a $k$th root of unity by realizing it as (some rescaling of) a matrix element of a certain unitary matrix $U_\sigma$, the image of $\sigma$ under a certain unitary representation of the braid group $B_{2n}$. Given an implementation of $U_\sigma$ as a quantum circuit, approximating its matrix elements is straightforward using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Hadamard_test_(quantum_computation)&quot; rel=&quot;nofollow noreferrer&quot;&gt;Hadamard test&lt;/a&gt;. The nontrivial part is approximating $U_\sigma$ as a quantum circuit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If $\sigma$ is a braid on $2n$ strands with $m$ crossings, we can write $\sigma = \sigma_{a_1}^{\epsilon_1} \sigma_{a_2}^{\epsilon_2} \cdots \sigma_{a_m}^{\epsilon_m}$, where $a_1, a_2, \ldots, a_m \in \{1, 2, \ldots, 2n - 1\}$, $\epsilon_1, \epsilon_2, \ldots, \epsilon_m \in \{\pm 1\}$, and $\sigma_i$ is the generator of $B_{2n}$ that corresponds to crossing the $i$th strand over the $(i + 1)$st. It suffices to describe $U_{\sigma_i}$, since $U_\sigma = U_{\sigma_{a_1}}^{\epsilon_1} \cdots U_{\sigma_{a_m}}^{\epsilon_m}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To define $U_{\sigma_i}$, we first give a certain subset of the standard basis of $\mathbb{C}^{2^{2n}}$ on which $U_{\sigma_i}$ acts nontrivially. For $\psi = \lvert b_1 b_2 \cdots b_{2n} \rangle$, let $\ell_{i'}(\psi) = 1 + \sum_{j = 1}^{i'} (-1)^{1-b_j}$. Let's call $\psi$ &lt;em&gt;admissible&lt;/em&gt; if $1 \leq \ell_{i'}(\psi) \leq k - 1$ for all $i' \in \{1, 2, \ldots, 2n\}$. (This corresponds to $\psi$ describing a path of length $2n$ on the graph $G_k$ defined in the AJL paper.) Let $$\lambda_r = \begin{cases}\sin(\pi r / k) &amp;amp; \textrm{if $1 \leq r \leq k - 1$},\\ 0 &amp;amp; \textrm{otherwise.}\end{cases}$$ Let $A = ie^{-\pi i/2k}$ (this is mistyped in the AJL paper; also note that here and only here, $i = \sqrt{-1}$ is not the index $i$). Write $\psi = \lvert \psi_i b_i b_{i+1} \cdots\rangle$, where $\psi_i$ is the first $i - 1$ bits of $\psi$, and let $z_i = \ell_{i-1}(\psi_i)$. Then&#xA;$$&#xA;\begin{align}&#xA;U_{\sigma_i}(\lvert\psi_i 00 \cdots\rangle) &amp;amp; = A^{-1}\lvert\psi_i 00 \cdots\rangle\\&#xA;U_{\sigma_i}(\lvert\psi_i 01 \cdots \rangle) &amp;amp; = \left( A\frac{\lambda_{z_i-1}}{\lambda_{z_i}} + A^{-1}\right)\lvert\psi_i 01 \cdots\rangle + A\frac{\sqrt{\lambda_{z_i+1}\lambda_{z_i-1}}}{\lambda_{z_i}}\lvert\psi_i 10 \cdots\rangle\\&#xA;U_{\sigma_i}(\lvert\psi_i 10 \cdots \rangle) &amp;amp; = A\frac{\sqrt{\lambda_{z_i+1}\lambda_{z_i-1}}}{\lambda_{z_i}}\lvert\psi_i 01 \cdots\rangle + \left(A\frac{\lambda_{z_i+1}}{\lambda_{z_i}} + A^{-1}\right)\lvert\psi_i 10 \cdots\rangle\\&#xA;U_{\sigma_i}(\lvert\psi_i 11 \cdots\rangle) &amp;amp; = A^{-1}\lvert\psi_i 11 \cdots\rangle&#xA;\end{align}&#xA;$$&#xA;We define $U_{\sigma_i}(\psi) = \psi$ for non-admissible basis elements $\psi$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We would now like to describe $U_{\sigma_i}$ as a quantum circuit with polynomially many (in $n$ and $k$) gates. Notice that while $U_{\sigma_i}$ only changes two qubits, it also depends on the first $i - 1$ qubits through the dependence on $z_i$ (and indeed, it depends on all qubits for the admissibility requirement). However, we can run a counter to calculate and store $z_i$ (and also determine admissibility of the input) in logarithmically many (in $k$) ancilla qubits, and therefore we can apply the &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0505030&quot; rel=&quot;nofollow noreferrer&quot;&gt;Solovay-Kitaev algorithm&lt;/a&gt; to get a good approximation to $U_{\sigma_i}$ using only polynomially many gates. (The paper appeals to Solovay-Kitaev twice: once for incrementing the counter at each step, and once for applying $U_{\sigma_i}$; I'm not sure if there is a more direct way to describe either of these as quantum circuits with standard gates. The paper also doesn't mention the need to check for admissibility here; I'm not sure if this is important, but certainly we at least need $1 \leq z_i \leq k - 1$.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So to recap:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Start with a braid $\sigma \in B_{2n}$ with $m$ crossings.&lt;/li&gt;&#xA;&lt;li&gt;Write $\sigma = \sigma_{a_1}^{\epsilon_1} \sigma_{a_2}^{\epsilon_2} \cdots \sigma_{a_m}^{\epsilon_m}$.&lt;/li&gt;&#xA;&lt;li&gt;For each $i \in \{1, 2, \ldots, m\}$, apply the Solovay-Kitaev algorithm to get an approximation of the unitary matrix $U_{\sigma_{a_i}}$ (or its inverse if $\epsilon_i = -1$).&lt;/li&gt;&#xA;&lt;li&gt;Compose all of the approximations from step 3 to get a quantum circuit with polynomially many gates that approximates $U_{\sigma}$.&lt;/li&gt;&#xA;&lt;li&gt;Apply the real and imaginary Hadamard tests polynomially many times with the circuit from step 4 and the state $\lvert 1010 \cdots 10\rangle$.&lt;/li&gt;&#xA;&lt;li&gt;Average the results of step 5 and multiply by some scaling factor to get an approximation to the real and imaginary parts of the Jones polynomial of the plat closure of $\sigma$ evaluated at $e^{2\pi i/k}$.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="2547" LastActivityDate="2018-06-17T23:52:35.393" CommentCount="0" />
  <row Id="2375" PostTypeId="2" ParentId="2371" CreationDate="2018-06-18T00:53:27.893" Score="4" Body="&lt;p&gt;Enabling network sockets to handle 10k clients at the same time with over 1 gigabit per second Ethernet (the C10k problem), is different from making a quantum computer that can handle 10k qubits concurrently. Remember 10k bits is only 1.25kB which is not even enough to store a typical operating system.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you want to consider each qubit as a &quot;client&quot; in some generalization of the C10k problem, then the answer to your question depends on whether or not you need a universal gate set to be applicable between each of the 10,000 qubit connections. If so, the largest quantum computers with a universal gate set are the 50-qubit machine by IBM and the 72-qubit machine by Google (which has been announced but not shown to the public yet). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;You mention D-Wave, which makes non-universal quantum annealers. If each qubit is considered a &quot;client&quot;, it is true that the D-Wave 2000Q has 2048 qubits, but not all of them can be connected to any other qubit. &lt;a href=&quot;https://www.ibm.com/developerworks/community/blogs/jfp/resource/BLOGS_UPLOADED_IMAGES/chimera.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;This&lt;/a&gt; is the connectivity graph for a typical D-Wave machine. Notice that each qubit can only be connected to at most 6 other qubits. To get 10,000 qubits in this arrangement, you just need to create more of these &quot;unit cells&quot; of 8 qubits each. What's pictured here is the D-Wave One which has 16 units cells of 8 qubits each (8 x 16 = 128 total qubits). The D-Wave Two had 64 units cells of 8 qubits each (8 x 64 = 512 qubits). The D-Wave 2X had 132 unit cells (8 x 144 = 1152 total qubits), and the D-Wave 2000Q has 256 unit cells (8 x 256 = 2048 total qubits). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;For 10,000 qubits you just need 1250 units cells (8 x 1250 = 10,000). After that point D-Wave says that a re-design would need to be required, perhaps in the size of the unit cells, or in going from 2D to 3D, or in the physics itself.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-06-18T01:48:03.167" LastActivityDate="2018-06-18T01:48:03.167" CommentCount="8" />
  <row Id="2376" PostTypeId="1" AcceptedAnswerId="2377" CreationDate="2018-06-18T06:17:25.763" Score="9" ViewCount="518" Body="&lt;p&gt;In &lt;a href=&quot;https://arxiv.org/abs/1710.03599&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt;&lt;sup&gt;[1]&lt;/sup&gt; paper, on page 2, they mention that they are generating the weighting matrix as follows:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$W = \frac{1}{Md}[\sum_{m=1}^{m=M} \mathbf{x}^{(m)}\left(\mathbf{x}^{(m)}\right)^{T}] - \frac{\Bbb I_d}{d}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;where $\mathbf{x}^{(m)}$'s are the $d$-dimensional training samples (i.e. $\mathbf{x} := \{x_1,x_2,...,x_d\}^{T}$ where $x_i \in \{1,-1\} \ \forall \ i\in \{1,2,...,d\}$) and there are $M$ training samples in total. This generation of weighting matrix using matrix multiplication followed by a sum over $M$ terms seems to be a costly operation in terms of time complexity i.e. I guess around $O(Md)$ (?). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Does there exist any quantum algorithm which can offer a substantial speed-up for generation of the weighting matrix? I think in the paper their main speedup comes from the quantum matrix inversion algorithm (which is mentioned later on the paper), but they don't seem to have taken into account this aspect of the weighting matrix generation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[1]: &lt;em&gt;A Quantum Hopfield Neural Network&lt;/em&gt; Lloyd et al. (2018)&lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-06-18T10:02:13.760" Title="Is it possible to speed up the generation of the weighting matrix using a quantum algorithm?" Tags="&lt;quantum-algorithms&gt;&lt;neural-network&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="2377" PostTypeId="2" ParentId="2376" CreationDate="2018-06-18T09:07:23.153" Score="5" Body="&lt;p&gt;Taking the density matrix $$\rho=W+\frac{I_d}{d}=\frac 1M \sum_{m=1}^M\left|x^{\left(m\right)}\rangle\langle x^{\left(m\right)}\right|,$$ many of the details are all contained in the following paragraph on page 2:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Crucial  for  quantum  adaptations  of  neural  networks is the classical-to-quantum  read-in  of  activation  patterns. In our setting, reading in an activation pattern $x$ amounts to preparing the quantum state $|x〉$. This could&#xA;  in principle be achieved using the developing techniques of quantum random access memory (qRAM) [33] or efficient quantum state preparation, for which restricted, oracle based, results exist [34]. In both cases, the computational  overhead is logarithmic in terms of $d$. One can alternatively adapt a fully quantum perspective and take the activation patterns $|x〉$ directly from a quantum device or as the output of a quantum channel. For the former, our preparation run time is efficient whenever the quantum device is composed of a number of gates scaling at most polynomially with the number of qubits. Instead, for the latter, we typically view the channel as some form of fixed system-environment interaction that does not require a computational overhead to implement.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The references in the above are:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[33]: V. Giovannetti, S.  Lloyd, L.  Maccone, Quantum  random access memory, Physical Review Letters 100, 160501 (2008) [&lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.100.160501&quot; rel=&quot;nofollow noreferrer&quot;&gt;PRL link&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/0708.1879v2&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv link&lt;/a&gt;]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[34]: A. N. Soklakov, R. Schack, Efficient state preparation for a register of quantum bits, Physical Review A 73, 012307 (2006). [&lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.73.012307&quot; rel=&quot;nofollow noreferrer&quot;&gt;PRA link&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0408045v2&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv link&lt;/a&gt;]&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Without going into details of how, both of the above are indeed schemes for respectively, implementing an efficient qRAM; and efficient state preparation that recreate the state $\left|x\right&amp;gt;$ in time $\mathcal O\left(\log_2 d\right)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, this only gets us so far: this can be used to create the state $\rho^{\left(m\right)} = \left|x^{\left(m\right)}\rangle\langle x^{\left(m\right)}\right|$, while we want a sum over all the possible $m$'s.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Crucially, $\rho = \sum_m\rho^{\left(m\right)}/M$ is mixed, so cannot be represented by a single pure state, so the second of the above two references on recreating pure states doesn't apply and the first requires the state to already be in qRAM.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As such, the authors make one of three possible assumptions:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;They have a device that just so happens to give them the correct input state&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;They either have the states $\rho^{\left(m\right)}$ in qRAM,&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;They are able to create those states at will, using the second of the above references. The mixed state is then created using a &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_channel&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum channel&lt;/a&gt; (i.e. a completely positive, trace preserving (CPTP) map).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Forgetting about the first two of the above options for the moment (the first magically solves the problem anyway), the channel could either be:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;an engineered system, in that it would be created for a specific instance in something akin to an analogue simulation. In other words you've got a physical channel that takes a physical length of time $t$ (as opposed to some time complexity). This is the &quot;fixed system-environment interaction that does not require a computational overhead to implement.&quot;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;The channel is itself simulated. There are a few papers on this, such as Bény and Oreshkov's &lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.84.022333&quot; rel=&quot;nofollow noreferrer&quot;&gt;Approximate simulation of quantum channels&lt;/a&gt; (&lt;a href=&quot;https://arxiv.org/abs/1103.0649&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv link&lt;/a&gt; - this looks like a thorough paper, but I couldn't find any time complexity statements), Lu et. al.'s &lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.95.042310&quot; rel=&quot;nofollow noreferrer&quot;&gt;Experimental quantum channel simulation&lt;/a&gt; (no arXiv version seems to exist) and Wei, Xin and Long's arXiv preprint &lt;a href=&quot;https://arxiv.org/abs/1706.08080&quot; rel=&quot;nofollow noreferrer&quot;&gt;Efficient universal quantum channel simulation in IBM's cloud quantum computer&lt;/a&gt;, which (for number of qubits $n=\lceil\log_2 d\rceil$) gives a time complexity of $\mathcal O\left(\left(8n^3+n+1\right)4^{2n}\right)$. Stinespring dilation can also be used, with a complexity of $\mathcal O\left(27n^34^{3n}\right)$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Now looking at option 2&lt;sup&gt;1&lt;/sup&gt;, one possible more efficient method would be to transfer the states from the address register to the data register in the usual method: for addresses in register $a$, $\sum_j\psi_j\left|j\right&amp;gt;_a$, transferring this to the data register gives the state in the data register $d$ as $\sum_j\psi_j\left|j\right&amp;gt;_a\left|D_j\right&amp;gt;_d$. It should be possible to simply decohere the address and data register to turn this into a mixed state, giving a small time overhead, although no extra computational complexity overhead, giving a much improved complexity of producing $\rho$, given a qRAM with the states $\left|x^{\left(m\right)}\right&amp;gt;$, of $\mathcal O\left(n\right)$. This is also the complexity of creating the states $\left|x^{\left(m\right)}\right&amp;gt;$ in the first place, giving a potential (much improved) complexity of producing $\rho$ of $\mathcal O\left(n\right)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;1 With thanks to @glS for pointing this possibility out in chat&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;This density matrix is then fed into 'qHop' (quantum Hopfield), where it is used to simulate $e^{-iAt}$ for $$A=\begin{pmatrix}W-\gamma I_d &amp;amp;&amp;amp; P\\ P&amp;amp;&amp;amp; 0\end{pmatrix}$$ as per the &quot;&lt;strong&gt;Efficient Hamiltonian Simulation of A&lt;/strong&gt;&quot; subsection on page 8.&lt;/p&gt;&#xA;" OwnerUserId="23" LastEditorUserId="23" LastEditDate="2018-06-18T10:02:13.760" LastActivityDate="2018-06-18T10:02:13.760" CommentCount="1" />
  <row Id="2378" PostTypeId="2" ParentId="2372" CreationDate="2018-06-18T12:43:43.197" Score="5" Body="&lt;p&gt;One main assumption to be efficient within a usage of a database is that you can load with a superposition of addresses data from a RAM, also called QRAM (see &lt;a href=&quot;https://arxiv.org/abs/0708.1879&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/0708.1879&lt;/a&gt;). Then assume you have one state for the address, one state for the value, and a load operation, which loads the  value of the corresponding address into the value register. So the load operation would do the step&#xA;$$|x\rangle_{\text{address}}|0\rangle_{\text{value}} \rightarrow |x\rangle_{\text{address}}|\textrm{load}(x)\oplus 0\rangle_{\text{value}} = |x\rangle_{\text{address}}|\textrm{load}(x)\rangle_{\text{value}}.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the first step you apply the Hadamard gates on the address register and then apply the load operation on both registers. Then you will have a superposition of all values in the database an the value register. &#xA;$$H^{\otimes n}_{\text{address}} |0\rangle_{\text{address}}|\textrm0\rangle_{\text{value}}=\frac1{2^{n/2}}\sum_{x=0}^{2^n-1} |x\rangle_{\text{address}}|\textrm0\rangle_{\text{value}} $$&#xA;$$\text{apply load}\rightarrow&#xA;\frac1{2^{n/2}}\sum_{x=0}^{2^n-1} |x\rangle_{\text{address}}|\textrm{load}(x)\rangle_{\text{value}}$$&#xA;Then you apply the Grover algorithm on the value register with any oracle you want like looking a for a prime or a specific value. We know after $O(\sqrt{N})$ iterations the correct answer will be measured with high probability. Thus, the correct solution together with the register address $x^*$ of the correct solution will be very probable measured&#xA;$$|x^*\rangle_{\text{address}}|\textrm{load}(x^*)\rangle_{\text{value}}.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Maybe the main problem you have is with understanding the database not the Grover algorithm. You can see a more detailed explanation in chapter 6.5 Nielsen &amp;amp; Chuang for this.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I also think that the most useful application of the Grover algorithm is not the database application, but is its generalizations as amplitude amplification (see &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0005055&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/quant-ph/0005055&lt;/a&gt;) on any quantum algorithm.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;EDIT:&#xA;I thought of the problem glS answered already a bit: If we can built an oracle, isn't the problem already solved? Because to construct the oracle, we need to know how the correct solution looks like. And if you would have no background in computer science, this question would be hard to answer by yourself. However, under assumptions most scientists believe (NP$\neq$P), this is exactly the case for a subset of NP-complete problems (the ones which do not have good approximation methods) . We can construct an oracle, which can check if a solution is correct in polynomial time, but to construct an oracle, which finds the correct solution seems to be not efficiently computable.&lt;/p&gt;&#xA;" OwnerUserId="2691" LastEditorUserId="2691" LastEditDate="2018-07-24T08:29:33.463" LastActivityDate="2018-07-24T08:29:33.463" CommentCount="2" />
  <row Id="2379" PostTypeId="2" ParentId="2370" CreationDate="2018-06-18T13:00:08.743" Score="6" Body="&lt;p&gt;A natural way to relate Toffoli gates and PR boxes is to see them both as representations of the AND function of two binary inputs, but in different ways. The connection with the AND function is evident and clearly acknowledged by the question, but I would express it in a slightly different way:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;The Toffoli gate is of course the natural way of representing AND as a reversible function. It follows the usual pattern of representing an arbitrary function $f:\{0,1\}^n\rightarrow\{0,1\}$ reversibly as $|x,a\rangle \mapsto |x,a\oplus f(x)\rangle$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;The PR box can be seen as a distributed form of the AND function. The output of a PR box on input $(x,y)$ can be expressed as $(\text{AND}(x,y)\oplus a, a)$, or equivalently as $(a,\text{AND}(x,y)\oplus a)$, where $a\in\{0,1\}$ is a uniformly generated random bit. The output of the PR box is therefore either a perfectly correlated or perfectly anti-correlated pair of random bits, depending on whether the AND of the inputs is 0 or 1 respectively. This is interesting because Alice and Bob collectively know the output of the AND function (which they can obtain by computing the XOR of their output bits), while individually they have no information at all about this value.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;The idea that the PR box effectively computes the AND function in this distributed way is a key idea in Wim van Dam's proof that communication complexity becomes trivial in the presence of PR boxes:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Wim van Dam. &lt;a href=&quot;https://link.springer.com/article/10.1007/s11047-012-9353-6&quot; rel=&quot;noreferrer&quot;&gt;Implausible consequences of superstrong nonlocality.&lt;/a&gt;&#xA;  Natural Computing 12(1): 9-12, 2013.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="1764" LastActivityDate="2018-06-18T13:00:08.743" CommentCount="0" />
  <row Id="2380" PostTypeId="2" ParentId="2298" CreationDate="2018-06-18T13:26:25.050" Score="0" Body="&lt;p&gt;An answer to this question seems to have been given by the same authors, in a different follow-up paper which I hadn't seen before.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In &lt;a href=&quot;https://arxiv.org/abs/0807.4994&quot; rel=&quot;nofollow noreferrer&quot;&gt;[1]&lt;/a&gt;, the authors write (emphasis mine):&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;A classical RAM that uses the bucket-brigade addressing schemes need&#xA;  only activate $O(n)$ transistors in the course of a memory call, in&#xA;  contrast with a conventional RAM that activates $O(2^n)$ transistors. As&#xA;  a result, a RAM that uses our design might operate with less&#xA;  dissipation and power consumption than a conventional RAM. &lt;strong&gt;Note,&#xA;  however, that energy costs in the memory addressing are not&#xA;  sufficiently high in current RAM chips to justify an immediate&#xA;  adoption of the bucket-brigade.&lt;/strong&gt; Other sources of inefficiencies and&#xA;  dissipations are currently predominant (mostly in the memory cells&#xA;  themselves). However, new promising memory cell technologies are being&#xA;  developed (e.g. the “memristor” cells [15]), which would drastically&#xA;  cut back cell dissipation, so that cutting back dissipation in the&#xA;  addressing may become important in the future.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;It would therefore seem that, at least according to the authors, the bucket-brigade scheme would be also advantageous for classical architectures, in terms of energy consumption.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[1]: Giovannetti, Lloyd, and Maccone. &quot;&lt;em&gt;Architectures for a quantum random access memory&lt;/em&gt;.&quot; Physical Review A 78.5 (2008): 052310.&lt;/p&gt;&#xA;" OwnerUserId="55" LastActivityDate="2018-06-18T13:26:25.050" CommentCount="0" />
  <row Id="2381" PostTypeId="1" CreationDate="2018-06-18T15:14:18.037" Score="9" ViewCount="636" Body="&lt;p&gt;What is a &quot;qubit&quot;? Google tells me that it's another term for a &quot;quantum bit&quot;. What is a &quot;quantum bit&quot; &lt;em&gt;physically&lt;/em&gt;? How is it &quot;quantum&quot;? What purpose does it serve in quantum computing?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; I'd prefer an explanation that is easily understood by laypeople; terms specific to quantum computing should preferably be explained, in relatively simple terms.&lt;/p&gt;&#xA;" OwnerUserId="90" LastEditorUserId="26" LastEditDate="2018-07-14T18:34:15.170" LastActivityDate="2018-07-15T00:37:50.467" Title="What is a qubit?" Tags="&lt;quantum-computer&gt;&lt;qubit&gt;" AnswerCount="6" CommentCount="8" FavoriteCount="2" />
  <row Id="2382" PostTypeId="2" ParentId="2381" CreationDate="2018-06-18T17:12:35.817" Score="2" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;What is a &quot;quantum bit&quot; physically? How is it &quot;quantum&quot;?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;First let me give examples of classical bits:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;In a CPU: low voltage = 0, high voltage = 1&lt;/li&gt;&#xA;&lt;li&gt;In a hard drive: North magnet = 0, South magnet = 1&lt;/li&gt;&#xA;&lt;li&gt;In a barcode on your library card: Thin bar = 0, Thick bar = 1&lt;/li&gt;&#xA;&lt;li&gt;In a DVD: Absence of a deep microscopic pit on the disk = 0, Presence = 1 &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;In every case you can have something in between:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;If &quot;low voltage&quot; is 0 mV, and &quot;high voltage&quot; is 1 mV, you can have a medium voltage of 0.5 mV&lt;/li&gt;&#xA;&lt;li&gt;You can have a magnet polarized in any direction, such as North-West&lt;/li&gt;&#xA;&lt;li&gt;You can have lines in a barcode that are of any width&lt;/li&gt;&#xA;&lt;li&gt;You can have pits of various depths on the surface of a DVD&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;In quantum mechanics things can only exist in &quot;packages&quot; called &quot;quanta&quot;. The singular of &quot;quanta&quot;  is &lt;strong&gt;&quot;quantum&quot;&lt;/strong&gt;. This means for the barcode example, if the thin line was one &quot;quantum&quot;, the thick line can be two times the size of the thin line (two quanta), but it &lt;strong&gt;&lt;em&gt;cannot&lt;/em&gt;&lt;/strong&gt; be 1.5 times the thickness of the thin line. If you look at your library card you will notice that you &lt;strong&gt;&lt;em&gt;can&lt;/em&gt;&lt;/strong&gt; draw lines that are of thickness 1.5 times the size of the thin lines if you want to, which is one reason why barcode bits are not qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There do exist some things in which the laws of quantum mechanics do not permit anything between the 0 and the 1, some examples are below:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Spin_(physics)&quot; rel=&quot;nofollow noreferrer&quot;&gt;spin of an electron&lt;/a&gt;: It's either up (0) or down (1), but cannot be in between.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Energy_level&quot; rel=&quot;nofollow noreferrer&quot;&gt;energy level&lt;/a&gt; of an electron: 1st level is 0, 2nd level is 1, there is no such thing as 1.5th level&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;I have given you two examples of what a qubit can be physically: spin of an electron, or energy level of an electron. &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;What purpose does it serve in quantum computing?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The reason why the qubit examples I gave come in quanta are because they exist as solutions to something called the &lt;a href=&quot;https://en.wikipedia.org/wiki/Schr%C3%B6dinger_equation&quot; rel=&quot;nofollow noreferrer&quot;&gt;Schrödinger Equation&lt;/a&gt;. Two solutions to the Schrödinger equation (the 0 solution, and the 1 solution) can exist at the same time. So we can have 0 and 1 at the same time. If we have two qubits, each can be in 0 and 1 at the same time, so collectively we can have 00, 01, 10, and 11 (4 states) at the same time. If we have 3 qubits, each of them can be in 0 and 1 at the same time, so we can have 000, 001, 010, 011, 100, 101, 110, 111 (8 states) at the same time. Notice that for $n$ qubits we can have $2^n$ states at the same time. That is one of the reasons why quantum computers are more powerful than classical computers.  &lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-07-15T00:37:50.467" LastActivityDate="2018-07-15T00:37:50.467" CommentCount="1" />
  <row Id="2383" PostTypeId="2" ParentId="2381" CreationDate="2018-06-18T18:03:57.637" Score="2" Body="&lt;p&gt;A qubit (quantum bit) is a quantum system that can be fully described by (&quot;lives in&quot;) a 2-dimensional complex vector space. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, much more than that is required to do computations. There needs to exist two orthogonal basis vectors in that vector space, call them $|0\rangle$ and $|1\rangle$, that are stable in the sense that you can set the system very precisely to $|0\rangle$ or to $|1\rangle$, and it will stay there for a long time. This is easier said than done because unless noise is reduced somehow, it will cause the state to drift gradually so that it contains a component along both the $|0\rangle$ and $|1\rangle$ dimensions.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To do computations, you must also be able to induce a &quot;complete&quot; set of operations acting on one or two qubits. When you are not inducing an operation, qubits should not interact with each other. Unless interaction with the environment is suppressed, qubits will interact with each other.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A classical bit, by the way, is much simpler than a qubit. It's a system that can be described by a boolean variable&lt;/p&gt;&#xA;" OwnerUserId="1974" LastEditorUserId="26" LastEditDate="2018-07-13T14:56:48.843" LastActivityDate="2018-07-13T14:56:48.843" CommentCount="0" />
  <row Id="2385" PostTypeId="2" ParentId="2381" CreationDate="2018-06-19T01:16:18.860" Score="5" Body="&lt;p&gt;This is a good question and in my view gets at the heart of a qubit. Like &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2381/what-is-a-qubit#comment2794_2381&quot;&gt;the comment&lt;/a&gt; by &lt;a href=&quot;https://quantumcomputing.stackexchange.com/users/26/blue&quot;&gt;@Blue&lt;/a&gt;, it's not that it can be an equal superposition as this is the same as a classical probability distribution. It is that it can have negative signs. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Take this example. Imagine you have a bit in the $0$ state and represent it as vector $\begin{bmatrix}1 \\0 \end{bmatrix}$ and then you apply a coin flipping operation which can be represented by a stochastic matrix $\begin{bmatrix}0.5 &amp;amp; 0.5 \\0.5 &amp;amp; 0.5 \end{bmatrix}$ this will make a classical mixture $\begin{bmatrix}0.5 \\0.5 \end{bmatrix}$. If you apply this twice it will still be a classical mixture $\begin{bmatrix}0.5 \\0.5 \end{bmatrix}$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now lets go to the quantum case and start with a qubit in the $0$ state which again is represented by $\begin{bmatrix}1 \\0 \end{bmatrix}$. In quantum, operations are represented by a unitary matrix which has the property $U^\dagger U = I$. The simplest unitary to represent the action of a quantum coin flip is the Hadamard matrix $\begin{bmatrix}\sqrt{0.5} &amp;amp; \sqrt{0.5} \\\sqrt{0.5} &amp;amp; -\sqrt{0.5} \end{bmatrix}$ where the first column is defined so that after one operation it makes the state $|+\rangle =\begin{bmatrix}\sqrt{0.5}  \\\sqrt{0.5} \end{bmatrix}$, then the second column must be $\begin{bmatrix}\sqrt{0.5} &amp;amp; a \\\sqrt{0.5} &amp;amp; b \end{bmatrix}$ where $|a|^2 = 1/2$, $|b|^2 = 1/2$ and $ab^* = -1/2$. A solution to this is $a =\sqrt(0.5)$ and $b=-a$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now lets do the same experiment. Applying it once gives&#xA;$\begin{bmatrix}\sqrt{0.5}  \\\sqrt{0.5} \end{bmatrix}$ and if we measured (in the standard basis) we would get half the time 0 and the other 1 (recall in quantum &lt;a href=&quot;https://en.wikipedia.org/wiki/Born_rule&quot; rel=&quot;nofollow noreferrer&quot;&gt;Born rule&lt;/a&gt; is  $P(i) = |\langle i|\psi\rangle|^2$ and why we need all the square roots). So it is like the above and has a random outcome. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Lets apply it twice. Now we would get $\begin{bmatrix} 0.5+0.5  \\0.5-0.5\end{bmatrix}$. The negative sign cancels the probability of observing the 1 outcome and a physicist we refer to this as interference. It is these negative numbers that we get in quantum states which cannot be explained by probability theory where the vectors must remain positive and real. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Extending this to n qubits gives you a theory that has an exponential that we can't find efficient ways to simulate. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is not just my view. I have seen it shown in the talks by Scott Aaronson and I think its best to say quantum is like “Probability theory with Minus Signs” (this is a quote by Scott).  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am attaching the slides I like to give for explaining quantum (if it is not standard to have slides in an answer I am happy to write the math out to get across the concepts)&#xA;&lt;a href=&quot;https://i.stack.imgur.com/rvoOJ.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/rvoOJ.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="302" LastEditorUserId="302" LastEditDate="2018-06-24T19:16:45.143" LastActivityDate="2018-06-24T19:16:45.143" CommentCount="8" />
  <row Id="2386" PostTypeId="1" CreationDate="2018-06-19T03:28:50.520" Score="5" ViewCount="339" Body="&lt;p&gt;I am looking to collaborate on open source simulation efforts.&lt;/p&gt;&#xA;" OwnerUserId="1697" LastActivityDate="2018-06-19T08:25:57.327" Title="What are some open sources projects on quantum computing?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-gate&gt;" AnswerCount="2" CommentCount="6" FavoriteCount="1" ClosedDate="2018-06-19T13:59:06.097" />
  <row Id="2387" PostTypeId="2" ParentId="2386" CreationDate="2018-06-19T03:43:37.653" Score="3" Body="&lt;p&gt;There is in fact a &lt;a href=&quot;https://github.com/topics/quantum-computing&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum computing topic tag&lt;/a&gt; on github which comes up with a list of a whole bunch of projects.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://github.com/QISKit/qiskit-core&quot; rel=&quot;nofollow noreferrer&quot;&gt;QISKit&lt;/a&gt; is pretty well known; it's connected with IBM's quantum experience as well as the QASM language. It's a pure simulator.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In another direction, there's projects like &lt;a href=&quot;https://github.com/quantumlib/OpenFermion&quot; rel=&quot;nofollow noreferrer&quot;&gt;OpenFermion&lt;/a&gt; which is for finding algorithms to simulate different problems in quantum chemistry.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A fabulous little simulator that I prefer over IBM's is &lt;a href=&quot;https://github.com/Strilanc/Quirk&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quirk&lt;/a&gt; which runs in your browser and is open source.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can also start your own project like &lt;a href=&quot;https://github.com/physicsnerd/qc-sim&quot; rel=&quot;nofollow noreferrer&quot;&gt;I did&lt;/a&gt;, though I would not recommend becoming an open-source contributor to mine because I haven't updated my repository in a while and I'm pretty sure everything there is rather decisively out of date.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you can provide some more criteria, I can recommend some more specific projects.&lt;/p&gt;&#xA;" OwnerUserId="91" LastEditorUserId="26" LastEditDate="2018-06-19T04:17:41.033" LastActivityDate="2018-06-19T04:17:41.033" CommentCount="0" />
  <row Id="2388" PostTypeId="1" AcceptedAnswerId="2395" CreationDate="2018-06-19T08:00:32.173" Score="8" ViewCount="280" Body="&lt;p&gt;I have been trying to get my head around the famous(?) paper &lt;a href=&quot;https://arxiv.org/abs/0811.3171&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;strong&gt;Quantum algorithm for linear systems of equations (Harrow, Hassidim &amp;amp; Lloyd, 2009)&lt;/strong&gt;&lt;/a&gt; (more popularly known as the &lt;strong&gt;HHL09 algorithm&lt;/strong&gt; paper) for some time, now.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;On the very first page, they say&lt;/strong&gt;: &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;We sketch here the basic idea of our algorithm and then discuss it in&#xA;  more detail in the next section. Given a Hermitian $N\times N$ matrix&#xA;  $A$, and a unit vector $\vec{b}$, suppose we would like to find&#xA;  $\vec{x}$ satisfying $A\vec{x} = \vec{b}$. (We discuss later questions&#xA;  of efficiency as well as how the assumptions we have made about $A$&#xA;  and $\vec{b}$ can be relaxed.)  First, the algorithm represents&#xA;  $\vec{b}$ as a quantum state $|b\rangle = \sum_{i=1}^{N}b_i|i\rangle$.&#xA;  Next, we use techniques of Hamiltonian simulation [3, 4] to apply&#xA;  $e^{iAt}$ to $|b_i\rangle$ for a superposition of different times $t$.&#xA;  This ability to exponentiate $A$ translates, via the well-known&#xA;  technique of  phase-estimation [5–7] into the ability to decompose $|b\rangle$&#xA;  in the eigenbasis of $A$ and to find the corresponding eigenvalues&#xA;   $\lambda_j$ Informally, the state of the system after&#xA;  this stage is close to $\sum_{j=1}^{j=N} \beta_j&#xA; |u_j\rangle|\lambda_j\rangle$, where $u_j$ is the eigenvector basis of&#xA;  $A$ and $|b\rangle = \sum_{j=1}^{j=N} \beta_j|u_j\rangle$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;So far so good. As described in &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/1107002176&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;strong&gt;Nielsen &amp;amp; Chuang&lt;/strong&gt;&lt;/a&gt; in the chapter &quot;&lt;strong&gt;The quantum Fourier transform and its applications&lt;/strong&gt;&quot;, the phase estimation algorithm is used to estimate $\varphi$ in $e^{i2\pi \varphi}$ which is the eigenvalue corresponding to an eigenvector $|u\rangle$ of the unitary operator $U$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Here's the relevant portion from Nielsen &amp;amp; Chuang:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The phase estimation algorithm uses two registers. The first register&#xA;  contains $t$ qubits initially in the state $|0\rangle$. How we choose&#xA;   $t$ depends on two things: the number of digits of accuracy we wish to&#xA;  have in our estimate for $\varphi$, and with what probability we wish the&#xA;  phase estimation procedure to be successful. The dependence of $t$ on&#xA;  these quantities emerges naturally from the following analysis.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;The second register begins in the state $|u\rangle$ and contains as&#xA;  many qubits as is necessary to store $|u\rangle$. Phase estimation is&#xA;  performed in two stages. First, we apply the circuit shown in Figure&#xA;  5.2. The circuit begins by applying a Hadamard transform to the first register, followed by application of controlled - $U$ operations on&#xA;  the second register, with $U$ raised to successive powers of two. The&#xA;  final state of the first register is easily seen to be:&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;$$\frac{1}{2^{t/2}}\left(|0\rangle+\text{exp}(2\pi i&#xA; 2^{t-1}\varphi)|1\rangle)(|0\rangle+\text{exp}(2\pi i&#xA; 2^{t-2}\varphi)|1\rangle)...(|0\rangle+\text{exp}(2\pi i&#xA; 2^{0}\varphi)|1\rangle\right)=&#xA; \frac{1}{2^{t/2}}\sum_{k=0}^{2^{t}-1}\text{exp}(2\pi i \varphi&#xA; k)|k\rangle$$&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/qPhh0.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/qPhh0.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;The second stage of phase estimation is to apply the inverse quantum&#xA;  Fourier transform on the first register. This is obtained by reversing&#xA;  the circuit for the quantum Fourier transform in the previous section&#xA;  (Exercise 5.5) and can be done in $\Theta (t^2)$ steps. The third and&#xA;  final stage of phase estimation is to read out the state of the first&#xA;  register by doing a measurement in the computational basis. We will&#xA;  show that this provides a pretty good estimate of $\varphi$. An&#xA;  overall schematic of the algorithm is shown in Figure 5.3.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;To sharpen our intuition as to why phase estimation works, suppose $\varphi$&#xA;  may be expressed exactly int bits, as $\varphi = 0.\varphi_1 ...&#xA; \varphi_t$. Then the state (5.20) resulting from the first stage of&#xA;  phase estimation may be rewritten&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;$$\frac{1}{2^{t/2}}(|0\rangle + \exp(2\pi i&#xA; 0.\varphi_t|1\rangle)(|0\rangle + \exp(2\pi i 0.\varphi_{t-1}\varphi_t|1\rangle)...(|0\rangle + \exp(2\pi i 0.\varphi_1...\varphi_t|1\rangle)$$&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;The second stage of phase estimation is to apply the inverse quantum&#xA;  Fourier transform. But comparing the previous equation with the&#xA;  product form for the Fourier transform, Equation (5.4), we see that&#xA;  the output state from the second stage is the product state&#xA;   $|\varphi_1 ...\varphi_t\rangle$. A measurement in the computational&#xA;  basis, therefore, gives us $\varphi$ exactly!&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/9hDwn.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/9hDwn.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Summarizing, the phase estimation algorithm allows one to estimate the&#xA;  phase $\varphi$ of an eigenvalue of a unitary operator $U$, given the&#xA;  corresponding eigenvector $|u\rangle$. An essential feature at the&#xA;  heart of this procedure is the ability of the inverse Fourier&#xA;  transform to perform the transformation&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;$$\frac{1}{2^{t/2}}\sum_{j = 0}^{2^t-1}\exp(2\pi i \varphi j)|j\rangle |u\rangle \to |\tilde \varphi \rangle |u\rangle$$&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Let's proceed from here. I found a nice &lt;em&gt;circuit diagram&lt;/em&gt; for the &lt;strong&gt;HHL09 algorithm&lt;/strong&gt; &lt;a href=&quot;https://arxiv.org/abs/1612.02886v2&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;&lt;sup&gt;[$\dagger$]&lt;/sup&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/nEmvl.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/nEmvl.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Step 1 (Phase Estimation):&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;In the first step of the &lt;strong&gt;HHL09 algorithm&lt;/strong&gt; the same concept (of the standard Quantum Phase Estimation algorithm as described in Nielsen and Chuang) is used. However, we must keep in mind that $A$ by itself isn't a unitary operator. However, if we assume that $A$ is Hermitian then the exponential $e^{iAt}$ is unitary (no worries, there's exists a workaround in case $A$ isn't Hermitian!).  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here, we can write $U=e^{iAt}$. There's another subtle point involved here. We &lt;em&gt;do not&lt;/em&gt; know the eigenvectors $|u_j\rangle$ of $U$ beforehand (but we &lt;em&gt;do know&lt;/em&gt; that for any unitary matrix of size $N\times N$ there exist $N$ orthonormal eigenvectors). Moreover, we need to remind ourselves that if the eigenvalues of $A$ are $\lambda_j$ then the eigenvalues of $e^{iAt}$ will be $e^{i \lambda_j t}$. If we compare this with the form of eigenvalues given in Nielsen and Chuang for $U$ i.e. if  $e^{2\pi i \varphi} \equiv e^{ i \lambda_j t}$, we'd find $\varphi = \frac{\lambda_j t}{2\pi}$. In this case, we begin in the state $|b\rangle$ (which can be written as a superposition of the eigenvectors of $U$ i.e. $\sum_{j=1}^{j=N}\beta_j|u_j\rangle$) rather than any particular eigenvector $|u_j\rangle$ of $U$, as far as the second register of qubits is concerned. If we had begun in the state $|u\rangle \otimes (|0\rangle)^{\otimes t}$ we would have ended up with $|u\rangle \otimes |\tilde\varphi\rangle$ i.e. $|u_j\rangle \otimes |\tilde{\frac{\lambda_j t}{2\pi}}\rangle$ (considering that $\lambda_j$ is the eigenvalue associated with the eigenvector $|u_j\rangle$ of $A$). Now, instead if we begin in the superposition of eigenvectors $\sum_{j=1}^{j=N}\beta_j|u_j\rangle$ we should end up with $\sum_{j=1}^{j=N}\beta_j|u_j\rangle\otimes |\tilde{\frac{\lambda_j t}{2\pi}}\rangle$. &lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;strong&gt;Question:&lt;/strong&gt;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Part 1&lt;/strong&gt;: In the &lt;strong&gt;HHL09 paper&lt;/strong&gt;, they wrote about the state of the system after this Phase Estimation step is $\sum_{j=1}^{j=N}\beta_j|u_j\rangle\otimes |\tilde\lambda_j\rangle$. However, from what I wrote above it seems to me that the state of the system should rather be $\sum_{j=1}^{j=N}\beta_j|u_j\rangle\otimes |\tilde{\frac{\lambda_j t}{2\pi}}\rangle$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;What am I missing here? Where did the factor of $\frac{t}{2\pi}$ vanish in their algorithm?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; &lt;strong&gt;Part 2&lt;/strong&gt; has been asked &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2390/quantum-algorithm-for-linear-systems-of-equations-hhl09-step-1-number-of-qu&quot;&gt;here&lt;/a&gt; to make the individual questions more focused.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;I also have several confusions regarding Step 2 and Step 3 of the HHL09 algorithm too, but I decided to post them as separate question threads, as this one is becoming too long. I'll add the links to those question threads, on this post, once they are created.&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[$\dagger$]: &lt;em&gt;Homomorphic Encryption Experiments on IBM's Cloud Quantum Computing Platform&lt;/em&gt; Huang et al. (2016)&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-05T19:00:10.927" LastActivityDate="2018-07-05T19:00:10.927" Title="Quantum algorithm for linear systems of equations (HHL09): Step 1 - Confusion regarding the usage of phase estimation algorithm" Tags="&lt;quantum-algorithms&gt;&lt;qubit&gt;&lt;hhl-algorithm&gt;" AnswerCount="2" CommentCount="1" />
  <row Id="2389" PostTypeId="2" ParentId="2386" CreationDate="2018-06-19T08:25:57.327" Score="1" Body="&lt;p&gt;You can find some lists of open source quantum projects &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1918/does-a-complete-list-of-open-quantum-software-projects-exist&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I’d also advise you to check out the &lt;a href=&quot;https://qiskit.org/&quot; rel=&quot;nofollow noreferrer&quot;&gt;QISKit&lt;/a&gt; and &lt;a href=&quot;https://www.rigetti.com/community&quot; rel=&quot;nofollow noreferrer&quot;&gt;Forest&lt;/a&gt; Slack channels to find some potential ideas and collaborators.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-06-19T08:25:57.327" CommentCount="0" />
  <row Id="2390" PostTypeId="1" CreationDate="2018-06-19T08:40:02.743" Score="7" ViewCount="139" Body="&lt;p&gt;This is a continuation of &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2388/quantum-algorithm-for-linear-systems-of-equations-hhl09-step-1-confusion-re&quot;&gt;Quantum algorithm for linear systems of equations (HHL09): Step 1 - Confusion regarding the usage of phase estimation algorithm&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Questions (contd.):&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Part 2:&lt;/strong&gt; I'm not exactly sure how many qubits will be needed for the &lt;strong&gt;Step 1&lt;/strong&gt; of the &lt;strong&gt;HHL09&lt;/strong&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In Nielsen and Chuang (section 5.2.1, 10th anniversary edition) they say:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Thus to successfully obtain $\varphi$ accurate to $n$-bits with&#xA;  probability of sucess at least $1-\epsilon$ we choose &lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;$$t=n+\lceil { \log(2+\frac{1}{2\epsilon})\rceil}$$&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;So, say we want an accuracy of $90\%$ i.e. $1-\epsilon = 0.9 \implies \epsilon = 0.1$ and a precision of $3$-bits for $\frac{\lambda_j t}{2\pi}$ or $\lambda_j$ we'd need &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$t = 3 + \lceil { \log_2(2+\frac{1}{2 (0.1)})\rceil} = 3 + 3 = 6$$ &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Apart from that, since $|b\rangle$ can be represented as a sum of $N$ linearly independent eigenvectors of a $N\times N$ dimensional matrix $A$, we'd need minimum $\lceil{\log_2(N)\rceil}$ qubits to produce a vector space having at least $N$ - dimensions. So, we need $\lceil{\log_2(N)\rceil}$ for the second register. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, for the first register we not only $\lceil{\log_2(N)\rceil}$ qubits &lt;em&gt;won't be sufficient&lt;/em&gt; to represent the $N$ eigenvalues $|\lambda_j\rangle$, that is because we'll need more bits for representing each $|\lambda_j\rangle$ precisely upto $n$-bits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I guess we should again use the formula $$n+\lceil { \log(2+\frac{1}{2\epsilon})\rceil}$$ in this case. If we want each eigenvalue $|\lambda_i\rangle$ to be represented with a $3$-bit precision and $90\%$ accuracy  then we'd need $6\times \lceil{\log_2(N)\rceil}$ for the first register. Plus, one more qubit which is needed for the ancilla. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, we should need a total of $(6+1)\lceil{\log_2(N)\rceil}+1$ qubits for &lt;strong&gt;Step 1&lt;/strong&gt; of the &lt;strong&gt;HHL09 algorithm&lt;/strong&gt;. That's quite a lot!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Say we want to solve a $2\times 2$ linear equation system such that $A$ is Hermitian that itself would require $7\lceil{\log_2(2)\rceil}+1 = 8$ qubits! In case $A$ is not Hermitian we'd need even more qubits. Am I right?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, in &lt;a href=&quot;https://arxiv.org/abs/1710.03599&quot; rel=&quot;nofollow noreferrer&quot;&gt;this&lt;/a&gt;&lt;sup&gt;[$\dagger\dagger$]&lt;/sup&gt; paper on page 6 they claim that they used the &lt;strong&gt;HHL09 algorithm&lt;/strong&gt; to estimate the pseudoinverse of $A$ which of size ~$200\times 200$. In that paper, $A$ is defined as:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$A := \begin{pmatrix} W - \gamma \Bbb I_d &amp;amp; P \\ P &amp;amp; 0  \end{pmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;where $P$,$W$ and $\Bbb I_d$ are all $d\times d$ matrices.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/SeU2e.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/SeU2e.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the H1N1 related simulated Lloyd et al. have claimed to have made, $d = 100$. And they further claim that they used the &lt;strong&gt;HHL09 algorithm&lt;/strong&gt; to estimate the pseudo-inverse of $A$ (which is of size $200\times 200$). That would need a minimum of $7\lceil{\log_2(200)\rceil}+1 = 7(8)+1 = 57$ qubits to simulate. I have no idea how they could possibly do that using the current quantum computers or quantum computer simulations. As far as I know, IBM Q Experience at present supports ~$15$ qubits (that too it isn't as versatile as their $5$-qubit version).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Am I missing something here? Does this Step 1 actually require a lesser number of qubits than what I have estimated?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[$\dagger\dagger$]: &lt;em&gt;A Quantum Hopfield Neural Network&lt;/em&gt; Lloyd et al. (2018)&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-05T19:00:29.757" LastActivityDate="2018-07-05T19:00:29.757" Title="Quantum algorithm for linear systems of equations (HHL09): Step 1 - Number of qubits needed" Tags="&lt;quantum-algorithms&gt;&lt;qubit&gt;&lt;neural-network&gt;&lt;hhl-algorithm&gt;" AnswerCount="1" CommentCount="2" />
  <row Id="2391" PostTypeId="2" ParentId="2381" CreationDate="2018-06-19T09:00:33.777" Score="2" Body="&lt;p&gt;A qubit is a two-dimensional quantum system, and the quantum generalization of a bit. Like bits, qubits can be in the states &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. In quantum notation, we write these as $|0\rangle$ and $|1\rangle$. They can also be in superposition states such as&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ |\psi_0 \rangle = \alpha |0\rangle + \beta |1\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here $\alpha$ and $\beta$ are complex numbers in general. But for this answer, I'll just assume they are normal real numbers. The name I've given this state, $|\psi_0 \rangle$, is just for convenience. It has no deeper meaning.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Extracting an output from a qubit is done by a process known as measurement. The most common measurement is what we call the $Z$ measurement. This means just asking the qubit whether it is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;. If it is in a superposition state, such as the one above, the output will be random. You'll get &lt;code&gt;0&lt;/code&gt; with probability $\alpha^2$ and &lt;code&gt;1&lt;/code&gt; with probability $\alpha^2$ (so clearly these numbers need to satisfy ($\alpha^2+\beta^2=1$).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This might make it seem that superpositions are just random number generators, but that isn't the case. For every $ \alpha |0\rangle + \beta |1\rangle$ , we can construct the following state&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ |\psi_1 \rangle = \beta |0\rangle - \alpha |1\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is as different to $|\psi_0\rangle$ as $|0\rangle$ is to $|1\rangle$. We call it a state that is &lt;em&gt;orthogonal&lt;/em&gt; to $|\psi_0\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;With this we can define an alternative measurement that looks at whether our qubit is $|\psi_0\rangle$ or $|\psi_1\rangle$. For this measurement, it is the $|\psi_0\rangle$ and $|\psi_1\rangle$ states that give us definite answers. For other states, such as $|0\rangle$ and $|1\rangle$, we'd get random outputs. This is because they can be thought of as superpositions of $|\psi_0\rangle$ and $|\psi_1\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, trying to summarize a little, qubits are objects that we can use to store a bit. We usually do this in the states $|0\rangle$ and $|1 \rangle$, but in fact, we could choose to do it in any of the infinite possible pairs of orthogonal states. If we want to get the bit out again with certainty, we have to measure according to the encoding we used. Otherwise, there will always be a degree of randomness. For more detail on all this, you can check out a &lt;a href=&quot;https://medium.com/@decodoku/quantum-computation-with-the-simplest-maths-possible-c23ff6563964&quot; rel=&quot;nofollow noreferrer&quot;&gt;blog post&lt;/a&gt; I once wrote.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To start getting interesting things happing, we need more than one qubit. Since $n$ bits can be made into $2^n$ different bit strings, there is an exponentially large number of orthogonal states that can be included in our superpositions of $n$ qubits. This is the space in which we can do all the tricks of quantum computation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But as for how that works, I'll have to refer you to the rest of the questions and answers in this Stack Exchange.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="26" LastEditDate="2018-07-13T14:55:55.303" LastActivityDate="2018-07-13T14:55:55.303" CommentCount="0" />
  <row Id="2392" PostTypeId="1" CreationDate="2018-06-19T10:58:31.203" Score="5" ViewCount="51" Body="&lt;p&gt;In a paper I am reading, it states:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;For open-loop coherent controllability a quantum system with Hamiltonian $H$ is open-loop controllable by a coherent controller if and only if the algebra $\mathcal{A}$ generated from $\{ H, H_i \}$ by commutation is the full algebra of Hermitian operators for the system.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;How would you produce an algebra from the set $\{ H, H_i \}$ using commutation? What is the basic idea in this regard?&lt;/p&gt;&#xA;" OwnerUserId="2032" LastEditorUserId="26" LastEditDate="2018-07-15T13:16:51.293" LastActivityDate="2018-07-15T13:16:51.293" Title="Generating algebra from commutation" Tags="&lt;quantum-information&gt;&lt;quantum-control&gt;&lt;mathematics&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="2" />
  <row Id="2393" PostTypeId="1" AcceptedAnswerId="2396" CreationDate="2018-06-19T11:03:29.097" Score="6" ViewCount="151" Body="&lt;p&gt;&lt;sup&gt;This is a sequel to &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2388/quantum-algorithm-for-linear-systems-of-equations-hhl09-step-1-confusion-re&quot;&gt;Quantum algorithm for linear systems of equations (HHL09): Step 1 - Confusion regarding the usage of phase estimation algorithm&lt;/a&gt; and &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2390/quantum-algorithm-for-linear-systems-of-equations-hhl09-step-1-number-of-qu&quot;&gt;Quantum algorithm for linear systems of equations (HHL09): Step 1 - Number of qubits needed&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;In the paper: &lt;a href=&quot;https://arxiv.org/abs/0811.3171&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;Quantum algorithm for linear systems of equations (Harrow, Hassidim &amp;amp; Lloyd, 2009)&lt;/strong&gt;&lt;/a&gt;, what's written up to the portion &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The next step is to decompose $|b\rangle$ in the eigenvector basis,&#xA;  using phase estimation [5–7]. Denote by $|u_j\rangle$ the eigenvectors&#xA;  of $A$ (or equivalently, of $e^{iAt}$), and by $\lambda_j$ the&#xA;  corresponding eigenvalues.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;on page $2$ makes &lt;em&gt;some&lt;/em&gt; sense to me (the confusions up till there have been addressed in the previous posts linked above). However, the next portion i.e. the $R(\lambda^{-1})$ rotation seems a bit cryptic.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Let $$|\Psi_0\rangle := \sqrt{\frac{2}{T}}\sum_{\tau =0}^{T-1} \sin&#xA; \frac{\pi(\tau+\frac{1}{2})}{T}|\tau\rangle$$&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;for some large $T$. The coefficients of $|\Psi_0\rangle$ are chosen&#xA;  (following [5-7]) to minimize a certain quadratic loss function which&#xA;  appears in our error analysis (see [13] for details).&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Next, we apply the conditional Hamiltonian evolution $\sum_{\tau =&#xA; 0}^{T-1}|\tau\rangle \langle \tau|^{C}\otimes e^{iA\tau t_0/T}$ on&#xA;   $|\Psi_0\rangle^{C}\otimes |b\rangle$, where $t_0 =&#xA; \mathcal{O}(\kappa/\epsilon)$. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;&lt;strong&gt;Questions:&lt;/strong&gt;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; What exactly is $|\Psi_0\rangle$? What do $T$ and $\tau$ stand for? I've no idea from where this gigantic expression $$\sqrt{\frac{2}{T}}\sum_{\tau =0}^{T-1} \sin&#xA;\frac{\pi(\tau+\frac{1}{2})}{T}|\tau\rangle$$ suddenly comes from and what its use is. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt;  After the phase estimation step, the state of our system is &lt;em&gt;apparently&lt;/em&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\left(\sum_{j=1}^{j=N}\beta_j|u_j\rangle\otimes |\tilde\lambda_j\rangle\right)\otimes |0\rangle_{\text{ancilla}}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This surely &lt;strong&gt;cannot&lt;/strong&gt; be written as $$\left(\sum_{j=1}^{j=N}\beta_j|u_j\rangle\right)\otimes \left(\sum_{j=1}^{j=N}|\tilde\lambda_j\rangle\right)\otimes |0\rangle_{\text{ancilla}}$$ i.e. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$|b\rangle\otimes \left(\sum_{j=1}^{j=N}|\tilde\lambda_j\rangle\right)\otimes |0\rangle_{\text{ancilla}}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, it is clear that $|b\rangle$ is not available &lt;em&gt;separately&lt;/em&gt; in the second register. So I've no idea how they're preparing a state like  $|\Psi_0\rangle^{C}\otimes |b\rangle$ in the first place! Also, what does that $C$ in the superscript of $|\Psi_0\rangle^{C}$ denote?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; Where does  this expression $\sum_{\tau =&#xA; 0}^{T-1}|\tau\rangle \langle \tau|^{C}\otimes e^{iA\tau t_0/T}$ suddenly appear from ? What's the use of simulating it? And what is $\kappa$ in $\mathcal{O}(\kappa/\epsilon)$ ?&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-05T19:00:54.647" LastActivityDate="2018-07-05T19:00:54.647" Title="Quantum algorithm for linear systems of equations (HHL09): Step 2 - What is $|\Psi_0\rangle$?" Tags="&lt;quantum-algorithms&gt;&lt;hhl-algorithm&gt;&lt;hamiltonian-simulation&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="2394" PostTypeId="2" ParentId="2392" CreationDate="2018-06-19T11:13:46.480" Score="3" Body="&lt;p&gt;In general, an algebra $\mathcal{A}$ generated from a set $\{H_1, H_2,..., H_n\}$ by commutation refers to the algebra whose generators are $H_1,H_2,...,H_n$, all their first-order commutators $C_{ij} = [H_i,H_j]$, and all their second-order commutators $C_{ijk} = [[H_i, H_j],H_k]$ and so on.&lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-06-19T11:13:46.480" CommentCount="3" />
  <row Id="2395" PostTypeId="2" ParentId="2388" CreationDate="2018-06-19T11:33:48.223" Score="4" Body="&lt;p&gt;It depends on the papers but I saw 2 approaches:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;In most of the papers I read about the HHL algorithm and its implementation, the Hamiltonian evolution time $t$ is taken such that this factor disappear, i.e. $t = t_0 = 2\pi$. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;The approximate eigenvalue is often written $\tilde \lambda$. In some paper this notation really means &quot;the approximation of the true eigenvalue $\lambda$&quot; and in other papers they seems to include $\frac{t}{2\pi}$ in this definition, i.e. &quot;$\tilde \lambda$ is the approximation of the value of $\frac{\lambda t}{2\pi}$&quot;.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Here are some links:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1802.08227&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum linear systems algorithms: a primer (Dervovic, Herbster, Mountney, Severini, Usher &amp;amp; Wossnig, 2018)&lt;/a&gt;: a complete and very good article on HHL algorithm and some improvements that has been discovered. The paper is from the 22th of February, 2018. The value of $t$ you are interested in is first addressed in page 30, in the legend of Figure 5 and is fixed at $2\pi$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1110.2232v2&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Circuit Design for Solving Linear Systems of Equations (Cao, Daskin, Frankel &amp;amp; Kais, 2013)&lt;/a&gt; (take the v2 and not the v3): a detailed implementation of HHL algorithm for a fixed 4x4 matrix. If you plan to use the article let me warn you that there are some mistakes in it. I can provide you the ones I found if you are interested. The value for $t$ (which is denoted as $t_0$ in this paper) is fixed to $2\pi$ in the second page (at the start of the right column).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1302.4310&quot; rel=&quot;nofollow noreferrer&quot;&gt;Experimental Quantum Computing to Solve Systems of Linear Equations (Cai,  Weedbrook, Su, Chen, Gu, Zhu, Li, Liu, Lu &amp;amp; Pan, 2013)&lt;/a&gt;: an implementation of HHL algorithm for a 2x2 matrix on an experimental setup. They fix $t = 2\pi$ in the legend of Figure 1.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1302.1946&quot; rel=&quot;nofollow noreferrer&quot;&gt;Experimental realization of quantum algorithm for solving linear systems of equations (Pan, Cao, Yao, Li, Ju, Peng, Kais &amp;amp; Du, 2013)&lt;/a&gt;: implementation of HHL for a 2x2 matrix. The implementation is similar to the one given in the second point above, with the 4x4 matrix. They fix $t_0 = 2\pi$ in page 3, bullet point n°2. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="1386" LastEditorUserId="1386" LastEditDate="2018-06-19T14:25:48.073" LastActivityDate="2018-06-19T14:25:48.073" CommentCount="0" />
  <row Id="2396" PostTypeId="2" ParentId="2393" CreationDate="2018-06-19T13:38:06.450" Score="4" Body="&lt;h1&gt;1. Definitions&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Names and symbols used in this answer follow the ones defined in &lt;a href=&quot;https://arxiv.org/abs/1802.08227&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum linear systems algorithms: a primer (Dervovic, Herbster, Mountney, Severini, Usher &amp;amp; Wossnig, 2018)&lt;/a&gt;. A recall is done below.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;1.1 Register names&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Register names are defined in Figure 5. of &lt;a href=&quot;https://arxiv.org/abs/1802.08227&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum linear systems algorithms: a primer (Dervovic, Herbster, Mountney, Severini, Usher &amp;amp; Wossnig, 2018)&lt;/a&gt; (reproduced below):&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$S$ (1 qubit) is the ancilla register used to check if the output is valid or not. &lt;/li&gt;&#xA;&lt;li&gt;$C$ ($n$ qubits) is the clock register, i.e. the register used to estimate the eigenvalues of the hamiltonian with quantum phase estimation (QPE).&lt;/li&gt;&#xA;&lt;li&gt;$I$ ($m$ qubits) is the register storing the right-hand side of the equation $Ax = b$. It stores $x$, the result of the equation, when $S$ is measured to be $\left|1\right&amp;gt;$ at the end of the algorithm.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/rMzOI.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/rMzOI.png&quot; alt=&quot;HHL algorithm&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;2. About $\left|\Psi_0\right&amp;gt;$:&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;What exactly is $\left|\Psi_0\right&amp;gt;$?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\left|\Psi_0\right&amp;gt;$ is one possible initial state of the clock register $C$. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;What do $T$ and $\tau$ stand for?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$T$ stands for a big positive integer. This $T$ should be as large as possible because the expression of $\left|\Psi_0\right&amp;gt;$ asymptotically minimise a given error for $T$ growing to infinity. In the expression of $\left|\Psi_0\right&amp;gt;$, $T$ will be $2^n$, the number of possible states for the quantum clock $C$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\tau$ is just the summation index&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Why such a gigantic expression for $\left|\Psi_0\right&amp;gt;$?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;See &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2462/1386&quot;&gt;DaftWullie's post&lt;/a&gt; for a detailed explanation.&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Following the citations in &lt;a href=&quot;https://arxiv.org/abs/0811.3171&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum algorithm for linear systems of equations (Harrow, Hassidim &amp;amp; Lloyd, 2009 v3)&lt;/a&gt; we end up with:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;The previous version of the same paper &lt;a href=&quot;https://arxiv.org/abs/0811.3171v2&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum algorithm for linear systems of equations (Harrow, Hassidim &amp;amp; Lloyd, 2009 v2)&lt;/a&gt;. The authors revised the paper 2 times (there are 3 versions of the original HHL paper) and version n°3 does not include all the informations provided in the previous versions. In the V2 (section A.3. starting at page 17), the authors provide a detailed analysis of the error with this special initial state.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/quant-ph/9808042v2.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Optimal Quantum Clocks (Buzek, Derka, Massar, 1998)&lt;/a&gt; where the expression of $\left|\Psi_0\right&amp;gt;$ is given as $\left|\Psi_{opt}\right&amp;gt;$ in Equation 10. I don't have the knowledge to understand fully this part, but it seems like this expression is &quot;optimal&quot; in some sense.&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1&gt;3. Preparation of $\left|\Psi_0\right&amp;gt;$:&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;As said in the previous part, $\left|\Psi_0\right&amp;gt;$ is an initial state. They do not prepare $\left|\Psi_0\right&amp;gt;$ after the phase estimation procedure. The sentence ordering is not really optimal in the paper. The phase estimation procedure they use in the paper is a little bit different from the &quot;classic&quot; phase estimation algorithm represented in the quantum circuit linked in part 1, and that is why they explain it in details. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Their phase estimation algorithm is:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Prepare the $\left|\Psi_0\right&amp;gt;$ state in the register $C$.&lt;/li&gt;&#xA;&lt;li&gt;Apply the conditional Hamiltonian evolution to the registers $C$ and $I$ (which are in the state $\left|\Psi_0\right&amp;gt;\otimes \left|b\right&amp;gt;$).&lt;/li&gt;&#xA;&lt;li&gt;Apply the quantum Fourier transform to the resulting state.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Finally, the $C$ in $\left| \Psi_0 \right&amp;gt;^C$ means that the state $\left| \Psi_0 \right&amp;gt;$ is stored in the register $C$. This is a short and convenient notation to keep track of the registers used.&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;4. Hamiltonian simulation:&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;First of all, $\kappa$ is the condition number (&lt;a href=&quot;https://en.wikipedia.org/wiki/Condition_number&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wikipedia page on &quot;condition number&quot;&lt;/a&gt;) of the matrix $A$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\sum_{\tau = 0}^{T-1}|\tau\rangle \langle \tau|^{C}\otimes e^{iA\tau t_0/T}$ is the mathematical representation of a quantum gate. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The first part in the sum $|\tau\rangle \langle \tau|^{C}$ is a control part. It means that the operation will be controlled by the state of the first quantum register (the register $C$ as the exponent tells us).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The second part is the &quot;Hamiltonian simulation&quot; gate, i.e. a quantum gate that will apply the unitary matrix given by $e^{iA\tau t_0/T}$ to the second register (the register $I$ that is in the initial state $\left|b\right&amp;gt;$).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The whole sum is the mathematical representation of the controlled-U operation in the quantum circuit of &quot;1. Definitions&quot;, with $U = e^{iA\tau t_0/T}$.&lt;/p&gt;&#xA;" OwnerUserId="1386" LastEditorUserId="1386" LastEditDate="2018-06-27T06:21:14.917" LastActivityDate="2018-06-27T06:21:14.917" CommentCount="0" />
  <row Id="2397" PostTypeId="1" AcceptedAnswerId="2398" CreationDate="2018-06-19T17:44:46.100" Score="9" ViewCount="306" Body="&lt;p&gt;A CCCNOT gate is a four-bit reversible gate that flips its fourth bit if and only if the first three bits are all in the state $1$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;How would I implement a CCCNOT gate using Toffoli gates? Assume that bits in the workspace start with a particular value, either 0 or 1, provided you return them to that value.&lt;/p&gt;&#xA;" OwnerUserId="2713" LastEditorUserId="55" LastEditDate="2018-06-19T18:58:54.907" LastActivityDate="2018-06-21T11:56:43.730" Title="Implementing a CCCNOT gate using only Toffoli gates" Tags="&lt;quantum-computer&gt;&lt;quantum-gate&gt;&lt;gate-synthesis&gt;" AnswerCount="1" CommentCount="4" FavoriteCount="1" />
  <row Id="2398" PostTypeId="2" ParentId="2397" CreationDate="2018-06-19T19:20:18.097" Score="6" Body="&lt;p&gt;I guess what you're looking for is the following circuit. Here, $b_1,b_2,b_3,b_4 \in \{0,1\}$, and $\oplus$ is addition modulo $2$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/ELZCQ.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/ELZCQ.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here, the fifth qubit is used as an &lt;em&gt;auxiliary&lt;/em&gt;, or &lt;em&gt;ancilla qubit&lt;/em&gt;. It starts at $|0\rangle$ and ends in $|0\rangle$ when the circuit is applied.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let me elaborate on how this circuit works. The idea is to first of all check whether the first two qubits are in state $|1\rangle$. This can be done using a single Toffoli gate, and the result is stored in the auxiliary qubit. Now, the problem reduces to flipping qubit $4$, whenever qubits $3$ and the auxiliary qubit are in $|1\rangle$. This can also be achieved using one application of a Toffoli gate, namely the middle one in the circuit shown above. Finally, the last Toffoli gate serves to &lt;em&gt;uncompute&lt;/em&gt; the temporary result that we stored in the auxiliary qubit, such that the state of this qubit returns to $|0\rangle$ after the circuit is applied.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;In the comment section, the question arose whether it is possible to implement such a circuit using only Toffoli gates, without using auxiliary qubits. This question can be answered in the negative, as I will show here.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We want to implement the $CCCNOT$-gate, which acts on four qubits. We can define the following matrix (the matrix representation of the Pauli-$X$-gate):&#xA;$$X = \begin{bmatrix}&#xA;0 &amp;amp; 1 \\ 1 &amp;amp; 0&#xA;\end{bmatrix}$$&#xA;Furthermore, we denote the $N$-dimensional identity matrix by $I_N$. Now, we observe that the matrix representation of the $CCCNOT$-gate, acting on four qubits, is given by the following $16 \times 16$ matrix:&#xA;$$CCCNOT = \begin{bmatrix}&#xA;I_{14} &amp;amp; 0 \\ 0 &amp;amp; X&#xA;\end{bmatrix}$$&#xA;Hence, we can determine its determinant:&#xA;$$\det(CCCNOT) = -1$$&#xA;Now consider the matrix representation of the Toffoli gate, acting on the first three qubits of a $4$-qubit system. Its matrix representation is written as (where we used the Kronecker product of matrices):&#xA;$$Toffoli \otimes I_2 = \begin{bmatrix}&#xA;I_6 &amp;amp; 0 \\ 0 &amp;amp; X&#xA;\end{bmatrix} \otimes I_2 = \begin{bmatrix}&#xA;I_{12} &amp;amp; 0 \\ 0 &amp;amp; X \otimes I_2&#xA;\end{bmatrix} = \begin{bmatrix}&#xA;I_{12} &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; I_2 \\ 0 &amp;amp; I_2 &amp;amp; 0&#xA;\end{bmatrix}$$&#xA;Calculating its determinant yields:&#xA;$$\det(Toffoli \otimes I_2) = 1$$&#xA;The Toffoli gates can also act on different qubits of course. Suppose we let the Toffoli gate act on the first, second and fourth qubit, where the fourth qubit is the target qubit. Then we obtain the new matrix representation from the one displayed above by swapping the columns corresponding to the states that differ only in the third and fourth qubit, i.e., $|0001\rangle$ with $|0010\rangle$, $|0101\rangle$ with $|0110\rangle$, etc. The important thing to note here, is that the number of swaps of columns is even, and hence that the determinant remains unchanged. As we can write every permutation of qubits as a sequence of consecutive permutations of just $2$ qubits (that is, $S_4$ is generated by the transpositions in $S_4$), we find that for all Toffoli gates, applied to any combination of control and target qubits, its matrix representation has determinant $1$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The final thing to note is that the determinant commutes with matrix multiplication, i.e., $\det(AB) = \det(A)\det(B)$, for any two matrices $A$ and $B$ compatible with matrix multiplication. Hence, it now becomes apparent that applying multiple Toffoli gates in sequence never creates a circuit whose matrix representation has a determinant different from $1$, which in particular implies that the $CCCNOT$-gate cannot be implemented using only Toffoli gates on $4$ qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The obvious question, now, is what changes when we do allow an auxiliary qubit. We find the answer when we write out the action of the $CCCNOT$-gate on a $5$-qubit system:&#xA;$$CCCNOT \otimes I_2 = \begin{bmatrix}&#xA;I_{14} &amp;amp; 0 \\ 0 &amp;amp; X&#xA;\end{bmatrix} \otimes I_2 = \begin{bmatrix}&#xA;I_{28} &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; I_2 \\ 0 &amp;amp; I_2 &amp;amp; 0&#xA;\end{bmatrix}$$&#xA;If we calculate this determinant, we find:&#xA;$$\det(CCCNOT \otimes I_2) = 1$$&#xA;Hence, the determinant of the $CCCNOT$-gate acting on $5$ qubits is $1$, instead of $-1$. This is why the previous argument is not valid for $5$ qubits, as we already knew because of the explicitly constructed circuit the OP asked for.&lt;/p&gt;&#xA;" OwnerUserId="24" LastEditorUserId="24" LastEditDate="2018-06-21T11:56:43.730" LastActivityDate="2018-06-21T11:56:43.730" CommentCount="8" />
  <row Id="2399" PostTypeId="1" AcceptedAnswerId="2401" CreationDate="2018-06-19T21:14:31.540" Score="9" ViewCount="141" Body="&lt;p&gt;This question is very similar as &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1584/is-there-any-general-statement-about-what-kinds-of-problems-can-be-solved-more-e&quot;&gt;Is there any general statement about what kinds of problems can be solved more efficiently using a quantum computer?&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But the answers provided to that questions mainly looked at it from a &lt;em&gt;theoretical / mathematical&lt;/em&gt; point of view.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For this question I am more interested in the &lt;em&gt;practical / engineering&lt;/em&gt; point of view.  So I would like to understand what kind of a problems can be more efficiently solved by a quantum algorithm than you would currently be able to do with a classical algorithm.  So I am really assuming that you do not have all knowledge about all possible classical algorithms that could optimally solve the same problem !&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am aware that the &lt;a href=&quot;https://math.nist.gov/quantum/zoo/&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum zoo&lt;/a&gt; expresses a whole collection of problems for which there exists a quantum algorithm that runs more efficiently than a classical algorithm but I fail to link these algorithms to &lt;em&gt;real world problems&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I understand that Shor's factoring algorithm is very important in the world of cryptography but I have deliberately excluded cryptography from the scope of this question as the world of cryptography is a very specific world which deserves his own questions.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;With efficient quantum algorithm, I mean that there must at least be one step in the algorithm that must be translated to a quantum circuit on a n-qubit quantum computer.  So basically this quantum circuit is creating a $2^n$ x $2^n$ matrix and its execution will give one of the $2^n$ possibilities with a certain possibility (so different runs might give different results - where the likely hood of each of the $2^n$ possibilities is determined by the constructed $2^n$ x $2^n$ Hermitian matrix.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So I think to answer my question there must be some aspect / characteristic of the real world problem that can be mapped to an $2^n$ x $2^n$ Hermitian matrix.&#xA;&lt;em&gt;So what kind of aspects / characteristics of a real world problem can be mapped to such a matrix&lt;/em&gt; ?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;With &lt;em&gt;real world problem&lt;/em&gt; I mean an actual problem that might be solved by a quantum algorithm, I don't mean a domain where there might be a potential use of the quantum algorithm.&lt;/p&gt;&#xA;" OwnerUserId="2529" LastEditorUserId="2529" LastEditDate="2018-06-20T07:36:44.073" LastActivityDate="2018-06-20T07:36:44.073" Title="What kind of real world problems (excluding cryptography) can be solved efficiently by a quantum algorithm?" Tags="&lt;quantum-computer&gt;&lt;quantum-algorithms&gt;" AnswerCount="1" CommentCount="1" FavoriteCount="3" />
  <row Id="2400" PostTypeId="2" ParentId="2381" CreationDate="2018-06-19T22:53:53.417" Score="4" Body="&lt;p&gt;I'll probably be expanding this more (!) and adding pictures and links as I have time, but here's my first shot at this.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Mostly math-free explanation&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;A special coin&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Let's begin by thinking about normal bits. Imagine this normal bit is a coin, that we can flip to be heads or tails. We'll call heads equivalent to &quot;1&quot; and tails &quot;0&quot;. Now imagine instead of just flipping this coin, we can rotate it - 45${}^\circ$ above horizontal, 50$^\circ$ above horizontal, 10$^\circ$ below horizontal, whatever - these are all states. This opens up a huge new possibility of states - I could encode the whole works of Shakespeare into this one coin this way.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But what's the catch? No such thing as a free lunch, as the saying goes. When I actually look at the coin, to see what state it's in, it becomes either heads or tails, based on probability - a good way to look at it is if it's closer to heads, it's more likely to become heads when looked at, and vice versa, though there's a chance the close-to-heads coin could become tails when looked at.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Further, once I  look at this special coin, any information that was in it before can't be accessed again. If I look at my Shakespeare coin, I just get heads or tails, and when I look away, it still is whatever I saw when I looked at it - it doesn't magically revert to Shakespeare coin. I should note here that you might think, as Blue points out in the comments, that &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Given the huge advancement in modern day technology there's nothing stopping me from monitoring the exact orientation of a coin tossed in air as it falls. I don't necessarily need to &quot;look into it&quot; i.e. stop it and check whether it has fallen as &quot;heads&quot; or &quot;tails&quot;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;This &quot;monitoring&quot; counts as measurement. &lt;em&gt;There is no way to see the inbetween state of this coin.&lt;/em&gt; None, nada, zilch. This is a bit different from a normal coin, isn't it?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So encoding all the works of Shakespeare in our coin is theoretically possible but we can never truly access that information, so not very useful.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Nice little mathematical curiosity we've got here, but how could we actually do anything with this?&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;The problem with classical mechanics&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Well, let's take a step back a minute here and switch to another tack. If I throw a ball to you and you catch it, we can basically model that ball's motion &lt;em&gt;exactly&lt;/em&gt; (given all parameters). We can analyze its trajectory with Newton's laws, figure out its movement through the air using fluid mechanics (&lt;a href=&quot;https://physics.stackexchange.com/questions/56496/what-is-the-mystery-of-turbulence&quot;&gt;unless there's turbulence&lt;/a&gt;), and so forth.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So let's set us up a little experiment. I've got a wall with two slits in it and another wall behind that wall. I set up one of those tennis-ball-thrower things in the front and let it start throwing tennis balls. In the meantime, I'm at the back wall marking where all our tennis balls end up. When I mark this, there are clear &quot;humps&quot; in the data right behind the two slits, as you might expect.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, I switch our tennis-ball-thrower to something that shoots out really tiny particles. Maybe I've got a laser and we're looking where the photons look up. Maybe I've got an electron gun. Whatever, we're looking at where these sub-atomic particles end up again. This time, we don't get the two humps, we get an interference pattern.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/oI0yy.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/oI0yy.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Does that look familiar to you at all? Imagine you drop two pebbles in a pond right next to each other. Look familiar now? The ripples in a pond &lt;a href=&quot;https://en.wikipedia.org/wiki/Wave_interference&quot; rel=&quot;nofollow noreferrer&quot;&gt;interfere&lt;/a&gt; with each other. There are spots where they cancel out and spots where they swell bigger, making beautiful patterns. Now, we're seeing an interference pattern shooting &lt;em&gt;particles&lt;/em&gt;. These particles must have wave-like behavior. So maybe we were wrong all along. (This is called the &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-slit_experiment&quot; rel=&quot;nofollow noreferrer&quot;&gt;double slit experiment&lt;/a&gt;.)Sorry, electrons are waves, not particles.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Except...they're particles too. When you look at &lt;a href=&quot;https://en.wikipedia.org/wiki/Cathode_ray&quot; rel=&quot;nofollow noreferrer&quot;&gt;cathode rays&lt;/a&gt; (streams of electrons in vacuum tubes), the behavior there clearly shows electrons are a particle. To quote wikipedia:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Like a wave, cathode rays travel in straight lines, and produce a shadow when obstructed by objects. Ernest Rutherford demonstrated that rays could pass through thin metal foils, behavior expected of a particle. These conflicting properties caused disruptions when trying to classify it as a wave or particle [...] The debate was resolved when an electric field was used to deflect the rays by J. J. Thomson. This was evidence that the beams were composed of particles because scientists knew it was impossible to deflect electromagnetic waves with an electric field.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;So...they're &lt;em&gt;both&lt;/em&gt;. Or rather, they're something completely different. That's one of several puzzles physicists saw at the beginning of the twentieth century. If you want to look at some of the others, look at &lt;a href=&quot;https://en.wikipedia.org/wiki/Black-body_radiation&quot; rel=&quot;nofollow noreferrer&quot;&gt;blackbody radiation&lt;/a&gt; or the &lt;a href=&quot;https://en.wikipedia.org/wiki/Photoelectric_effect&quot; rel=&quot;nofollow noreferrer&quot;&gt;photoelectric effect&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;What fixed the problem - quantum mechanics&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;These problems lead us to realize that the laws that allow us to calculate the motion of that ball we're tossing back and forth just don't work on a really small scale. So a new set of laws were developed. These laws were called quantum mechanics after one of the major ideas behind them - the existence of fundamental packets of energy, called quanta. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The idea is that I can't just give you .00000000000000000000000000 plus a bunch more zeroes 1 Joules of energy - there is a minimum possible amount of energy I can give you. It's like, in currency systems, I can give you a dollar or a penny, but (in American money, anyway) I can't give you a &quot;half-penny&quot;. Doesn't exist. Energy (and other values) can be like that in certain situations. (Not all situations, and this can occur in classical mechanics sometimes - see also &lt;a href=&quot;https://physics.stackexchange.com/questions/193133/quantization-vs-continuous-energy-levels/193164#193164&quot;&gt;this&lt;/a&gt;; thanks to Blue for pointing this out.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So anyway, we got this new set of laws, quantum mechanics. And the development of those laws is complete, though not completely correct (see quantum field theories, quantum gravity) but the history of their development is kind of interesting. There was this guy, Schrodinger, of cat-killing (&lt;a href=&quot;https://en.wikipedia.org/wiki/Schr%C3%B6dinger&amp;#39;s_cat&quot; rel=&quot;nofollow noreferrer&quot;&gt;maybe?&lt;/a&gt;) fame, who came up with the &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Schr%C3%B6dinger_equation&quot; rel=&quot;nofollow noreferrer&quot;&gt;wave equation&lt;/a&gt;&lt;/em&gt; formulation of quantum mechanics. And this was preferred by a lot of physicists preferred this, because it was sort of similar to the classical way of calculating things - integrals and hamiltonians and so forth.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Another guy, Heisenberg, came up with another totally different way of calculating the state of a particle quantum-mechanically, which is called matrix mechanics. Yet another guy, Dirac, proved that the matrix mechanical and wave equation formulations were equal.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So now, we must switch tacks again - what are matrices, and their friend vectors?&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Vectors and matrices - or, some hopefully painless linear algebra&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Vectors are, at their simplest, arrows. I mean, they're on a coordinate plane, and they're math-y, but they're arrows. (Or you could take the programmer view and call them lists of numbers.) They're quantities that have a magnitude and a direction. So once we have this idea of vectors...what might we use them for? Well, maybe I have an acceleration. I'm accelerating to the right at 1 m/s$^2$, for example. That could be represented by a vector. How long that arrow is represents how quickly I am accelerating, the arrow would be pointing right along the x-axis, and by convention, the arrow's tail would be situated at the origin. We notate a vector by writing something like [2, 3] which would notate a vector with its tail at the origin and its point at (2, 3).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So we have these vectors. What sorts of math can I do with them? How can I manipulate a vector? I can multiply vectors by a normal number, like 3 or 2 (these are called scalars), to stretch it, shrink it (if a fraction), or flip it (if negative). I can add or subtract vectors pretty easily - if I have a vector (2, 3) + (4, 2) that equals (6, 5). There's also stuff called dot products and cross products that we won't get into here - if interested in any of this, look up &lt;a href=&quot;https://www.youtube.com/watch?v=kjBOesZCoqc&amp;amp;list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab&quot; rel=&quot;nofollow noreferrer&quot;&gt;3blue1brown's linear algebra series&lt;/a&gt;, which is very accessible, actually teaches you how to &lt;em&gt;do&lt;/em&gt; it, and is a fabulous way to learn about this stuff. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now let's say I have one coordinate system, that my vector is in, and then I want to move that vector to a new coordinate system. I can use something called a matrix to do that. Basically we can define in our system two vectors, called $\hat{i}$ and $\hat{j}$, read i-hat and j-hat (we're doing all this in two dimensions in the real plane; you can have higher dimension vectors with complex numbers ($\sqrt{-1} = i$) as well but we're ignoring them for simplicity), which are vectors that are one unit in the x direction and one unit in the y direction - that is, (0, 1) and (1, 0). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then we see where i-hat and j-hat end up in our new coordinate system. In the first column of our matrix, we write the new coordinates of i-hat and in the second column the new coordinates of j-hat. We can now multiply this matrix by any vector and get that vector in the new coordinate system. The reason this works is because you can rewrite vectors as what are called linear combinations. This means that we can rewrite say, (2, 3) as 2*(1, 0) + 3*(0, 1) - that is, 2*i-hat + 3*j-hat. When we use a matrix, we're effectively re-multiplying those scalars by the &quot;new&quot; i-hat and j-hat. Again, if interested, see 3blue1brown's videos. These matrices are used a lot in many fields, but this is where the name matrix mechanics comes from.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Tying it all together&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Now matrices can represent rotations of the coordinate plain, or stretching or shrinking the coordinate plane or a bunch of other things. But some of this behavior...sounds kind of familiar, doesn't it? Our little special coin sounds kind of like it. We have this rotation idea. What if we represent the horizontal state by i-hat, and the vertical by j-hat, and describe what the rotation of our coin is using linear combinations? That works, and makes our system much easier to describe. So our little coin can be described using linear algebra.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What else can be described linear algebra and has weird probabilities and measurement? Quantum mechanics. (In particular, this idea of linear combinations becomes the idea called a superposition, which is where the whole idea, oversimplified to the point it's not really correct, of &quot;two states at the same time&quot; comes from.) So these special coins can be quantum mechanical objects. What sorts of things are quantum mechanical objects?&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;photons&lt;/li&gt;&#xA;&lt;li&gt;superconductors&lt;/li&gt;&#xA;&lt;li&gt;electron energy states in an atom&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Anything, in other words, that has the discrete energy (quanta) behavior, but also can act like a wave - they can interfere with one another and so forth.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So we have these special quantum mechanical coins. What should we call them? They store an information state like bits...but they're quantum. They're qubits. And now what do we do? We manipulate the information stored in them with matrices (ahem, gates). We measure to get results. In short, we compute.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, we know that we cannot encode infinite amounts of information in a qubit and still access it (see the notes on our &quot;shakespeare coin&quot;), so what then is the advantage of a qubit? It comes in the fact that those extra bits of information can affect all the other qubits (it's that superposition/linear combination idea again), which affects the probability, which then affects your answer - but it's very difficult to use, which is why there are so few quantum algorithms.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;The special coin versus the normal coin - or, what makes a qubit different?&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;So...we have this qubit. But Blue brings up a great point.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;how is a quantum state like $\frac{1}{\sqrt{2}}|0\rangle + \frac{1}{\sqrt{2}}|1\rangle$ different from a coin which when tossed in the air has a 50−50 chance of turning out to be heads or tails. Why can't we say that a classical coin is a &quot;qubit&quot; or call a set of classical coins a system of qubits?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There are several differences - the way that measurement works (see the fourth paragraph), this whole superposition idea - but the defining difference (Mithrandir24601 pointed this out in chat, and I agree) is the violation of the Bell inequalities.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's take another tack. Back when quantum mechanics was being developed, there was a big debate. It started between Einstein and Bohr. When Schrodinger's wave theory was developed, it was clear that quantum mechanics would be a probabilistic theory. Bohr published a paper about this probabilistic worldview, which he concluded saying&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Here the whole problem of determinism comes up. From the standpoint of our quantum mechanics there is no quantity which in any individual case causally fixes the consequence of the collision; but also experimentally we have so far no reason to believe that there are some inner properties of the atom which conditions a definite outcome for the collision. Ought we to hope later to discover such properties ... and determine them in individual cases? Or ought we to believe that the agreement of theory and experiment—as to the impossibility of prescribing conditions for a causal evolution—is a pre-established harmony founded on the nonexistence of such conditions? I myself am inclined to give up determinism in the world of atoms. But that is a philosophical question for which physical arguments alone are not decisive.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The idea of determinism has been around for a while. Perhaps one of the more famous quotes on the subject is from Laplace, who said&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;An intellect which at a certain moment would know all forces that set nature in motion, and all positions of all items of which nature is composed, if this intellect were also vast enough to submit these data to analysis, it would embrace in a single formula the movements of the greatest bodies of the universe and those of the tiniest atom; for such an intellect nothing would be uncertain and the future just like the past would be present before its eyes.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The idea of determinism is that if you know all there is to know about a current state, and apply the physical laws we have, you can figure out (effectively) the future. However, quantum mechanics decimates this idea with probability. &quot;I myself am inclined to give up determinism in the world of atoms.&quot; This is a huge deal!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Albert Einstein's famous response: &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Quantum mechanics is very worthy of regard. But an inner voice tells me that this is not yet the right track. The theory yields much, but it hardly brings us closer to the Old One's secrets. I, in any case, am convinced that He does not play dice.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;(Bohr's response was apparently &quot;Stop telling God what to do&quot;, but anyway.) &lt;/p&gt;&#xA;&#xA;&lt;p&gt;For a while, there was debate. Hidden variable theories came up, where it wasn't just probability - there was a way the particle &quot;knew&quot; what it was going to be when measured; it wasn't all up to chance. And then, there was the Bell inequality. To quote Wikipedia,&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;In its simplest form, Bell's theorem states&lt;/p&gt;&#xA;  &#xA;  &lt;blockquote&gt;&#xA;    &lt;p&gt;No physical theory of local hidden variables can ever reproduce all of the predictions of quantum mechanics.&lt;/p&gt;&#xA;  &lt;/blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;And it provided a way to experimentally check this. It's true - it is pure probability. This is no classical behavior. It is all chance, chance that affects other chances through superposition, and then &quot;collapses&quot; to a single state upon measurement (if you follow the Copenhagen interpretation). So to summarize: firstly, measurement is fundamentally different in quantum mechanics, and secondly, that quantum mechanics is not deterministic. Both of these points mean that any quantum system, including a qubit, is going to be fundamentally different from any classical system.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;A small disclaimer&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/7ze5C.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/7ze5C.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As xkcd wisely points out, any analogy is an approximation. This answer isn't formal at all, and there's a heck of a lot more to this stuff. I'm hoping to add to this answer with a slightly more formal (though still not completely formal) description, but please keep this in mind.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Resources&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Nielsen and Chuang, Quantum Computing and Quantum Information. The bible of quantum computing.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;3blue1brown's linear algebra and calculus courses are great for the math.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Michael Nielsen (yeah, the guy who coauthored the textbook above) has a video series called Quantum Computing for the Determined. 10/10 would recommend.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;quirk is a great little simulator of a quantum computer that you can play around with.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;I wrote some blog posts on this subject a while back (if you don't mind reading my writing, which isn't very good) that can be found &lt;a href=&quot;https://medium.com/universe-factory/taking-into-account-quantum-encryption-part-1-db86d1f1665a&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt; which attempts to start from the basics and work on up.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="91" LastEditorUserId="91" LastEditDate="2018-06-20T23:00:13.370" LastActivityDate="2018-06-20T23:00:13.370" CommentCount="1" />
  <row Id="2401" PostTypeId="2" ParentId="2399" CreationDate="2018-06-20T05:05:37.820" Score="5" Body="&lt;p&gt;I won't be giving any &lt;em&gt;precise&lt;/em&gt; statements about which problems can be solved more efficiently using quantum algorithms (compared to &lt;em&gt;existing&lt;/em&gt; classical algorithms) but rather &lt;em&gt;some examples&lt;/em&gt;:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Discrete Fourier transform&lt;/strong&gt; (DFT) is used in pretty much all modern day music systems, for example in iPods. That algorithm single-handedly changed the world of digital music. See &lt;a href=&quot;https://gizmodo.com/digital-music-couldnt-exist-without-the-fourier-transfo-1699155287&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt; for a summary. However, &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_Fourier_transform&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;Quantum Fourier transform&lt;/strong&gt;&lt;/a&gt; can further improve upon the complexity of DFT i.e. from $\mathcal{O}(N\log(N))$ to $\mathcal{O}(\log^2 N)$. I've written an answer regarding this &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2002/26&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_algorithm_for_linear_systems_of_equations&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;Quantum algorithm for linear systems of equations&lt;/strong&gt;&lt;/a&gt; provides an exponential speedup over the classical methods like Gaussian elimination. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The quantum algorithm for linear systems of equations, designed by&#xA;  Aram Harrow, Avinatan Hassidim, and Seth Lloyd is a quantum algorithm&#xA;  formulated in 2009 for solving linear systems. The algorithm estimates&#xA;  the result of a scalar measurement on the solution vector to a given&#xA;  linear system of equations.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;The algorithm is one of the main fundamental algorithms expected to&#xA;  provide a speedup over their classical counterparts, along with Shor's&#xA;  factoring algorithm, Grover's search algorithm and quantum simulation.&#xA;  Provided the linear system is a sparse and has a low condition number&#xA;  ${\displaystyle \kappa }$ , and that the user is interested in&#xA;  the result of a scalar measurement on the solution vector, instead of&#xA;  the values of the solution vector itself, then the algorithm has a&#xA;  runtime of $O(\log(N)\kappa ^{2})$, where ${\displaystyle N}$ is the&#xA;  number of variables in the linear system. This offers an exponential&#xA;  speedup over the fastest classical algorithm, which runs in&#xA;  ${\displaystyle O(N\kappa )}$or $O(N{\sqrt {\kappa }})$ for positive&#xA;  semidefinite matrices).&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_algorithm_for_linear_systems_of_equations#Hamiltonian_simulation&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;Hamiltonian simulation&lt;/strong&gt;&lt;/a&gt;: &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;One of the earliest – and most important – applications of a quantum&#xA;  computer is likely to be the simulation of quantum mechanical systems.&#xA;  There are quantum systems for which no efficient classical simulation&#xA;  is known, but which we can simulate on a universal quantum computer.&#xA;  What does it mean to “simulate” a physical system? According to the&#xA;  OED, simulation is “the technique of imitating the behaviour of some&#xA;  situation or process (whether economic, military, mechanical, etc.) by&#xA;  means of a suitably analogous situation or apparatus”. What we will&#xA;  take simulation to mean here is approximating the dynamics of a&#xA;  physical system. Rather than tailoring our simulator to simulate only&#xA;  one type of physical system (which is sometimes called analogue&#xA;  simulation), we seek a general simulation algorithm which can simulate&#xA;  many different types of system (sometimes called digital simulation)&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;For the details, check chapter 7 of the &lt;a href=&quot;https://people.maths.bris.ac.uk/~csxam/teaching/qc2018/lecturenotes.pdf&quot; rel=&quot;noreferrer&quot;&gt;lecture notes&lt;/a&gt; by Ashley Montaro.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_algorithm#Hybrid_Quantum/Classical_Algorithms&quot; rel=&quot;noreferrer&quot;&gt;&lt;strong&gt;Hybrid Quantum/Classical Algorithms&lt;/strong&gt;&lt;/a&gt;:&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Hybrid Quantum/Classical Algorithms combine quantum state preparation&#xA;  and measurement with classical optimization. These algorithms&#xA;  generally aim to determine the ground state eigenvector and eigenvalue&#xA;  of a Hermitian Operator.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;strong&gt;QAOA&lt;/strong&gt;:&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;The quantum approximate optimization&#xA;  algorithm&lt;sup&gt;[1]&lt;/sup&gt; is a toy model of quantum&#xA;  annealing which can be used to solve problems in graph theory. The&#xA;  algorithm makes use of classical optimization of quantum operations to&#xA;  maximize an objective function.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;strong&gt;Variational Quantum Eigensolver&lt;/strong&gt;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;The VQE algorithm applies classical optimization to minimize the&#xA;  energy expectation of an ansatz state to find the ground state energy&#xA;  of a molecule &lt;sup&gt;[2]&lt;/sup&gt;. This can also be extended to find&#xA;  excited energies of molecules.&lt;sup&gt;[3]&lt;/sup&gt;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;You can find many more such examples on &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_algorithm&quot; rel=&quot;noreferrer&quot;&gt;Wikipedia&lt;/a&gt; itself. Apart from those, there are lots of recent algorithms which can be used in machine learning and data science. This answer will get a bit too long if I add the details of all those. However, see &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_machine_learning&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_neural_network&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt; and the references therein.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[1]: &lt;a href=&quot;https://arxiv.org/abs/1411.4028&quot; rel=&quot;noreferrer&quot;&gt;A Quantum Approximate Optimization Algorithm&lt;/a&gt; Farhi &lt;em&gt;et al.&lt;/em&gt; (2014)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[2]: &lt;a href=&quot;https://arxiv.org/abs/1304.3061&quot; rel=&quot;noreferrer&quot;&gt;A variational eigenvalue solver on a quantum processor&lt;/a&gt;  Peruzzo &lt;em&gt;et al.&lt;/em&gt; (2013)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[3]: &lt;a href=&quot;https://arxiv.org/abs/1805.08138&quot; rel=&quot;noreferrer&quot;&gt;Variational Quantum Computation of Excited States&lt;/a&gt; Brierley &lt;em&gt;et al.&lt;/em&gt; (2018)&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-06-20T05:38:58.257" LastActivityDate="2018-06-20T05:38:58.257" CommentCount="5" />
  <row Id="2402" PostTypeId="1" AcceptedAnswerId="2404" CreationDate="2018-06-20T09:32:50.140" Score="8" ViewCount="2026" Body="&lt;p&gt;I want to know what time complexity is considered efficient/inefficient for quantum computers. For this, I need to know how many operations a quantum computer can perform per second. Can anyone tell me how to calculate it and what factors it depends on (implementation details or number of qubits etc.)?&lt;/p&gt;&#xA;" OwnerUserId="2559" LastEditorUserId="26" LastEditDate="2018-07-03T18:23:50.960" LastActivityDate="2018-07-03T18:23:50.960" Title="How many operations can a quantum computer perform per second?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-computer&gt;&lt;complexity-theory&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="2403" PostTypeId="1" CreationDate="2018-06-20T09:50:18.070" Score="7" ViewCount="210" Body="&lt;p&gt;The governments, big companies (&lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_quantum_processors&quot; rel=&quot;nofollow noreferrer&quot;&gt;list of quantum processors&lt;/a&gt;) and smaller ones are in the competition of building bigger and bigger quantum computers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Not unexpectedly the number of qubits of those quantum computers seem to double every year but those qubits are &lt;em&gt;noisy qubits&lt;/em&gt;.  What is a more meaningful metric is the number of error corrected qubits and some sources say that we need 100 noisy qubits to simulate one error corrected qubit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Besides the error corrected qubits there are other substantial hurdles that need to be passed to come to a universal quantum computer that can do something useful (see &lt;a href=&quot;http://algassert.com/post/1800&quot; rel=&quot;nofollow noreferrer&quot;&gt;Why Will Quantum Computers be Slow?&lt;/a&gt;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I read quotes like (source &lt;a href=&quot;https://www.wired.com/story/google-alibaba-spar-over-timeline-for-quantum-supremacy/&quot; rel=&quot;nofollow noreferrer&quot;&gt;GOOGLE, ALIBABA SPAR OVER TIMELINE FOR 'QUANTUM SUPREMACY&lt;/a&gt;):&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Intel CTO Mike Mayberry told WIRED this week that he sees broad&#xA;  commercialization of the technology as a 10-year project. &lt;a href=&quot;https://www.nextbigfuture.com/2018/03/in-five-years-quantum-computing-will-be-mainstream.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;IBM has said&#xA;  it can be “mainstream” in five&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;So when might we actually expect the first universal quantum computer that can do something useful outside the academic world ?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;With &lt;em&gt;useful&lt;/em&gt; I mean that brings real value (e.g. commercial application) and that cannot be done with same efficiency using existing classical computing algorithms/models.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I have deliberately mentioned &lt;em&gt;outside the academic world&lt;/em&gt; as obviously currently pure by their existence the current quantum computers are useful for the theoretical computer scientist, quantum physicist, quantum specialist, ...  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;What currently interests me more is the usefulness of the outcome of this quantum algorithm for real world problems (e.g. cracking an actual key, designing a new molecule with specific characteristics, finding the optimal solution of an actual problem, recognizing real images, ....)&lt;/p&gt;&#xA;" OwnerUserId="2529" LastEditorUserId="2529" LastEditDate="2018-06-20T11:31:27.560" LastActivityDate="2018-06-21T22:09:26.377" Title="When can we expect the first (universal) quantum computer being able to do something useful outside the academic world?" Tags="&lt;quantum-computer&gt;" AnswerCount="3" CommentCount="10" FavoriteCount="1" ClosedDate="2018-06-22T11:01:37.440" />
  <row Id="2404" PostTypeId="2" ParentId="2402" CreationDate="2018-06-20T10:00:34.323" Score="10" Body="&lt;p&gt;Giving an estimate for a generic quantum chip is impossible as there is no standard implementation for the moment.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Nevertheless, it is possible to estimate this number for specific quantum chip, with the information provided online. I found information on the IBM Q chips, so here is the answer for the &lt;a href=&quot;https://github.com/QISKit/qiskit-backend-information/tree/master/backends/tenerife/V1&quot; rel=&quot;nofollow noreferrer&quot;&gt;IBM Q 5 Tenerife chip&lt;/a&gt;. In the link you will find information on the chip, but nothing about timings. You need to access the &lt;a href=&quot;https://github.com/QISKit/qiskit-backend-information/blob/master/backends/tenerife/V1/version_log.md&quot; rel=&quot;nofollow noreferrer&quot;&gt;version log&lt;/a&gt; of the chip (via a link given on the &lt;a href=&quot;https://github.com/QISKit/qiskit-backend-information/tree/master/backends/tenerife/V1&quot; rel=&quot;nofollow noreferrer&quot;&gt;IBM Q 5 Tenerife chips&lt;/a&gt; page). In this version log, go to a &quot;Gate Specification&quot; section, you will have the following information (more explanation below):&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;A time for &quot;GD&quot;, which is 60ns in the link above.&lt;/li&gt;&#xA;&lt;li&gt;Multiple times for &quot;GF&quot; (let's take 200ns for the computations below).&lt;/li&gt;&#xA;&lt;li&gt;A &quot;buffer time&quot;, which is 10ns in the link above.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;But what do &quot;GD&quot;, &quot;GF&quot; or &quot;buffer time&quot; represent? They are base &lt;strong&gt;physical&lt;/strong&gt; operations, i.e. the operations that will be performed on the physical qubit. These physical operation are then used to implement some base quantum gates. You can find the decomposition of the 4 base quantum gates of the IBM Q backends in terms of these physical operations on the &lt;a href=&quot;https://github.com/QISKit/qiskit-backend-information/tree/master/backends/tenerife/V1&quot; rel=&quot;nofollow noreferrer&quot;&gt;IBM Q 5 Tenerife chips&lt;/a&gt; page. I copied the illustration below.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/UMN6b.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/UMN6b.png&quot; alt=&quot;Base operation decomposition&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Along with &quot;GD&quot; and &quot;GF&quot;, there is a physical &quot;FC&quot; operation that does not appears in the timings. This is because this &quot;FC&quot; operation just &quot;changes the frame of the following pulses&quot; (citing Jay Gambeta from a conversation on the QISKit Slack), and so the &quot;FC&quot; operation has a cost (time of application) of 0.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &quot;buffer time&quot; is just a pause time between each physical operation application.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So finally we can compute the time needed to apply each base gate on this specific backend:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;U1&lt;/strong&gt;: 0ns&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;U2&lt;/strong&gt;: 60ns = 0ns + 60ns + 0ns&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;U3&lt;/strong&gt;: 120ns = 0ns + 60ns + 0ns + 60ns + 0ns&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;CX&lt;/strong&gt;: 520ns = 0ns + 60ns + 200ns + 60ns + 200ns&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;From these timings, you can deduce the number of operations per second that the ibmqx4 backend can perform.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Taking 200ns per operation as a crude approximation of the mean timing for an operation, you end up with 5 000 000 operations per seconds.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can find the data for other backends on the &lt;a href=&quot;https://github.com/QISKit/qiskit-backend-information&quot; rel=&quot;nofollow noreferrer&quot;&gt;qiskit-backend-information GitHub repository&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1386" LastEditorUserId="1386" LastEditDate="2018-06-21T07:40:59.380" LastActivityDate="2018-06-21T07:40:59.380" CommentCount="3" />
  <row Id="2405" PostTypeId="2" ParentId="2402" CreationDate="2018-06-20T10:02:43.513" Score="6" Body="&lt;p&gt;There is an important difference between &lt;em&gt;physical&lt;/em&gt; operations and &lt;em&gt;logical&lt;/em&gt; operations.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Physical operations that will be slightly imperfect, performed on qubits that are also imperfect. The rate at which these can be performed depends on what physical system is being used to realize the qubits. For example, superconducting qubits can perform two qubit gates (the slowest ones) in a time on the order of 100 ns (see &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2402/how-many-operations-can-a-quantum-computer-perform-per-second/2404#2404&quot;&gt;Nelimee's answer&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;By combining many physical qubits, and doing a process with lots of physical operations, we can build &lt;em&gt;logical qubits&lt;/em&gt;. By doing error correction, these qubits and the operations done upon them can be made arbitrarily accurate. These are the kind of operations that are required to implement quantum algorithms.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are currently too many unknowns to give you a clock rate of logical operations. Especially since even proof-of-principle logical qubits have not yet been built (not with quantum error correction codes, at least). It depends on how imperfect the physical qubits and operations are, and so how much we need to do to clean everything up. It depends on what kind of error correcting code we use, which in turn depends on the instruction set of our quantum processors (i.e., which pairs of qubits can have a two qubit gate applied on them directly). And this depends on how much noise we are willing to have, because better architectures often come at the cost of noise. So there are a lot of interdependencies, and much to be resolved.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-06-20T10:08:19.067" LastActivityDate="2018-06-20T10:08:19.067" CommentCount="0" />
  <row Id="2406" PostTypeId="1" AcceptedAnswerId="2421" CreationDate="2018-06-20T11:30:53.763" Score="5" ViewCount="98" Body="&lt;p&gt;For a Hilbert space $\mathcal{H}_A$, I have seen the phrase &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;density matrices acting on $\mathcal{H}_A$&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;multiple times, e.g. &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_channel#Schr%C3%B6dinger_picture&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is clear to me that if $\mathcal{H}_A$ has finite Hilbert dimension $n$, then this makes sense mathematically, because a density matrix $\rho$ can be written as $\rho \in \mathbb{C}^{n \times n}$ and elements $\phi$ of $\mathcal{H}_A$ can be written as $\phi \in \mathbb{C}^n$, so I can write down $\rho \phi \in \mathbb{C}^n$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, it is unclear what this means? The density matrix $\rho$ describes a (possibly mixed) state of a quantum system. But I can also interpret $\phi$ as a single state vector, describing a quantum system in a pure state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, what does $\rho\phi$ refer to (where $\rho \in \mathbb{C}^{n \times n}$ is a density matrix, and $\phi \in \mathbb{C}^n$ is an element of $\mathcal{H}_A$)? Can I interpret it? How can a density matrix (i.e., the representation of a state) act on states (on single state vectors)? &lt;strong&gt;Why do we interpret density matrices (which represent states) as operators?&lt;/strong&gt;&lt;/p&gt;&#xA;" OwnerUserId="2444" LastEditorUserId="2444" LastEditDate="2018-06-21T14:42:43.030" LastActivityDate="2018-06-21T14:42:43.030" Title="How do density matrices act on $\mathcal{H}_A$?" Tags="&lt;density-matrix&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="2407" PostTypeId="1" AcceptedAnswerId="2426" CreationDate="2018-06-20T15:14:25.017" Score="7" ViewCount="58" Body="&lt;p&gt;Theorem 2 of [1] states:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Suppose $C$ is an additive self-orthogonal sub-code of $\textrm{GF}(4)^n$, containing $2^{n-k}$ vectors, such that there are no vectors of weight $&amp;lt;d$ in $C^\perp/C$. Then any eigenspace of $\phi^{-1}(C)$ is an additive quantum-error-correcting code with parameters $[[n, k, d]]$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;where here $\phi: \mathbb{Z}_2^{2n} \rightarrow \textrm{GF}(4)^n$ is the map between the binary representation of $n$-fold Pauli operators and their associated codeword, and $C$ is &lt;em&gt;self-orthogonal&lt;/em&gt; if $C \subseteq C^\perp$ where $C^\perp$ is the dual of $C$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This tells us that each additive self-orthogonal $\textrm{GF}(4)^n$ classical code represents a $[[n, k, d]]$ quantum code.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is whether the reverse is also true, that is: &lt;strong&gt;is every $[[n, k, d]]$ quantum code represented by an additive self-orthogonal $\textrm{GF}(4)^n$ classical code?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Or equivalently: &lt;strong&gt;Are there any $[[n, k, d]]$ quantum codes that are not represented by an additive self-orthogonal $\textrm{GF}(4)^n$ classical code?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[1]: Calderbank, A. Robert, et al. &quot;Quantum error correction via codes over GF (4).&quot; IEEE Transactions on Information Theory 44.4 (1998): 1369-1387.&lt;/p&gt;&#xA;" OwnerUserId="391" LastEditorUserId="391" LastEditDate="2018-06-21T12:21:19.770" LastActivityDate="2018-06-21T13:51:10.233" Title="Are all $[[n, k, d]]$ quantum codes equivalent to additive self-orthogonal $GF(4)^n$ classical codes?" Tags="&lt;quantum-error-correction&gt;&lt;stabilizer-code&gt;" AnswerCount="1" CommentCount="4" />
  <row Id="2408" PostTypeId="1" AcceptedAnswerId="2409" CreationDate="2018-06-20T23:08:14.950" Score="4" ViewCount="123" Body="&lt;p&gt;Reproduced from Exercise 2.1 of Nielsen &amp;amp; Chuang's &lt;em&gt;Quantum Computation and Quantum Information (10th Anniversary Edition)&lt;/em&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Show that $(1, −1)$, $(1, 2)$ and $(2, 1)$ are linearly dependent.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Note: This question is part of a series attempting to provide worked solutions to the exercises provided in the above book. For a list of all exercises added so far, see &lt;a href=&quot;https://quantumcomputing.stackexchange.com/tags/nielsen-and-chuang/info&quot;&gt;here&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;" OwnerUserId="391" LastEditorUserId="391" LastEditDate="2018-06-26T09:10:57.327" LastActivityDate="2018-06-26T09:10:57.327" Title="Nielsen &amp; Chuang Exercise 2.1 - &quot;Linear dependence: example&quot;" Tags="&lt;quantum-information&gt;&lt;nielsen-and-chuang&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="1" />
  <row Id="2409" PostTypeId="2" ParentId="2408" CreationDate="2018-06-20T23:08:14.950" Score="4" Body="&lt;p&gt;A set of $n$ vectors $V = \{\vec{v}_1, \ldots, \vec{v}_n\}$ are linearly dependant if there exists a set of scalars $a_1, \ldots, a_n$ (which are not all zero) such that&#xA;$$&#xA;\sum_{i=1}^n a_i\vec{v_i} = \vec{0}&#xA;$$&#xA;where $\vec{0}$ is the all-zero vector.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Writing $V$ as a matrix with vectors as columns, this is equivalent to finding a solution to the matrix equation&#xA;$$&#xA;V\vec{a} = \vec{0}, \quad\textrm{where}\quad \vec{a} = \begin{pmatrix} a_1\\ \vdots \\ a_n \end{pmatrix}.&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In our case, we have&#xA;$$&#xA;V = \begin{pmatrix}&#xA;1 &amp;amp; 1 &amp;amp; 2 \\&#xA;-1 &amp;amp; 2 &amp;amp; 1&#xA;\end{pmatrix},&#xA;$$&#xA;with a solution to $V\vec{a} = \vec{0}$ provided by &#xA;$$&#xA;\vec{a} = \begin{pmatrix} 1\\ 1 \\ -1 \end{pmatrix},&#xA;$$&#xA;hence showing linear dependance.&lt;/p&gt;&#xA;" OwnerUserId="391" LastActivityDate="2018-06-20T23:08:14.950" CommentCount="0" />
  <row Id="2410" PostTypeId="1" AcceptedAnswerId="2412" CreationDate="2018-06-21T02:59:10.223" Score="4" ViewCount="40" Body="&lt;p&gt;I have seen qubits, qutrits &amp;amp; entangled bits (e-bits) a decent amount. I have also seen qunits/qudits for n-th level qubits. What I am trying to wrap my head around is the differences between n-th level e-bits vs n-th level qunits. What are the similarities? Differences? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;What generalizations exist about n-th level e-bits / qunits?&lt;/strong&gt;&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="26" LastEditDate="2018-06-21T08:14:26.943" LastActivityDate="2018-06-21T08:14:26.943" Title="Generalization of n-th level entangled system" Tags="&lt;qubit&gt;&lt;quantum-entanglement&gt;&lt;qudit&gt;&lt;qutrit&gt;" AnswerCount="1" CommentCount="2" />
  <row Id="2411" PostTypeId="2" ParentId="2406" CreationDate="2018-06-21T03:18:45.127" Score="0" Body="&lt;p&gt;By &quot;acting of $\mathcal{H}_A$&quot; I believe you mean &quot;acting on $\mathcal{H}_A$&quot;, which is what is written in the section you provided a link to.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What it means is &quot;acting on a state in $\mathcal{H}_A$&quot;.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;I do not know what it means for a state to act on $\phi$.&quot;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;You defined $\phi$ as a state. States do not act on states. Operators (such as $\rho$) act on states. The section you provided a link to, does not mention &quot;acting on a state $\phi$&quot; at any point.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-06-21T03:18:45.127" CommentCount="2" />
  <row Id="2412" PostTypeId="2" ParentId="2410" CreationDate="2018-06-21T07:00:10.563" Score="1" Body="&lt;p&gt;&lt;sup&gt;&lt;strong&gt;Disclaimer&lt;/strong&gt;: Since you haven't stated the source from where you got those terms, I will mention the most &lt;em&gt;obvious&lt;/em&gt; definitions for those, which occur &lt;em&gt;to me&lt;/em&gt; - simply looking at the names.&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;strong&gt;Qunit&lt;/strong&gt;&quot; refers to any quantum system whose state lies in a complex &lt;a href=&quot;https://en.wikipedia.org/wiki/Vector_space&quot; rel=&quot;nofollow noreferrer&quot;&gt;vector space&lt;/a&gt; whose &lt;a href=&quot;https://en.wikipedia.org/wiki/Dimension_(vector_space)&quot; rel=&quot;nofollow noreferrer&quot;&gt;dimension&lt;/a&gt; is &lt;em&gt;any&lt;/em&gt; natural number $n$. Example of qunits are qubits, for which $n=2$ and qutrits for which $n=3$. Also check this for other less commonly used terms: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2100/do-any-specific-types-of-qudits-other-than-qubits-and-qutrits-have-a-name/2102&quot;&gt;Do any specific types of qudits other than qubits and qutrits have a name?&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Next, remember that a system of two qu&lt;strong&gt;bits&lt;/strong&gt; will lie in a $2\times 2$-dimensional vector space i.e. $\Bbb C^2\times \Bbb C^2$. A system of three qubits will lie in a $2\times 2 \times 2$-dimensional vector space $\Bbb C^2\times \Bbb C^2\times \Bbb C^2$ and so on. By &quot;$n$-dimensional&quot; e-&lt;strong&gt;bits&lt;/strong&gt; they're referring to the dimension of the vector space again. As for the &quot;e-&lt;strong&gt;bit&lt;/strong&gt;&quot; part, that's simple. That is, the state of the system of qubits is basically not separable into individual qubit states lying in $\Bbb C^2$ each (i.e. the qubits are &lt;em&gt;entangled&lt;/em&gt;). Check out the answers in: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2263/how-do-i-show-that-a-two-qubit-state-is-an-entangled-state&quot;&gt;How do I show that a two-qubit state is an entangled state?&lt;/a&gt; &lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-06-21T07:00:10.563" CommentCount="2" />
  <row Id="2413" PostTypeId="1" AcceptedAnswerId="2418" CreationDate="2018-06-21T08:03:09.517" Score="8" ViewCount="558" Body="&lt;p&gt;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2263/&quot;&gt;&quot;How do I show that a two-qubit state is an entangled state?&quot;&lt;/a&gt; includes &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2266/2645&quot;&gt;an answer&lt;/a&gt; which references the &lt;a href=&quot;https://en.wikipedia.org/wiki/Peres%E2%80%93Horodecki_criterion&quot; rel=&quot;nofollow noreferrer&quot;&gt;Peres–Horodecki criterion&lt;/a&gt;. This works for $2\times 2$ and $2\times3$ dimensional cases; however, in higher dimensions, it is &quot;inconclusive.&quot; It is suggested to supplement with more advanced tests, such as those based on &lt;a href=&quot;https://en.wikipedia.org/wiki/Entanglement_witness&quot; rel=&quot;nofollow noreferrer&quot;&gt;entanglement witness&lt;/a&gt;. How would this be done? Are there alternative ways to go about this?&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="15" LastEditDate="2018-06-21T12:02:02.683" LastActivityDate="2018-06-21T12:02:02.683" Title="How to show that an n-level system is entangled?" Tags="&lt;quantum-entanglement&gt;&lt;qubit-state&gt;&lt;qudit&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="2414" PostTypeId="1" CreationDate="2018-06-21T08:03:42.980" Score="16" ViewCount="321" Body="&lt;p&gt;It seems to be a widely held belief within the scientific community that it is possible to do &quot;universal, fault-tolerant&quot; quantum computation using optical means by following what is called  &quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_optical_quantum_computing&quot; rel=&quot;nofollow noreferrer&quot;&gt;linear optical quantum computing (LOQC)&lt;/a&gt;&quot; pioneered by KLM (Knill, Laflamme, Milburn). However, LOQC uses only modes of light that contain either zero or one photon, not more.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Continuous modes of light contain, by definition, much more than one photon. The paper &lt;strong&gt;Probabilistic Fault-Tolerant Universal Quantum Computation and Sampling Problems in Continuous Variables&lt;/strong&gt; Douce &lt;em&gt;et al.&lt;/em&gt; (2018) &lt;a href=&quot;https://arxiv.org/abs/1806.06618&quot; rel=&quot;nofollow noreferrer&quot;&gt;[quant-ph arXiv:1806.06618v1]&lt;/a&gt; claims &quot;probabilistic universal fault-tolerant&quot; quantum computation can also be done using continuous modes of squeezed light. The paper goes even further and claims it is possible to demonstrate quantum supremacy using continuous modes.  In fact, the paper's abstract says:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Furthermore, we show that this model can be adapted to yield sampling&#xA;  problems that cannot be simulated efficiently with a classical&#xA;  computer, unless the polynomial hierarchy collapses.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;A quantum computing startup called &lt;a href=&quot;https://www.xanadu.ai/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Xanadu&lt;/a&gt; that has some credibility because it has written several papers with Seth Lloyd, seems to be claiming that they too will ultimately be able to do quantum computation with continuous modes of light, and perform some tasks better than a classical computer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And yet, what they are doing seems to me to be analog computing (is fault tolerant error correction possible for analog computing?). Also, they use squeezing and displacement operations. Such operations do not conserve energy (squeezing or displacing a mode can change its energy), so such operations seem to require exchanges of macroscopic amounts (not quantized amounts) of energy with an external environment, which probably can introduce a lot of noise into the qc. Furthermore, squeezing has only been achieved in the lab for limited small values, and a claim of universality might require arbitrary large squeezing as a resource.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, my question is, are these people being too optimistic or not? What kind of computing can be done realistically in the lab with continuous modes of light?&lt;/p&gt;&#xA;" OwnerUserId="1974" LastEditorUserId="419" LastEditDate="2018-08-06T08:04:34.010" LastActivityDate="2018-08-06T08:04:34.010" Title="Is &quot;probabilitistic,universal, fault tolerant quantum computation&quot; possible with continuous values?" Tags="&lt;experimental-results&gt;&lt;optical-quantum-computing&gt;&lt;continuous-variable&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="2" />
  <row Id="2415" PostTypeId="1" AcceptedAnswerId="2417" CreationDate="2018-06-21T08:15:44.593" Score="3" ViewCount="271" Body="&lt;p&gt;What is the difference between 3 qubits, 2 qutrits and a 6th level qunit? Are they equivalent? Why / why not?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Can 6 classical bits be super-densely coded into each?&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-07-02T15:22:29.377" LastActivityDate="2018-07-02T15:22:29.377" Title="Difference between 3 qubits, 2 qutrits &amp; 1 six level qunit" Tags="&lt;quantum-entanglement&gt;&lt;qudit&gt;&lt;qutrit&gt;&lt;matrix-representation&gt;" AnswerCount="2" CommentCount="2" />
  <row Id="2416" PostTypeId="2" ParentId="2415" CreationDate="2018-06-21T08:38:13.027" Score="2" Body="&lt;p&gt;They are not equivalent. It can be seen by the fact that the system of $3$ qubits acts on a $8$ dimensional Hilbert space, the 2 qutrit system acts on a $9$ dimensional Hilbert space, and the 6 level qunit acts on a $6$ dimensional Hilbert space. Consequently, the nature of the states defined by each of the quantum systems is different. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This dimension argument comes from the fact that a k-level n-qunit system acts on a state space of dimension $k^n$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For the superdense-coding, I am aware that Bell pairs are used in order to obtain the desired coding, and as you do not consider such entangled qubits, I am not sure to answer such question.&lt;/p&gt;&#xA;" OwnerUserId="2371" LastEditorUserId="26" LastEditDate="2018-06-21T09:08:22.523" LastActivityDate="2018-06-21T09:08:22.523" CommentCount="4" />
  <row Id="2417" PostTypeId="2" ParentId="2415" CreationDate="2018-06-21T09:15:59.690" Score="5" Body="&lt;p&gt;The Hilbert space dimension of $n$ qudits is $d^n$, where $d$ is the dimension of the qudit ($d=2$ for qubit, $d=3$ for qutrit, etc). So three qubits have an $8$ dimensional space, two qutrits have a $9$ dimensional space, and one $d=6$ qudit has a six dimensional space. As such, we cannot regard them as equivalent.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I guess you meant to compare situations with equal total Hilbert space dimension. Such as a comparing a pair of qubits with a $d=4$ system. In this case, there is mathematically no distinction. You could choose to relabel the basis states $|00\rangle$, $|01\rangle$, $|10\rangle$ and $|11\rangle$ as the qudit basis states $|0\rangle$, $|1\rangle$, $|2\rangle$ and $|3\rangle$. Then any qudit operations defined with the qudit basis could be equivalently defined with the qubits, and vice-versa. You could also use other mappings between basis states, this was just an example.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We could also use a subspace of a larger space to simulate a smaller one. For example, suppose you want to simulate a spin-$1$ particle, which is a 3 level system. You could do this using a pair of qubits (a four level system) and identifying three basis states of the former with three of the latter (such as $|-1\rangle$, $|0\rangle$ and $|1\rangle$ with $|00\rangle$, $|01\rangle$ and $|10\rangle$, for example). As long as you implement your spin-$1$ operations correctly, you'll always avoid the $|11\rangle$ state, and your two qubits effectively become a qutrit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You might also be interested in my answer to the question &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1602/what-is-the-most-economical-and-preferred-basis-for-the-qudit/1673#1673&quot;&gt;What is the most economical and preferred basis for the qudit?&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-06-21T10:01:49.117" LastActivityDate="2018-06-21T10:01:49.117" CommentCount="1" />
  <row Id="2418" PostTypeId="2" ParentId="2413" CreationDate="2018-06-21T09:33:30.957" Score="4" Body="&lt;p&gt;Determining whether a given state is entangled or not is NP hard. So if you include all possible types on entanglement, including mixed states and multipartite entanglement, there is never going to be an elegant solution. Techniques are therefore defined for specific cases, where the structure of the problem can be used to create an efficient solution.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, if a state is bipartite and pure, you can simply take the reduced density matrix of one party and see if it is mixed. This could be done by computing the Von Neumann entropy to see if it is non-zero (this quantity provides a measure of entanglement in this case).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This approach would work for any pure state of two particles, whatever their dimension. It can also be used to calculate entanglement for any bipartition. For example, if you had $n$ particles, you could take the first $m$ to be one party, and the remaining $n-m$ to be another, and use this technique to see if any entanglement exists between these groups.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For other cases, the approach you take will depend on the kind of entanglement you are looking for.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-06-21T09:33:30.957" CommentCount="0" />
  <row Id="2419" PostTypeId="2" ParentId="2413" CreationDate="2018-06-21T09:37:03.623" Score="4" Body="&lt;p&gt;As suggested in your Wiki link, the way to  detect an entangled state is to find a hyperplane that separates it from the convex set of separable states. This hyperplane represents  what is called an entanglement witness. The PPT criterion that you mentioned is one such witness. Now to construct  entanglement witnesses for higher dimensional systems is not easy, but it can be done algorithmically by solving a hierarchy semi-definite programs (SDP) [1]. This hierarchy is complete, as every entangled state will eventually be detected. But it is computationally inefficient if the entangled state is very close to the convex set of separable states. It is infact known that detecting entanglement is NP-hard[2].&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[1]Doherty, Andrew C., Pablo A. Parrilo, and Federico M. Spedalieri. &quot;Complete family of separability criteria.&quot; Physical Review A69.2 (2004): 022308&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[2]Gharibian, Sevag. &quot;Strong NP-hardness of the quantum separability problem.&quot; arXiv preprint arXiv:0810.4507 (2008).&lt;/p&gt;&#xA;" OwnerUserId="2663" LastActivityDate="2018-06-21T09:37:03.623" CommentCount="0" />
  <row Id="2420" PostTypeId="1" AcceptedAnswerId="2433" CreationDate="2018-06-21T09:58:57.613" Score="4" ViewCount="99" Body="&lt;p&gt;&lt;a href=&quot;https://www.wired.com/story/quantum-internet-is-13-years-away-wait-whats-quantum-internet&quot; rel=&quot;nofollow noreferrer&quot;&gt;This article&lt;/a&gt; from 2017 predicts the quantum internet by 2030. What are the biggest bottlenecks in the realization of a global quantum network (ie quantum internet)?&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-06-21T18:19:52.887" LastActivityDate="2018-06-22T20:13:32.060" Title="How could a global quantum network be realized?" Tags="&lt;quantum-information&gt;&lt;quantum-networks&gt;&lt;quantum-communication&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2421" PostTypeId="2" ParentId="2406" CreationDate="2018-06-21T12:37:34.457" Score="6" Body="&lt;p&gt;It is common that one refers to a density matrix (or, equivalently, a density operator) $\rho$ as &lt;em&gt;acting on&lt;/em&gt; a particular space $\mathcal{H}$. This serves to establish the &quot;type&quot; of $\rho$ in computer science parlance. In particular, when there are multiple spaces under consideration, it may be helpful for a reader to know that $\rho$ corresponds specifically to whatever abstract physical system is described by the space $\mathcal{H}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Referring to $\rho$ as acting on a space $\mathcal{H}$ also makes perfect sense, as the question points out, because $\rho$ can be viewed as a linear map from $\mathcal{H}$ to itself. The properties of $\rho$ that relate to its action as a linear mapping of this form are important and say a lot about the state. For example, the eigenvalues of $\rho$ describe the randomness or uncertainty inherent to that state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, this does not mean that if $\phi\in\mathcal{H}$ is a unit vector that describes a pure state, then $\rho\phi$ should have an interpretation. Such a vector might show up in a proof or calculation -- for example, the quantity $\langle \phi | \rho | \phi\rangle$, which is the inner product between $\phi$ and $\rho\phi$, is a commonly encountered quantity known as the &lt;em&gt;fidelity&lt;/em&gt; (or &lt;em&gt;squared fidelity&lt;/em&gt;) between the states represented by $\rho$ and $\phi$ -- but in my view the vector $\rho\phi$ is just a vector and does not have a natural or fundamental physical interpretation.&lt;/p&gt;&#xA;" OwnerUserId="1764" LastActivityDate="2018-06-21T12:37:34.457" CommentCount="0" />
  <row Id="2422" PostTypeId="2" ParentId="2381" CreationDate="2018-06-21T12:59:23.247" Score="0" Body="&lt;p&gt;All we observe in quantum technologies (photons, atoms, etc) are bits (either a 0 or a 1). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;At the essence, no one really knows what a quantum bit is.  Some people say it's an object that is &quot;both&quot; 0 and 1; others say it's about things to do with parallel universes; but physicists don't know what it is, and have come up with interpretations that are not proven.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The reason for this &quot;confusion&quot; is due to two factors:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(1) One can get remarkable tasks accomplished which cannot be explained by thinking of the quantum technology in terms of normal bits.  So there must be some extra element involved which we label &quot;quantum&quot; bit.  But here's the critical piece: this extra &quot;quantum&quot; element cannot be directly detected; all we observe are normal bits when we &quot;look&quot; at the system.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(2) One way to &quot;see&quot; this extra &quot;quantum&quot; stuff is through maths.  Hence a valid description of a qubit is mathematical, and every translation of that is an interpretation that has not yet been proven.    &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In summary, no one knows what quantum bits are.  We know there's something more than bits in quantum technologies, which we label as &quot;quantum&quot; bit. And so far, the only valid (yet unsatisfying) description is mathematical.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Hope that helps.  &lt;/p&gt;&#xA;" OwnerUserId="2084" LastActivityDate="2018-06-21T12:59:23.247" CommentCount="0" />
  <row Id="2423" PostTypeId="1" AcceptedAnswerId="2424" CreationDate="2018-06-21T13:16:32.857" Score="2" ViewCount="165" Body="&lt;p&gt;Reproduced from Exercise 2.2 of Nielsen &amp;amp; Chuang's &lt;em&gt;Quantum Computation and Quantum Information (10th Anniversary Edition)&lt;/em&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Suppose $V$ is a vector space with basis vectors $|0\rangle$ and $|1\rangle$, and $A$ is a linear operator from $V$ to $V$ such that $A|0\rangle = |1\rangle$ and $A|1\rangle = |0\rangle$. Give a matrix representation for $A$, with respect to the input basis $|0\rangle, |1\rangle$, and the output basis $|0\rangle, |1\rangle$. Find input and output bases which give rise to a different matrix representation of $A$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Note: This question is part of a series attempting to provide worked solutions to the exercises provided in the above book. For a list of all exercises added so far, see &lt;a href=&quot;https://quantumcomputing.stackexchange.com/tags/nielsen-and-chuang/info&quot;&gt;here&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;" OwnerUserId="391" LastEditorUserId="391" LastEditDate="2018-06-26T09:11:46.983" LastActivityDate="2018-06-26T09:11:46.983" Title="Nielsen &amp; Chuang Exercise 2.2 - “Matrix representations: example”" Tags="&lt;quantum-gate&gt;&lt;matrix-representation&gt;&lt;nielsen-and-chuang&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="3" />
  <row Id="2424" PostTypeId="2" ParentId="2423" CreationDate="2018-06-21T13:16:32.857" Score="4" Body="&lt;p&gt;Immediately, we can see that&#xA;$$&#xA;A = |1\rangle\langle0| + |0\rangle\langle1|.&#xA;$$&#xA;If the input and out bases are $\{|0\rangle, |1\rangle\}$, then&#xA;$$&#xA;|0\rangle = \begin{pmatrix} 1 \\ 0 \end{pmatrix}, \quad |1\rangle = \begin{pmatrix} 0 \\ 1 \end{pmatrix} \quad\textrm{and}\quad \langle0| = \begin{pmatrix} 1 &amp;amp; 0 \end{pmatrix}, \quad \langle1| = \begin{pmatrix} 0 &amp;amp; 1 \end{pmatrix},&#xA;$$&#xA;so we can write the first equation as&#xA;$$&#xA;\begin{align}&#xA;A &amp;amp;= \begin{pmatrix} 1 \\ 0 \end{pmatrix} \otimes \begin{pmatrix} 0 &amp;amp; 1 \end{pmatrix}  + \begin{pmatrix} 0 \\ 1 \end{pmatrix} \otimes \begin{pmatrix} 1 &amp;amp; 0 \end{pmatrix} \\&#xA;&amp;amp;= \begin{pmatrix} 0 &amp;amp; 1 \\ 0 &amp;amp; 0 \end{pmatrix} + \begin{pmatrix} 0 &amp;amp; 0 \\ 1 &amp;amp; 0 \end{pmatrix}\\&#xA;&amp;amp;= \begin{pmatrix} 0 &amp;amp; 1 \\ 1 &amp;amp; 0 \end{pmatrix}&#xA;\end{align}&#xA;$$&#xA;to solve the first question. Note that in this case, $A$ is the equal to the &lt;em&gt;bitflip&lt;/em&gt; or &lt;em&gt;Pauli $X$&lt;/em&gt; operation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Secondly, for fun, let us choose to write $A$ in input basis $\{|+\rangle, |-\rangle\}$, where&#xA;$$&#xA;|+\rangle = \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle) \quad\textrm{and}\quad |-\rangle = \frac{1}{\sqrt{2}}(|0\rangle - |1\rangle)&#xA;$$&#xA;and output basis $\{|L\rangle, |R\rangle\}$, where&#xA;$$&#xA;|L\rangle = \frac{1}{\sqrt{2}}(|0\rangle + i|1\rangle) \quad\textrm{and}\quad |R\rangle = \frac{1}{\sqrt{2}}(|0\rangle - i|1\rangle).&#xA;$$&#xA;Rewriting our original $\{|0\rangle, |1\rangle\}$ bases vectors in terms of the above bases, we find&#xA;$$&#xA;\begin{align}&#xA;|0\rangle &amp;amp;= \frac{1}{\sqrt{2}}(|+\rangle + |-\rangle) = \frac{1}{\sqrt{2}}(|L\rangle + |R\rangle) \quad \textrm{and}\\&#xA;|1\rangle &amp;amp;= \frac{1}{\sqrt{2}}(|+\rangle - |-\rangle) = \frac{i}{\sqrt{2}}(|R\rangle - |L\rangle),&#xA;\end{align}&#xA;$$&#xA;with $\langle0| = (|0\rangle)^\dagger$ and $\langle1| = (|1\rangle)^\dagger$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;From this we can rewrite $A$ as&#xA;$$&#xA;\begin{align}&#xA;A &amp;amp;= \frac{i}{2}(|R\rangle - |L\rangle)(\langle+| + \langle-|) + \frac{1}{2}(|L\rangle + |R\rangle)(\langle+| - \langle-|) \\&#xA;&amp;amp;= \frac{1}{2}\big[ (1+i)|R\rangle\langle+| + (1-i)|L\rangle\langle+| + (-1+i)|R\rangle\langle-| + (-1-i)|L\rangle\langle-|\big] \\&#xA;&amp;amp;= \frac{1+i}{2}(|R\rangle\langle+| - i|L\rangle\langle+| + i|R\rangle\langle-| - |L\rangle\langle-|)&#xA;\end{align}&#xA;$$&#xA;To get $A$ in the desired matrix form, we then set&#xA;$$&#xA;|L\rangle = \begin{pmatrix} 1 \\ 0 \end{pmatrix}, \quad |R\rangle = \begin{pmatrix} 0 \\ 1 \end{pmatrix} \quad\textrm{and}\quad \langle+| = \begin{pmatrix} 1 &amp;amp; 0 \end{pmatrix}, \quad \langle-| = \begin{pmatrix} 0 &amp;amp; 1 \end{pmatrix},&#xA;$$&#xA;such that&#xA;$$&#xA;A = \frac{1+i}{2} \begin{pmatrix} -i &amp;amp; -1 \\ 1 &amp;amp; i \end{pmatrix}.&#xA;$$&lt;/p&gt;&#xA;" OwnerUserId="391" LastActivityDate="2018-06-21T13:16:32.857" CommentCount="2" />
  <row Id="2425" PostTypeId="1" CreationDate="2018-06-21T13:46:38.737" Score="6" ViewCount="57" Body="&lt;p&gt;In Ref. [1] absolutely maximally entangled (AME) states are defined as:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;An $\textrm{AME}(n,d)$ state (absolutely maximally entangled state) of $n$ qudits of dimension $d$, $|\psi\rangle \in \mathbb{C}^{\otimes n}_d$, is a pure state for which every bipartition of the system into the sets $B$ and $A$,&#xA;  with $m = |B| \leq |A| = n − m$, is strictly maximally entangled such that &#xA;  $$&#xA;S(\rho_B) = m \log_2 d.&#xA;$$&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;As the name would have you believe, &lt;strong&gt;does this mean that an $\textrm{AME}(n,d)$ state is maximally entangled across &lt;em&gt;all&lt;/em&gt; entanglement monotones (for fixed $n$ and $d$)&lt;/strong&gt;?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[1]: Helwig, Wolfram, et al. &lt;em&gt;&quot;Absolute maximal entanglement and quantum secret sharing.&quot;&lt;/em&gt; Physical Review A 86.5 (2012): 052335.&lt;/p&gt;&#xA;" OwnerUserId="391" LastActivityDate="2018-06-25T15:38:18.587" Title="Are Absolutely Maximally Entangled states maximally entangled under all entanglement monotones?" Tags="&lt;quantum-entanglement&gt;&lt;quantum-state&gt;" AnswerCount="1" CommentCount="1" FavoriteCount="2" />
  <row Id="2426" PostTypeId="2" ParentId="2407" CreationDate="2018-06-21T13:51:10.233" Score="1" Body="&lt;p&gt;The additive self-orthogonal constraint on the classical codes in order to create stabilizer quantum codes is needed due to the fact that the stabilizer generators must commute between them in order to create a valid code space. When creating quantum codes from classical codes, the commutation relationship for the stabilizers is equivalent to having a self-orthogonal classical code.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, quantum codes can be constructed from non self-orthogonal classical codes over $GF(4)^n$ by means of entanglement-assistance. In this constructions, an arbitrary classical code is selected, and by adding some Bell pairs in the qubit sytem, commutation between the stabilizers is obtained.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This entanglement assisted paradigm for constructing QECCs from any classical code is presented in &lt;a href=&quot;https://arxiv.org/pdf/1610.04013.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/pdf/1610.04013.pdf&lt;/a&gt;, which is based on the paper &quot;Correcting Quantum Errors with Entanglement&quot; published in Science by Brun, Devetak and Hsieh.&lt;/p&gt;&#xA;" OwnerUserId="2371" LastActivityDate="2018-06-21T13:51:10.233" CommentCount="0" />
  <row Id="2427" PostTypeId="1" CreationDate="2018-06-21T14:31:58.267" Score="5" ViewCount="73" Body="&lt;p&gt;Quantum networks or quantum internet are terms that can be found when reading about quantum computation and information nowadys, but still I they are pretty vague concepts that are still in development.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I was wondering about the fact that this networks or internet would be pretty limited in communications between several computers as sending redundant information to several of them would be prohibited because of the no-cloning theorem. That would mean that only point-to-point communications could be done in quantum network. Moreover, once sent the information cannot be sent again as no copies of it are remaining, and so the communication could be done just once or the state should be created again by doing the same computations as before each time we want to send it. This sounds pretty inefficient coparing to the classical networks and internet.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Am I right about this thought or am I missing something?&lt;/p&gt;&#xA;" OwnerUserId="2371" LastEditorUserId="23" LastEditDate="2018-06-21T20:06:52.657" LastActivityDate="2018-06-29T15:19:38.633" Title="Does the no-cloning theorem impose limits on the capabilities of quantum networks?" Tags="&lt;quantum-computer&gt;&lt;quantum-networks&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="2428" PostTypeId="2" ParentId="2427" CreationDate="2018-06-21T15:11:18.693" Score="4" Body="&lt;p&gt;Setting aside the practical problems in actually building such things, quantum computers/networks can do everything their classical counterparts do without any fundamental overhead.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Your reasoning seems to stem from a misunderstanding of the no-cloning theorem.&#xA;The no-cloning theorem says that you cannot reversibly clone unknown states &lt;em&gt;with a protocol that does not depend on the state being cloned&lt;/em&gt; (see e.g. &lt;a href=&quot;https://physics.stackexchange.com/q/248563/58382&quot;&gt;this question&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This has nothing to do with the communication context that you mention. If I want to send you some classical information, I would do it in basically the same way as it is done in a &quot;classical&quot; network. If I want to send you a quantum state, &lt;em&gt;and I know what that state is&lt;/em&gt;, again there are no problems in &quot;cloning&quot; that state (I can just generate the same state many times).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If I have an &lt;em&gt;unknown&lt;/em&gt; state and I want to send you many copies of it, then yes, the no-cloning theorem prevents me from doing so. However, it is not clear why should I want to do this for communication purposes.&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-06-21T17:18:22.343" LastActivityDate="2018-06-21T17:18:22.343" CommentCount="3" />
  <row Id="2429" PostTypeId="2" ParentId="2403" CreationDate="2018-06-21T17:24:13.170" Score="0" Body="&lt;p&gt;&lt;strong&gt;2023&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[1] Source IBM Research &lt;a href=&quot;https://www.research.ibm.com/5-in-5/quantum-computing/&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://www.research.ibm.com/5-in-5/quantum-computing/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;... Within five years, the industry will have discovered the first&#xA;  applications where a quantum computer (used alongside a classical&#xA;  computer) will offer a benefit to solving specific problems. ...&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;[2] point [3] in answer &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2430/2529&quot;&gt;2028&lt;/a&gt; also supports to some extent this period.&lt;/p&gt;&#xA;" OwnerUserId="2529" LastEditorUserId="2529" LastEditDate="2018-06-21T22:09:26.377" LastActivityDate="2018-06-21T22:09:26.377" CommentCount="0" />
  <row Id="2430" PostTypeId="2" ParentId="2403" CreationDate="2018-06-21T17:43:27.973" Score="0" Body="&lt;p&gt;&lt;strong&gt;2028&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[1] Source Scientific American : &lt;a href=&quot;https://www.scientificamerican.com/article/how-close-are-we-really-to-building-a-quantum-computer/&quot; rel=&quot;nofollow noreferrer&quot;&gt;How Close Are We—Really—to Building a Quantum Computer?&lt;/a&gt;(Intel’s head of quantum computing talks about the challenges of developing algorithms, software programs and other necessities for a technology that doesn’t yet exist)&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The race is on to build the world’s first meaningful quantum&#xA;  computer—one that can deliver the technology’s long-promised ability&#xA;  to help scientists do things like develop miraculous new materials,&#xA;  encrypt data with near-perfect security and accurately predict how&#xA;  Earth’s climate will change. Such a machine is likely more than a&#xA;  decade away, but IBM, Microsoft, Google, Intel and other tech&#xA;  heavyweights breathlessly tout each tiny, incremental step along the&#xA;  way.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;and a bit further down the same article:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;People think quantum computers are just around the corner, but history&#xA;  shows these advances take time. If 10 years from now we have a quantum&#xA;  computer that has a few thousand qubits, that would certainly change&#xA;  the world in the same way the first microprocessor did. We and others&#xA;  have been saying it’s 10 years away. Some are saying it’s just three&#xA;  years away, and I would argue that they don’t have an understanding of&#xA;  how complex the technology is.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;[2] Source : &lt;a href=&quot;https://futurism.com/when-will-quantum-computers-be-consumer-products/&quot; rel=&quot;nofollow noreferrer&quot;&gt;When Will Quantum Computers Be Consumer Products?&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Andrew Dzurak, Professor in Nanoelectronics at University of New South&#xA;  Wales,  ... “I think that within ten years, there will be&#xA;  demonstrations of modelling of certain chemicals and drugs that&#xA;  couldn’t be done today but I don’t think there will be a convenient,&#xA;  routine [system] that [people] can use,” Dzurak said in the interview.&#xA;  “To move to that stage will take another decade further beyond that.”&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;[3] &lt;a href=&quot;https://www.informationweek.com/why-quantum-computing-should-be-on-your-radar-now/a/d-id/1331946&quot; rel=&quot;nofollow noreferrer&quot;&gt;Why Quantum Computing Should Be on Your Radar Now&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This report could also be interpreted that the first useful thing could happen earlier than 2028 (e.g. in 2023)&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;What to expect, when&lt;/strong&gt;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;There's a lot of confusion about the current state of quantum&#xA;  computing which industry research firms Boston Consulting Group (BCG)&#xA;  and Forrester are attempting to clarify.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;In the Forrester report, Hopkins estimates that quantum computing is&#xA;  in the early stages of commercialization, a stage that will persist&#xA;  through 2025 to 2030. The growth stage will begin at the end of that&#xA;  period and continue through the end of the forecast period which is&#xA;  2050.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;...&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;BCG also reasons that the quantum computing market will advance in&#xA;  three distinct phases:&lt;/p&gt;&#xA;  &#xA;  &lt;ol&gt;&#xA;  &lt;li&gt;&lt;p&gt;The first generation will be specific to applications that are quantum&#xA;  in nature, similar to what D-Wave is doing. &lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;The second generation will unlock what report co-author and BCG senior partner Massimo Russo&#xA;  calls &quot;more interesting use cases.&quot; &lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;In the third generation, quantum&#xA;  computers will have achieved the number of logical qubits required to&#xA;  achieve Quantum Supremacy. (Note: Quantum Supremacy and logical qubits&#xA;  versus physical qubits are important concepts addressed below.)&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="2529" LastEditorUserId="2529" LastEditDate="2018-06-21T22:00:57.503" LastActivityDate="2018-06-21T22:00:57.503" CommentCount="0" />
  <row Id="2431" PostTypeId="2" ParentId="2403" CreationDate="2018-06-21T21:35:34.417" Score="0" Body="&lt;p&gt;&lt;strong&gt;2033 or later&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[1] source &lt;a href=&quot;http://algassert.com/post/1800&quot; rel=&quot;nofollow noreferrer&quot;&gt;Why will quantum computers be slow?&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This site mentions the following bottlenecks:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Bottleneck #0: Qubit count&lt;/li&gt;&#xA;&lt;li&gt;Bottleneck #1: T count&lt;/li&gt;&#xA;&lt;li&gt;Bottleneck #2: Measurement depth&lt;/li&gt;&#xA;&lt;li&gt;Bottleneck #3: Spacetime volume&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Regarding the first bottleneck it says the following:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;If the qubit count doubles every year, it'll be 17 years before we get to 100%.&#xA;  That 17 year gap is daunting. 50 to 100 noisy qubits should be enough&#xA;  to do something hard, and 100 to 200 logical qubits should be enough&#xA;  to do something useful, but at the moment it's not known if there's&#xA;  much in between. If there really is nothing on the decade-long road&#xA;  from 100 noisy qubits to 100 error-corrected qubits,&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The summary of the blog:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;Summary&lt;/strong&gt;&#xA;  To run a quantum computation really fast, you need:&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;1 Enough qubits to fit the computation in the first place. &#xA;  2 Then enough T factories to perform T gates as fast as the computation needs them.&#xA;  3 Then wider circuits that do measurements in parallel instead of&#xA;  serially. &#xA;  4 Then efficient strategies for routing qubits and packing braiding operations.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;I like to imagine that each bottleneck will be&#xA;  the &quot;most relevant&quot; for about a decade. We'll naturally transition&#xA;  from one to the next because, funnily enough, every single one of&#xA;  these bottlenecks falls to adding more qubits....&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;[2] The points mentioned in answer &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2430/2529&quot;&gt;2028&lt;/a&gt; mainly give an indication when they expect it might happen.  They are not excluding it can be several years later.&lt;/p&gt;&#xA;" OwnerUserId="2529" LastEditorUserId="2529" LastEditDate="2018-06-21T22:08:37.647" LastActivityDate="2018-06-21T22:08:37.647" CommentCount="0" />
  <row Id="2432" PostTypeId="1" AcceptedAnswerId="2451" CreationDate="2018-06-22T15:34:38.563" Score="6" ViewCount="103" Body="&lt;p&gt;$T_2$ generally refers to the measurement of the coherence of the qubit with respect to its dephasing (that's a rotation through the $|0\rangle$  - $|1\rangle$ axis of the Bloch sphere for those of us visualizing). But sometime in the literature, it's called $T_2$ and other times it's referred to as $T_2^*$. The fact that it is never explained leads me to believe the distinction is very simple. What's the distinction between these two concepts?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I assert that this nomenclature is very common in the literature (at least regarding solid-state QC). Here is one example: &lt;a href=&quot;https://www.nature.com/articles/nmat2420&quot; rel=&quot;nofollow noreferrer&quot;&gt;Ultralong spin coherence time in isotopically engineered diamond.&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My internet search for an explanation has come up dry. Please help.&lt;/p&gt;&#xA;" OwnerUserId="1867" LastEditorUserId="26" LastEditDate="2018-06-23T13:43:21.830" LastActivityDate="2018-06-24T20:04:57.440" Title="What's the Difference between T2 and T2*?" Tags="&lt;quantum-decoherence&gt;&lt;solid-state&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="2433" PostTypeId="2" ParentId="2420" CreationDate="2018-06-22T20:13:32.060" Score="1" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;What are the biggest bottlenecks in the realization of a global &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_network&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum network&lt;/a&gt; (ie quantum internet)?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;It would seem only complexity, getting everything working together, with high reliability, for a long enough period of time. The &lt;a href=&quot;https://en.wikipedia.org/wiki/OSI_model#Description_of_OSI_layers&quot; rel=&quot;nofollow noreferrer&quot;&gt;OSI description of network layers&lt;/a&gt; describes 7 layers, quantum networks will likely end up with more but we can already implement the OSI conventional model thus proving the viability and existence of quantum networking.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The article mentions some concerns, which are being successfully worked on:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Transmission via fiber optics instead of satellite&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;a href=&quot;https://arxiv.org/abs/1401.6958&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum teleportation from a telecom-wavelength photon to a solid-state quantum memory&lt;/a&gt;&quot; (27 Jan 2014), by Felix Bussieres, Christoph Clausen, Alexey Tiranov, &amp;amp; 11 others.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.unige.ch/gap/quantum/news:20180418-1451-characterization_of_the_hyperfine_properties_for_quantum_memory_application&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum memories&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.unige.ch/gap/quantum/research:quantum_memories_and_repeaters&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum repeaters&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Not mentioned in the article is the first level, the symbol layer, converting the qubit's state to something that can be transmitted and restored on the other end: the &lt;a href=&quot;http://www.iqst.org/research/focus-areas/light-matter-interface.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;light-matter interface&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Complexity and cost won't be a problem for the first users, the delay (2030) would be due to commercialization and popularity for a sufficiently large group. The local network is operating today (&lt;a href=&quot;https://www.nature.com/articles/d41586-018-01835-3&quot; rel=&quot;nofollow noreferrer&quot;&gt;scheduled opening 2020&lt;/a&gt;).&lt;/p&gt;&#xA;" OwnerUserId="278" LastActivityDate="2018-06-22T20:13:32.060" CommentCount="2" />
  <row Id="2434" PostTypeId="2" ParentId="2432" CreationDate="2018-06-23T09:29:04.747" Score="1" Body="&lt;p&gt;From Chapter 15 of NII's quantum information lecture series on &quot;Fundamentals of Noise processes&quot; (link &lt;a href=&quot;https://www.nii.ac.jp/qis/first-quantum/e/forStudents/lecture/index.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;):&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;An applied DC field $H_0$ is not completely uniform in all space points. If many spin qubits are placed in such an inhomogeneous DC field, they have different Larmor frequencies. This leads to the dephasing effect if we compare the phase difference between different qubits. A time constant for this dephasing process is determined by the spatial (not temporal) inhomogeneous broadening of the DC field and distinguished from $T_2$ process. A new time constant is often referred to as $T_2^*$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;So, if I am understanding this correctly (and I am not an expert in this), then $T_2^*$ is the combined dephasing from the standard dephasing mechanism (described by $T_2$) and any inhomogeneities in the DC field. Presumably, the reason it is often not distinguished from $T_2$ in papers is that it is assumed that such inhomogeneities always exist and so $T^*_2$ is almost always the value being measured and the most relevant in practise.&lt;/p&gt;&#xA;" OwnerUserId="391" LastActivityDate="2018-06-23T09:29:04.747" CommentCount="0" />
  <row Id="2435" PostTypeId="1" CreationDate="2018-06-23T19:59:46.763" Score="3" ViewCount="98" Body="&lt;p&gt;What would happen if, in a periodic medium, the oscillation that occupies in it is continuously transformed from a square lattice to a hexagonal or triangular lattice?  The only guess would be that the smallest persistent patterns that were previously square on edge would become rounder on edge.  Has anybody heard of something like that?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The sixth post down &lt;a href=&quot;http://www.conwaylife.com/forums/viewtopic.php?f=11&amp;amp;t=3195&amp;amp;start=0&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt; shows the hexagonal lattice.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Just click &quot;show in viewer&quot;, and then hit play.  It's only one half of the entire grid because there's another hexagonal lattice that is the &quot;flipped over&quot; version, that's then pasted so that the center X's align, and only the very central X would be symmetric and not clockwise or counterclockwise (pasting the clockwise directly on top of the counterclockwise removes any mirror and makes it symmetric).  But when you place the &quot;flipped over&quot; hexagon, the X's actually all line up in rows and columns, except for the center, whereas that lattice is spaced ---- skip a square, then shift a half a square ----, but when the flipped over is pasted directly over, you then get 12 around 1 instead of six around 1, but everything then aligns (the X's that is) in rows and columns neatly.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I know this is completely disorganized, but on my last post in the Conway life forum, and in that journal link right below here, if you go up you'll see a pattern in an earlier post of three X's in a row, with horizontal lines from the flags.  Well since, in the hexagonal lattice (both sets pasted on top of each other so you have 12 around 1), since everything lines up in neat rows and columns, I believe it's the configurations of the horizontal or vertical lines that control what happens.  What you want is a ball to form that flows through the &quot;strings&quot; that you can see when zoomed out in Golly.  And the ball should jump up or down in a configuration, you can see &lt;a href=&quot;https://journals.aps.org/prapplied/abstract/10.1103/PhysRevApplied.9.051001&quot; rel=&quot;nofollow noreferrer&quot;&gt;this link&lt;/a&gt;&lt;sup&gt;[1]&lt;/sup&gt; (&lt;a href=&quot;https://arxiv.org/abs/1710.01859&quot; rel=&quot;nofollow noreferrer&quot;&gt;ArXiv version&lt;/a&gt;). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;It looks like energy levels but you'll notice in the &quot;jumps&quot; in the diagram in the picture you can click on the journal link, the one with the energy levels, you'll notice the &quot;jumper&quot; always originates from a certain level, jumps to other levels and always returns in an orderly fashion.  That's a Deutsch gate.  And in this automata (I'll have to post later a cleaned up reply), the ball that should form in the two hexagonal lattices that are pasted right on top of each other as described (only the centers get pasted directly, and you have 12 around 1), that flows through the flicker, it should jump in a fashion that's the Deutsch quantum gate.  I'll have to work on it to get it to work like that, but that's what it should be.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[1]: Deutsch, Toffoli, and CNOT Gates via Rydberg Blockade of Neutral Atoms (Xiao-Feng Shi, 2018)&lt;/p&gt;&#xA;" OwnerUserId="2748" LastEditorUserId="23" LastEditDate="2018-06-27T12:10:23.360" LastActivityDate="2018-06-27T12:10:23.657" Title="Transforming square lattice to hexagonal lattice" Tags="&lt;quantum-gate&gt;" AnswerCount="0" CommentCount="7" FavoriteCount="1" />
  <row Id="2436" PostTypeId="5" CreationDate="2018-06-23T21:51:45.883" Score="0" Body="&lt;p&gt;The textbook &lt;a href=&quot;http://admin.cambridge.org/academic/subjects/physics/quantum-physics-quantum-information-and-quantum-computation/quantum-computation-and-quantum-information-10th-anniversary-edition&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Computation and Quantum Information&lt;/a&gt; by Michael A. Nielsen and Isaac L. Chuang (referred to as 'Nielsen and Chuang' or more informally as 'Mike and Ike') was first published in 2000, with the current edition being the second, published in 2010.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;This tag is to be used for general questions about the contents of this textbook as well as for the project on &lt;a href=&quot;https://quantumcomputing.meta.stackexchange.com/q/250/23&quot;&gt;answering all the exercises it contains&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;Exercise questions directory&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Below are links to each exercise, grouped by chapter. This will be updated as more are added.&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;2 Introduction to quantum mechanics&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;2.1 Linear algebra&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;2.1.1 Bases and linear independence&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;2.1: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2408/nielsen-chaung-exercise-2-1-linear-dependence-example&quot;&gt;Linear dependence: example&lt;/a&gt; [Answered]&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;2.1.2 Linear operators and matrices&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;2.2: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2423/nielsen-chuang-exercise-2-2-matrix-representations-example&quot;&gt;Matrix representations: example&lt;/a&gt; [Answered]&lt;/li&gt;&#xA;&lt;li&gt;2.3: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2473/nielsen-chuang-exercise-2-3-matrix-representation-for-operator-products&quot;&gt;Matrix representation for operator products&lt;/a&gt; [Answered]&lt;/li&gt;&#xA;&lt;li&gt;2.4: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2487/nielsen-chuang-exercise-2-4-matrix-representation-for-identity&quot;&gt;Matrix representation for identity&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;2.5: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2508/nielsen-chuang-exercise-2-5-inner-products-of-complex-vectors&quot;&gt;Inner products of complex vectors&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="91" LastEditorUserId="391" LastEditDate="2018-06-29T21:55:42.040" LastActivityDate="2018-06-29T21:55:42.040" CommentCount="0" />
  <row Id="2437" PostTypeId="4" CreationDate="2018-06-23T21:51:45.883" Score="0" Body="For questions about exercises or passages from the popular quantum computing textbook *Quantum Computation and Quantum Information* by Michael Nielsen and Isaac Chuang. This is also used for the site wide project answering all the questions contained therein." OwnerUserId="91" LastEditorUserId="23" LastEditDate="2018-06-23T22:29:42.273" LastActivityDate="2018-06-23T22:29:42.273" CommentCount="0" />
  <row Id="2438" PostTypeId="2" ParentId="2390" CreationDate="2018-06-24T05:25:46.603" Score="2" Body="&lt;p&gt;Calculation of the inverse of an $N\times N$ matrix can be done by applying HHL with $N$ different $\vec{b}_i$ (specifically, HHL is applied $N$ times, once for each computational basis vector used as the $\vec{b}_i$).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In each case, phase estimation has to be done for an $N \times N$ matrix. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The number of qubits required for phase estimation is written on page 249 of the 10th anniversary edition of N&amp;amp;C:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;The quantum phase estimation procedure uses two registers. The first&#xA;  register contains $t$ qubits.&quot; &lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&quot;The second register [...] contains as many qubits as is necessary&#xA;  to store $|u\rangle$&quot;, where $|u\rangle$ is an $N$-dimensional vector.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;So you are correct that we would need $6$ qubits for the first register, and $\log N=8$ qubits for the second register. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is 14 qubits in total to do the phase esitmation part of each HHL iteration involved in calculating the inverse of a matrix. 14 qubits is well within the capabilities of a laptop.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-06-24T05:25:46.603" CommentCount="6" />
  <row Id="2439" PostTypeId="1" AcceptedAnswerId="2464" CreationDate="2018-06-24T07:08:52.883" Score="6" ViewCount="141" Body="&lt;p&gt;&lt;sup&gt; This is a continuation of &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2393/quantum-algorithm-for-linear-systems-of-equations-hhl09-step-2-what-is-p&quot;&gt;Quantum algorithm for linear systems of equations (HHL09): Step 2 - What is $|\Psi_0\rangle$?&lt;/a&gt; &lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;In the paper: &lt;a href=&quot;https://arxiv.org/abs/0811.3171&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;strong&gt;Quantum algorithm for linear systems of equations (Harrow, Hassidim &amp;amp; Lloyd, 2009)&lt;/strong&gt;&lt;/a&gt;, the details of the actual implementation of the algorithm is not given. &lt;strong&gt;How&lt;/strong&gt; exactly the states $|\Psi_0\rangle$ and $|b\rangle$ are created, is sort of a &quot;&lt;strong&gt;black-box&lt;/strong&gt;&quot; (see pages 2-3). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$|\Psi_0\rangle = \sqrt{\frac{2}{T}}\sum_{\tau = 0}^{T-1}\sin \frac{\pi (\tau+\frac{1}{2})}{T}|\tau\rangle$$ &lt;/p&gt;&#xA;&#xA;&lt;p&gt;and $$|b\rangle = \sum_{1}^{N}b_i|i\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;where $|\Psi_0\rangle$ is the initial state of the clock register and $|b\rangle$ is the initial state of the Input register. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;(Say) &lt;strong&gt;I want to carry out their algorithm on the IBM $16$-qubit quantum computer.&lt;/strong&gt; And I want to solve a certain equation $\mathbf{Ax=b}$ where $\mathbf{A}$ is a $4\times 4$ Hermitian matrix with real entries and $\mathbf{b}$ is a $4\times 1$ column vector with real entries. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's take an example:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\mathbf{A} = \begin{bmatrix} 1 &amp;amp; 2 &amp;amp; 3 &amp;amp; 4 \\ 2 &amp;amp; 1 &amp;amp; 5 &amp;amp; 6 \\ 3 &amp;amp; 5 &amp;amp; 1 &amp;amp; 7 \\ 4 &amp;amp; 6 &amp;amp; 7 &amp;amp; 1 \end{bmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;and &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\mathbf{b}=\begin{bmatrix} 1 \\ 2 \\ 3 \\ 4 \end{bmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Given the dimensions of $\mathbf{A}$ and $\mathbf{b}$, we should need $\lceil{\log_2 4\rceil}=2$ qubits for the input register and another $6$ qubits for the clock register assuming we want the eigenvalues to be represented with $90\%$ accuracy and up to $3$-bit precision for the eigenvalues (this has been discussed &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2390/quantum-algorithm-for-linear-systems-of-equations-hhl09-step-1-number-of-qu/2438?noredirect=1#comment2939_2438&quot;&gt;here&lt;/a&gt; previously). So total $2+6+1=9$ qubits will be needed for this purpose (the extra $1$ qubit is the ancilla).&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Questions:&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Using this information, is it &lt;strong&gt;possible&lt;/strong&gt; to create the initial states $|\Psi_0\rangle$ and $|b\rangle$ on the IBM $16$ qubit version?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;If you think $4\times 4$ is too large to be implemented on the IBM quantum computers you could even show an &lt;em&gt;example&lt;/em&gt; of initial state preparation for a $2\times 2$ Hermitian matrix $\mathbf{A}$ (or just give a reference to such an example). &lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;I simply want to get a &lt;em&gt;general idea&lt;/em&gt; about whether this can be done (i.e. whether it is possible) on the IBM 16-qubit quantum computer, and for that which gates will be necessary. If not the IBM 16-qubit quantum computer, can the QISKit simulator used for recreating the initial state preparation of $|\Psi_0\rangle$ and $|b\rangle$ in the HHL algorithm? Is there any other better alternative to go about this?&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-05T19:01:52.570" LastActivityDate="2018-07-06T09:30:16.743" Title="Quantum algorithm for linear systems of equations (HHL09): Step 2 - Preparation of the initial states $|\Psi_0\rangle$ and $|b\rangle$" Tags="&lt;quantum-algorithms&gt;&lt;ibm-q-experience&gt;&lt;qiskit&gt;&lt;hhl-algorithm&gt;" AnswerCount="2" CommentCount="8" />
  <row Id="2440" PostTypeId="1" AcceptedAnswerId="2442" CreationDate="2018-06-24T08:49:03.517" Score="3" ViewCount="66" Body="&lt;p&gt;As explained in this &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1909/what-exactly-is-a-phase-vector&quot;&gt;this answer&lt;/a&gt;, when we have different (relative) phases between two states, those two states will yield the same probabilities when measured in the same basis but different probabilities when measured in different bases.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is why would we need to do measurement in different bases?&lt;br&gt;&#xA;I'm asking from a quantum programming point of view. Why would I need to change the (relative) phase of two states when writing a program?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One constraint though: I don't understand how to read a Bloch sphere so the matrix and circuit formalisms are preferred.&lt;/p&gt;&#xA;" OwnerUserId="2417" LastActivityDate="2018-06-25T14:13:39.203" Title="Use of change of phase gates" Tags="&lt;quantum-algorithms&gt;&lt;quantum-gate&gt;" AnswerCount="3" CommentCount="0" />
  <row Id="2441" PostTypeId="2" ParentId="2440" CreationDate="2018-06-24T09:34:17.470" Score="1" Body="&lt;p&gt;The phase mentioned in that question and answer are of the form:&#xA;$$&#xA;P = &#xA;\begin{bmatrix} &#xA;e^{i\theta} &amp;amp; 0 \\ &#xA;0 &amp;amp; e^{i\phi}&#xA;\end{bmatrix}&#xA;$$&#xA;so, they are not global phases. However, two particular states, aka its eigenstates, are unaffected by this relative phase operator. Because, this operator is diagonal it means the basis we are currently using is their eigenstate.&lt;/p&gt;&#xA;" OwnerUserId="2023" LastActivityDate="2018-06-24T09:34:17.470" CommentCount="0" />
  <row Id="2442" PostTypeId="2" ParentId="2440" CreationDate="2018-06-24T09:49:43.423" Score="1" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;My question is why would we need to do measurement in different bases?&#xA;  I'm asking from a quantum programming point of view. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Quantum programs are usually written to implement some quantum algorithm. Depending on the algorithm you &lt;em&gt;might&lt;/em&gt; need to change the basis of measurement at some point. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;For instance, &lt;a href=&quot;https://en.wikipedia.org/wiki/Bell_state#Bell_state_measurement&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bell state measurement&lt;/a&gt; is useful in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_teleportation&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum teleportation protocol&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-06-24T09:49:43.423" CommentCount="0" />
  <row Id="2443" PostTypeId="1" CreationDate="2018-06-24T10:55:31.113" Score="5" ViewCount="197" Body="&lt;p&gt;I had asked this question earlier in the comment section of the post: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2381/what-is-a-qubit&quot;&gt;What is a qubit?&lt;/a&gt; but none of the answers there seem to address it at a satisfactory level.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &lt;strong&gt;question&lt;/strong&gt; basically is:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;How is a &lt;strong&gt;single qubit&lt;/strong&gt; in a Bell state&#xA;  $\frac{1}{\sqrt{2}}(|0\rangle + |1\rangle)$ any &lt;strong&gt;different&lt;/strong&gt; from a&#xA;  classical coin spinning in the air (on being tossed)? &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;The &lt;strong&gt;one-word&lt;/strong&gt; answer for &lt;em&gt;difference between a system of &lt;strong&gt;2 qubits&lt;/strong&gt; and a system of &lt;strong&gt;2 classical coins&lt;/em&gt;&lt;/strong&gt; is &quot;&lt;strong&gt;entanglement&lt;/strong&gt;&quot;. For instance, you cannot have a system of two coins in the state $\frac{1}{\sqrt 2}|00\rangle+\frac{1}{\sqrt 2}|11\rangle$. The reason is simple: when two &quot;fair&quot; coins are spinning in air, there is always some &lt;strong&gt;finite probability&lt;/strong&gt; that the first coin lands heads-up while the second coin lands tails-up, and also the vice versa is true. In the combined Bell state $\frac{1}{\sqrt 2}|00\rangle+\frac{1}{\sqrt 2}|11\rangle$ that is not possible. If the first qubit turns out to be $|0\rangle$, the second qubit will necessarily be $|1\rangle$. Similarly, if the first qubit turns out to be $|1\rangle$, the second qubit will necessarily turn out to be $|1\rangle$. At, this point someone might point out that if we use $2$ &quot;&lt;strong&gt;biased&lt;/strong&gt;&quot; coins then it might be possible to recreate the combined Bell state. The answer is still &lt;strong&gt;no&lt;/strong&gt; (it's possible to mathematically prove it...try it yourself!). That's because the Bell state cannot be decomposed into a tensor product of two individual qubit states i.e. the two qubits are &lt;em&gt;entangled&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;While the reasoning for the &lt;strong&gt;2-qubit&lt;/strong&gt; case is understandable from there, I'm not sure what fundamental reason distinguishes a &lt;strong&gt;single qubit&lt;/strong&gt; from a &lt;strong&gt;single &quot;fair&quot; coin&lt;/strong&gt; spinning in the air. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2385/26&quot;&gt;answer by @Jay Gambetta&lt;/a&gt; somewhat gets at it (but is still not satisfactory):&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;This is a good question and in my view gets at the heart of a qubit.&#xA;  Like the comment by&#xA;  &lt;a href=&quot;https://quantumcomputing.stackexchange.com/users/26/blue&quot;&gt;@blue&lt;/a&gt;,&#xA;  it's not that it can be an equal superposition as this is the same as&#xA;  a classical probability distribution. It is that it can have negative&#xA;  signs. &lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Take this example. Imagine you have a bit in the $0$ state and then&#xA;  you apply a coin flipping operation by some stochastic matrix&#xA;   $\begin{bmatrix}0.5 &amp;amp; 0.5 \\0.5 &amp;amp; 0.5 \end{bmatrix}$ this will make a&#xA;  classical mixture. If you apply this twice it will still be a&#xA;  classical mixture. &lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Now lets got to the quantum case and start with a qubit in the $0$&#xA;  state and apply a coin flipping operation by some unitary matrix&#xA;   $\begin{bmatrix}\sqrt{0.5} &amp;amp; \sqrt{0.5} \\\sqrt{0.5} &amp;amp; -\sqrt{0.5}&#xA; \end{bmatrix}$. This makes an equal superposition and you get random&#xA;  outcomes like above. Now applying this twice you get back the state&#xA;  you started with. The negative sign cancels due to interference which&#xA;  cannot be explained by probability theory. &lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Extending this to n qubits gives you a theory that has an exponential&#xA;  that we can't find efficient ways to simulate. &lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;This is not just my view. I have seen it shown in talks of Scott&#xA;  Aaronson and I think its best to say quantum is like “Probability&#xA;  theory with Minus Signs” (this is a quote I seen Scott make).&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I'm not exactly sure &lt;strong&gt;how&lt;/strong&gt; they're getting the unitary matrix $\begin{bmatrix}\sqrt{0.5} &amp;amp; \sqrt{0.5} \\\sqrt{0.5} &amp;amp; -\sqrt{0.5} \end{bmatrix}$ and what the motivation behind that is. Also, they say: &quot;The negative sign cancels due to &lt;strong&gt;interference&lt;/strong&gt; which can not be explained by probability theory.&quot; The way they've used the word interference seems very vague to me. It would be useful if someone can elaborate on the logic used in that answer and explain &lt;strong&gt;what they actually mean by interference&lt;/strong&gt; and &lt;strong&gt;why exactly it cannot be explained by classical probability&lt;/strong&gt;. Is it some &lt;em&gt;extension&lt;/em&gt; of &lt;strong&gt;Bell's inequality&lt;/strong&gt; for &lt;strong&gt;1-qubit systems&lt;/strong&gt; (doesn't seem so based on my conversations with the folks in the main chat though)? &lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-08T14:00:16.443" LastActivityDate="2018-07-13T15:03:10.593" Title="How is a single qubit fundamentally different from a classical coin spinning in the air?" Tags="&lt;qubit&gt;&lt;qubit-state&gt;" AnswerCount="3" CommentCount="0" FavoriteCount="1" />
  <row Id="2444" PostTypeId="1" CreationDate="2018-06-24T14:31:19.543" Score="6" ViewCount="124" Body="&lt;p&gt;I mean are we certain that they will be able to provide us a huge improvements (in some tasks) compared to clasical computers?&lt;/p&gt;&#xA;" OwnerUserId="2754" LastEditorUserId="26" LastEditDate="2018-06-24T15:49:37.350" LastActivityDate="2018-06-26T03:11:25.767" Title="Are we certain that quantum computers more efficient than classical computers can be built?" Tags="&lt;quantum-computer&gt;&lt;classical-computing&gt;" AnswerCount="3" CommentCount="0" />
  <row Id="2445" PostTypeId="2" ParentId="2443" CreationDate="2018-06-24T15:25:12.490" Score="3" Body="&lt;p&gt;The analogy between qubits and coin flips is popular but can be misleading.  (See, for example, this video: &lt;a href=&quot;https://www.youtube.com/watch?v=lypnkNm0B4A&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://www.youtube.com/watch?v=lypnkNm0B4A&lt;/a&gt;)  A coin spinning in the air and landing on the ground is not truly random, though we may describe it as such.  The key point is how you measure it.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;At any point in time the coin has a definite orientation, though it may be unknown to us.  Likewise, qubits have a definite state at any time, which we can describe by a point on the surface of a sphere (the so-called Bloch sphere).  Mathematically, a coin's orientation and a qubit's state are equivalent.  While in the air, the coin may undergo deterministic and reversible motion (e.g., spinning and falling).  Likewise, prior to measurement a qubit may undergo deterministic and reversible transformations (e.g., unitary gate operations on a quantum computer).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Measurement represents an irreversible process.  For a coin, it is a series of inelastic collisions with the ground, bouncing and spinning until it comes to rest.  If we are completely ignorant of the initial conditions of the coin, the two final orientations (heads or tails) will appear equally likely, but this is not always the case.  If I drop it oriented &quot;heads up&quot; from a short height, it will land flat with &quot;heads up&quot; with near certainty.  But suppose I was standing next to a large magnetic wall and did this.  The coin would hit edge-on and would likely land with either heads or tails showing, with equal probability.  One could imagine doing this experiment with various initial orientations of the coin and orientations of the magnetic wall (upright, flat, slanted, etc.).  You can imagine that the probability of getting heads or tails will be different, depending on the relative orientations of the coin and wall.  (In theory it's all completely deterministic, but in practice we never know the initial conditions &lt;em&gt;that&lt;/em&gt; precisely.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Measurements of qubits are quite similar.  I can prepare a qubit in the state $\frac{1}{\sqrt{2}}[|0\rangle + |1\rangle]$, measure it in the 0/1 basis $\{|0\rangle, |1\rangle\}$, and get either $|0\rangle$ or $|1\rangle$ with equal probability.  If, however, I measure in the +/- basis $\{|+\rangle, |-\rangle\}$ (analogous to using a magnetic wall), I get $|+\rangle$ with near certainty.  (I say &quot;near certainty&quot; because, well, nothing in the real world is perfect.)  Here, $|\pm\rangle = \frac{1}{\sqrt{2}}[|0\rangle\pm|1\rangle$ are the +/- basis states.  For polarized photons, for example, this could be done used polarization filters rotated $45^\circ$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The difference between preparing the state $\frac{1}{\sqrt{2}}[|0\rangle + |1\rangle]$ and the state $\frac{1}{\sqrt{2}}[|0\rangle - |1\rangle]$ is the difference between preparing a vertically oriented coin with either heads or tails facing away from the wall.  (A good picture would really help here.)  We can tell which of the two states is prepared based on the outcome of a suitably chosen measurement, which in this case would be a +/- basis (or magnetic wall) measurement.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Jay Gambetta mentions a unitary matrix that is used to represent a Hadamard gate.  It corresponds to rotating a coin by $90^\circ$, so a coin that's initially heads up becomes vertically oriented with, say, heads facing away from the wall.  If the wall is magnetic and you release the coin, it will stick to it with heads up.  If, instead, you started with a coin that's tails up and applied the same rotation, it would be vertical with tails facing away from the wall.  If you release it (and the wall is still magnetic), you get tails.  On the other hand, if the wall is not magnetic and you drop it, it lands heads or tails with equal probability.  Using a &quot;floor&quot; measurement doesn't distinguish between the two vertical orientations, but using a &quot;wall&quot; measurement does.  It's not so much whether things are predictable or not, it's the type of measurement you do that distinguishes one quantum state (or coin orientation) from another.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is the whole of it.  The only remaining mystery is that the outcome of the coin measurement is considered to be, in theory, completely deterministic, while that of the qubit is considered to be, except in special cases, &quot;intrinsically random.&quot;  But that's another discussion...&lt;/p&gt;&#xA;" OwnerUserId="356" LastEditorUserId="356" LastEditDate="2018-06-24T16:56:16.897" LastActivityDate="2018-06-24T16:56:16.897" CommentCount="3" />
  <row Id="2446" PostTypeId="1" AcceptedAnswerId="2479" CreationDate="2018-06-24T16:50:17.770" Score="3" ViewCount="78" Body="&lt;p&gt;I recently found out about &lt;a href=&quot;https://en.wikipedia.org/wiki/Shadowgraph&quot; rel=&quot;nofollow noreferrer&quot;&gt;shadowgraphy&lt;/a&gt; and was wondering if a technique like this could be used to:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Visually show entanglement&lt;/li&gt;&#xA;&lt;li&gt;Suffice as a measure (e.g. continous partial trace)&lt;/li&gt;&#xA;&lt;li&gt;Most useful applications &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Resources&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;http://iopscience.iop.org/article/10.1088/0741-3335/58/6/065004/meta&quot; rel=&quot;nofollow noreferrer&quot;&gt;Modeling ultrafast shadowgraphy in laser-plasma interaction experiments&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://www.osapublishing.org/ao/abstract.cfm?uri=ao-48-22-4449&quot; rel=&quot;nofollow noreferrer&quot;&gt;Retroreflective shadowgraph technique for large-scale flow visualization&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://ieeexplore.ieee.org/document/5499779/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Digital in-line holography with the Iterative Shadowgraphic Method&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://www.semanticscholar.org/paper/Quantum-algorithmic-information-theory-Svozil/4994981ca4971525d44053ed06b9516efcd61da6&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum algorithmic information theory&lt;/a&gt;: Appendices C &amp;amp; D&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Mach%E2%80%93Zehnder_interferometer&quot; rel=&quot;nofollow noreferrer&quot;&gt;Mach–Zehnder interferometer&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-06-25T22:15:55.717" LastActivityDate="2018-06-26T19:45:46.920" Title="Realization of Quantum Shadowgraphy" Tags="&lt;quantum-algorithms&gt;&lt;quantum-entanglement&gt;&lt;measurement&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2447" PostTypeId="2" ParentId="2443" CreationDate="2018-06-24T17:55:37.567" Score="0" Body="&lt;p&gt;You have already mentioned the practical differences, such as qubit entanglement, and the negative signs (or more general &quot;phases&quot;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The fundamental reason for this is that allowed quantum states are solutions of the Schrödinger equation, which is a &lt;strong&gt;&lt;em&gt;linear differential equation&lt;/em&gt;&lt;/strong&gt;. The sum of solutions to a linear differential equation is &lt;strong&gt;always&lt;/strong&gt; also a solution to that differential equation [&lt;a href=&quot;https://math.stackexchange.com/questions/246643/why-is-a-linear-combination-of-solutions-also-a-solution&quot;&gt;1&lt;/a&gt;],[&lt;a href=&quot;https://math.stackexchange.com/questions/1626362/why-does-the-sum-of-two-linearly-independent-solutions-of-a-second-order-homogen&quot;&gt;2&lt;/a&gt;],[&lt;a href=&quot;https://math.stackexchange.com/questions/1353043/why-is-the-sum-of-two-independent-solutions-of-homogenous-2nd-order-odes-a-solut&quot;&gt;3&lt;/a&gt;]. Since &quot;solution&quot; to differential equation is synonymous with &quot;allowed quantum state&quot; or &quot;allowed wavefunction&quot;, &lt;strong&gt;any&lt;/strong&gt; sum of allowed states is also allowed (ie. superpositions like Bell states are allowed).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;That is the fundamental reason why quantum mechanical bits (qubits) can exist in superpositions. In fact, not just any sum, but any linear combination of states is an allowed state because the differential equation is linear. This means we can even add constants (phases of -1 or +1 or $e^{i\theta}$) and still have allowed states. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Bits that follow the rules of quantum physics, for example, the Schrödinger equation, can physically exist in superpositions and with phases, due to linearity (review &lt;a href=&quot;https://en.wikipedia.org/wiki/Vector_space&quot; rel=&quot;nofollow noreferrer&quot;&gt;vector spaces&lt;/a&gt; if this is not clear). Classical physics does not give any mechanism for a system to be in more than one state at the same time.&lt;/strong&gt; &lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="26" LastEditDate="2018-07-13T15:03:10.593" LastActivityDate="2018-07-13T15:03:10.593" CommentCount="3" />
  <row Id="2448" PostTypeId="2" ParentId="2444" CreationDate="2018-06-24T18:19:40.853" Score="3" Body="&lt;p&gt;The answer is no. We cannot be 100% certain.&lt;br&gt;&#xA;Just  like we don't have a proof that P $\ne$ NP, there is no proof that NP $\ne$ QMA, though we &lt;strong&gt;believe&lt;/strong&gt; both these inequalities to be true even without proof.&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Furthermore, we do not know how the &quot;engineering complexity&quot; scales, so even though Shor's algorithm has exponentially fewer operations to perform than the best known classical algorithm, it might be &lt;em&gt;double exponentially&lt;/em&gt; more difficult to implement it physically. See my answer to this question: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2017/are-there-any-estimates-on-how-complexity-of-quantum-engineering-scales-with-siz/2019#2019&quot;&gt;Are there any estimates on how complexity of quantum engineering scales with size?&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is also possible that there exists a proof  that NP $\ne$ QMA and that the engineering complexity scales linearly, meaning that quantum computers could &quot;provably&quot; have some advantage, but we just do not know of any such proof yet. Until we see a quantum computer give these &quot;huge improvements&quot; for a problem where it is provably better than the best classical algorithm, we have no way of being 100% certain that quantum computers will provide what you ask.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quantum &lt;strong&gt;&lt;em&gt;communication&lt;/em&gt;&lt;/strong&gt; though (not necessarily quantum computing), does have some provable benefits over present day classical communication devices, and one example is the BB84 protocol.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-06-24T18:19:40.853" CommentCount="0" />
  <row Id="2449" PostTypeId="1" AcceptedAnswerId="2450" CreationDate="2018-06-24T18:24:06.580" Score="4" ViewCount="74" Body="&lt;p&gt;When considering Shor's algorithm, we use ancilla qubits to effectively obtain the state&#xA;$$\sum_x \left|x,f(x)\right&amp;gt;$$&#xA;for the function $f(x) = a^x \mod N$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As I have learned it, we then measure the ancilla qubits, to obtain, say $f(x) = b$ and get the state&#xA;$$\sum_{x\mid f(x) = b} \left|x,f(x)\right&amp;gt;.$$ &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then applying a QFT will give the period. However, I think that the measurement of the ancilla qubits is not necessary, in order to be able to apply the QFT (or its inverse for that matter) and do a measurement to obtain the period. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is that correct? Is it necessary to measure the ancilla qubits in Shor's algorithm?&lt;/p&gt;&#xA;" OwnerUserId="2005" LastActivityDate="2018-06-24T19:58:38.243" Title="Measuring ancillas in Shor's algorithm" Tags="&lt;measurement&gt;&lt;shors-algorithm&gt;&lt;ancilla&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2450" PostTypeId="2" ParentId="2449" CreationDate="2018-06-24T19:12:13.837" Score="5" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Is that correct? Is it [not] necessary to measure the ancilla qubits in Shor's algorithm?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Correct, it is not necessary to measure the ancillae.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is easily seen by appealing to the no-communication theorem. If measuring the ancillae could affect the success of the algorithm, you could communicate faster-than-light by starting the algorithm many times, giving the ancillae to Alice, sending her far away, have her encode a bit by measuring or not measuring the ancillae, then having Bob measure how often the factoring was succeeding to read out the bit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Another way to see that this works &lt;a href=&quot;http://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B1%2C1%2C1%2C1%2C1%2C1%2C1%2C1%2C%7B%22id%22%3A%22setR%22%2C%22arg%22%3A27%7D%2C1%2C%7B%22id%22%3A%22setB%22%2C%22arg%22%3A8%7D%5D%2C%5B%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%2C%22H%22%2C%22X%22%5D%2C%5B%22Density7%22%5D%2C%5B%5D%2C%5B%5D%2C%5B%5D%2C%5B%5D%2C%5B%5D%2C%5B%5D%2C%5B%22inputA7%22%2C1%2C1%2C1%2C1%2C1%2C1%2C%22*BToAmodR5%22%5D%2C%5B%22Density7%22%5D%2C%5B%5D%2C%5B%5D%2C%5B%5D%2C%5B%5D%2C%5B%5D%2C%5B%5D%2C%5B%22QFT%E2%80%A07%22%5D%2C%5B%22Density7%22%5D%2C%5B%5D%2C%5B%5D%2C%5B%5D%2C%5B%5D%2C%5B%5D%2C%5B%5D%2C%5B%22Chance7%22%5D%5D%7D&quot; rel=&quot;nofollow noreferrer&quot;&gt;is by simulating it&lt;/a&gt;. From the results you can see that, as soon as the modular-exponentiation into the ancillae has happened, the density matrix of the input has been decohered in a very particular periodic way. And that the inverse QFT of this decohered density matrix has magnitude spikes at the correct places:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/5g7B7.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/5g7B7.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Notice that this is all in place even though the ancillae were not measured. Measuring them changes none of the density matrices.&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-06-24T19:58:38.243" LastActivityDate="2018-06-24T19:58:38.243" CommentCount="0" />
  <row Id="2451" PostTypeId="2" ParentId="2432" CreationDate="2018-06-24T19:51:44.220" Score="4" Body="&lt;p&gt;The naming started in NMR and it has become the difference between the following two experiments. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Experiment one&lt;/strong&gt;: Prepare the qubit in a superposition state (apply a H gate) and vary the wait time and then measure in the superposition basis (apply another H gate). The decay time of this experiment is $T_2^*$. We commonly call this a Ramsey experiment. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Experiment two&lt;/strong&gt;:  Prepare the qubit in a superposition state and apply half the wait time and then apply a pi-pulse (X operator) and then the remainder of the wait time and measure in the superposition basis. The decay time of this experiment is $T_2$. We commonly call this a Hahn Echo. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the second experiment, the pi-pulse refocuses slow noise which depending on the system can be due to many reasons. There are higher order experiments that refocus the noise better and this is an active research area. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;To see this imagine the simplest case where the noise can be explained by a Hamiltonian $H = \Delta |1\rangle\langle 1|$ that is constant and unknown. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the &lt;strong&gt;first experiment&lt;/strong&gt;: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Step 1. Apply H makes $(|0\rangle+|1\rangle)/\sqrt(2)$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Step 2. Wait makes $(|0\rangle+\exp(-i\Delta t)|1\rangle)/\sqrt{2}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Step 3. Apply H $[(1+e^{-i\Delta t})|0\rangle+(1-e^{-i\Delta t})|1\rangle]/2$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The probability of getting outcome 0 is $1/2+\cos(\Delta t)/2$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the &lt;strong&gt;second experiment&lt;/strong&gt;: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Step 1. Apply H gives $(|0\rangle+|1\rangle)/\sqrt(2)$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Step 2. Half Wait gives $(|0\rangle+\exp(-i\Delta t/2)|1\rangle)/\sqrt{2}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Step 3. Apply X gives $(|1\rangle+\exp(-i\Delta t/2)|0\rangle)/\sqrt{2}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Step 3. Half Wait gives $\exp(-i\Delta t/2)(|1\rangle+|0\rangle)/\sqrt{2}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Step 4. Apply H gives $\exp(-i\Delta t/2)|0\rangle$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The probability of getting outcome $0$ is always $1$ (there is no decay). So the $T_2$ of this experiment would be infinite. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the more general case $H = \Delta(t) |1\rangle\langle 1|$ the first experiment gives $\mathrm{Pr}(0) = 1/2+\langle\cos(\int_0^t \Delta(t))\rangle/2$ where we have averaged over different shots (runs of the experiment). I similar but different expression can be derived for the second experiment and I will leave as an exercise what happens but depending on the assumptions you are willing to make about the noise correlations you can simplify this expression in terms of the noise spectrum. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you want to go check it out on a real experiment you can try the notebook &lt;a href=&quot;https://github.com/QISKit/qiskit-tutorial/blob/master/reference/qcvv/relaxation_and_decoherence.ipynb&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://github.com/QISKit/qiskit-tutorial/blob/master/reference/qcvv/relaxation_and_decoherence.ipynb&lt;/a&gt; but you need an account on the IBM Q experience. &lt;/p&gt;&#xA;" OwnerUserId="302" LastEditorUserId="26" LastEditDate="2018-06-24T20:04:57.440" LastActivityDate="2018-06-24T20:04:57.440" CommentCount="2" />
  <row Id="2452" PostTypeId="2" ParentId="1808" CreationDate="2018-06-24T20:20:40.730" Score="1" Body="&lt;p&gt;If $a^{r/2} \equiv -1$, then $a^{r/2}$ is a trivial square root of 1 instead of an interesting square root. We &lt;em&gt;already knew&lt;/em&gt; that -1 is a square root of 1. We need a square root we didn't already know.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Suppose I give you a number $x$ such that $x^2 = 1 \pmod{N}$. You can rewrite this equation as:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\begin{align}&#xA;x^2 &amp;amp;= 1 + k \cdot N&#xA;\\&#xA;x^2 - 1 &amp;amp;= k \cdot N&#xA;\\&#xA;(x+1)(x-1) &amp;amp;= k \cdot N&#xA;\end{align}&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The key thing to realize is that &lt;em&gt;this equation is trivial when x is ±1 (mod N)&lt;/em&gt;. If $x\equiv -1$, then the left hand side is 0 mod N because the factor $(x+1)\equiv 0$. The same thing happens if $x \equiv +1$, but with the other factor.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In order for both $(x+1)$ and $(x-1)$ to be interesting (i.e. non-zero mod N), we need $x$ to be an &lt;em&gt;extra&lt;/em&gt; square root of 1. A square root besides the obvious +1 and -1 answers. When that happens, it is impossible for the prime factors of $N$ to all go into $(x+1)$ or all go into $(x-1)$, and so $\gcd(x+1, N)$ is guaranteed to give you a factor of $N$ instead of a multiple of $N$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, if $N=221$ then $x=103$ is an extra square root of 1. And indeed, both $\gcd(x+1, N) = \gcd(104, 221) = 13$ and $\gcd(x-1, N) = \gcd(102, 221) = 17$ are factors of 221. Whereas if we had picked the boring square root $x=-1\equiv 220$, then neither $\gcd(x+1,N) = \gcd(221, 221) = 221$ nor $\gcd(x-1,N) = \gcd(219,221) = 1$ are factors of 221.&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-06-24T20:34:19.160" LastActivityDate="2018-06-24T20:34:19.160" CommentCount="0" />
  <row Id="2453" PostTypeId="2" ParentId="2195" CreationDate="2018-06-24T20:43:17.197" Score="1" Body="&lt;p&gt;You can find detailed instructions about what you need to install for your particular OS &lt;a href=&quot;https://github.com/QISKit/qiskit-tutorial/blob/master/INSTALL.md#5-visualizing-circuits&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;. This visualization uses Latex, so you need to have a latex compiler installed. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Also make sure you have the latest version of Qiskit, as a Windows visualization bug was recently fixed. You can upgrade by doing: &#xA;&lt;code&gt;pip install -U qiskit&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Within the next couple weeks, Qiskit will have another visualization method that runs purely in Python, hence no other software installations required.&lt;/p&gt;&#xA;" OwnerUserId="2503" LastActivityDate="2018-06-24T20:43:17.197" CommentCount="0" />
  <row Id="2454" PostTypeId="1" AcceptedAnswerId="2455" CreationDate="2018-06-24T21:23:36.790" Score="7" ViewCount="80" Body="&lt;p&gt;I found it odd that the result of the action of identity gate (namely a $2\times2$ identity matrix) on a pure state $|0\rangle$ (namely the vector corresponding to the $2\times1$ matrix $\begin{bmatrix} 1\\0 \end{bmatrix}$) becomes a $2\times2$ matrix $\begin{bmatrix} 1+0\cdot i&amp;amp;0+0\cdot i\\0+0\cdot i&amp;amp;1+0\cdot i \end{bmatrix}=\begin{bmatrix} 1&amp;amp;0\\0&amp;amp;1 \end{bmatrix}$ as I found it &lt;a href=&quot;https://nbviewer.jupyter.org/github/QISKit/qiskit-tutorial/blob/master/reference/tools/quantum_gates_and_linear_algebra.ipynb#Identity-gate&quot; rel=&quot;nofollow noreferrer&quot;&gt;HERE&lt;/a&gt; (QISKit tutorial page):&#xA;&lt;a href=&quot;https://i.stack.imgur.com/W79pi.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/W79pi.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Also, when one lets for more precision, the result gets odd:    &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/cv2Kx.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/cv2Kx.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Why is this? The same thing happens for other gates listed on the page referenced above.&lt;/p&gt;&#xA;" OwnerUserId="2757" LastEditorUserId="2757" LastEditDate="2018-06-25T02:48:15.497" LastActivityDate="2018-06-25T02:48:15.497" Title="One-qubit gates results in QISKit" Tags="&lt;quantum-gate&gt;&lt;qiskit&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="2455" PostTypeId="2" ParentId="2454" CreationDate="2018-06-25T01:28:53.873" Score="3" Body="&lt;p&gt;In the first case you are not asking for the state but the unitary matrix representing the circuit. This is correct and just rounding error.   It looks like you are not using the latest version so I would update. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the second case are you sure that you don’t have a previous circuit loaded in memory. In that notebook all examples have the same circuit name and it looks like this is a different gate.  If i had to guess it is the u2 example. If this is not the case you have found a bug and please submit an issue and we try to debug it.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I would also change the title as this is not a general quantum computing question to one qubit gates errors in qiskit or something like that. &lt;/p&gt;&#xA;" OwnerUserId="302" LastEditorUserId="302" LastEditDate="2018-06-25T02:22:56.967" LastActivityDate="2018-06-25T02:22:56.967" CommentCount="7" />
  <row Id="2456" PostTypeId="1" AcceptedAnswerId="2459" CreationDate="2018-06-25T06:53:29.573" Score="3" ViewCount="114" Body="&lt;p&gt;I was not able to locate any visuals online. The visual I have in my head is a cube w/ bloch spheres as the eight vertices. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am also curious about a matrix representation, although I am not sure how feasible this is as a qubyte has $2^8$ (256) states.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;What is the best way to represent a qubyte?&lt;/strong&gt;&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="26" LastEditDate="2018-07-16T15:03:25.637" LastActivityDate="2018-07-16T15:03:25.637" Title="How to represent a qubyte?" Tags="&lt;quantum-entanglement&gt;&lt;qudit&gt;" AnswerCount="2" CommentCount="1" />
  <row Id="2457" PostTypeId="2" ParentId="2444" CreationDate="2018-06-25T07:12:18.163" Score="1" Body="&lt;p&gt;There is no absolute certainty. People introduce complexity classes: BPP for the set of problems that a classical computer (with access to a source of randomness) can solve in polynomial time, and BQP for the set of problems that a quantum computer can efficiently solve. We know that BQP contains BPP, but we do not know for certain that there are problems in BQP but not BPP. It is generally believed that there are some. &lt;a href=&quot;https://en.wikipedia.org/wiki/Shor%27s_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;Shor's algorithm&lt;/a&gt; for factoring large composite numbers is most typically hailed as a likely candidate, although the best candidate is the &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0511096&quot; rel=&quot;nofollow noreferrer&quot;&gt;algorithm for the Jones polynomial&lt;/a&gt; because this problem is known to be the hardest that is efficiently solvable by a quantum computer. But we don't &lt;em&gt;know&lt;/em&gt;. It may be that there is an efficient classical algorithm for this problem, and we just haven't been smart enough to find it yet.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What we &lt;em&gt;do&lt;/em&gt; know is that with respect to certain oracles (i.e. black boxes that function in particular ways), quantum algorithms do outperform classical ones. You can think of this as &quot;if we program an algorithm in a particular way, how fast can it run?&quot;. The advantage of these oracle-based algorithms is that lower bounds can be proven, showing the minimum number of operations required. The classic example of this is &lt;a href=&quot;https://en.wikipedia.org/wiki/Simon%27s_problem&quot; rel=&quot;nofollow noreferrer&quot;&gt;Simon's problem&lt;/a&gt;. Again, it doesn't mean that there can't be a better way of doing it classically via another route.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The other aspect that is implied by your question is whether a scalable universal quantum computer can actually be built. Until this is actually done, I don't think it can be proven, although it is generally believed that it will happen. There are, however, those who believe there are fundamental limitations that will prevent the construction of a suitable device. Gil Kalai, &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/1794/1837&quot;&gt;for example&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-25T07:12:18.163" CommentCount="0" />
  <row Id="2458" PostTypeId="1" AcceptedAnswerId="2652" CreationDate="2018-06-25T07:13:55.123" Score="3" ViewCount="129" Body="&lt;p&gt;What quantum technologies and/or techniques (if any) could be used to evaluate the value of large numbers in the &lt;a href=&quot;https://googology.wikia.com/wiki/Introduction_to_the_fast-growing_hierarchy&quot; rel=&quot;nofollow noreferrer&quot;&gt;fast growing hierarchy&lt;/a&gt; such as &lt;a href=&quot;http://googology.wikia.com/wiki/TREE(3)&quot; rel=&quot;nofollow noreferrer&quot;&gt;Tree(3)&lt;/a&gt; or &lt;a href=&quot;http://googology.wikia.com/wiki/Subcubic_graph_number&quot; rel=&quot;nofollow noreferrer&quot;&gt;SCG(13)&lt;/a&gt;?&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-07-06T15:15:11.160" LastActivityDate="2018-07-06T15:20:03.390" Title="Quantum algorithm to evaluate numbers in fast growing hierarchy" Tags="&lt;quantum-algorithms&gt;&lt;randomised-benchmarking&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="1" />
  <row Id="2459" PostTypeId="2" ParentId="2456" CreationDate="2018-06-25T07:19:44.070" Score="6" Body="&lt;p&gt;I don't think you'll find a good visual representation. The Bloch sphere for a qubit is a particularly unique coincidence because the number of parameters to represent an arbitrary mixed state is only 1 more than the number of parameters required to represent an arbitrary pure state, and so the pure states can be thought of as the surface to a mixed state's volume.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A cube with Bloch spheres at the vertices is a fair representation if all 8 qubits remain separable at all times. However, you will get in a mess trying to represent entanglement in that picture (you'll need superpositions of several different separable states). As you've said, an arbitrary pure state of a qubyte has $2^8$ states, requiring $2^{16}-2$ real parameters to describe. 8 (pure) Bloch states give you access to only 16 parameters. You're probably best sticking to a complex vector of $2^8$ elements (minus 2 real parameters for global phase and normalisation).&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-25T07:19:44.070" CommentCount="3" />
  <row Id="2460" PostTypeId="2" ParentId="2443" CreationDate="2018-06-25T07:47:28.560" Score="4" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;How is a single qubit in a Bell state $\frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)$ any different from a classical coin spinning in the air (on being tossed)?&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;For both of them, the probability of getting heads is 1/2&#xA;  and getting tails is also 1/2 (we can assume that heads$\equiv|1\rangle$ and tails$\equiv|0\rangle$ and that we are &quot;measuring&quot; in the heads-tails basis).&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;For &lt;em&gt;any&lt;/em&gt; 1-qubit state $|\psi\rangle$, if all you do is measure it in the computational basis, you will always be able to explain it in terms of a probability distribution p(heads)$=|\langle 0|\psi\rangle|^2$ and p(tails)$=|\langle 1|\psi\rangle|^2$. The key differences are in using different bases and/or performing unitary evolutions.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The classic example is the Mach-Zehnder interferometer. Think of it this way: any 1-bit probabilistic operation is described by a $2\times 2$ stochastic matrix (i.e. all columns sum to 1). Call it $P$. It is easy enough to show that &lt;strong&gt;there is no $P$ such that $P^2=X$&lt;/strong&gt;, where $X$ is the Pauli matrix (in other words, a NOT gate). Thus, there is no probabilistic gate that can be considered the square-root of NOT. On the other hand, we can build such a device. A half-silvered mirror performs the square-root of not action.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A half-silvered mirror has two inputs (labelled 0 and 1) and two outputs (also labelled 0 and 1). Each input is a photon coming in a different direction, and it is either reflected or transmitted. If you just look at one half-silvered mirror, then whatever input you give, the output is 50:50 reflected or transmitted. It seems just like the coin you're talking about. However, if you put two of them together, if you input 0, or always get the output 1, and vice versa. The only way to explain this is with probability amplitudes, and a transition matrix that looks like&#xA;$$&#xA;U=\frac{1}{\sqrt{2}}\left(\begin{array}{cc}&#xA;1 &amp;amp; i \\ i &amp;amp; 1&#xA;\end{array}\right).&#xA;$$&#xA;&lt;strong&gt;In quantum mechanics, the square-root of not gate exists.&lt;/strong&gt;&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-25T07:47:28.560" CommentCount="9" />
  <row Id="2461" PostTypeId="2" ParentId="2388" CreationDate="2018-06-25T09:04:08.840" Score="0" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;What am I missing here? Where did the factor of $\frac{t}{2\pi}$ vanish in their algorithm?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Remember that in Dirac notation, whatever you write inside the ket is an arbitrary label referring to something more abstract. So, it is true that you are finding the (approximate) eigenvector to $U$, which has eigenvalue $e^{-i\lambda t}$ and therefore what you're extracting is $\lambda t/(2\pi)$, but that is the same as the eigenvector of $A$ with eigenvalue $\lambda$, and it is that which is being referred to in the notation. But if you wanted to be really clear, you could write it as&lt;/p&gt;&#xA;&#xA;&lt;p&gt;|approximate eigenvector of $U$ for which eigenvalue is $e^{-i\lambda t}$ and of $A$ for which eigenvalue if $\lambda\rangle$,&lt;/p&gt;&#xA;&#xA;&lt;p&gt;but perhaps instead of writing that out every time, we might just write $|\tilde\lambda\rangle$ for brevity!&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-25T09:04:08.840" CommentCount="0" />
  <row Id="2462" PostTypeId="2" ParentId="2393" CreationDate="2018-06-25T10:12:43.420" Score="2" Body="&lt;p&gt;$\newcommand{\bra}[1]{\left\langle#1\right|}\newcommand{\ket}[1]{\left|#1\right\rangle}\newcommand{\proj}[1]{|#1\rangle\langle#1|}\newcommand{\half}{\frac12}$In answer to your first question, I wrote myself some notes some time ago about my understanding of how it worked. The notation is probably a bit different (I've tried to bring it more into line, but it's easy to miss bits), but attempts to explain that choice of the state $|\Psi_0\rangle$. There also seem to be some factors of $\frac12$ floating around in places.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When we first study phase estimation, we're usually thinking about it in respect to use in some particular algorithm, such as Shor's algorithm. This has a specific goal: getting the best $t$-bit approximation to the eigenvalue. You either do, or you don't, and the description of phase estimation is specifically tuned to give as high a success probability as possible.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In HHL, we are trying to produce some state&#xA;$$&#xA;\ket{\phi}=\sum_j\frac{\beta_j}{\lambda_j}\ket{\lambda_j},&#xA;$$&#xA;where $\ket{b}=\sum_j\beta_j\ket{\lambda_j}$, making use of phase estimation. The accuracy of the approximation of this will depend far more critically on an accurate estimation of the eigenvalues that are close to 0 rather than those that are far from 0. An obvious step therefore, is to attempt to modify the phase estimation protocol so that rather than using `bins' of fixed width $2\pi/T$ for approximating the phases of $e^{-iAt}$ ($T=2^t$ and $t$ is number of qubits in phase estimation register), we might rather specify a set of $\phi_y$ for $y\in\{0,1\}^t$ to act as the centre of each bin so that we can have vastly increased accuracy close to 0 phase. More generally, you might specify a trade-off function for how tolerant you might be of errors as a function of the phase $\phi$. The precise nature of this function can then be tuned to a given application, and the particular figure of merit which you will use to determine success. In the case of Shor's algorithm, our figure of merit was simply this binning protocol -- we were successful if the answer was in the correct bin, and unsuccessful outside it. This is not going to be the case in HHL, whose success is more reasonably captured by a continuous measure such as the fidelity. So, for the general case, we shall designate a cost function $C(\phi,\phi')$ which specifies a penalty for answers $\phi'$ if the true phase is $\phi$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Recall that the standard phase estimation protocol worked by producing an input state that was the uniform superposition of all basis states $\ket{x}$ for $x\in\{0,1\}^t$. This state was used to control the sequential application of multiple controlled-$U$ gates, which are followed up by an inverse Fourier transform. Imagine we could replace the input state with some other state&#xA;$$&#xA;\ket{\Psi_0}=\sum_{x\in\{0,1\}^t}\alpha_x\ket{x},&#xA;$$&#xA;and then the rest of the protocol could work as before. For now, we will ignore the question of how hard it is to produce the new state $\ket{\Psi_0}$, as we are just trying to convey the basic concept. Starting from this state, the use of the controlled-$U$ gates (targeting an eigenvector of $U$ of eigenvalue $\phi$), produces the state&#xA;$$&#xA;\sum_{x\in\{0,1\}^t}\alpha_xe^{i\phi x}\ket{x}.&#xA;$$&#xA;Applying the inverse Fourier transform yields&#xA;$$&#xA;\frac{1}{\sqrt{T}}\sum_{x,y\in\{0,1\}^t}e^{ix\left(\phi-\frac{2\pi y}{M}\right)}\alpha_x\ket{y}.&#xA;$$&#xA;The probability of getting an answer $y$ (i.e. $\phi'=2\pi y/T$) is&#xA;$$&#xA;\frac{1}{T}\left|\sum_{x\in\{0,1\}^t}e^{ix\left(\phi-\frac{2\pi y}{T}\right)}\alpha_x\right|^2&#xA;$$&#xA;so the expected value of the cost function, assuming a random distribution of the $\phi$, is&#xA;$$&#xA;\bar C=\frac{1}{2\pi T}\int_0^{2\pi}d\phi\sum_{y\in\{0,1\}^t}\left|\sum_{x\in\{0,1\}^t}e^{ix\left(\phi-\frac{2\pi y}{T}\right)}\alpha_x\right|^2C(\phi,2\pi y/T),&#xA;$$&#xA;and our task is to select the amplitudes $\alpha_x$ that minimise this for any specific realisation of $C(\phi,\phi')$. If we make the simplifying assumption that $C(\phi,\phi')$ is only a function of $\phi-\phi'$, then we can make a change of variable in the integration to give&#xA;$$&#xA;\bar C=\frac{1}{2\pi}\int_0^{2\pi}d\phi\left|\sum_{x\in\{0,1\}^t}e^{ix\phi}\alpha_x\right|^2C(\phi),&#xA;$$&#xA;As we noted, the most useful measure is likely to be a fidelity measure. Consider we have a state $\ket{+}$ and we wish to implement the unitary $U_\phi=\proj{0}+e^{i\phi}\proj{1}$, but instead we implement $U_{\phi'}=\proj{0}+e^{i\phi'}\proj{1}$. The fidelity measures how well this achieves the desired task,&#xA;$$&#xA;F=\left|\bra{+}U_{\phi'}^\dagger U\ket{+}\right|^2=\cos^2\left(\frac{\phi-\phi'}{2}\right),&#xA;$$&#xA;so we take&#xA;$$&#xA;C(\phi-\phi')=\sin^2\left(\frac{\phi-\phi'}{2}\right),&#xA;$$&#xA;since in the ideal case $F=1$, so the error, which is what we want to minimise, can be taken as $1-F$.&#xA;This will certainly be the correct function for evaluating any $U^t$, but for the more general task of modifying the amplitudes, not just the phases, the effects of inaccuracies propagate through the protocol in a less trivial manner, so it is difficult to prove optimality, although the function $C(\phi-\phi')$ will already provide some improvement over the uniform superposition of states. Proceeding with this form, we have&#xA;$$&#xA;\bar C=\frac{1}{2\pi}\int_0^{2\pi}d\phi\left|\sum_{x\in\{0,1\}^t}e^{ix\phi}\alpha_x\right|^2\sin^2\left(\half\phi\right),&#xA;$$&#xA;The integral over $\phi$ can now be performed, so we want to minimise the function&#xA;$$&#xA;\half\sum_{x,y=0}^{T-1}\alpha_x\alpha_y^\star(\delta_{x,y}-\half\delta_{x,y-1}-\half\delta_{x,y+1}).&#xA;$$&#xA;This can be succinctly expressed as&#xA;$$&#xA;\min\bra{\Psi_0}H\ket{\Psi_0}&#xA;$$&#xA;where&#xA;$$&#xA;H=\half\sum_{x,y=0}^{T-1}(\delta_{x,y}-\half\delta_{x,y-1}-\half\delta_{x,y+1})\ket{x}\bra{y}.&#xA;$$&#xA;The optimal choice of $\ket{\Psi_0}$ is the minimum eigenvector of the matrix $H$,&#xA;$$&#xA;\alpha_x=\sqrt{\frac{2}{T+1}}\sin\left(\frac{(x+1)\pi}{T+1}\right),&#xA;$$&#xA;and $\bar C$ is the minimum eigenvalue&#xA;$$&#xA;\bar C=\half-\half\cos\left(\frac{\pi}{T+1}\right).&#xA;$$&#xA;Crucially, for large $T$, $\bar C$ scales as $1/T^2$ rather than the $1/T$ that we would have got from the uniform coupling choice $\alpha_x=1/\sqrt{T}$. This yields a significant benefit for the error analysis.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you want to get the same $|\Psi_0\rangle$ as reported in the HHL paper, I believe you have to add the terms $-\frac14\left(\ket{0}\bra{T-1}+\ket{T-1}\bra{0}\right)$ to the Hamiltonian. I have no justification for doing so, however, but this is probably my failing.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-06-27T06:24:21.060" LastActivityDate="2018-06-27T06:24:21.060" CommentCount="0" />
  <row Id="2463" PostTypeId="2" ParentId="2440" CreationDate="2018-06-25T14:13:39.203" Score="2" Body="&lt;p&gt;Strictly, it's never necessary to measure in different bases, because any projective measurement can be decomposed as a unitary followed by a projective measurement in the computational basis. Conversely, there are times when algorithms are described as unitaries followed by measurements in the computational basis, and you might choose to move some of those unitaries into a description of the basis.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The point I'm trying to make here is that the division between measurement and the rest of an algorithm is fairly arbitrary, so to get to the heart of your question, we really have to ask about the importance of relative phases inside a quantum algorithm. These are absolutely crucial, as these are what provide for the constructive and destructive interference that permit outcomes different from classical computation. Take a look at &lt;a href=&quot;https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm#Deutsch&amp;#39;s_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;Deutsch's algorithm&lt;/a&gt; for the simplest, 1 qubit, example. This is usually described as -prepare $|0\rangle$ state, Hadamard, function evaluation, Hadamard, measure in computational basis- but you could describe it as -prepare $|+\rangle$ state, function evaluation,measure in $|\pm\rangle$ basis-. The function evaluation, the thing you really want to get at, is entirely encoded in the relative phase between the two states.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To give one extreme example, consider &lt;a href=&quot;https://en.wikipedia.org/wiki/One-way_quantum_computer&quot; rel=&quot;nofollow noreferrer&quot;&gt;measurement-based quantum computation&lt;/a&gt;. Here, we produce a standard quantum state, and the computation to be performed is entirely defined by the choice of single-qubit measurements that are performed.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-25T14:13:39.203" CommentCount="2" />
  <row Id="2464" PostTypeId="2" ParentId="2439" CreationDate="2018-06-25T15:09:49.790" Score="2" Body="&lt;p&gt;It's not possible to create the initial states $\left| \Psi_0\right&amp;gt;$ and $\left|b\right&amp;gt;$ on the IBM 16 qubits version. On the other hand, it is possible to approximate them with an arbitrarily low error&lt;sup&gt;1&lt;/sup&gt; as the gates implemented by the IBM chips offer this possibility.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here you ask for 2 different quantum states:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;$\left| b \right&amp;gt;$ is not restricted at all. The state $\left| b \right&amp;gt;$ is represented by a vector of $N$ complex numbers that can be anything (as long as the vector has unitary norm).&lt;/li&gt;&#xA;&lt;li&gt;$\left| \Psi_0 \right&amp;gt;$ can be seen as a special case of $\left| b \right&amp;gt;$, where the coefficients $b_i$ are more constrained. &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;With this analysis, any method that can be used for creating $\left|b\right&amp;gt;$ can also be used to create $\left| \Psi_0 \right&amp;gt;$. On the other hand, as $\left| \Psi_0 \right&amp;gt;$ is more constrained, we can hope that there exists more efficient algorithms to produce $\left| \Psi_0 \right&amp;gt;$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Useful for $\left|b\right&amp;gt;$ and $\left|\Psi_0\right&amp;gt;$&lt;/strong&gt;: Based on &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0406176v5&quot; rel=&quot;nofollow noreferrer&quot;&gt;Synthesis of Quantum Logic Circuits (Shende, Bullock &amp;amp; Markov, 2006)&lt;/a&gt;, the QISKit Python SDK implements a generic method to initialize an arbitrary quantum state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Useful for $\left|\Psi_0\right&amp;gt;$&lt;/strong&gt;: &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0208112&quot; rel=&quot;nofollow noreferrer&quot;&gt;Creating superpositions that correspond to efficiently integrable probability distributions (Grover &amp;amp; Rudolph, 2002)&lt;/a&gt; presents quickly an algorithm to initialise a state whose amplitudes represents a probability distribution respecting some constraints. These constraints are respected for $\left|\Psi_0\right&amp;gt;$ according to &lt;a href=&quot;https://arxiv.org/abs/0811.3171&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum algorithm for solving linear systems of equations (Harrow, Hassidim &amp;amp; Lloyd, 2009)&lt;/a&gt;, last line of page 5.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For the implementation on QISKit, here is a sample to initialise a given quantum state:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import qiskit&#xA;&#xA;statevector_backend = qiskit.get_backend('local_statevector_simulator')&#xA;&#xA;###############################################################&#xA;# Make a quantum program for state initialization.&#xA;###############################################################&#xA;qubit_number = 5&#xA;Q_SPECS = {&#xA;    &quot;name&quot;: &quot;StatePreparation&quot;,&#xA;    &quot;circuits&quot;: [&#xA;        {&#xA;            &quot;name&quot;: &quot;initializerCirc&quot;,&#xA;            &quot;quantum_registers&quot;: [{&#xA;                &quot;name&quot;: &quot;qr&quot;,&#xA;                &quot;size&quot;: qubit_number&#xA;            }],&#xA;            &quot;classical_registers&quot;: [{&#xA;                &quot;name&quot;: &quot;cr&quot;,&#xA;                &quot;size&quot;: qubit_number&#xA;            }]},&#xA;    ],&#xA;}&#xA;Q_program = qiskit.QuantumProgram(specs=Q_SPECS)&#xA;&#xA;## State preparation&#xA;import numpy as np&#xA;from qiskit.extensions.quantum_initializer import _initializer&#xA;&#xA;def psi_0_coefficients(qubit_number: int):&#xA;    T = 2**qubit_number&#xA;    tau = np.arange(T)&#xA;    return np.sqrt(2 / T) * np.sin(np.pi * (tau + 1/2) / T)&#xA;&#xA;def get_coeffs(qubit_number: int):&#xA;    # Can be changed to anything, the initialize function will take&#xA;    # care of the initialisation.&#xA;    return np.ones((2**qubit_number,)) / np.sqrt(2**qubit_number)&#xA;    #return psi_0_coefficients(qubit_number)&#xA;&#xA;circuit_prep = Q_program.get_circuit(&quot;initializerCirc&quot;)&#xA;qr = Q_program.get_quantum_register(&quot;qr&quot;)&#xA;cr = Q_program.get_classical_register('cr')&#xA;coeffs = get_coeffs(qubit_number)&#xA;_initializer.initialize(circuit_prep, coeffs, [qr[i] for i in range(len(qr))])&#xA;&#xA;res = qiskit.execute(circuit_prep, statevector_backend).result()&#xA;statevector = res.get_statevector(&quot;initializerCirc&quot;)&#xA;print(statevector)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;1&lt;/sup&gt;Here &quot;error&quot; refers to the error between the ideal state and the approximation when dealing with a perfect quantum computer (i.e. no decoherence, no gate error).&lt;/p&gt;&#xA;" OwnerUserId="1386" LastEditorUserId="1386" LastEditDate="2018-06-26T08:17:42.790" LastActivityDate="2018-06-26T08:17:42.790" CommentCount="0" />
  <row Id="2465" PostTypeId="2" ParentId="2425" CreationDate="2018-06-25T15:38:18.587" Score="1" Body="&lt;p&gt;There is no &lt;em&gt;a priori&lt;/em&gt; reason why an entanglement monotone should have this property. I think the particular issue is that, restricting to pure states, when you start to look at multiparticle states, you get inequivalent states. For example, for 3 qubits, the W state and GHZ state are inequivalent, and both are maximally entangled representatives for their SLOCC equivalence class (stochastic local operations and classical communication). There's no particular reason that an entanglement monotone should always favour GHZ (the AME(3,2)) over W-state. Indeed, they don't. Looking through the list of &lt;a href=&quot;https://en.wikipedia.org/wiki/Multipartite_entanglement#Multipartite_entanglement_measures_for_pure_states&quot; rel=&quot;nofollow noreferrer&quot;&gt;common multipartite entanglement monotones&lt;/a&gt; on Wikipedia, the one that stands out to me is the &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0007081&quot; rel=&quot;nofollow noreferrer&quot;&gt;Schmidt Measure&lt;/a&gt;. It has value $\log_2(3)$ for a W state and one a value 1 for the GHZ state, so the AME is not maximally entangled by this measure.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-25T15:38:18.587" CommentCount="0" />
  <row Id="2466" PostTypeId="1" AcceptedAnswerId="2468" CreationDate="2018-06-26T01:54:44.063" Score="5" ViewCount="167" Body="&lt;p&gt;&lt;strong&gt;How could a $\sqrt{SWAP}$ circuit be expressed in terms of CNOT gates &amp;amp; single qubit rotations?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/RkZvk.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/RkZvk.png&quot; alt=&quot;CNOT &amp;amp; SQRT of SWAP&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CNOT &amp;amp; $\sqrt{SWAP}$ Gates&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Any quantum circuit can be simulated to an arbitrary degree of accuracy using a combination of CNOT gates and single qubit rotations. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Controlled_NOT_gate&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://en.wikipedia.org/wiki/Controlled_NOT_gate&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Both CNOT and $\sqrt{SWAP}$ are universal two-qubit gates and can be transformed into each other.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_logic_gate#Universal_quantum_gates&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://en.wikipedia.org/wiki/Quantum_logic_gate#Universal_quantum_gates&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The questions are not identical, and are likely to attract different audiences. -DaftWullie &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Can the difference be regarded as applied vs theoretic?&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-06-26T07:50:53.313" LastActivityDate="2018-06-26T09:08:36.643" Title="Expressing &quot;Square root of Swap&quot; gate in terms of CNOT" Tags="&lt;quantum-gate&gt;&lt;universal-gates&gt;&lt;gate-synthesis&gt;&lt;controlled-gates&gt;" AnswerCount="2" CommentCount="5" />
  <row Id="2467" PostTypeId="2" ParentId="2444" CreationDate="2018-06-26T03:11:25.767" Score="0" Body="&lt;p&gt;It seems that there's a fairly convincing argument now that even if P = NP, BQP is a separate complexity class: &lt;a href=&quot;https://eccc.weizmann.ac.il/report/2018/107/&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://eccc.weizmann.ac.il/report/2018/107/&lt;/a&gt; &lt;/p&gt;&#xA;" OwnerUserId="2763" LastActivityDate="2018-06-26T03:11:25.767" CommentCount="1" />
  <row Id="2468" PostTypeId="2" ParentId="2466" CreationDate="2018-06-26T06:59:32.620" Score="5" Body="&lt;p&gt;As pointed out by @Nelimee, this question is essentially answered in &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/2228/1837&quot;&gt;this question&lt;/a&gt;, even if that question seems more specific. However, for the sake of completeness... (Note that I make no claims about minimality of construction with respect to, for example, number of controlled-not gates.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's start with a unitary matrix for the square root of SWAP:&#xA;$$&#xA;\left(&#xA;\begin{array}{cccc}&#xA; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; \frac{1}{2}+\frac{i}{2} &amp;amp; \frac{1}{2}-\frac{i}{2} &amp;amp; 0 \\&#xA; 0 &amp;amp; \frac{1}{2}-\frac{i}{2} &amp;amp; \frac{1}{2}+\frac{i}{2} &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\&#xA;\end{array}&#xA;\right)&#xA;$$&#xA;Note that if we pre- and post-multiply by a controlled NOT, controlled off qubit 2, this transforms into the form of a controlled-$U$ gate:&#xA;$$&#xA;\left(&#xA;\begin{array}{cccc}&#xA; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; \frac{1}{2}+\frac{i}{2} &amp;amp; \frac{1}{2}-\frac{i}{2} \\&#xA; 0 &amp;amp; 0 &amp;amp; \frac{1}{2}-\frac{i}{2} &amp;amp; \frac{1}{2}+\frac{i}{2} \\&#xA;\end{array}&#xA;\right)&#xA;$$&#xA;There are standard constructions for this controlled-$U$ gate. So, overall, we have a circuit that looks like&#xA;&lt;a href=&quot;https://i.stack.imgur.com/wXWk3.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/wXWk3.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&#xA;where $ABC=\mathbb{I}$ and $AXBXC=e^{i\pi/4}\sqrt{X}$. Again, there are standard routes towards finding $A$, $B$ and $C$. For instance, we can define $R_Y(\theta)$ to be a rotation about the $Y$ axis by an angle $\theta$, i.e. $R_Y(\theta)=e^{i\theta Y}$ (there may be a factor of $\frac12$ here compared to some definitions). Then, if&#xA;$$&#xA;A=R_Y(\theta)R_Z(\phi)\qquad B=R_Z(-2\phi)\qquad C=R_Z(\phi)R_Y(-\theta),&#xA;$$&#xA;then it's easy to verify that $ABC=\mathbb{I}$. Furthermore, $AXBXC=R_Y(\theta)R_Z(4\phi)R_Y(-\theta)$ since $XR_Z(\phi)X=R_Z(-\phi)$. You can think of this as $R_Z(4\phi)$ specifying the eigenvalues that we want, and the $R_Y(\theta)$ is changing the basis from the computational basis into something else. In the present case, we have $\theta=\pi/2$ and $4\phi=\pi/4$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The one little thing that we haven't got right yet is a phase factor. Our $AXBXC$ is creating the correct rotation up to an overall phase of $e^{i\pi/4}$:&#xA;$$&#xA;\left(&#xA;\begin{array}{cccc}&#xA; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\&#xA; 0 &amp;amp; 0 &amp;amp; \frac{1}{\sqrt{2}} &amp;amp; -\frac{i}{\sqrt{2}} \\&#xA; 0 &amp;amp; 0 &amp;amp; -\frac{i}{\sqrt{2}} &amp;amp; \frac{1}{\sqrt{2}} \\&#xA;\end{array}&#xA;\right)&#xA;$$&#xA;The trick to get this right is to apply an $R_Z(\pi/8)$ on the first qubit and remove a global phase of $e^{i\pi/8}$. Thus, we have&#xA;&lt;a href=&quot;https://i.stack.imgur.com/fsQ9U.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/fsQ9U.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-26T06:59:32.620" CommentCount="0" />
  <row Id="2469" PostTypeId="1" CreationDate="2018-06-26T07:34:08.697" Score="6" ViewCount="69" Body="&lt;p&gt;Let there be a known a scheme (quantum circuit) of Controlled-G, where unitary gate G has G$^†$ such that G≠G$^†$ and GG$^†$=I (for example S and S$^†$, T and T$^†$, V and V$^†$, but not Pauli and H gates).  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question for the experts is:  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;How is correct that new scheme of Controlled-G$^†$ gate may be constructed from this known scheme of Controlled-G gate by reversing the order of used gates (U) and each U in this scheme changes to the corresponding U$^†$&#xA;(if U≠U$^†$ of course)?  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, see below my OPENQASM-program (note that suffix 'dg' for gate name is used instead '$^†$'in OPENQASM), where it is used well-known scheme of Controlled-S gate and my scheme of Controlled-S$^†$ gate, constructed from this well-known scheme by the above method.&lt;br&gt;&#xA;So far I have only received successful results of applying this method and have not found any obvious contradictions with the &lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.52.3457&quot; rel=&quot;noreferrer&quot;&gt;known theory&lt;/a&gt; &lt;sup&gt;[*]&lt;/sup&gt;, but suddenly I didn't take something into account.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My program in OPENQASM for example:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//Name of Experiment: Amy Matthew controlled-s and my controlled-sdg gates v7&#xA;OPENQASM 2.0; &#xA;include &quot;qelib1.inc&quot;;&#xA;qreg q[3];&#xA;creg c[3];&#xA;gate cs a,b {&#xA;// a is control, b is target&#xA;// see https//uwspace.uwaterloo.ca/bitstream/handle/10012/7818/AmyMatthew.pdf&#xA;// fig.4.6b&#xA;cx b,a;&#xA;tdg a;&#xA;cx b,a;&#xA;t a;&#xA;t b;&#xA;}&#xA;gate csdg a,b {&#xA;// a is control, b is target&#xA;// my controlled-sdg (I hope that is reverse of controlled-s)&#xA;tdg b;&#xA;tdg a;&#xA;cx b,a;&#xA;t a;&#xA;cx b,a;&#xA;}&#xA;&#xA;h q[0];&#xA;cx q[0],q[1]&#xA;;&#xA;x q[2];&#xA;h q[2];&#xA;barrier q;&#xA;cs q[0],q[2];&#xA;cs q[1],q[2];&#xA;barrier q;&#xA;csdg q[0],q[2];&#xA;csdg q[1]&#xA;&#xA;,q[2];&#xA;&#xA;barrier q;&#xA;h q[2];&#xA;measure q -&amp;gt; c; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/sH9if.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/sH9if.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[*]: &lt;em&gt;Elementary gates for quantum computation&lt;/em&gt; Barenco &lt;em&gt;et al.&lt;/em&gt; (1995)&lt;/p&gt;&#xA;" OwnerUserId="2764" LastEditorUserId="26" LastEditDate="2018-06-26T08:14:32.283" LastActivityDate="2018-06-26T09:00:16.507" Title="Construct Controlled-$G^{\dagger}$ from known Controlled-$G$" Tags="&lt;quantum-algorithms&gt;&lt;ibm-q-experience&gt;&lt;qiskit&gt;&lt;controlled-gates&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="2470" PostTypeId="2" ParentId="2469" CreationDate="2018-06-26T07:46:05.937" Score="3" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;How is correct that new scheme of Controlled-$G^\dagger$ gate may be constructed from this known scheme of Controlled-G gate by reversing the order of used gates ($U$) and each $U$ in this scheme changes to the corresponding $U^\dagger$ (if $U≠U^\dagger$ of course)?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;It's 100% correct:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Inverting a composed quantum gate is done with the algorithm you gave. You can check for example the &lt;a href=&quot;https://qiskit.org/documentation/_modules/qiskit/_compositegate.html#CompositeGate.inverse&quot; rel=&quot;nofollow noreferrer&quot;&gt;implementation of the &lt;code&gt;inverse()&lt;/code&gt; method in &lt;code&gt;qiskit.CompositeGate&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;def inverse(self):&#xA;    &quot;&quot;&quot;Invert this gate.&quot;&quot;&quot;&#xA;    # self.data is a list of the quantum gates composing the CompositeGate.&#xA;    self.data = [gate.inverse() for gate in reversed(self.data)]&#xA;    self.inverse_flag = not self.inverse_flag&#xA;    return self&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Inverting a controlled-gate boils down to apply the controlled-[inverse of this gate].&lt;/p&gt;&#xA;" OwnerUserId="1386" LastActivityDate="2018-06-26T07:46:05.937" CommentCount="0" />
  <row Id="2471" PostTypeId="2" ParentId="2469" CreationDate="2018-06-26T08:27:09.110" Score="2" Body="&lt;p&gt;If I understand the question correctly, you're assuming that you have some gate $V$ that you've decomposed as $\prod_{i=1}^NU_i$ and you want to show that $V^\dagger$ is $\prod_{i=1}^NU_{N+1-i}^\dagger$ where the product is taken in the opposite order?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In that case, you just need to show that $VV^\dagger=\mathbb{I}$ given that $U_iU_i^\dagger=\mathbb{I}$. You can do this directly using the stated decompositions above:&#xA;$$&#xA;VV^\dagger=(U_1U_n\ldots U_N)(U_N^\dagger\ldots U_2^\dagger U_1^\dagger)=U_1U_n\ldots U_{N-1}(U_NU_N^\dagger)U_{N-1}^\dagger\ldots U_2^\dagger U_1^\dagger&#xA;$$&#xA;and so on.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This solution is completely general, and does not need to make any assumptions about the form of the original unitary $V$.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-06-26T09:00:16.507" LastActivityDate="2018-06-26T09:00:16.507" CommentCount="4" />
  <row Id="2472" PostTypeId="2" ParentId="2466" CreationDate="2018-06-26T09:08:36.643" Score="3" Body="&lt;p&gt;I think that you want answers to explicitly use full cnots, rather than partial versions. But since you already have an answer for that, I'll contribute a different perspective.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A $SWAP$ can be thought of as a cnot that has been conjugated by oppositely oriented cnots.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ SWAP = {\rm cx}(k,j) \,\, {\rm cx}(j,k) \,\, {\rm cx}(k,j) $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To make a $\sqrt{SWAP}$, we can instead use a square root of cnot conjugated by oppositely oriented cnots.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ \sqrt{SWAP} = {\rm cx}(k,j) \,\, \sqrt{{\rm cx}(j,k)} \,\, {\rm cx}(k,j) $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To verify that this is indeed a $\sqrt{SWAP}$, you can simply square it and verify that it ends up in the way we expect (using the fact that cnots square to identity).&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-06-26T09:08:36.643" CommentCount="1" />
  <row Id="2473" PostTypeId="1" AcceptedAnswerId="2474" CreationDate="2018-06-26T09:16:44.673" Score="3" ViewCount="98" Body="&lt;p&gt;Reproduced from Exercise 2.3 of Nielsen &amp;amp; Chuang's &lt;em&gt;Quantum Computation and Quantum Information (10th Anniversary Edition)&lt;/em&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Suppose $A$ is a linear operator from vector space $V$ to vector space $W$, and $B$ is a linear operator from vector space $W$ to vector space $X$. Let $|v_i⟩$, $|w_j⟩$, and $|x_k⟩$ be bases for the vector spaces $V$, $W$, and $X$, respectively. Show that the matrix representation for the linear transformation $BA$ is the matrix product of the matrix representations for $B$ and $A$, with respect to the appropriate bases.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Note: This question is part of a series attempting to provide worked solutions to the exercises provided in the above book. For a list of all exercises added so far, see &lt;a href=&quot;https://quantumcomputing.stackexchange.com/tags/nielsen-and-chuang/info&quot;&gt;here&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;" OwnerUserId="391" LastActivityDate="2018-06-26T11:18:58.797" Title="Nielsen &amp; Chuang Exercise 2.3 - “Matrix representation for operator products”" Tags="&lt;quantum-gate&gt;&lt;matrix-representation&gt;&lt;nielsen-and-chuang&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="2474" PostTypeId="2" ParentId="2473" CreationDate="2018-06-26T10:28:02.057" Score="4" Body="&lt;p&gt;Consider the linear maps $A: V\to W$ and $B: W\to X$. The composition $BA$ is a linear map from $V$ to $X$. Now, how can $\mathcal{M}(BA)$ be computed from $\mathcal{M}(B)$ and $\mathcal{M}(A)$? $\mathcal{M}(A)$ is the $n\times p$ matrix representation of the linear map $A$ w.r.t the basis $\{v_1,...,v_p\}$ and $\{w_1,...,w_n\}$. $\mathcal{M}(B)$ is the $m\times n$ matrix representation of the linear map $B$ w.r.t the basis $\{w_1,...,w_n\}$ and $\{x_1,...,x_m\}$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Say, $\mathcal{M}(A) = \begin{bmatrix}a_{11} &amp;amp; ... &amp;amp; a_{1p}\\... &amp;amp; ... &amp;amp; ...\\a_{n1} &amp;amp; ... &amp;amp;a_{np}\end{bmatrix}$ &amp;amp; $\mathcal{M}(B) = \begin{bmatrix}b_{11} &amp;amp; ... &amp;amp; b_{1n}\\... &amp;amp; ... &amp;amp; ...\\b_{m1} &amp;amp; ... &amp;amp;b_{mn}\end{bmatrix}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, let's see the action of the linear map $BA$ on a certain basis vector of $V$, say $v_k$ (as it is sufficient to just know the action of any linear transformation on the basis vectors, in order to determine the transformation):&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\therefore BA(v_k)=B(\sum_{r=1}^{n} a_{r,k}w_r)$$&#xA;$$= \sum_{r=1}^{n}a_{r,k}Bw_r$$&#xA;$$= \sum_{r=1}^{n}a_{r,k}\sum_{j=1}^{m}b_{j,r}x_j$$&#xA;$$= \sum_{j=1}^{m}(\sum_{r=1}^{n}b_{j,r}a_{r,k})x_j$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thus, $\mathcal{M}(BA)$ is the $m\times p$ matrix whose entry in row $j$, column $k$ equals $\sum_{r=1}^{n}b_{j,r}a_{r,k}$. This is exactly equal to the $j,k$-th element of the matrix we get after multiplying $\mathcal{M}(B)$ and $\mathcal{M}(A)$. Hence, &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;$$\mathcal{M}(BA)=\mathcal{M}(B)\mathcal{M}(A)$$&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: I've omitted the ket notation given in the original question, for ease of typing. By default, $|v_i\rangle = v_i,|w_j\rangle = w_j$ and $|x_k\rangle = x_k$ for indices $i,j,k$.&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-06-26T11:18:58.797" LastActivityDate="2018-06-26T11:18:58.797" CommentCount="0" />
  <row Id="2475" PostTypeId="1" CreationDate="2018-06-26T16:10:50.620" Score="5" ViewCount="113" Body="&lt;p&gt;Suppose we have any matrix in $\mathrm U(2)$ and we need to construct a Controlled-$U$ operation with the $H,T,S$ gates. Then I am aware of the construction given in N&amp;amp;C of decomposing $U$ into $e^{ia}AXBXC$. My question is how to implement gates $A,B,C$ using the gates from library set $\left\lbrace H,T,S,X,Y,Z\right\rbrace$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Also, any sequence of the gates induces some phase to the matrix (while $A,B,C \in \mathrm{SU}(2)$), so how is that phase removed from the circuit?&lt;/p&gt;&#xA;" OwnerUserId="2770" LastEditorUserId="23" LastEditDate="2018-06-26T16:59:39.223" LastActivityDate="2018-06-27T08:41:52.177" Title="Controlled-U operation in IBMQ" Tags="&lt;quantum-gate&gt;&lt;ibm-q-experience&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="2476" PostTypeId="2" ParentId="2456" CreationDate="2018-06-26T16:43:23.640" Score="2" Body="&lt;p&gt;For a pure state of 8 qubits, the Hilbert space is $2^8$ dimensional. Dropping the normalization and phase information means you are left with the space $\mathbb{CP}^{2^8-1}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Unlike a single qubit which give the Bloch sphere $\mathbb{CP}^{2^1-1}$, this is too big to draw directly. Instead one usually draws simpler spaces that capture the essential features. This is thanks to the fact that these spaces are &lt;a href=&quot;https://en.wikipedia.org/wiki/Toric_variety&quot; rel=&quot;nofollow noreferrer&quot;&gt;toric varieties&lt;/a&gt;. The example of how to draw $\mathbb{CP}^2$ as a triangle with tori above each point is given there. What this amounts to is remembering only the amplitudes first and then realizing that you forgot the phases and fixing that later.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So instead of drawing a line segment (a 1-cube) as you would for a single qubit, you would have to draw a $2^8-1$ simplex. Of course you can't do that, but you can project onto planes that you can draw several 2 dimensional pictures for. So this draws only certain linear combinations of probabilities for the $2^8$ basis states. Do several of these.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A lot of information is lost, because you couldn't draw the full $2^8-1$ complex dimensional ($2^{16}-2$ real dimensional) thing, but by throwing away information about phases and only taking certain linear combinations of probabilities, you get something you can visualize. Also you know what sort of structure you forgot along the way. Like when going from the point on the simplex back to the full complex projective space, you lost all the phases. You can draw those as points on the circle as usual, so you can recover the full information from those two diagrams.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you want to say that some of the qubits are separable from others, then you get $\mathbb{CP}^{2^n-1} \times \mathbb{CP}^{2^m-1}$ where $n+m=8$. This is also toric and so also has a polytope that replaces the $2^8-1$ simplex. If you want it fully separable this would be $\mathbb{CP}^{2^1-1} \times \cdots \mathbb{CP}^{2^1-1}$ 8 times. The polytope that replaces the $2^8-1$ simplex there is a product of 8 1-cubes as already mentioned. Again above this polytope are some phases you lost along the way, but those are easy to draw in an accompanying diagram.&lt;/p&gt;&#xA;" OwnerUserId="434" LastActivityDate="2018-06-26T16:43:23.640" CommentCount="0" />
  <row Id="2477" PostTypeId="1" AcceptedAnswerId="2478" CreationDate="2018-06-26T16:52:18.747" Score="4" ViewCount="120" Body="&lt;p&gt;How to implement the phase shift gate in qiskit or ibmq?&#xA;Phase Shift Gate : $$\begin{pmatrix}e^{ia} &amp;amp;&amp;amp; 0 \\ 0 &amp;amp;&amp;amp; e^{ia}\end{pmatrix} = e^{ia}I$$&lt;/p&gt;&#xA;" OwnerUserId="2771" LastEditorUserId="23" LastEditDate="2018-06-26T17:04:25.140" LastActivityDate="2018-06-26T17:05:56.987" Title="Phase-Shift Gate in Qiskit" Tags="&lt;ibm-q-experience&gt;&lt;qiskit&gt;" AnswerCount="1" CommentCount="1" FavoriteCount="1" />
  <row Id="2478" PostTypeId="2" ParentId="2477" CreationDate="2018-06-26T17:05:56.987" Score="7" Body="&lt;p&gt;You can implement the phase shift gate&#xA;$$R_{zz}(\theta) = \begin{pmatrix}e^{i\theta} &amp;amp; 0\\0 &amp;amp; e^{i\theta}\end{pmatrix}$$&#xA;with the &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;u1&lt;/code&gt; gate from the IBM Q chips:&#xA;$$ \begin{align}&#xA;R_{zz}(\theta) &amp;amp;= U_1(\theta)\ X\ U_1(\theta)\ X \\&#xA;&amp;amp;= \begin{pmatrix}1 &amp;amp; 0\\0 &amp;amp; e^{i\theta}\end{pmatrix} \begin{pmatrix}0 &amp;amp; 1\\1 &amp;amp; 0\end{pmatrix} \begin{pmatrix}1 &amp;amp; 0\\0 &amp;amp; e^{i\theta}\end{pmatrix} \begin{pmatrix}0 &amp;amp; 1\\1 &amp;amp; 0\end{pmatrix} \\&#xA;&amp;amp;= \begin{pmatrix}0 &amp;amp; 1\\e^{i\theta} &amp;amp; 0\end{pmatrix}\begin{pmatrix}0 &amp;amp; 1\\e^{i\theta} &amp;amp; 0\end{pmatrix} \\&#xA;&amp;amp;= \begin{pmatrix}e^{i\theta} &amp;amp; 0\\0 &amp;amp; e^{i\theta}\end{pmatrix}&#xA;\end{align}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;def Rzz(quantum_circuit, theta, qubit):&#xA;    quantum_circuit.u1(theta, qubit)&#xA;    quantum_circuit.x(qubit)&#xA;    quantum_circuit.u1(theta, qubit)&#xA;    quantum_circuit.x(qubit)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;implements the $R_{zz}$ gate on QISKit.&lt;/p&gt;&#xA;" OwnerUserId="1386" LastActivityDate="2018-06-26T17:05:56.987" CommentCount="0" />
  <row Id="2479" PostTypeId="2" ParentId="2446" CreationDate="2018-06-26T19:45:46.920" Score="3" Body="&lt;p&gt;There is an analogue to shadowgraphy which shows up in quantum information, which is the phase-space representation of quantum states via the Wigner function.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Wigner function W(q,p) is a phase-space representation of quantum states of a single particle, which gives the quantum mechanical probability distributions for position measurements, momentum measurements, and in general for any quadrature observable (i.e. linear combinations of position and momentum). For a general introduction, check this link:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Wigner_quasiprobability_distribution&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://en.wikipedia.org/wiki/Wigner_quasiprobability_distribution&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;These marginal distributions can be interpreted as a shadow of the quantum state along a direction specified by which quadrature is measured. Interestingly, there are quantum states for which the Wigner function may be negative in some phase-space regions! This is an indication of non-classicality, as the multiple &quot;shadows&quot; fail to make sense together: each shadow is a sensible probability distribution, but the &quot;object&quot; that casts the shadows is a phase-space distribution without direct interpretation in terms of probabilities (as it can be negative in some regions).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;At least for some definitions of discrete Wigner functions (useful for describing states in finite-dimensional Hilbert spaces), this negativity has been linked to contextuality and advantage in quantum computation, as pointed out for example in these papers:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1201.1256&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/1201.1256&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/0710.5549&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/0710.5549&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="2558" LastActivityDate="2018-06-26T19:45:46.920" CommentCount="0" />
  <row Id="2480" PostTypeId="2" ParentId="2475" CreationDate="2018-06-26T21:24:09.683" Score="2" Body="&lt;p&gt;In general, it is not possible to implement every single-qubit operation exactly. However, it is possible to construct a quantum circuit whose action is approximately equal to this single-qubit operation. This can be done in many different ways, but I'm not sure if it is known which one is most efficient. I do not know of any &lt;em&gt;efficient&lt;/em&gt; way to construct such a circuit, however, there is a pretty inefficient method that is well-known. I'll leave it to the OP to decide if it is efficient enough for his/her purposes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Nielsen and Chuang explain one construction using just the $H$ and $T$ gates. This is done in chapter 4, especially in section 4.5.3. This section builds on earlier results of chapter 4, one of them being exercise 4.11. It is important to note that this exercise is wrong in some editions (have a look at the &lt;a href=&quot;http://www.michaelnielsen.org/qcqi/errata/errata/errata.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;errata&lt;/a&gt; if this is true for your edition). Another source that provides this construction is &lt;a href=&quot;https://bit.ly/2JVU8ro&quot; rel=&quot;nofollow noreferrer&quot;&gt;this&lt;/a&gt;, section 4.3, where the $\pi/8$-gate is just a different notation for the $T$-gate.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The construction is difficult to present concisely in this answer. The main idea is to consider the following two gate sequences $HTHT$ and $THTH$. These two gate sequences can be visualized as rotations in the Bloch sphere, where the angle of rotation is an irrational multiple of $\pi$ for both of these gate sequences. Consecutive applications of these two rotations are enough to implement any rotation, and hence the gate sequences $HTHT$ and $THTH$ can be used to construct any single-qubit gate.&lt;/p&gt;&#xA;" OwnerUserId="24" LastActivityDate="2018-06-26T21:24:09.683" CommentCount="0" />
  <row Id="2481" PostTypeId="2" ParentId="2242" CreationDate="2018-06-27T02:33:58.860" Score="2" Body="&lt;p&gt;In Qiskit you can compose two circuits to make a bigger circuit. You can do this simply by using the &lt;code&gt;+&lt;/code&gt; operator on the circuits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here is your program rewritten to illustrate this&#xA;(note: you need the latest version of Qiskit for this, upgrade with &lt;code&gt;pip install -U qiskit&lt;/code&gt;).&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;from qiskit import *&#xA;qr = QuantumRegister(2)&#xA;cr = ClassicalRegister(2)&#xA;qc1 = QuantumCircuit(qr, cr)&#xA;qc1.x(qr)&#xA;&#xA;qc2 = QuantumCircuit(qr, cr)&#xA;qc2.x(qr)&#xA;&#xA;qc3 = qc1 + qc2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;You can see that qc3 is a concatenation of q1 and q2.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;print(qc3.qasm())&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Yields:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;OPENQASM 2.0;&#xA;include &quot;qelib1.inc&quot;;&#xA;qreg q0[2];&#xA;creg c0[2];&#xA;x q0[0];&#xA;x q0[1];&#xA;x q0[0];&#xA;x q0[1];&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Now, you seem to want to probe the state twice: once where qc1 ends, and once when qc2 ends. You can do this in a simulator by inserting &lt;code&gt;snapshot&lt;/code&gt; commands. This will save the statevector at a given point in the circuit. It does not collapse the state.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;from qiskit.extensions.simulator import *&#xA;qc1.snapshot('0')    # save the snapshot in slot &quot;0&quot;&#xA;qc2.snapshot('1')    # save the snapshot in slot &quot;1&quot;&#xA;qc2.measure(qr, cr)  # measure to get final counts&#xA;&#xA;qc3 = qc1 + qc2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;You can now execute &lt;code&gt;qc3&lt;/code&gt; on a simulator. &lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;job = execute(qc3, 'local_qasm_simulator')&#xA;result = job.result()&#xA;print(result.get_snapshot('0'))&#xA;print(result.get_snapshot('1'))&#xA;print(result.get_counts())&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Yields:&#xA;    [0.+0.j 0.+0.j 0.+0.j 1.+0.j]&#xA;    [1.+0.j 0.+0.j 0.+0.j 0.+0.j]&#xA;    {'00': 1024}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So the state goes back to |00&gt; as expected.&lt;/p&gt;&#xA;" OwnerUserId="2503" LastActivityDate="2018-06-27T02:33:58.860" CommentCount="0" />
  <row Id="2483" PostTypeId="1" AcceptedAnswerId="2550" CreationDate="2018-06-27T03:13:05.430" Score="3" ViewCount="106" Body="&lt;p&gt;In &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0404107&quot; rel=&quot;nofollow noreferrer&quot;&gt;Realization of a photonic CNOT gate sufficient for quantum computation&lt;/a&gt; FIG. 1 there is a &quot;scheme to obtain a photonic realization of a CNOT gate with two independent qubits.&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;What components are needed to realize a photonic CNOT gate &lt;strike&gt;in &lt;a href=&quot;http://quantumgame.io/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Game with Photons&#xA;&lt;/a&gt;&lt;/strike&gt;?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strike&gt;See: &lt;em&gt;Adventures of a curious creature&lt;/em&gt;&lt;/strike&gt;&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-06-27T08:31:03.090" LastActivityDate="2018-07-02T06:39:00.593" Title="Components for realizing a photonic CNOT gate" Tags="&lt;quantum-gate&gt;&lt;quantum-programming&gt;&lt;universal-gates&gt;&lt;gate-synthesis&gt;&lt;controlled-gates&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="2484" PostTypeId="2" ParentId="2483" CreationDate="2018-06-27T06:23:00.370" Score="2" Body="&lt;p&gt;The original question was asking with respect to a particular &lt;a href=&quot;http://quantumgame.io/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Game&lt;/a&gt;. This quantum game only contains the elements of &lt;em&gt;linear optics&lt;/em&gt;, not all optics, so it was basically asking how CNot can be realised with linear optical elements.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This cannot be done with 100% efficiency. However, there are schemes that allow it to work in a heralded way, i.e. it works sometimes, and you know if it's worked. One of the best known schemes is the &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2550/1837&quot;&gt;KLM scheme&lt;/a&gt;, which has since been described in more detail in the other answer. However, the efficiency can be very low. The other problem is that when the scheme fails, what happens to the information you tried to compute on? Depending on the scheme, it could be destroyed. A good way around this is with measurement-based quantum computation, where you can &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0509209&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;grow&quot; a resource state first&lt;/a&gt;, and only once you've been successful do you actually compute with it.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One recent experiment is described &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0404107&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;, and their main optical circuit is reproduced below:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/fLT5v.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/fLT5v.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, the linear optical elements are supplemented by the presence of an entangled pair of photons to enhance the success rate. I don't think the game currently has the capability of producing those: the typical way to get them is to introduce a non-linear crystal that splits a single photon into an entangled pair.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Another option is that instead of using two photons with qubits encoded in the respective polarisations (as in the previous case), you can encode two qubits using a single photon by combining path information (two possible paths) and polarisation. Then a polarising beam splitter implements what you're after: there are two inputs, 0 and 1. If the input is one polarisation (say H), the input is transmitted, meaning that the output is the same as the input (so $\mathbb{I}$ is enacted on the path information). For the orthogonal polarisation (V), the input is reflected, so $X$ is enacted on the path information.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-07-02T06:39:00.593" LastActivityDate="2018-07-02T06:39:00.593" CommentCount="4" />
  <row Id="2485" PostTypeId="2" ParentId="2475" CreationDate="2018-06-27T08:41:52.177" Score="2" Body="&lt;p&gt;You asked for a decomposition using the $\left\lbrace H,T,S,X,Y,Z\right\rbrace$. I assume that's because you think that's all that IBMQ offers. However, it is also possible to do rotations around the $x$, $y$ and $z$ axes, which make things a lot easier.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Any single qubit unitary matrix may be decomposed as a sequence of rotations around two, non-parallel axes. For example&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$U = e^{i\alpha}&#xA;\,\,&#xA;R_z(\beta)&#xA;\,\,&#xA;R_y(\gamma)&#xA;\,\,&#xA;R_z(\delta)&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here the global phase $\alpha$ has no physical effects, and can be ignored. The $\beta$ and $\delta$ are angles of rotation around the $z$ axis, and $\gamma$ is the angle for the $y$ axis.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The $z$ axes rotation is called &lt;code&gt;U1&lt;/code&gt; on the IBM Q Experience and in QISKit. It takes a single parameter as an argument, which is the angle of rotation expressed in radians.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The $y$ axis rotation can be done using &lt;code&gt;U3&lt;/code&gt;. This takes three arguments. The first of which is the angle in radians for the $y$ rotation, and the other two should be set to zero.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So if you want to do a rotation with $\beta=0.1$, $\gamma=0.2$ and $\delta=0.3$, for example, this could be done using the QASM editor of the IBM Q Experience with&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;u1(0.3) q[0];&#xA;u3(0.2,0,0) q[0];&#xA;u1(0.1) q[0];&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;It can also be done using the composer. You just need to tick the 'advanced' checkbox to see these gates.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-06-27T08:41:52.177" CommentCount="0" />
  <row Id="2486" PostTypeId="1" AcceptedAnswerId="2497" CreationDate="2018-06-27T12:32:54.373" Score="8" ViewCount="129" Body="&lt;p&gt;Maybe it is a naive question, but I cannot figure out how to actually exponentiate a matrix in a quantum circuit.&#xA;Assuming to have a generic square matrix &lt;em&gt;A&lt;/em&gt;, if I want to obtain its exponential, $e^{A}$, i can use the series&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$e^{A} \simeq I+ A+\frac{A^2}{2!}+\frac{A^3}{3!}+...$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To have its approximation. I do not get how to do the same using quantum gates then apply it for instance to perform an Hamiltonian simulation. Some help?&lt;/p&gt;&#xA;" OwnerUserId="2648" LastActivityDate="2018-06-28T09:24:44.050" Title="How to implement a matrix exponential in a quantum circuit?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-gate&gt;&lt;matrix-representation&gt;&lt;hamiltonian-simulation&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="3" />
  <row Id="2487" PostTypeId="1" AcceptedAnswerId="2488" CreationDate="2018-06-27T12:40:32.250" Score="2" ViewCount="59" Body="&lt;p&gt;Reproduced from Exercise 2.4 of Nielsen &amp;amp; Chuang's &lt;em&gt;Quantum Computation and Quantum Information (10th Anniversary Edition)&lt;/em&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Show that the identity operator on a vector space $V$ has a matrix representation which is one along the diagonal and zero everywhere else, if the matrix representation is taken with respect to the same input and output bases. This matrix is known as the identity matrix.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Note: This question is part of a series attempting to provide worked solutions to the exercises provided in the above book. For a list of all exercises added so far, see &lt;a href=&quot;https://quantumcomputing.stackexchange.com/tags/nielsen-and-chuang/info&quot;&gt;here&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;" OwnerUserId="391" LastActivityDate="2018-06-27T15:04:26.587" Title="Nielsen &amp; Chuang Exercise 2.4 - “Matrix representation for identity”" Tags="&lt;matrix-representation&gt;&lt;nielsen-and-chuang&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="2488" PostTypeId="2" ParentId="2487" CreationDate="2018-06-27T15:04:26.587" Score="2" Body="&lt;p&gt;On a vector space $V = \textrm{span}(\{|v_1⟩, \ldots, |v_n⟩\})$, the identity operator $\mathcal{I}$ maps each vector to itself, such that &#xA;$$&#xA;\mathcal{I} = \sum_i |v_i⟩⟨v_i|.&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If $\{|v_1⟩, \ldots, |v_n⟩\}$ is chosen as the basis for the matrix representation, then we set&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;|v_1⟩ = \begin{pmatrix} 1 \\ 0 \\ \vdots \\ 0 \end{pmatrix}, \quad |v_2⟩ = \begin{pmatrix} 0 \\ 1 \\ \vdots \\ 0 \end{pmatrix}, \quad \cdots \quad |v_n⟩ = \begin{pmatrix} 0 \\ 0 \\ \vdots \\ 1 \end{pmatrix},&#xA;$$&lt;br&gt;&#xA;and $⟨v_1| = (|v_1⟩)^\dagger$ such that &#xA;$$&#xA;|v_1⟩⟨v_1| = \begin{pmatrix} 1 \\ 0 \\ \vdots \\ 0 \end{pmatrix} \otimes \begin{pmatrix} 1 &amp;amp; 0 &amp;amp; \cdots &amp;amp; 0 \end{pmatrix} = \textrm{diag}(1,0,\ldots,0) , \quad\textrm{etc}.&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Summing over all terms therefore produces the desired matrix&#xA;$$&#xA;\mathcal{I} = &#xA;\begin{pmatrix} &#xA;1 &amp;amp; 0 &amp;amp; \cdots &amp;amp; 0 \\ &#xA;0 &amp;amp; 1 &amp;amp; \cdots &amp;amp; 0 \\ &#xA;\vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\&#xA;0 &amp;amp; 0 &amp;amp; \cdots &amp;amp; 1 &#xA;\end{pmatrix}&#xA;$$&lt;/p&gt;&#xA;" OwnerUserId="391" LastActivityDate="2018-06-27T15:04:26.587" CommentCount="0" />
  <row Id="2489" PostTypeId="1" AcceptedAnswerId="2495" CreationDate="2018-06-27T20:17:54.900" Score="6" ViewCount="91" Body="&lt;p&gt;&lt;a href=&quot;https://medium.com/@decodoku/understanding-quantum-computers-through-a-simple-puzzle-game-a290dde89fb2&quot; rel=&quot;noreferrer&quot;&gt;Using a simple puzzle game to benchmark quantum computers&lt;/a&gt; is the most clever approach I have seen so far.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The author of the aforementioned article, &lt;a href=&quot;https://quantumcomputing.stackexchange.com/users/409/james-wootton&quot;&gt;James&lt;/a&gt;, makes a nice analogy to buying a laptop (&quot;more than just a single number when comparing&quot;) in an answer to &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1255/how-should-different-quantum-computing-devices-be-compared&quot;&gt;How should different quantum computing devices be compared?&lt;/a&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Another answer by &lt;a href=&quot;https://quantumcomputing.stackexchange.com/users/274/whurley&quot;&gt;whurley&lt;/a&gt; to the same question mentions the &lt;a href=&quot;https://standards.ieee.org/develop/project/7131.html&quot; rel=&quot;noreferrer&quot;&gt;IEEE Standard for Quantum Computing Performance Metrics &amp;amp; Performance Benchmarking&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/65/when-will-we-know-that-quantum-supremacy-has-been-reached&quot;&gt;When will we know that quantum supremacy has been reached?&lt;/a&gt; there is an answer by &lt;a href=&quot;https://quantumcomputing.stackexchange.com/users/124/niel-de-beaudrap&quot;&gt;Niel&lt;/a&gt; which includes this snippet:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;But the bottom line is that, yes, &quot;quantum supremacy&quot; is precisely about &quot;not being able to simulate quantum computers of certain sizes&quot;, or at least &lt;strong&gt;not being able to simulate certain specific processes that you can have them perform&lt;/strong&gt;, and &lt;strong&gt;&lt;em&gt;this benchmark&lt;/em&gt;&lt;/strong&gt; depends not only on quantum technology but on the best available classical technology and the best available classical techniques. It is a blurry boundary which, if we are being serious about things, we will only be confident that we have passed a year or two after the fact. But it is an important boundary to cross.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;My question is bipartite:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;What will be the &lt;strong&gt;primary metrics for quantum computers?&lt;/strong&gt; (Clasical examples include processor speed, RAM &amp;amp; hard drive space)&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Best tools / strategies for benchmarking&lt;/strong&gt;  above metrics? (Existing or proposed)&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="26" LastEditDate="2018-06-27T20:47:55.287" LastActivityDate="2018-06-28T07:36:10.777" Title="How to benchmark a quantum computer?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-supremacy&gt;&lt;randomised-benchmarking&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="2490" PostTypeId="1" AcceptedAnswerId="2494" CreationDate="2018-06-27T22:13:57.977" Score="3" ViewCount="68" Body="&lt;p&gt;On page 2 of the paper &lt;a href=&quot;https://arxiv.org/abs/1110.2232v2&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Circuit Design for Solving Linear Systems of Equations (Cao &lt;em&gt;et al.&lt;/em&gt;,2012)&lt;/a&gt; there's this circuit:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/DUzV6.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/DUzV6.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It further says:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;After the inverse Fourier transform is executed on register $C$, we&#xA;  use its $|\lambda_j\rangle$ states stored in register $C$ &lt;strong&gt;as a&#xA;  control&lt;/strong&gt; for a Hamiltonian simulation $\exp(iH_0t_0)$ that is applied&#xA;  on register $M$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;But then again:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;We further establish the &lt;strong&gt;control relation&lt;/strong&gt; between Register $L$ and&#xA;  $\exp[-ip\left(\dfrac{\lambda_j}{2^m}\dfrac{1}{2^{l-k_l}}\right)t_0]$&#xA;  simulation that acts on register $M$. The values of the binary numbers&#xA;  stored in register $L$ are then able to determine the time parameter&#xA;  $t$ in overall Hamiltonian simulation $\exp(-iH_0t)$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;From here, I'm a bit confused &lt;strong&gt;which register of qubits&lt;/strong&gt; is being used to control the Hamiltonian simulation $\exp(-iH_0t)$. Are both registers: $L$ and $C$ being used as &quot;control&quot;? How does control by multiple registers work? (I only know how control by a single register of qubits works, as of now)&lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-06-28T08:04:12.663" Title="How are two different registers being used as &quot;control&quot;?" Tags="&lt;quantum-gate&gt;&lt;controlled-gates&gt;&lt;hamiltonian-simulation&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="2491" PostTypeId="1" CreationDate="2018-06-27T23:10:34.733" Score="7" ViewCount="148" Body="&lt;p&gt;I'm at the AQC conference at NASA and everybody seems to suddenly be talking about the &lt;a href=&quot;http://qserver.usc.edu/qec11/slides/Brooks_QEC11.pdf&quot; rel=&quot;noreferrer&quot;&gt;Bacon-Shor&lt;/a&gt; code but there is no Wikipedia page and the pdf that I gave a link to does not really explain what it is and how it works.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;How does it compare to the &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1845/intuition-for-shor-code-failure-probability&quot;&gt;Shor code&lt;/a&gt; ?&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-06-28T22:43:02.900" Title="What is a Bacon-Shor code and what is its significance?" Tags="&lt;quantum-error-correction&gt;&lt;stabilizer-code&gt;" AnswerCount="3" CommentCount="4" FavoriteCount="2" />
  <row Id="2492" PostTypeId="2" ParentId="2491" CreationDate="2018-06-27T23:50:58.107" Score="0" Body="&lt;p&gt;&lt;strong&gt;Shor Code&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Can detect and correct arbitrary single qubit errors, but if there are 2 or more single qubit errors before a correction round, the correction will fail. -&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1845/intuition-for-shor-code-failure-probability&quot;&gt;Intuition for Shor code failure probability&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Bacon-Shor Code&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Bacon-Shor codes, quantum subsystem codes which are well suited for applications to fault-tolerant quantum memory because the error syndrome can be extracted by performing two-qubit measurements. &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0610088&quot; rel=&quot;nofollow noreferrer&quot;&gt;Optimal Bacon-Shor codes&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Contrarily to Shor's code, these stabilizers cannot identify the precise qubit on which a bit-flip occurs, they can only identify the column in which it occurs. - &lt;a href=&quot;https://books.google.com/books?id=XV9sAAAAQBAJ&amp;amp;pg=PA172&amp;amp;lpg=PA172&amp;amp;dq=difference+between+%22shor%27s+code%22+and+bacon-shor+code&amp;amp;source=bl&amp;amp;ots=zs1Mq6kjUW&amp;amp;sig=wdqFiz718SC_A_qi-fJ1ketyElM&amp;amp;hl=en&amp;amp;sa=X&amp;amp;ved=0ahUKEwichMWl__TbAhXKsFQKHdMRAlgQ6AEIXzAH#v=onepage&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Error Correction&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;For the $[[n^2, 1, n]]$ Bacon-Shor code the qubits are laid out in&#xA;  a 2D n × n square array. It is also possible to work with asymmetric Bacon-Shor codes with qubits in a n × m array. - &lt;a href=&quot;https://arxiv.org/abs/1302.3428&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Error Correction for Quantum Memories pg. 34&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;We have shown that for every generalized Shor code&#xA;  there is an subsystem code with the same parameters but&#xA;  which requires significantly fewer stabilizer measurements&#xA;  in order to perform quantum error correction. - &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0610088&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Error Correcting Subsystem Codes From Two Classical Linear Codes&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Also, here is a video from Microsoft &lt;a href=&quot;https://www.youtube.com/watch?v=-bFz58qMogQ&quot; rel=&quot;nofollow noreferrer&quot;&gt;Universal Fault-Tolerant Computing with Bacon-Shor Codes&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-06-28T01:28:50.007" LastActivityDate="2018-06-28T01:28:50.007" CommentCount="4" />
  <row Id="2493" PostTypeId="2" ParentId="2491" CreationDate="2018-06-28T05:03:40.200" Score="2" Body="&lt;p&gt;&lt;sup&gt;&lt;strong&gt;Disclaimer&lt;/strong&gt;: This answer is based on what I deduced from a brief Googling session. I might make further additions/improvements as and when I will understand the details more thoroughly. Feel free to make suggestions in the comments.&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &lt;strong&gt;$9$-qubit Shor code&lt;/strong&gt; $[[9,1,3]]$ (qubits laid in a $3\times 3$ lattice) is the &lt;strong&gt;smallest member&lt;/strong&gt; in the family of &lt;strong&gt;$m^2$-qubit Bacon-Shor code(s)&lt;/strong&gt; $[[m^2,1,m]]$ (qubits laid in a $m\times m$ lattice). &lt;strong&gt;Shor's code&lt;/strong&gt;, as you know, can correct both Pauli &lt;strong&gt;sign flip&lt;/strong&gt; and Pauli &lt;strong&gt;bit-flip&lt;/strong&gt; errors in a single qubit. Moreover, to correct &lt;em&gt;any&lt;/em&gt; single-qubit error (with a high probability), it is sufficient to be able to correct against any single qubit Pauli error.&lt;sup&gt;[1]&lt;/sup&gt;  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/PN3Mh.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/PN3Mh.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, &lt;strong&gt;Bacon-Shor code(s)&lt;/strong&gt; is(/are) a &lt;em&gt;generalization&lt;/em&gt; of this concept to noise models where the qubit&lt;strong&gt;s&lt;/strong&gt; in a code block are subject to both &lt;strong&gt;bit-flip&lt;/strong&gt; errors with probability $p_X$ and &lt;strong&gt;dephasing&lt;/strong&gt; errors with probability $p_Z$. The noise is assumed to act independently on each qubit and the $X$ and $Z$ errors are uncorrelated.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/BDwUb.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/BDwUb.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In (Napp and Preskill, 2013) the authors find that the optimally-sized Bacon-Shor code for equal $X$ and $Z$ errors rate $p$ is given by $m=\frac{\log 2}{4p}$ and for that optimal choice they can bound the logical $X$(or $Z$) error rate as $\tilde p(p) \lesssim \exp(\frac{-0.06}{p})$&lt;sup&gt;[2]&lt;/sup&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is also possible to work with &lt;strong&gt;asymmetric Bacon-Shor codes&lt;/strong&gt; with qubits in an $n \times m$ array. Asymmetric codes can have better performance when, say, $Z$ errors are more likely than $X$ errors&lt;sup&gt;[3]&lt;/sup&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;References:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1302.3428&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Error Correction for Quantum Memories (Barbara M. Terhal, 2015)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1209.0794&quot; rel=&quot;nofollow noreferrer&quot;&gt;Optimal Bacon-Shor codes (Napp &amp;amp; Preskill, 2012)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1211.1400&quot; rel=&quot;nofollow noreferrer&quot;&gt;Fault-tolerant quantum computation with asymmetric Bacon-Shor codes (Brooks &amp;amp; Preskill, 2013)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-06-28T05:25:39.277" LastActivityDate="2018-06-28T05:25:39.277" CommentCount="2" />
  <row Id="2494" PostTypeId="2" ParentId="2490" CreationDate="2018-06-28T07:22:43.483" Score="2" Body="&lt;p&gt;You can see from the circuit diagram that in the third-last slice, both registers $L$ and $C$ are being used as controls. There's no problem with two registers being controls, after all, that's exactly what a Toffoli (controlled-controlled-NOT) gate does. It probably helps to explicitly write down what transformation they're talking about. I'll call it $U$. (I'm mostly extrapolating this from what you've written, rather than delving extensively into the paper or references.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Before I do that, I just want to change notation slightly, because what I see there, I find slightly misleading. If the eigenvalues of $At_0$ are $\lambda_j$, then the states of the register $C$ might better be written as $k\in\{0,1\}^t$ (assuming $t$ qubits are being used) with $\lambda_jt_0=2\pi k/2^t$. You could say that $|\lambda_j\rangle$ is an appropriate label for the ket, but it makes me think of the eigenvector, rather than the binary representation of the (rescaled) eigenvalue.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Having done that, we have&#xA;$$&#xA;U=\sum_{k\in\{0,1\}^t}\sum_{s\in\{0,1\}^l}\sum_{p\in\{0,1\}^m}|k\rangle\langle k|_C\otimes|s\rangle\langle s|_L\otimes|p\rangle\langle p|_Me^{-i2\pi p k \frac{f(s)}{2^{t+m+l}}}&#xA;$$&#xA;where $f(s)$ is some function of $s$ that I haven't entirely understood yet - I'm finding the paper quite opaque on that point, although figure 6 probably helps a bit. I &lt;em&gt;think&lt;/em&gt; it's simply&#xA;$$&#xA;f(s)=\sum_{q=1}^l\frac{s_q}{2^{-q}}=s&#xA;$$&#xA;(where the final answer is $s$ represented as a decimal, rather than binary). To explain: we go through each bit value and controlled off its value, add a phase. So the value $s_q$ indicates whether the $q^{th}$ bit is controlling, and the contributed phase is $1/2^{-q}=2^q$. A product of phases means we look at the sum of the arguments. Where I'm using $q$, the paper uses $k_l$, I think, which is, I think, not supposed to be the $l^{th}$ bit of the $k$ index we're using on register $C$. $\sum_qs_q2^q$ is just the decimal representation of a binary string.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="26" LastEditDate="2018-06-28T08:04:12.663" LastActivityDate="2018-06-28T08:04:12.663" CommentCount="4" />
  <row Id="2495" PostTypeId="2" ParentId="2489" CreationDate="2018-06-28T07:36:10.777" Score="1" Body="&lt;p&gt;This may not exactly answer your question (which I suspect is still very much an open question, and what you're likely to get as answers are opinions), but have you looked at &lt;a href=&quot;https://www.nature.com/articles/s41534-017-0025-3&quot; rel=&quot;nofollow noreferrer&quot;&gt;blind quantum computation&lt;/a&gt;? See &lt;a href=&quot;https://arxiv.org/abs/0810.5375&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt; for another perspective.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One way that we can describe that premise is to imagine some company claims to have developed a fabulous universal quantum computer. But it's so expensive, difficult to control etc. that only they can be trusted to run stuff on it, and it's not directly open for use by other people. How do you know it's really running as a quantum computer, and not just that, for example, they have some new classical algorithm that can simulate quantum computations better than we were expecting?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Blind quantum computation achieves this by making the quantum computer perform a computation without knowing what that computation actually is! The company who owns the computer is left blind to what it's supposed to be doing, so their cheating strategies are severely curtailed.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, I assume that this method would not be applicable to the quantum supremacy scenario.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-28T07:36:10.777" CommentCount="1" />
  <row Id="2496" PostTypeId="1" AcceptedAnswerId="2498" CreationDate="2018-06-28T09:08:57.430" Score="7" ViewCount="100" Body="&lt;p&gt;I would like to represent the state of a qubit on a Bloch sphere from the measurements made with Q#.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;According the &lt;a href=&quot;https://docs.microsoft.com/fr-fr/qsharp/api/prelude/microsoft.quantum.primitive.measure&quot; rel=&quot;noreferrer&quot;&gt;documentation&lt;/a&gt;, it is possible to measure a qubit in the different Pauli bases (PauliX, PauliY, PauliZ). This returns &lt;code&gt;Zero&lt;/code&gt; if the +1 eigenvalue is observed, and &lt;code&gt;One&lt;/code&gt; if the −1 eigenvalue is observed.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I can repeat this several times to find the probabilities for each base. Unfortunately, from there, I don't know how to calculate the density matrix or the X, Y, Z coordinates needed to use the &lt;a href=&quot;https://github.com/JRial95/blochsphere-jquery-plugin&quot; rel=&quot;noreferrer&quot;&gt;jQuery plugin&lt;/a&gt; to create the Bloch sphere.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is it possible to find the density matrix or the X, Y, Z coordinates from these measurements? If yes, how ? &lt;/p&gt;&#xA;" OwnerUserId="2782" LastActivityDate="2018-06-28T15:27:26.337" Title="From Q# measurements to Bloch sphere" Tags="&lt;density-matrix&gt;&lt;bloch-sphere&gt;&lt;q#&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="2497" PostTypeId="2" ParentId="2486" CreationDate="2018-06-28T09:24:44.050" Score="3" Body="&lt;p&gt;Reformulating your question:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;How to perform Hamiltonian Simulation for a generic square matrix $A$?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Quick answer&lt;/strong&gt;: it is not possible.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The goal of Hamiltonian Simulation (HS) is to find a quantum circuit (i.e. a succession of gates) that acts like $U(t) = e^{-iAt}$ on a quantum state. Here $U(t)$ needs to be unitary (because of the properties of quantum gates) and so $e^{-iAt}$ needs also to be unitary.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So the HS algorithm is only applicable to matrices $A$ such that $e^{-iAt}$ is unitary. Every hermitian matrix satisfy this property, but not every &lt;code&gt;generic square matrix&lt;/code&gt; does. Depending on your problem, this limitation may or may not be an issue but you can't use HS if $e^{-iAt}$ is not unitary.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example for the &lt;a href=&quot;https://arxiv.org/abs/0811.3171&quot; rel=&quot;nofollow noreferrer&quot;&gt;HHL algorithm&lt;/a&gt; (that use HS of $A$ as a subroutine) with a system $Ax=b$, if $e^{-iAt}$ is not unitary you can instead consider the problem&#xA;$$Cy = \begin{pmatrix} 0 &amp;amp; A \\ A^\dagger &amp;amp; 0 \end{pmatrix} \begin{pmatrix} 0 \\ x\end{pmatrix} = \begin{pmatrix}b \\ 0\end{pmatrix},$$ &#xA;solve it with HHL (which is now possible because the new matrix $C$ is hermitian) and recover $x$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So the interesting question is now:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;How to perform Hamiltonian Simulation for a given hermitian matrix $A$?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;And the answer will depend on the properties of $A$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is a huge research topic and there are plenty of things to say on it. I will not present every methods here as they are quite complicated and I did not understand all of them. Here is a list of papers/presentations that are related to HS and that may be interesting to start with HS:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://www.cs.umd.edu/~amchilds/talks/ibm13.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Simulating Hamiltonian dynamics on a small quantum computer&lt;/a&gt;: slides about HS. Even if it is a presentation, this is the most complete source I found on Hamiltonian Simulation. It presents quickly 3 different methods and cites interesting papers for each method.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://www.cs.umd.edu/~amchilds/qa/qa.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Lecture Notes on Quantum Algorithms (Andrew M. Childs, 2017)&lt;/a&gt;: recent and rather complete. HS is discussed in chapter 25 (page 123).&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1312.1414v2&quot; rel=&quot;nofollow noreferrer&quot;&gt;Exponential improvement in precision for simulating sparse Hamiltonians&lt;/a&gt;: presents in details one of the 3 methods presented in 1.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/quant-ph/0508139.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Efficient quantum algorithms for simulating sparse Hamiltonians&lt;/a&gt;: presents in details another of the 3 methods presented in 1. &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="1386" LastActivityDate="2018-06-28T09:24:44.050" CommentCount="3" />
  <row Id="2498" PostTypeId="2" ParentId="2496" CreationDate="2018-06-28T11:40:24.460" Score="4" Body="&lt;p&gt;The problem you are describing (i.e. finding an approximation of some state given some number of identical copies of it and some set of measurements) is known as &lt;em&gt;quantum state tomography&lt;/em&gt; or &lt;em&gt;state tomography&lt;/em&gt; for short.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In practise, the most efficient schemes for state tomography will depend on a specific experiment's setup and limitations, for which different protocols exist (see the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_tomography&quot; rel=&quot;nofollow noreferrer&quot;&gt;wikipedia page&lt;/a&gt; for an overview). Because the efficiency scaling of state tomography is notoriously bad in general, finding optimal tomography schemes for particular scenarios is an active area of research.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;That being said, for the rest of this answer I will assume that efficiency scalings are not important for what you want to do and describe the general theory behind state tomography on a single qubit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It can be shown that any density matrix can be written out as a linear combination of Pauli matrices, such that&#xA;$$&#xA;\rho = \frac{1}{2}(I + x\sigma_x + y\sigma_y + z\sigma_z) = \frac{1}{2} (I + \vec{r} \cdot \vec{\sigma})&#xA;$$&#xA;where $\vec{\sigma} = (\sigma_x, \sigma_y, \sigma_z)$ and $\vec{r} = (x, y, z)$ is the so-called &lt;em&gt;Bloch vector&lt;/em&gt; representing the coordinates on the Bloch sphere you reference above. To find these, we observe that&#xA;$$&#xA;x = \textrm{Tr}(\rho \sigma_x) = \langle \sigma_x \rangle_\rho, \quad y = \textrm{Tr}(\rho \sigma_y) = \langle \sigma_y \rangle_\rho, \quad z = \textrm{Tr}(\rho \sigma_z) = \langle \sigma_z \rangle_\rho.&#xA;$$&#xA;and so each the amplitude of each component of the Bloch vector is given by the expectation value of it's associated Pauli operator on $\rho$. Recall that the expectation value $\langle A \rangle_\rho$ is given by the average over all eigenvalues returned by measurement of $A$ on $\rho$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, to find the state's Bloch vector, just perform each Pauli measurements many times to find the respective expectation value. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Finally, to retrieve the matrix representation of $\rho$, simply recall that &#xA;$$&#xA;I = \begin{pmatrix} 1 &amp;amp; 0 \\ 0 &amp;amp; 1 \end{pmatrix}, \quad &#xA;\sigma_x = \begin{pmatrix} 0 &amp;amp; 1 \\ 1 &amp;amp; 0 \end{pmatrix} \quad&#xA;\sigma_y = \begin{pmatrix} 0 &amp;amp; -i \\ i &amp;amp; 0 \end{pmatrix} \quad&#xA;\sigma_z = \begin{pmatrix} 1 &amp;amp; 0 \\ 0 &amp;amp; -1 \end{pmatrix},&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;and so&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;\rho = \frac{1}{2} \begin{pmatrix} 1 + z &amp;amp; x - iy \\ x + iy &amp;amp; 1 - z \end{pmatrix}.&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Useful links and further reading:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://atom.physik.unibas.ch/fileadmin/user_upload/atom-physik-unibas-ch/Publications/People_Publications/Schmied2016a.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum state tomography of a single qubit: comparison of methods&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;http://research.physics.illinois.edu/QI/Photonics/tomography-files/tomo_chapter_2004.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;Quantum State Tomography&quot; chapter from &quot;Quantum State Estimation&quot; textbook&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Afterword&lt;/strong&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;By extending this protocol to two qubits we can flavour of why state tomography is not scalable in general. For two qubits $\rho_1$ and $\rho_2$ the combined state $\rho_{1,2} = \rho_1 \otimes \rho_2$ is given by&#xA;\begin{align}&#xA;\rho_{1,2} = \frac{1}{2} (I + \vec{r}_1 \cdot \vec{\sigma}_1) \otimes \frac{1}{2} (I + \vec{r}_2 \cdot \vec{\sigma}_2)&#xA;\end{align}&#xA;which is going to contain $4^2 = 16$ components, one for each $2$-fold Pauli operator. Clearly a strategy that requires $4^n$ different expectation values to be estimated to recover an $n$-qubit state is unfeasible for even small systems of qubits. So this is where the aforementioned research comes in.&lt;/p&gt;&#xA;" OwnerUserId="391" LastEditorUserId="391" LastEditDate="2018-06-28T14:24:47.007" LastActivityDate="2018-06-28T14:24:47.007" CommentCount="1" />
  <row Id="2499" PostTypeId="1" AcceptedAnswerId="2552" CreationDate="2018-06-28T14:11:42.940" Score="113" ViewCount="24615" Body="&lt;p&gt;I have a computer science degree. I work in IT, and have done so for many years. In that period &quot;classical&quot; computers have advanced by leaps and bounds. I now have a terabyte disk drive in my bedroom drawer amongst my socks, my phone has phenomenal processing power, and computers have revolutionized our lives. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;But as far as I know, quantum computing hasn't done anything. Moreover it looks like it's going to stay that way. Quantum computing has been around now for the thick end of forty years, and real computing has left it in the dust. See the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_computing#Timeline&quot; rel=&quot;noreferrer&quot;&gt;timeline&lt;/a&gt; on Wikipedia, and ask yourself &lt;em&gt;where's the parallel adder?&lt;/em&gt; Where's the equivalent of Atlas, or the MU5? I went to Manchester University, see the history on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Manchester_computers#MU5&quot; rel=&quot;noreferrer&quot;&gt;Manchester Computers&lt;/a&gt; article on Wikipedia. Quantum computers don't show similar progress. Au contraire, it looks like they haven't even got off the ground. You won't be buying one in PC World any time soon. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Will you ever be able to? Is it all hype and hot air? Is quantum computing just pie in the sky? Is it all just jam-tomorrow woo peddled by quantum quacks to a gullible public? If not, &lt;em&gt;why not?&lt;/em&gt; &lt;/p&gt;&#xA;" OwnerUserId="1905" LastEditorUserId="252" LastEditDate="2018-07-02T15:16:07.713" LastActivityDate="2018-07-14T18:27:43.770" Title="Is quantum computing just pie in the sky?" Tags="&lt;quantum-computer&gt;&lt;classical-computing&gt;&lt;history&gt;&lt;applications&gt;" AnswerCount="14" CommentCount="24" FavoriteCount="43" />
  <row Id="2500" PostTypeId="2" ParentId="2499" CreationDate="2018-06-28T14:57:06.110" Score="29" Body="&lt;p&gt;Classical computing has been around longer than quantum computing. The early days of classical computing is similar to what we are experiencing now with quantum computing.  The &lt;a href=&quot;https://en.wikipedia.org/wiki/Z3_(computer)&quot; rel=&quot;noreferrer&quot;&gt;Z3&lt;/a&gt; (First Turing complete electronic device) built in the 1940s was the size of a room and less powerful than your phone. This speaks to the phenomenal progress we have experienced in classical computing. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The dawn of quantum computing on the other hand, did not start until the &lt;a href=&quot;https://en.wikipedia.org/wiki/Timeline_of_quantum_computing#1980s&quot; rel=&quot;noreferrer&quot;&gt;1980s&lt;/a&gt;. Shor's factoring algorithm; the discovery that jump-started the field was discovered in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Timeline_of_quantum_computing#1990s&quot; rel=&quot;noreferrer&quot;&gt;1990s&lt;/a&gt;. This was followed a few years later with the first experimental demonstration of a quantum algorithm.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There is evidence that quantum computers can work. There is a tremendous amount of progress on the experimental and theoretical aspects of this field every year and there is no reason to believe that it's going to stop. The &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_threshold_theorem&quot; rel=&quot;noreferrer&quot;&gt;Quantum threshold theorem&lt;/a&gt; states that large scale quantum computing is possible if the error rates for physical gates are below a certain threshold. We are approaching (some argue that we are already there) this threshold for small systems.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It's good to be skeptical about the usefulness of quantum computation. In fact, it's encouraged! It's also natural to compare the progress of quantum computation with classical computation; forgetting that quantum computers are more difficult to build than classical computers.&lt;/p&gt;&#xA;" OwnerUserId="362" LastEditorUserId="362" LastEditDate="2018-07-04T02:43:10.333" LastActivityDate="2018-07-04T02:43:10.333" CommentCount="7" />
  <row Id="2501" PostTypeId="2" ParentId="2499" CreationDate="2018-06-28T14:59:34.523" Score="12" Body="&lt;p&gt;Early classical computers were built with existing technology. For example, vacuum tubes were invented around four decades before they were used to make Colossus.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For quantum computers, we need to invent the technology before we make the computer. And the technology is so beyond what had previous existed, that just this step has taken a few decades.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now we pretty much have our quantum versions of vacuum tubes. So expect a Colossus in a decade or so.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-06-28T14:59:34.523" CommentCount="2" />
  <row Id="2502" PostTypeId="2" ParentId="2496" CreationDate="2018-06-28T15:27:26.337" Score="1" Body="&lt;p&gt;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2498/2782&quot;&gt;SLesslyTall's answer&lt;/a&gt; is correct and very well explained. Let me add a little explanation on the interpretation of the return value of the Q# measurement function.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When you measure many times a qubit with the state $|1\rangle$, here are the results you get :&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Measurements in the Pauli $X$ basis : 50% of &lt;code&gt;Zero&lt;/code&gt; and 50% of &lt;code&gt;One&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;Measurements in the Pauli $Y$ basis : 50% of &lt;code&gt;Zero&lt;/code&gt; and 50% of &lt;code&gt;One&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;Measurements in the Pauli $Z$ basis : 0% of &lt;code&gt;Zero&lt;/code&gt; and 100% of &lt;code&gt;One&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;As explained in the &lt;a href=&quot;https://docs.microsoft.com/fr-fr/qsharp/api/prelude/microsoft.quantum.primitive.measure?view=qsharp-preview&quot; rel=&quot;nofollow noreferrer&quot;&gt;documentation&lt;/a&gt;, the function returns &lt;code&gt;Zero&lt;/code&gt; for the $+1$ eigenvalue and &lt;code&gt;One&lt;/code&gt; for the $-1$ eigenvalue. So to find $x$, $y$, $z$ you have to perform the following calculations:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$x = 0.5 \cdot 1 + 0.5 \cdot (-1) = 0.5 - 0.5 = 0$&lt;/li&gt;&#xA;&lt;li&gt;$y = 0.5 \cdot 1 + 0.5 \cdot (-1) = 0.5 - 0.5 = 0$&lt;/li&gt;&#xA;&lt;li&gt;$z = 0 \cdot 1 + 1 \cdot (-1) = 0 - 1 = -1$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Then to get the density matrix, you can use the formula given by &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2498/2782&quot;&gt;SLesslyTall&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\rho = \frac{1}{2}\begin{pmatrix}1+z&amp;amp;x-iy\\x+iy&amp;amp;1-z\end{pmatrix} = \frac{1}{2}\begin{pmatrix}1+(-1)&amp;amp;0-i0\\0+i0&amp;amp;1-(-1)\end{pmatrix} = \frac{1}{2}\begin{pmatrix}0&amp;amp;0\\0&amp;amp;2\end{pmatrix} = \begin{pmatrix}0&amp;amp;0\\0&amp;amp;1\end{pmatrix}$&lt;/p&gt;&#xA;" OwnerUserId="2782" LastActivityDate="2018-06-28T15:27:26.337" CommentCount="0" />
  <row Id="2503" PostTypeId="2" ParentId="2499" CreationDate="2018-06-28T16:46:44.810" Score="6" Body="&lt;p&gt;Why would you expect two different technologies to advance at the same rate?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Simply put, quantum computers can be immensely more powerful but are immensely harder to build than classical computers. The theory of their operation is more complicated and based on recent physics, there are greater theoretical pitfalls and obstacles that inhibit their scaling up in size, and their design requires much more sophisticated hardware which is harder to engineer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Nearly every stage of development of a quantum computer is inanalogous to that of a classical computer. So a question for you; why compare them?&lt;/p&gt;&#xA;" OwnerUserId="2591" LastEditorUserId="2591" LastEditDate="2018-06-28T20:36:11.697" LastActivityDate="2018-06-28T20:36:11.697" CommentCount="5" />
  <row Id="2504" PostTypeId="2" ParentId="2499" CreationDate="2018-06-28T16:52:20.277" Score="66" Body="&lt;p&gt;I'll be trying to approach this from a neutral point of view. Your question is sort of &quot;opinion-based&quot;, but yet, there are a few important points to be made. &lt;strong&gt;Theoretically&lt;/strong&gt;, there's no &lt;em&gt;convincing&lt;/em&gt; argument (yet) as to why quantum computers aren't practically realizable. But, do check out: &lt;a href=&quot;http://www.ma.huji.ac.il/~kalai/Qitamar.pdf&quot; rel=&quot;noreferrer&quot;&gt;How Quantum Computers Fail: Quantum Codes, Correlations in Physical Systems, and Noise Accumulation - Gil Kalai&lt;/a&gt; (PDF alert!) and the &lt;a href=&quot;https://www.scottaaronson.com/blog/?p=902&quot; rel=&quot;noreferrer&quot;&gt;related blog post by Scott Aaronson&lt;/a&gt;. If you want to dig into the history of why Aaronson thinks Kalai's claims are flawed, consider reading and following the links in the blog article. Also, see &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1795/26&quot;&gt;James Wotton's answer&lt;/a&gt; to the related QCSE post: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1794/is-gil-kalais-argument-against-topological-quantum-computers-sound&quot;&gt;Is Gil Kalai&amp;#39;s argument against topological quantum computers sound?&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, yes, of course, there are &lt;strong&gt;engineering problems&lt;/strong&gt;.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Problems:&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Sensitivity to interaction with the environment:&lt;/strong&gt; Quantum computers are extremely sensitive to interaction with the surroundings since&#xA;any interaction (or measurement) leads to a collapse of the state function. This&#xA;phenomenon is called decoherence. It is extremely difficult to isolate a quantum system, especially an engineered one for a computation, without it getting entangled with the environment. The larger the number of qubits the harder is it to maintain the coherence. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;[Further reading: &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_computing#Quantum_decoherence&quot; rel=&quot;noreferrer&quot;&gt;Wikipedia: Quantum decoherence&lt;/a&gt;]&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Unreliable quantum gate actions:&lt;/strong&gt; Quantum computation on qubits is accomplished by operating upon them with an array of transformations that are implemented in principle using small gates. It is imperative that no phase errors be introduced in these transformations. But practical schemes are likely to introduce such errors. It is also possible that the quantum register is already entangled with the environment even before the beginning of the computation. Furthermore, uncertainty in initial phase&#xA;makes calibration by rotation operation inadequate. In addition, one must consider the relative lack of precision in the classical control that&#xA;implements the matrix transformations. This lack of precision cannot be completely compensated for by the quantum algorithm.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Errors and their correction:&lt;/strong&gt;  Classical error correction employs redundancy. The simplest way is to store the information multiple times, and—if these copies are later found to disagree—just take a majority vote; e.g. Suppose we copy a bit three times. Suppose further that a noisy error corrupts the three-bit state so that one bit is equal to zero but the other two are equal to one. If we assume that noisy errors are independent and occur with some probability $p$, it is most likely that the error is a single-bit error and the transmitted message is three ones. It is possible that a double-bit error occurs and the transmitted message is equal to three zeros, but this outcome is less likely than the above outcome. Copying quantum information is not possible due to the no-cloning theorem. This theorem seems to present an obstacle to formulating a theory of quantum error correction. But it is possible to spread the information of one qubit onto a highly entangled state of several (physical) qubits. Peter Shor first discovered this method of formulating a quantum error correcting code by storing the information of one qubit onto a highly entangled state of nine qubits. However, quantum error correcting code(s) protect quantum information against errors of only some limited forms. Also, they are efficient only for errors in a small number of qubits. Moreover, the number of qubits needed to correct errors doesn't normally scale well with the number of qubits in which error actually occurs.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[Further reading: &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_error_correction&quot; rel=&quot;noreferrer&quot;&gt;Wikipedia: Quantum error correction&lt;/a&gt;]&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Constraints on state preparation:&lt;/strong&gt; State preparation is the essential first step to be considered before the beginning of any quantum computation. In most schemes, the qubits need to be in a &lt;em&gt;particular&lt;/em&gt; superposition state for the quantum computation to proceed correctly. But creating arbitrary states precisely can be exponentially hard (in both time and resource (gate) complexity).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Quantum information, uncertainty, and entropy of quantum gates:&lt;/strong&gt; &#xA;Classical information is easy to obtain by means of interaction with the system. On the other hand, the impossibility of cloning means that any specific unknown state cannot be determined. This means that unless the system has specifically been prepared, our ability to control it remains limited. The average information of a system is given by its entropy. The determination of entropy would depend on the statistics obeyed by the object. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;A requirement for low temperatures&lt;/strong&gt;: Several &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_computing#Developments&quot; rel=&quot;noreferrer&quot;&gt;quantum computing architectures&lt;/a&gt;&#xA;like &lt;a href=&quot;https://en.wikipedia.org/wiki/Superconducting_quantum_computing&quot; rel=&quot;noreferrer&quot;&gt;superconducting quantum computing&lt;/a&gt; require extremely low temperatures (close to absolute zero) for functioning. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;Progress:&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Around a decade and a half, ago the &lt;strong&gt;decoherence time&lt;/strong&gt; for the so-called &quot;quantum computers&quot; were lesser than $1$ nanosecond. Now, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Nitrogen-vacancy_center&quot; rel=&quot;noreferrer&quot;&gt;IBM Quantum Experience&lt;/a&gt; 16 qubit version which you can access online has a decoherence time $~100$ $\mu s$ (see: &lt;a href=&quot;https://arxiv.org/abs/1801.02363&quot; rel=&quot;noreferrer&quot;&gt;Demonstration of Envariance and Parity Learning on the IBM 16 Qubit Processor (Davide Ferrari &amp;amp; Michele Amoretti, 2018)&lt;/a&gt;). The decoherence time of $100 \mu s$ is sufficient to run simple quantum algorithms already! You can check it out yourself on the 5 qubit and 16 qubit quantum computers which have been made accessible online by IBM. I think Google has been able to achieve even better decoherence times with their superconducting chips (having an equivalent number of qubits).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;There has been a lot of improvement in the area of &lt;strong&gt;quantum error correction&lt;/strong&gt; in the past decade (requiring a much lesser number of total qubits). See Quantum &lt;a href=&quot;https://arxiv.org/abs/1302.3428&quot; rel=&quot;noreferrer&quot;&gt;Error Correction for Quantum Memories (Terhal, 2015)&lt;/a&gt; for a brief review. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Also, quoting: &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_error_correction#Experimental_realization&quot; rel=&quot;noreferrer&quot;&gt;Wikipedia: Quantum error correction - Experimental realization&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;There have been several experimental realizations of CSS-based codes.&#xA;  The first demonstration was with NMR qubits. Subsequently, &#xA;  demonstrations have been made with linear optics, trapped ions, and &#xA;  superconducting (transmon) qubits. Other error-correcting codes have &#xA;  also been implemented, such as one aimed at correcting for photon &#xA;  loss, the dominant error source in photonic qubit schemes.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Preparation of arbitrary quantum states&lt;/strong&gt; is still a major problem. But now at least we know the exact gate decomposition for any unitary evolution (&lt;a href=&quot;https://arxiv.org/abs/1003.5760&quot; rel=&quot;noreferrer&quot;&gt;Quantum-state preparation with universal gate decompositions (Plesch &amp;amp; Brukner, 2011)&lt;/a&gt;), albeit the number of gates doesn't usually scale well with a number of qubits. There have been further improvements like in &lt;a href=&quot;https://arxiv.org/abs/1709.05279&quot; rel=&quot;noreferrer&quot;&gt;High-fidelity quantum state preparation using neighboring optimal control (Yuchen Peng &amp;amp; Frank Gaitan, 2017)&lt;/a&gt;. For some other recently developed high-precision methods of state preparation see &lt;a href=&quot;https://aip.scitation.org/doi/abs/10.1063/1.4940696?journalCode=jmp&quot; rel=&quot;noreferrer&quot;&gt;The preparation of states in quantum mechanics (Fröhlich, 2016)&lt;/a&gt; and &#xA;and &lt;a href=&quot;https://www.epj-conferences.org/articles/epjconf/abs/2017/31/epjconf_incape2017_01039/epjconf_incape2017_01039.html&quot; rel=&quot;noreferrer&quot;&gt;Preparation of quantum state (Ali et al.,2017)&lt;/a&gt;. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;One of the main constraints we still have is &lt;strong&gt;number of qubits&lt;/strong&gt; (note that this issue is &lt;em&gt;intrinsically&lt;/em&gt; related to the difficulty of maintaining coherence for long periods of time c.f. &lt;a href=&quot;https://physics.stackexchange.com/questions/101560/schr%C3%B6dingers-cat-and-the-difficulty-of-macroscopic-superposition-state/267462&quot;&gt;Schrödinger's cat and the difficulty of macroscopic superposition state&lt;/a&gt; and the excellent answer therein). None of the present day quantum computers is sufficient to show any &lt;em&gt;considerable&lt;/em&gt; improvement in &quot;capability&quot; compared to classical computers. The largest number factorized by a quantum computer till date is $291311$ (&lt;a href=&quot;https://arxiv.org/abs/1706.08061&quot; rel=&quot;noreferrer&quot;&gt;High-fidelity adiabatic quantum computation using the intrinsic Hamiltonian of a spin system: Application to the experimental factorization of 291311 (Li et al., 2017)&lt;/a&gt;). But, as &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2499/is-quantum-computing-just-pie-in-the-sky/2504#comment3228_2504&quot;&gt;user @R.. says&lt;/a&gt;, brute-force factorization of $291311$ takes at most ~$270$ divisions, each of which takes ~$10$ns on modern CPUs. That's $3$us in total, implying that the factorization will be several orders of magnitude faster on your laptop (although I guess that difference won't be &lt;em&gt;perceptible&lt;/em&gt;). The practical improvement in time complexity won't be noticeable unless and until the number of qubits increases by &lt;em&gt;at least&lt;/em&gt; $10$ times or so (I'm not considering the D-Wave machines which have over $1000$ qubits, as they use a different mechanism known as quantum annealing which is effective only in a few narrow ranges of problems). But, arguably even the number of qubits is on a steady rise. Recently Google announced a $72$ qubit machine (&#xA;&lt;a href=&quot;https://ai.googleblog.com/2018/03/a-preview-of-bristlecone-googles-new.html&quot; rel=&quot;noreferrer&quot;&gt;Google AI blog: A Preview of Bristlecone, Google’s New Quantum Processor&lt;/a&gt;) and Intel announced a $49$ qubit chip (&lt;a href=&quot;https://spectrum.ieee.org/tech-talk/computing/hardware/intels-49qubit-chip-aims-for-quantum-supremacy&quot; rel=&quot;noreferrer&quot;&gt;IEEE Spectrum:: CES 2018: Intel's 49-Qubit Chip Shoots for Quantum Supremacy&lt;/a&gt;). Compare that to the 2000s when we only used to have a single-digit number of qubits!&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Several quantum computing architectures have been discovered in the past couple of decades, for which &lt;strong&gt;near-absolute-zero temperatures are not necessary&lt;/strong&gt;, for example, optical quantum computers, trapped-ion quantum computers, diamond-based quantum computers, etc. C.f. &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/117/why-do-optical-quantum-computers-not-have-to-be-kept-near-absolute-zero-while-su&quot;&gt;Why do optical quantum computers not have to be kept near absolute zero while superconducting quantum computers do?&lt;/a&gt;  &lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;Conclusion:&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Whether we will ever have efficient quantum computers which can visibly outperform classical computers in certain areas, is something which only time will say.&lt;/strong&gt; However, looking at the considerable progress we have been making, it probably wouldn't be too wrong to say that in a couple of decades we should have sufficiently powerful quantum computers. On the theoretical side though, we don't yet &lt;em&gt;know&lt;/em&gt; if classical algorithms (can) exist which will match quantum algorithms in terms of time complexity. See my &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1585/26&quot;&gt;previous answer&lt;/a&gt; about this issue. &lt;strong&gt;From a completely theoretical perspective, it would also be &lt;em&gt;extremely&lt;/em&gt; interesting if someone can prove that all BQP problems lie in BPP or P!&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I personally believe that in the coming decades we will be using a &lt;strong&gt;combination of quantum computing techniques and classical computing techniques&lt;/strong&gt; (i.e. either your PC will be having both classical hardware components as well as quantum hardware or quantum computing will be totally cloud-based and you'll only access online them from classical computers). Because remember that quantum computers are efficient only for a very narrow range of problems. It would be pretty resource-intensive and unwise to do an addition like $2+3$ using a quantum computer (see &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1289/how-does-a-quantum-computer-do-basic-math-at-the-hardware-level&quot;&gt;How does a quantum computer do basic math at the hardware level?&lt;/a&gt;). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, coming to your point of whether &lt;strong&gt;national funds are unnecessarily being wasted on trying to build quantum computers&lt;/strong&gt;. My answer is &lt;strong&gt;NO&lt;/strong&gt;! Even if we fail to build legitimate and efficient quantum computers, we will still have gained &lt;strong&gt;a lot&lt;/strong&gt; in terms of &lt;strong&gt;engineering progress&lt;/strong&gt; and &lt;strong&gt;scientific progress&lt;/strong&gt;. Already research in photonics and superconductors has increased manyfold and we are beginning to understand a lot of physical phenomena better than ever before. Moreover, quantum information theory and quantum cryptography have led to the discovery of a few neat mathematical results and techniques which may be useful in a lot of other areas too (c.f. &lt;a href=&quot;https://physics.stackexchange.com/questions/40834/mathematically-challenging-areas-in-quantum-information-theory-and-quantum-crypt/40848&quot;&gt;Physics SE: Mathematically challenging areas in Quantum information theory and quantum cryptography&lt;/a&gt;). We will also have understood a lot more about some of the &lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_unsolved_problems_in_computer_science&quot; rel=&quot;noreferrer&quot;&gt;hardest problems in theoretical computer science&lt;/a&gt; by that time (even if we fail to build a &quot;quantum computer&quot;).&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Sources and References:&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/cs/0602096&quot; rel=&quot;noreferrer&quot;&gt;Difficulties in the Implementation of Quantum Computers (Ponnath, 2006)&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_computing&quot; rel=&quot;noreferrer&quot;&gt;Wikipedia: Quantum computing&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_error_correction&quot; rel=&quot;noreferrer&quot;&gt;Wikipedia: Quantum error correction&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Addendum:&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;After a bit of searching, I found a very nice &lt;a href=&quot;https://www.scottaaronson.com/democritus/lec14.html&quot; rel=&quot;noreferrer&quot;&gt;article&lt;/a&gt; which outlines almost all of Scott Aaronson's counter-arguments against the quantum computing skepticism. I &lt;strong&gt;very highly recommend&lt;/strong&gt; going through all the points given in there. It's actually &lt;strong&gt;part 14&lt;/strong&gt; of the &lt;a href=&quot;https://www.scottaaronson.com/democritus/default.html&quot; rel=&quot;noreferrer&quot;&gt;lecture notes&lt;/a&gt; put up by Aaronson on his website. They were used for the course PHYS771 at the University of Waterloo. The lectures notes are based on his popular textbook &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/0521199565&quot; rel=&quot;noreferrer&quot;&gt;Quantum Computing Since Democritus&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-06T09:14:30.730" LastActivityDate="2018-07-06T09:14:30.730" CommentCount="7" />
  <row Id="2505" PostTypeId="1" AcceptedAnswerId="2520" CreationDate="2018-06-28T18:20:31.200" Score="6" ViewCount="110" Body="&lt;p&gt;I'm just starting of on quantum computing, specifically following the IBM Q Experience documentation &lt;sup&gt;[1]&lt;/sup&gt;. In here, they are explaining the following experiment:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$T|+\rangle$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The expected outcomes according to the document:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Phase angle: $\pi/4$ &lt;/li&gt;&#xA;&lt;li&gt;Gates: $T$&lt;/li&gt;&#xA;&lt;li&gt;Prob 0: 0.8535533  &lt;/li&gt;&#xA;&lt;li&gt;Prob 1: 0.1464466 &lt;/li&gt;&#xA;&lt;li&gt;X-length: 0.7071067&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;I'm trying to deduce this with math. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$T |+\rangle = \begin{bmatrix}1 &amp;amp; 0 \\ 0 &amp;amp; e^{i\pi/4}\end{bmatrix} {1\over\sqrt 2} \begin{bmatrix} 1 \\ 1 \end{bmatrix} = {1\over\sqrt 2} \begin{bmatrix}1\\e^{i\pi/4}\end{bmatrix}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I think I now need to split this out in $|0\rangle$ and $|1\rangle$ so that I get the quantum amplitudes:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$ = {1\over\sqrt 2} \begin{bmatrix}1\\0\end{bmatrix} + {1\over\sqrt 2} e^{i\pi/4} \begin{bmatrix}0 \\1 \end{bmatrix}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here things are falling apart, as&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$ P(0) = |{1\over\sqrt 2}|^2 = 0.5 $ &lt;br&gt;&#xA;$ P(1) = |{1\over\sqrt 2} e^{i\pi/4}|^2 = 0.5 $&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So my question: &lt;strong&gt;How do I correctly calculate the probabilities and the X-length?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[1]: &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/proxy/tutorial/full-user-guide/002-The_Weird_and_Wonderful_World_of_the_Qubit/003-Introducing_qubit_phase.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;IBM Q: User Guide / The Weird and Wonderful World of the Qubit / Introducing Qubit Phase&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="2794" LastEditorUserId="26" LastEditDate="2018-06-29T07:54:29.500" LastActivityDate="2018-07-22T16:27:48.500" Title="What are the P(0) and P(1) probabilities for the T transformation in quantum computing?" Tags="&lt;quantum-gate&gt;" AnswerCount="2" CommentCount="1" />
  <row Id="2506" PostTypeId="2" ParentId="2499" CreationDate="2018-06-28T18:48:09.817" Score="8" Body="&lt;p&gt;The sad truth for most of the people here is that John Duffield (the asker) is right. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;There is no proof that a quantum computer will ever be of any value.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, for the companies that have invested in quantum computing (IBM, Google, Intel, Microsoft, etc.), it is entirely worth it to try to build one, because if they are successful they will be able to solve some problems exponentially faster than classical computers, and if they are not successful no dent has been put in the billions of dollars they have available.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The attempt to build useful quantum computers, which you can call a failure so far, has at least lead to advances in understanding superconductors, photonics, and even quantum theory itself. A lot of mathematics used for analyzing quantum mechanics, was developed in the context of quantum information theory.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And finally, quantum computers might never be marketable, but quantum communication devices by Toshiba, HP, IBM, Mitsubishi, NEC and NTT are already on the market.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In conclusion: I agree with John Duffield that quantum computing may never be of any value. But quantum communication is already marketable, and a lot of new science, mathematics, and engineering (e.g. for superconductors) was developed for our failed (so far) attempts in making quantum computing a reality.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-07-02T06:45:08.407" LastActivityDate="2018-07-02T06:45:08.407" CommentCount="13" />
  <row Id="2508" PostTypeId="1" CreationDate="2018-06-28T20:43:47.690" Score="2" ViewCount="52" Body="&lt;p&gt;Reproduced from Exercise 2.5 of Nielsen &amp;amp; Chuang’s Quantum Computation and Quantum Information (10th Anniversary Edition):&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;A function $(\cdot, \cdot)$ from $V × V$ to $C$ is an inner product if it satisfies the requirements:&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;(1) $(\cdot, \cdot)$ is linear in the second argument,&#xA;  $$&#xA;\left(|v⟩,  \sum_iλ_i|w_i⟩\right) = \sum_i λ_i (|v⟩, |w_i⟩).&#xA;$$&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;(2) $(|v⟩,|w⟩)=(|w⟩,|v⟩)^∗$.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;(3) $(|v⟩, |v⟩) ≥ 0$ with equality if and only if $|v⟩ = 0$.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;For example, $C^n$ has an inner product defined by&#xA;  $$&#xA;((y_1,...,y_n),(z_1,...,z_n)) ≡ \sum_i y_i^* z_i = \begin{bmatrix} y_1 &amp;amp; \ldots &amp;amp; y_n\end{bmatrix}\begin{bmatrix} z_1 \\ \vdots \\ z_n\end{bmatrix}.&#xA;$$&#xA;  &lt;strong&gt;Verify that $(·, ·)$ just defined is an inner product on $C^n$.&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Note: This question is part of a series attempting to provide worked solutions to the exercises provided in the above book. For a list of all exercises added so far, see &lt;a href=&quot;https://quantumcomputing.stackexchange.com/tags/nielsen-and-chuang/info&quot;&gt;here&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&#xA;" OwnerUserId="391" LastActivityDate="2018-06-28T20:43:47.690" Title="Nielsen &amp; Chuang Exercise 2.5 - Inner products of complex vectors" Tags="&lt;nielsen-and-chuang&gt;" AnswerCount="0" CommentCount="2" ClosedDate="2018-07-01T16:44:01.850" />
  <row Id="2509" PostTypeId="2" ParentId="2499" CreationDate="2018-06-28T22:32:26.360" Score="3" Body="&lt;p&gt;There are many technical challenges to developing a universal quantum computer consisting of with many qubits, as pointed out in the other answers. See also this &lt;a href=&quot;https://www.nature.com/articles/nature23460&quot; rel=&quot;nofollow noreferrer&quot;&gt;review article&lt;/a&gt;. However, there may be workaround ways to get certain nontrivial quantum computing results before we get to the first truly universal quantum computer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that classical computing devices existed a long time before the first universal computer was made. E.g. to numerically solve differential equations, you can construct an electric circuit consisting of capacitors, coils and resistors, such that the voltage between certain points will satisfy the same differential equation as the one you want to solve. This method was popular in astrophysics before the advent of digital computers. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In case of quantum computing, note that when Feynman came up with the idea of quantum computing, he argued on the basis of the difficulty of simulating quantum mechanical properties of certain physical systems using ordinary computers. He turned the argument around by noting that the system itself solves the mathematical problem that is hard to solve using ordinary computers. The quantum mechanical nature of the system makes that so, therefore one can consider if one can construct quantum mechanical devices that are able to tackle problems that are hard to solve using ordinary computers. &lt;/p&gt;&#xA;" OwnerUserId="2803" LastActivityDate="2018-06-28T22:32:26.360" CommentCount="0" />
  <row Id="2510" PostTypeId="2" ParentId="2499" CreationDate="2018-06-28T22:37:35.140" Score="6" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;See the timeline on Wikipedia, and ask yourself where's the parallel adder? &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;It seems to me that your answer lies in your question.  Looking at the timeline on Wikipedia shows very slow progress from 1959 until about 2009.  It was mainly theoretical work until we went from &lt;a href=&quot;https://en.wikipedia.org/wiki/Zero_to_One&quot; rel=&quot;noreferrer&quot;&gt;zero to one&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the only &lt;em&gt;9&lt;/em&gt; years since then, the pace of progress has been tremendous, going from 2 qubits to 72 and if you include dwave up to 2000 qubits.  And, there's one working in the cloud right now that we have access to.  Graph the progress of the last 60 years and I'm sure you'll see quite the knee in the curve you seem to desire and a rebuttal to your statement &lt;em&gt;But as far as I know, quantum computing hasn't done anything.&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Where's the equivalent of Atlas, or the MU5?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Is that the measure against which your question is based?&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Will you ever be able to? Is it all hype and hot air? Is quantum computing just pie in the sky? Is it all just jam-tomorrow woo peddled by quantum quacks to a gullible public?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Yes. No. No. No.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;If not, why not? &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Because, as your referenced timeline shows, people are making significant progress in the number and stability of qubits as well as in quantum algorithms.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Asking people to predict the future has always been fraught with failure which is why most of these sites don't allow 'opinion based' questions.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Perhaps more specific (non-opinion based) questions would better serve to answer your questions.&lt;/p&gt;&#xA;" OwnerUserId="2806" LastActivityDate="2018-06-28T22:37:35.140" CommentCount="2" />
  <row Id="2511" PostTypeId="2" ParentId="2491" CreationDate="2018-06-28T22:37:38.963" Score="3" Body="&lt;p&gt;The key difference is that the Bacon-Shor code is a &lt;em&gt;subsystem&lt;/em&gt; code, while the Shor code is a &lt;em&gt;stabilizer&lt;/em&gt; code. They have the same &lt;em&gt;stabilizer operators&lt;/em&gt;, but the error correction procedure is different. The canonical reference for this construction is &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0508131&quot; rel=&quot;nofollow noreferrer&quot;&gt;[Poulin]&lt;/a&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Stabilizer codes rely on measuring eigenvalues of &lt;em&gt;commuting&lt;/em&gt; operators (the stabilizers). Because these operators commute, we can label subspaces of the state space by these eigenvalues. In particular, the joint +1 eigenspace is the &lt;em&gt;codespace&lt;/em&gt;. If any of our measurements result in a -1 eigenvalue, we know that the state has wandered out of the codespace and can (hopefully) do something to rectify this. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;With subsystem codes, we also measure eigenvalues of some operators, but this time they do &lt;em&gt;not&lt;/em&gt; form a commuting set of operators. These operators are called &lt;em&gt;gauge operators&lt;/em&gt;. They generate a group called the &lt;em&gt;gauge group&lt;/em&gt;. The trick to this construction is that the &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Center_(group_theory)&quot; rel=&quot;nofollow noreferrer&quot;&gt;center&lt;/a&gt;&lt;/em&gt; of the gauge group is the stabilizer group. This is the group of operators generated by the gauge operators that commute with every element of the gauge group.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;How this works in practice:&lt;/strong&gt; suppose you have a stabilizer operator $s$ written as a product of gauge operators $\{g_i\}$:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ s = \prod_i g_i. $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now we go ahead and measure each of the $g_i$. Each measurement gives a random eigenvalue $\lambda_i = \pm 1$ but the product of these $\lambda = \prod \lambda_i$ labels the eigenspace of $s$ that the state belongs to. Once we have all the eigenvalues of the stabilizers in this way we can (hopefully) do something to rectify the state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;An example:&lt;/strong&gt; I find it helpful to think of the &quot;4-qubit Bacon-Shor code&quot;. This is an error &lt;em&gt;detecting&lt;/em&gt; subsystem code. The gauge operators are&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\{XXII, IIXX, ZIZI, IZIZ\}.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Think of these as operating on a $2\times 2$ lattice of qubits. These operators generate the stabilizers $XXXX$ and $ZZZZ.$ Once we measure $XXII$ and $IIXX$ we multiply the two eigenvalue measurements to find the eigenvalue of $XXXX$. These gauge operators are &quot;easier&quot; to measure, because they only involve two qubits, but the cost is that we mess up the state in other ways. These &quot;other ways&quot; are the &lt;em&gt;gauge qubits&lt;/em&gt;, and we don't care about these. The encoded qubits, or &lt;em&gt;logical&lt;/em&gt; qubits are the ones we are trying to preserve. The operators that act on the encoded qubits are the &lt;em&gt;logical operators&lt;/em&gt;. For this example these are $ZZII$ and $XIXI$. As an exercise I would recommend working out the corresponding eigenvectors (and eigenspaces) for all these operators.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Larger Bacon-Shor codes work similarly. For an $n\times n$ lattice of qubits, there are a bunch of 2-qubit gauge operators, arranged like &quot;dominoes&quot; on the lattice. The $X$ type gauge operators are horizontal dominoes, and the $Z$ type gauge operators are vertical dominoes. A vertical stack of $n$ of the $X$ type dominoes generates an $X$ type stabilzer on $n\times 2$ qubits. And so on. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The relevance to adiabatic quantum computing is that we can form a Hamiltonian from these operators, as the negative sum of the gauge operators. The groundspace of the Hamiltonian corresponds to the logical qubits of the gauge code, and excitations of the state correspond to errors. For the Bacon-Shor code, the gap of this Hamiltonian goes to zero as the size of the system grows. Therefore this Hamiltonian does not work to protect the encoded state (energetically.) This Hamiltonian is also known as the &lt;em&gt;&lt;a href=&quot;https://arxiv.org/abs/cond-mat/0501708&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum compass model&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I also wrote a paper about &lt;a href=&quot;https://arxiv.org/abs/1801.03243&quot; rel=&quot;nofollow noreferrer&quot;&gt;subsystem codes and Hamiltonians&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="263" LastEditorUserId="263" LastEditDate="2018-06-28T22:43:02.900" LastActivityDate="2018-06-28T22:43:02.900" CommentCount="0" />
  <row Id="2512" PostTypeId="2" ParentId="2499" CreationDate="2018-06-28T23:02:36.697" Score="7" Body="&lt;p&gt;To answer part of the question, &quot;will I ever buy a quantum computer&quot;, etc. I think there is a fundamental misunderstanding.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quantum computing isn't just classical computing but faster. A quantum computer solves certain kinds of problems in a short time that would take a classical super computer a thousand years. This isn't an exaggeration. But regular kinds of computing, adding numbers, moving bits for graphics, etc. Those will still just be classical computing things. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If the technology could ever be miniaturized (I don't know), it might be something more like an MMU or a graphics card. An additional feature to your classical computer, not a replacement. In the same way a high end graphics card lets your computer do things that it would not be able to (in reasonable time) with the main CPU, a quantum computer would allow other sorts of operations that can't be done currently.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I recommend you at least scan maybe the first paragraph of the &quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_computing#Principles_of_operation&quot; rel=&quot;noreferrer&quot;&gt;Principles of Operation&lt;/a&gt;&quot; page on the quantum computing Wikipedia page.&lt;/p&gt;&#xA;" OwnerUserId="2810" LastActivityDate="2018-06-28T23:02:36.697" CommentCount="0" />
  <row Id="2513" PostTypeId="1" AcceptedAnswerId="2519" CreationDate="2018-06-29T00:37:30.167" Score="4" ViewCount="105" Body="&lt;p&gt;I want to understand the relation between the following two ways of deriving a (unitary) matrix that  corresponds to the action of a gate on a single qubit:   &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;1)&lt;/strong&gt; &lt;a href=&quot;https://nbviewer.jupyter.org/github/QISKit/qiskit-tutorial/blob/master/reference/tools/quantum_gates_and_linear_algebra.ipynb#Single-Qubit-Quantum-states&quot; rel=&quot;nofollow noreferrer&quot;&gt;HERE&lt;/a&gt;, in IBM's tutorial, they represent the general unitary matrix acting on a qubit as: &#xA;  $$&#xA;U = \begin{pmatrix}&#xA;\cos(\theta/2) &amp;amp; -e^{i\lambda}\sin(\theta/2) \\&#xA;e^{i\phi}\sin(\theta/2) &amp;amp; e^{i\lambda+i\phi}\cos(\theta/2) &#xA;\end{pmatrix},&#xA;$$&#xA;  where $0\leq\theta\leq\pi$, $0\leq \phi&amp;lt;2\pi$, and $0\leq \lambda&amp;lt;2\pi$.  &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;This is derived algebraically using the definition of a unitary operator $U$ to be: $UU^{\dagger}=I$. &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;2)&lt;/strong&gt; &lt;a href=&quot;http://www.vcpc.univie.ac.at/~ian/hotlist/qc/talks/bloch-sphere-rotations.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;HERE&lt;/a&gt; (pdf), similar to Kaye's book &lt;em&gt;An Introduction Quantum Computing&lt;/em&gt;, the same operator is calculated to be: &#xA;  $$U=e^{i\gamma}\,R_{\hat n}(\alpha).$$&#xA;  Here, $R_{\hat n}(\alpha)$ is the rotation matrix around an arbitrary unit vector (a vector on the Bloch sphere) as the axis of rotation for an angle $\alpha$. Also, $e^{i\gamma}$ gives the global phase factor to the formula(which is not observable after all). The matrix corresponding to this way of deriving $U$ is: $$e^{i\gamma}\cdot\begin{pmatrix} cos\frac{\alpha}{2}-i\,sin\frac{\alpha}{2}\,cos\frac{\theta}{2}&amp;amp;-i\,sin\frac{\alpha}{2}\,e^{-i\phi}\\ -i\,sin \frac{\alpha}{2}e^{i\phi}&amp;amp;cos\frac{\alpha}{2}+i\,sin\frac{\alpha}{2}\,cos\theta\end{pmatrix}.$$   &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;This derivation is clearer to me since it gives a picture of these gates in terms of rotating the qubits on the Bloch sphere, rather than just algebraic calculations as in 1.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; How do these angles correlate in 1 and 2? I was expecting these two matrix to be equal to each other up to a global phase factor.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;P.S.: This correspondence seems instrumental to me for understanding the U-gates defined in the tutorial (IBM). &lt;/p&gt;&#xA;" OwnerUserId="2757" LastEditorUserId="2757" LastEditDate="2018-06-29T01:18:01.937" LastActivityDate="2018-06-29T07:21:51.743" Title="The general form of unitary operations on a single qubit" Tags="&lt;quantum-gate&gt;&lt;bloch-sphere&gt;" AnswerCount="1" CommentCount="1" />
  <row Id="2514" PostTypeId="1" AcceptedAnswerId="2517" CreationDate="2018-06-29T01:55:06.777" Score="9" ViewCount="102" Body="&lt;p&gt;Is there some definition or theorem about what a quantum computer can achieve from which post-quantum cryptographic schemes (eg lattice cryptography, but not quantum cryptography) can justify their security? I know the period finding function is capable of breaking RSA and discrete logs, but is it the only algorithm relevant to breaking encryption schemes? Can I say that if a scheme is not susceptible to the period finding function it is not susceptible to quantum computing? If not, is there some similar, alternative statement of the form &quot;if an encryption scheme cannot be broken by algorithm X, it cannot be broken by quantum computing&quot;?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, is it sufficient to prove that an encryption scheme can only be broken by trying all possible keys, and the best that quantum computing can do in this regard is square root search time with Grover's algorithm?&lt;/p&gt;&#xA;" OwnerUserId="2816" LastEditorUserId="26" LastEditDate="2018-07-01T08:20:10.313" LastActivityDate="2018-07-01T08:20:10.313" Title="How to justify post quantum encryption security?" Tags="&lt;cryptography&gt;&lt;post-quantum-crypto&gt;" AnswerCount="2" CommentCount="3" FavoriteCount="2" />
  <row Id="2515" PostTypeId="2" ParentId="2514" CreationDate="2018-06-29T04:32:33.207" Score="4" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Is there some definition or theorem about what a quantum computer can&#xA;  achieve from which post quantum cryptographic schemes (eg lattice&#xA;  cryptography, but not quantum cryptography) can justify their&#xA;  security?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;No. Just because your post-quantum cryptographic scheme works today, doesn't mean Peter Shor won't find a quantum algorithm to break it tomorrow.&quot;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;I know the period finding function is capable of breaking RSA and discrete logs, but is it the only algorithm relevant to breaking encryption schemes? &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;No. An example of another algorithm is Grover's algorithm, which is relevant to breaking cryptosystems based on the &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2247/2293&quot;&gt;Transcendental Logarithm Problem&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Can I say that if a scheme is not susceptible to the period finding function it is not susceptible to quantum computing?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;No. Schemes based on the Transcendental Logarithm Problem are not susceptible to period finding, but are susceptible to quantum enhanced speed-ups.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;If not, is there some similar, alternative statement of the form &quot;if an encryption scheme cannot be broken by algorithm X, it cannot be broken by quantum computing&quot;?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;No. We do not know every single quantum algorithm in possible existence. Even if a scheme is resilient to period finding &lt;em&gt;and&lt;/em&gt; Grover's algorithm, it might be possible to use quantum computers to break it more efficiently than classical computers. We might just need to make Peter Shor interested enough to come up with a quantum enhanced decryption scheme for it.  &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Is it sufficient to prove that an encryption scheme can only be broken by trying all possible keys, and the best that quantum computing can do in this regard is square root search time with Grover's algorithm?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;No. Just because a classical computer cannot break your scheme except by trying all possible keys, doesn't mean a quantum computer cannot.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here is a question that does have a &lt;strong&gt;yes&lt;/strong&gt; answer:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;What can we do to prove that an encryption scheme is safe against quantum computers?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Answer: Prove that decrypting the code is a QMA complete or QMA hard problem. QMA hard problems are problems that are hard for quantum computers in the way that NP hard problems are hard for classical computers. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This has inspired me to ask &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2516/what-classical-public-key-cryptography-protocols-exist-for-which-decryption-is-q&quot;&gt;this&lt;/a&gt; question, which I do not know the answer to!&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-06-29T05:01:56.230" LastActivityDate="2018-06-29T05:01:56.230" CommentCount="1" />
  <row Id="2516" PostTypeId="1" CreationDate="2018-06-29T04:59:42.687" Score="6" ViewCount="65" Body="&lt;p&gt;Such a public key cryptosystem would be &quot;quantum safe&quot; in the sense that quantum computers cannot efficiently solve QMA hard problems.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-06-29T08:32:10.587" LastActivityDate="2018-06-29T08:32:10.587" Title="What classical public key cryptography protocols exist for which hacking is QMA complete or QMA hard?" Tags="&lt;complexity-theory&gt;&lt;classical-computing&gt;&lt;cryptography&gt;&lt;post-quantum-crypto&gt;&lt;qma&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="3" />
  <row Id="2517" PostTypeId="2" ParentId="2514" CreationDate="2018-06-29T06:48:02.613" Score="5" Body="&lt;p&gt;This is essentially the realm of computational complexity classes. For example, the class BQP may crudely described as the set of all problems that can be efficiently solved on a quantum computer. The difficulty with complexity classes is that it's hard to prove separations between many classes, i.e. the existence of problems which are in one class but not another.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In a sense, it is sufficient to be able to say &quot;if this quantum algorithm cannot break it, it is safe&quot;, you just have to use the right algorithm. You need a BQP-complete algorithm such as finding roots of the &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0511096&quot; rel=&quot;nofollow noreferrer&quot;&gt;Jones polynomial&lt;/a&gt; - any quantum algorithm can be cast as an instance of a BQP-complete algorithm. However, &lt;em&gt;how&lt;/em&gt; that algorithm might be used for the cracking is completely unclear and non-trivial. It's not enough to see that you can't directly brute force things. So, that approach is probably not so helpful.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What do we want from a post-quantum crypto scenario? We need:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;a function $y=f(x)$ that we can easily compute for the purposes of encryption.&lt;/li&gt;&#xA;&lt;li&gt;for which the inverse, $f^{-1}(y)$ cannot easily be computed on a quantum computer, i.e. the problem class is outside BQP.&lt;/li&gt;&#xA;&lt;li&gt;given some secret, $z$, there is a classically efficiently computable function $g(y,z)=x$, i.e. with the supplementary information, the function $f(x)$ can be inverted. This is so that the right person (who has the private key, $z$) can decrypt the message.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;This last bullet is (essentially) the definition of the complexity class NP: the problems for which it may be hard to find a solution, but for which a solution is easily verified when given a proof (corresponding to the private key in our case).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, what we're after are problems in NP but not in BQP. Since we don't know if NP=BQP, we don't know that such things exist. However, there's a good route for looking at solutions: we consider NP-complete problems. These are the hardest instances of problems in NP, so if BQP$\neq$ NP (which is widely believed to be the case), NP-complete problems are certainly not in BQP. (If a problem is complete for a complexity class, it means that if you can solve it efficiently, you can solve all instances of the class efficiently.) So, this is kind of the guidance for where one might look for post-quantum algorithms.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The additional subtlety that complicates matters, however, is roughly (I'm not an expert) that complexity classes talk about worst case complexity, i.e. for a given problem size, it's about how hard the hardest possible instance of the problem is. But there could be only one such problem instance, which would mean that if we fix the problem size (as is standard, e.g. you might talk about 1024 bit RSA; the 1024 bits is the problem size), there's only be one private key. If we know that, an eavesdropper can just use that private key to decrypt messages. So, we actually need that this computational complexity reasoning applies for a large proportion of possible inputs. This gets you into the world of average-case complexity where, as I understand it, it becomes much harder to make such statements.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It may help to make a comparison to RSA, a public key crypto-system, and ignoring the existence of quantum computers. It is based on the difficulty of factoring large composite numbers. This problem is not (believed to be) in P, so it is believed to be difficult for a hacker with a classical computer to get at the answer. Meanwhile, it is in NP because the solution is readily verified (if you're given one factor, you can easily check it's a factor). That means it can be decrypted using a classical computer by the rightful recipient.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-06-29T08:58:41.047" LastActivityDate="2018-06-29T08:58:41.047" CommentCount="0" />
  <row Id="2518" PostTypeId="2" ParentId="2516" CreationDate="2018-06-29T06:54:56.763" Score="2" Body="&lt;p&gt;Please start by reading my answer &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2517/1837&quot;&gt;here&lt;/a&gt;. I believe you've mistaken the requirements for post-quantum crypto. If you use a scheme which is QMA-hard, then that means either your problem is QMA-complete (in which case, you can decrypt the message using a quantum computer, but not with a classical computer unless NP=QMA), or not (in which case you cannot decrypt efficiently even on a quantum computer). What you typically want for post-quantum crypto is something for which the decryption (by the holder of the private key) can be performed efficiently on a classical computer. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;There may be schemes out there which are designed to be run with quantum computers performing the (allowed) decryption, but I'm not aware of any, and they are not the main focus of research at the moment.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As I also described in the other answer, what you're more likely to be interested in is some form of typical case complexity. I suppose it's conceivable that cases with an NP-complete typical case complexity &lt;em&gt;could&lt;/em&gt; have worst-case complexity that's QMA-hard.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-06-29T07:24:45.697" LastActivityDate="2018-06-29T07:24:45.697" CommentCount="5" />
  <row Id="2519" PostTypeId="2" ParentId="2513" CreationDate="2018-06-29T07:21:51.743" Score="1" Body="&lt;p&gt;Your second unitary isn't quite right, it's not even unitary! I think it should be:&#xA;$$e^{i\gamma}\cdot\begin{pmatrix} \cos\frac{\alpha}{2}-i\,\sin\frac{\alpha}{2}\,\cos\frac{\theta}{2}&amp;amp;-i\,\sin\frac{\alpha}{2}\sin\frac{\theta}{2}\,e^{-i\phi}\\ -i\,\sin \frac{\alpha}{2}\sin\frac{\theta}{2}e^{i\phi}&amp;amp;\cos\frac{\alpha}{2}+i\,\sin\frac{\alpha}{2}\,\cos\frac{\theta}{2}\end{pmatrix}.$$&lt;br&gt;&#xA;This may make is easier to find the correspondence. Let me put $\tilde\ $ over the entities from the first unitary in order to distinguish them.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's define $\tan(\beta)=\tan\frac{\alpha}{2}\cos\frac{\theta}{2}$. This is the phase of the first matrix element, so&#xA;$$&#xA;\cos\frac{\alpha}{2}-i\,\sin\frac{\alpha}{2}\,\cos\frac{\theta}{2}=e^{i\beta}\cos\frac{\tilde\theta}{2},&#xA;$$&#xA;where we're allowing equality between the two unitaries to be up to a global phase $e^{i(\gamma+\beta)}$. In other words,&#xA;$$&#xA;\cos^2\frac{\tilde\theta}{2}=\cos^2\frac{\alpha}{2}+\sin^2\frac{\alpha}{2}\cos^2\frac{\theta}{2}=\cos^2\frac{\alpha}{2}\sec^2\beta.&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For the off-diagonal entries, recall that a unitary matrix must have columns whose sum-mod-square must be 1. Thus, the off-diagonal entries must be $\sin\frac{\tilde\theta}{2}$ up to some phase which we have to fix. We need&#xA;$$&#xA;-\beta+\phi-\frac{\pi}{2}=\tilde\phi\qquad -\beta-\phi-\frac{\pi}{2}=\tilde\lambda+\pi,&#xA;$$&#xA;where I've incorporated the $i$ and $-1$ factors using phases $\pi/2$ and $\pi$. That perfectly fixes the relations between those two.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now we only have to get the bottom-right matrix element correct. Again, we've already got the weight correct by unitarity, it's just the phase that we need. This is $-2\beta$, which from adding together the above two relations gives $\tilde\phi+\tilde\lambda+2\pi\equiv\tilde\phi+\tilde\lambda$, exactly as required.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-29T07:21:51.743" CommentCount="2" />
  <row Id="2520" PostTypeId="2" ParentId="2505" CreationDate="2018-06-29T07:35:00.587" Score="4" Body="&lt;p&gt;You are correct with your calculation that&#xA;$$&#xA;T\left(\begin{array}{c} 1 \\ 1 \end{array}\right)/\sqrt{2}=\left(\begin{array}{c} 1 \\ e^{i\pi/4} \end{array}\right)/\sqrt{2},&#xA;$$&#xA;and you are correct that if you want to calculate the probability of getting a &quot;0&quot;$\equiv\left(\begin{array}{c} 1 \\ 0 \end{array}\right)$ measurement result, you evaluate&#xA;$$&#xA;P(0)=\left|\left(\begin{array}{cc} 1 &amp;amp; 0 \end{array}\right)\cdot\left(\begin{array}{c} 1 \\ e^{i\pi/4} \end{array}\right)/\sqrt{2}\right|^2=\frac{1}{2},&#xA;$$&#xA;so you get both answers with probability 1/2. However, this is not what the referenced page is trying to calculate. It says&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;If we start with a system initially in the |+⟩ (which is done using the Hadamard), then apply multiples of the T gate and measure in the x-basis...&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The X-basis is not the question of 0 or 1 that you have already calculated. Instead, it's the probability of being in $|\pm\rangle=\frac{1}{\sqrt{2}}\left(\begin{array}{c} 1 \\ \pm 1\end{array}\right)$. I think the confusion has arisen because while people often refer to 0 and 1 as being the computational basis (as I have, and you have), when you're talking about measurements where there are two possible results, you can always label the outcomes as 0 and 1, no matter what basis was used. This is what they've done.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So,&#xA;$$&#xA;P(+)=\left|\frac{1}{\sqrt{2}}\left(\begin{array}{cc} 1 &amp;amp; 1 \end{array}\right)\cdot\left(\begin{array}{c} 1 \\ e^{i\pi/4} \end{array}\right)/\sqrt{2}\right|^2=\frac{1}{4}|1+e^{i\pi/4}|^2&#xA;$$&#xA;Expanding this gives&#xA;$$&#xA;P(+)=\frac{1}{4}\left((1+\cos\frac{\pi}{4})^2+\sin^2\frac{\pi}{4}\right)=\frac{1}{4}\left((1+\frac{1}{\sqrt{2}})^2+\frac{1}{2}\right)=\frac{2+\sqrt{2}}{4}&#xA;$$&#xA;If you numerically evaluate this, you'll get the required result, 0.8535533. You could repeat the calculation for $P(-)$, or just use the fact that $P(+)+P(-)=1$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The x-length, as they call it, is&#xA;$$&#xA;P(+)-P(-)=2P(+)-1=\frac{2+\sqrt{2}}{2}-1=\frac{1}{\sqrt{2}}.&#xA;$$&#xA;Again, that's exactly what's claimed.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-29T07:35:00.587" CommentCount="5" />
  <row Id="2521" PostTypeId="1" CreationDate="2018-06-29T08:09:05.213" Score="5" ViewCount="88" Body="&lt;p&gt;I have been reading about the Quantum Channel Capacity and it seems to be an open problem to find such capacity in general. Quantum capacity is the highest rate at which quantum information can be communicated over many independent uses of a noisy quantum channel from a sender to a receiver.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Known results on the field are the Hashing bound, which is a lower bound on such quantum capacity and which is given by the LSD (Lloyd-Shor-Devetak) theorem; or the HSW (Holevo-Schumacher-Westmoreland) theorem for classical capacity over quantum channels.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I was wondering if there have been any advances in what a general expression for the quantum capacity since the release of those theorems. A glimpse on the advance in such field is enough for me, or references to papers where such task is developed.&lt;/p&gt;&#xA;" OwnerUserId="2371" LastActivityDate="2018-07-13T15:05:31.410" Title="Advances in Quantum Channel Capacity" Tags="&lt;quantum-information&gt;&lt;quantum-channel&gt;&lt;quantum-communication&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="3" />
  <row Id="2522" PostTypeId="1" CreationDate="2018-06-29T08:50:13.583" Score="4" ViewCount="30" Body="&lt;p&gt;I know there are measures that can be taken to mitigate the effects of dephasing (I'm referring here to Dynamic Decoupling and the other ideas it led to). I find it surprising that there is no equivalent procedure to mitigate the effects of energy leakage. In principle, it seems like if you add energy to the system at the rate it leaves (due to interactions with the measurement equipment, etc) you could keep a qubit at the same energy level indefinitely. That is, $T_1 \to \infty$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I know that just have the qubit at the correct energy probably isn't enough to ensure that it is in a pure state, so I want to try to formulate this idea using the density matrix formalism and try to see if there is any clever way to add the energy in such a way to keep the qubit in an initial .&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I can't get started, so I'm asking for help. How would you model a system at constant energy, with energy leaving and entering at the same rate?&lt;/p&gt;&#xA;" OwnerUserId="1867" LastEditorUserId="26" LastEditDate="2018-06-29T08:56:14.490" LastActivityDate="2018-06-29T09:10:58.057" Title="Modeling energy relaxation effects with density matrix formalism" Tags="&lt;density-matrix&gt;&lt;energy-relaxation&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2523" PostTypeId="2" ParentId="2522" CreationDate="2018-06-29T09:10:58.057" Score="1" Body="&lt;p&gt;I think the real question is &lt;em&gt;how&lt;/em&gt; are you putting the energy back in? Here's a natural suggestion:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Take one qubit for simplicity. It was two energy levels, call them 0 and 1. 1 is at an energy $\omega$ higher than 0. So, the natural Hamiltonian is&#xA;$$&#xA;H_0=\omega|1\rangle\langle 1|&#xA;$$&#xA;If you want to talk about energy dissipation, you probably have to go to the Lindblad equation, with an amplitude damping term&#xA;$$&#xA;L=\gamma|0\rangle\langle 1|.&#xA;$$&#xA;However, you're probably going to add energy back in using a unitary process,&#xA;$$&#xA;H_1=\Omega(|0\rangle\langle 1|+|1\rangle\langle 0|).&#xA;$$&#xA;Thus, the overall evolution is&#xA;$$&#xA;\frac{d\rho}{dt}=-i[H_0+H_1,\rho]+L\rho L^\dagger-\frac12(L^\dagger L\rho+\rho L^\dagger L).&#xA;$$&#xA;Now, if you want to make sure there's a balance of energy in and energy out, you want to evaluate the expected energy of the state, $\text{Tr}(\rho H_0)$, and make sure that's a constant, i.e. that the time derivative is 0. I haven't tried to solve it (you were asking for a starting point) but I presume that to make it work, $\Omega$ will be a function of time and of the initial state. The other interesting thing to calculate will presumably be $\text{Tr}(\rho^2)$ (or perhaps its first derivative). This will map the increasing mixedness of the state $\rho$, which can never be compensated for by the unitary action of $H_1$ (which preserves mixedness).&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-29T09:10:58.057" CommentCount="4" />
  <row Id="2524" PostTypeId="1" CreationDate="2018-06-29T10:04:47.453" Score="5" ViewCount="79" Body="&lt;p&gt;I don't know much about physics so maybe the question is stupid, but I wonder how engineers detect that the state function did not collapse due to the environment while a calculation is performed? Theoretically, a measurement will break the system. Related is also the next question, how to detect that a calculation is finished? A measurement should also break the state function and thus break an ongoing calculation. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If one thinks further, how is it even possible to check whether the experimenter produced a certain quantum state? Maybe all the bits have a totally different state right from the start and you just know about that afterwards. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I seem to miss something because if this would be true, quantum computers would be in-practical. Is it like this: The experimenter takes a measurement periodically and hopes that the operation was successful?&lt;/p&gt;&#xA;" OwnerUserId="2827" LastEditorUserId="26" LastEditDate="2018-06-29T11:01:28.690" LastActivityDate="2018-07-02T11:12:48.310" Title="How to check states?" Tags="&lt;measurement&gt;" AnswerCount="2" CommentCount="4" />
  <row Id="2525" PostTypeId="1" AcceptedAnswerId="2546" CreationDate="2018-06-29T11:17:13.757" Score="8" ViewCount="55" Body="&lt;p&gt;Qudit graph states are $d$-dimension generalisations of qubit graph states such that each state is represented by a weighted graph $G$ (with no self-loops) such that each edge $(i, j)$ is assigned a weight $A_{i, j} = 0,\ldots,d-1$. &#xA;The graph state associated with $G$ is then given by&#xA;$$&#xA;|G⟩ = \prod_{i&amp;gt;j} \textrm{CZ}_{i,j}^{A_{i,j}} |+⟩^{\otimes n},&#xA;$$ &#xA;where $|+⟩ = F^\dagger|0⟩$ and $F$ is the Fourier gate&#xA;$$&#xA;F = \frac{1}{\sqrt{d}}\sum_{k=0}^{d-1} \omega^{kl}|k⟩⟨l|.&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the literature on qudit graph states, there does not seem to be a consistency as to whether such states are defined only for $d$ prime or not.&#xA;For example, some sources only give the above definition for $d$ prime, such as&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://journals.aps.org/pra/pdf/10.1103/PhysRevA.82.062315&quot; rel=&quot;noreferrer&quot;&gt;Quantum secret sharing with qudit graph states&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1306.2879.pdf&quot; rel=&quot;noreferrer&quot;&gt;Absolutely Maximally Entangled Qudit Graph States&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;whereas some do not specify any such restriction, such as&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://journals.aps.org/prl/pdf/10.1103/PhysRevLett.110.100403&quot; rel=&quot;noreferrer&quot;&gt;Greenberger-Horne-Zeilinger Paradoxes from Qudit Graph States&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://journals.aps.org/pra/pdf/10.1103/PhysRevA.78.042303&quot; rel=&quot;noreferrer&quot;&gt;Quantum-error-correcting codes using qudit graph states&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;So which is correct? &#xA;&lt;strong&gt;Are qudit graph states (well-)defined when the dimension is non-prime?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Also, if so, &lt;strong&gt;are they uniquely defined?&lt;/strong&gt;&lt;/p&gt;&#xA;" OwnerUserId="391" LastActivityDate="2018-06-30T17:38:39.493" Title="Are qudit graph states well-defined for non-prime dimension?" Tags="&lt;qudit&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="2526" PostTypeId="1" CreationDate="2018-06-29T11:43:38.203" Score="5" ViewCount="105" Body="&lt;p&gt;I'm looking at &lt;a href=&quot;https://arxiv.org/pdf/1207.0511.pdf&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt; paper and try to implement the Quantum adders they define myself. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Suppose we have a number $b=b_{n-1}\dots b_1b_0$ and they want to add a constant number $a=a_{n-1}\dots a_1a_0$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;They define&#xA;$$A_j = \Pi_{k=1}^{j+1} R_k^{a_{j+1-k}}, \quad R_k = \begin{pmatrix}1&amp;amp;0\\0&amp;amp;e^{i2\pi/2^k}\end{pmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The result can be obtained by first applying a QFT on all qubits, then apply $A_j$ on qubit $j$ and then apply an inverse QFT. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, if I try to work this out for the simple case where $b=0$ and $a=1$, I end up with a quantum state &#xA;$$0.5\left|01\right&amp;gt; + (0.5+0.5i)\left|10\right&amp;gt; - 0.5i \left|11\right&amp;gt;.$$&#xA;Note in this case, $A_0 = Z$ and $A_1 = S$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is there an error in my calculation, or is the definition in the article not correct? &lt;/p&gt;&#xA;" OwnerUserId="2005" LastActivityDate="2018-06-29T22:03:21.600" Title="Quantum Arithmetic" Tags="&lt;quantum-algorithms&gt;&lt;circuit-model&gt;" AnswerCount="1" CommentCount="6" />
  <row Id="2527" PostTypeId="2" ParentId="2524" CreationDate="2018-06-29T13:44:12.460" Score="2" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;How engineers detect that the state function did not collapse due to the environment while a calculation is performed? &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;You can detect and correct errors during the calculation by using some &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_error_correction&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Error Correction code&lt;/a&gt;. The idea behind these error correction codes is:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;You entangle the qubit you want to &quot;protect&quot; against errors with $n$ other qubits.&lt;/li&gt;&#xA;&lt;li&gt;You perform the operation that may introduce an error.&lt;/li&gt;&#xA;&lt;li&gt;You measure a &lt;strong&gt;general&lt;/strong&gt; property of the system. &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;I recommend you to read &lt;a href=&quot;https://arxiv.org/abs/0905.2794&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Error Correction for Beginners (Devitt, Nemoto &amp;amp; Munro, 2013)&lt;/a&gt; if you want more details on quantum error correction (and detection!).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But you are right, a &lt;em&gt;dumb&lt;/em&gt; measurement will break the state function and thus break an ongoing calculation. &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;How to detect that a calculation is finished?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;From the comments you wrote, your question is based on &lt;a href=&quot;https://people.eecs.berkeley.edu/~christos/classics/Deutsch_quantum_theory.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum theory, the Church-Turing principle and the universal quantum computer&lt;/a&gt; (page 7). In this paper, David Deutsch tries to formalise the Quantum Turing Machine (QTM). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the model of the QTM, a user does not have any mean to know if the computation is over or not but the machine does (because there is no more instruction, because the quantum state ended up in a trap state, etc.). In order to let the user know that he can retrieve the result of its calculations, the machine just flips a (classical) bit to 1. This bit and the quantum bits used for the computation are obviously not entangled (classical bits cannot be entangled) and so measuring the bit will not change the quantum system.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In real-world models/implementations, this may be done by other means. For example with IBM's quantum chips, you know that your computation is finished when the results become available and IBM knows that the computation is over because they executed on the quantum chip all the quantum gates you asked them to execute.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;How is it even possible to check whether the experimenter produced a certain quantum state?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;You can perform 2 different checks:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Quantifying the reliability of the initial state: if the experimenter tell you that the initial state is $\left|\phi\right&amp;gt;$ you can run multiple experiments consisting in only a measurement of the initial state and count how many experiments gave wrong outcomes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This check consists in measurements and so may break the initial state, so you cannot check &lt;em&gt;just before your experiment&lt;/em&gt; that the initial state is good. You can only obtain numbers like &quot;the initial state will be good in 90% of the experiments&quot;.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Checking just before your calculations that the initial state is good. As said in the previous point, this may break the initial state and I don't know any algorithm capable of doing that for an arbitrary initial state.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;The 2 points above are not making any assumptions on the initial state. If you are using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_circuit&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum circuit model&lt;/a&gt; then you expect $\left|0\right&amp;gt;^n$ as initial state and this initial state can be checked and corrected before your calculations:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Perform a destructive measurement on the qubits. Depending on the outcome of the measurement, each qubit is either in the state $\left|0\right&amp;gt;$ or $\left|1\right&amp;gt;$.&lt;/li&gt;&#xA;&lt;li&gt;For all the qubits measured in the state $\left|1\right&amp;gt;$, apply an $X$ gate to flip the qubit state to $\left|0\right&amp;gt;$.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;I think this is how IBM reset its qubits to the $\left|0\right&amp;gt;$ state (but I don't have any links ensuring it).&lt;/p&gt;&#xA;" OwnerUserId="1386" LastEditorUserId="1386" LastEditDate="2018-07-02T11:12:48.310" LastActivityDate="2018-07-02T11:12:48.310" CommentCount="0" />
  <row Id="2528" PostTypeId="1" AcceptedAnswerId="2533" CreationDate="2018-06-29T14:15:00.067" Score="4" ViewCount="112" Body="&lt;p&gt;In $\mathbb{C^2}$, we generally take $+1$ and $-1$ as the standard eigenvalues, that's what Pauli-X, Pauli-Z measurements, etc will give us.&#xA;Is there a similar standard while measuring in the Bell basis and the computational basis in $\mathbb{C^2}\otimes\mathbb{C^2}$?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Of course, the actual eigenvalues don't matter, as long as we are talking about the same resolution of identity, but I was just wondering if there was a convention.&lt;/p&gt;&#xA;" OwnerUserId="2832" LastEditorUserId="434" LastEditDate="2018-06-29T18:30:45.483" LastActivityDate="2018-07-02T18:01:16.527" Title="What are the standard eigenvalues in $\mathbb{C^2}\otimes\mathbb{C^2}$?" Tags="&lt;qubit&gt;&lt;qubit-state&gt;&lt;measurement&gt;" AnswerCount="1" CommentCount="3" />
  <row Id="2529" PostTypeId="2" ParentId="2427" CreationDate="2018-06-29T15:19:38.633" Score="1" Body="&lt;p&gt;I have found this paper in which an insight about the question can be seen as the author states the difficulty of constructing the so-called &lt;em&gt;quantum repeaters&lt;/em&gt; for quantum networks due to the no-cloning theorem. However, the constructions are indeed possible. The aforementioned paper is can be found &lt;a href=&quot;https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;amp;arnumber=6246754&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;. The same author has a book called Quantum Networking where I consider that he will go further in explaining such difficulty and how to overcome it, but I do not have access to such text, so I am not sure if such explanation is given there.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am giving this information as an answer so that other users interested in quantum networking can find information about the question that is being asked here.&lt;/p&gt;&#xA;" OwnerUserId="2371" LastActivityDate="2018-06-29T15:19:38.633" CommentCount="0" />
  <row Id="2530" PostTypeId="1" AcceptedAnswerId="2532" CreationDate="2018-06-29T15:24:57.843" Score="6" ViewCount="1531" Body="&lt;p&gt;After taking some measure, how can a qunit be &quot;unmeasured&quot;? Is unmeasurement (ie reverse quantum computing) possible?&lt;/p&gt;&#xA;" OwnerUserId="2645" LastActivityDate="2018-07-01T02:03:53.217" Title="Reverse Quantum Computing: How to unmeasure a qunit" Tags="&lt;measurement&gt;&lt;qudit&gt;" AnswerCount="3" CommentCount="0" FavoriteCount="1" />
  <row Id="2531" PostTypeId="2" ParentId="2530" CreationDate="2018-06-29T15:30:01.533" Score="3" Body="&lt;p&gt;You can compute &lt;em&gt;by measuring&lt;/em&gt; - see cluster-based quantum computation - but the whole thing that makes measurement different in quantum mechanics is that it destroys the superposition. It can't be undone. Once you measure, the qudit isn't in a state $|\psi\rangle = \alpha|0\rangle + \beta|1\rangle + ... +\gamma|n\rangle$ but in a state $|\psi\rangle = |0\rangle$ or $|\psi\rangle = |1\rangle$ or what have you based upon probability. When you measure the qubit again soon after, it stays as either $|0\rangle$ or $|1\rangle$. The superposition is gone. We can't get it back (except by doing the same operations that lead our qubit to that point, in which case it'll be very similar) because we can't clone a qubit, so we can't figure out what $\alpha$ and $\beta$ are.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Tl;dr: No.&lt;/h2&gt;&#xA;" OwnerUserId="91" LastActivityDate="2018-06-29T15:30:01.533" CommentCount="8" />
  <row Id="2532" PostTypeId="2" ParentId="2530" CreationDate="2018-06-29T15:40:33.657" Score="5" Body="&lt;p&gt;I am not really sure about what you mean by &quot;unmeasuring&quot; a qubit, but if you mean to recover the qubit that was measured by manipulating the post-measurement state then I am afraid that the answer is no. When a quantum state is measured, the supoerposition state of such is collpased to one of the possible outcomes of the measurement, and so the qubit is lost. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The third postulate of quantum mechanics explains measurments in the quantum world, and such postulate says the following:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Quantum measurements are described by a collection $\{M_m\}$ of &lt;em&gt;measurement operators&lt;/em&gt;. These are operators acting on the state space of the system being measured. The index $m$ referes to the measurement outcomes that may occur in the experiment. If the state of the quantum system is $|\psi\rangle$ immediately before the measurement, then the probability that result $m$ occurs is given by \begin{equation}&#xA;p(m)=\langle\psi|M_m^\dagger M_m|\psi\rangle,&#xA;\end{equation}&#xA;  and the state of the sytem after the measurement is &#xA;  \begin{equation}&#xA;\frac{M_m|\psi\rangle}{\sqrt{\langle\psi|M_m^\dagger M_m|\psi\rangle}}.&#xA;\end{equation}&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;So the post-measurement state collapses into another state defined by the postulate 3, and the previous quantum state is lost irreversibly. See also this &lt;a href=&quot;https://en.wikipedia.org/wiki/Wave_function_collapse&quot; rel=&quot;noreferrer&quot;&gt;wikipedia&lt;/a&gt; entry for wave function collapse, where it explains the collapse of quantum states after measurement.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Consequently, if the same measurment wants to be done, the quantum state must be prepared again before the measurement and so the xperiment can be repeated.&lt;/p&gt;&#xA;" OwnerUserId="2371" LastActivityDate="2018-06-29T15:40:33.657" CommentCount="8" />
  <row Id="2533" PostTypeId="2" ParentId="2528" CreationDate="2018-06-29T17:44:30.540" Score="3" Body="&lt;p&gt;There is no notion of &quot;standard eigenvalues&quot; for general matrices.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Some meaningful eigenvalues for 4x4 matrices are:&#xA;&lt;br&gt; &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;{-3/2, -1/2, 1/2, 3/2} which are the possible z-projections of a spin-3/2 particle&lt;/li&gt;&#xA;&lt;li&gt;Instead of eigenvalues of X and Z, use the eigenvalues of the Dirac matrices, which are 4x4 matrices that are related to Pauli matrices&lt;/li&gt;&#xA;&lt;li&gt;Instead of eigenvalues of X and Z, use the eigenvalues of the 4x4 generalization of the Gell-Mann matrices (which themselves are 3x3 generalizations of the 2x2 Pauli matrices).&lt;/li&gt;&#xA;&lt;li&gt;Finally, as Neil de Beaudrap has noted in the comment, {-1,1} can also be eigenvalues for 4x4 matrices, such as the SWAP gate.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-07-02T18:01:16.527" LastActivityDate="2018-07-02T18:01:16.527" CommentCount="2" />
  <row Id="2534" PostTypeId="2" ParentId="2499" CreationDate="2018-06-29T19:55:39.933" Score="0" Body="&lt;p&gt;&lt;strong&gt;Seperating the wheat from the hype&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As someone who has an IT background &amp;amp; a fairly decent grasp on physics, I would say the answer is yes &amp;amp; no.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;Around 2020 ... transistors will be so small that quantum theory or atomic physics takes over and electrons leak out of the wires. For example, the thinnest layer inside your computer will be about five atoms across. At that point, according to the laws of physics, the quantum theory takes over.&quot; - &lt;a href=&quot;https://www.forbes.com/sites/alexknapp/2011/03/30/the-end-of-moores-law/&quot; rel=&quot;nofollow noreferrer&quot;&gt;The End of Moore's Law&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;So from a purely technical perspective, quantum computing is &lt;em&gt;required&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You also mentioned photonic computing, which imho, is the most &lt;a href=&quot;http://sam.zeloof.xyz/first-ic/&quot; rel=&quot;nofollow noreferrer&quot;&gt;realistic option&lt;/a&gt; moving forward. This form of computing &lt;strong&gt;&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Optical_computing#Photonic_logic&quot; rel=&quot;nofollow noreferrer&quot;&gt;is&lt;/a&gt;&lt;/strong&gt; quantum computing.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Realisticly, quantum computing will initially be available via cloud access to machines that already exist (or will exist in the near future) &amp;amp; via QPUs that function as co-processors similar to GPUs (eg. &lt;a href=&quot;http://optics.org/news/9/4/4&quot; rel=&quot;nofollow noreferrer&quot;&gt;Optalysys&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So when will we have quantum watches that let us teleport to Saturn for lunch w/ Buddha via nano sized worm holes? &lt;strong&gt;Probably never.&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt;: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;To elaborate on photonic computing being quantum computing:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;It will show you the scientific evidence that tells you that the photon has an E=hf wave nature, but is neither a wave train nor a wave packet. Nor is it an electric wave and an orthogonal magnetic wave that generate one another. Instead it’s a singleton soliton electromagnetic wave with a “quantum” nature. - &lt;a href=&quot;http://physicsdetective.com/the-speed-of-light/&quot; rel=&quot;nofollow noreferrer&quot;&gt;The Physics Detective&lt;/a&gt;, John Duffield &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;In the author's words a photon is &quot;a singleton soliton electromagnetic wave with a &lt;strong&gt;&quot;quantum&quot;&lt;/strong&gt; nature.&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Since photonic computing is computing w/ photons &amp;amp; photons by there nature are &quot;quantum&quot;, logically photonic computing has a &quot;quantum&quot; nature (ie is quantum computing).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In addition, it is not clear as to what &lt;a href=&quot;https://rationalwiki.org/wiki/Talk:John_Duffield&quot; rel=&quot;nofollow noreferrer&quot;&gt;John&lt;/a&gt; is defining quantum computing as (see &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2585/2645&quot;&gt;this answer&lt;/a&gt; for more info). It is however clear that &lt;strong&gt;&lt;a href=&quot;http://physicsdetective.com/future/&quot; rel=&quot;nofollow noreferrer&quot;&gt;the future isn't what it used to be&lt;/a&gt;&lt;/strong&gt;. &lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-07-03T15:55:17.247" LastActivityDate="2018-07-03T15:55:17.247" CommentCount="6" />
  <row Id="2535" PostTypeId="2" ParentId="2371" CreationDate="2018-06-29T20:16:44.163" Score="1" Body="&lt;p&gt;In the comments to my answer the OP has written:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;In the universal gate case you stated the largest systems are &amp;lt;100.&#xA;  How could it reach 10k?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Well I have good news for you. Four days ago D-Wave announced at the AQC conference that they can now do YY coupling:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/b4upM.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/b4upM.jpg&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here you can see the superconducting circuit that gives you ZZ and YY coupling at the same time: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/C2j4K.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/C2j4K.jpg&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I cannot show you more of their &quot;preview&quot; presentation, but expect for them to publish something very soon.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Why is YY coupling significant?&lt;/strong&gt; It is because in 2007, Jacob Biamonte and Peter Love from D-Wave &lt;a href=&quot;https://arxiv.org/abs/0704.1287&quot; rel=&quot;nofollow noreferrer&quot;&gt;proved&lt;/a&gt; that XX + ZZ is enough for universal quantum computation. XX and YY are equivalent up to a rotation, so they could easily have instead said that YY + ZZ is universal.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now that D-Wave has engineered a universal set of couplers, it should be possible to have a 10,000 qubit universal quantum computer when they extend to 1250 units cells (since 8 x 1250 = 10,000, see my first answer).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I'm sorry that there's no literature references for this yet, but the picture tells the whole story, and I'm afraid that until D-Wave publishes something, this is the &quot;source&quot; for the information. &lt;a href=&quot;https://math.meta.stackexchange.com/questions/8212/citing-stackexchange-postings&quot;&gt;This&lt;/a&gt; is how you can cite this answer. &lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-06-29T20:22:51.223" LastActivityDate="2018-06-29T20:22:51.223" CommentCount="0" />
  <row Id="2536" PostTypeId="1" CreationDate="2018-06-29T20:33:12.960" Score="6" ViewCount="157" Body="&lt;p&gt;How is D-Wave's Pegasus architecture different from the Chimera architecture?&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="26" LastEditDate="2018-07-05T08:06:41.173" LastActivityDate="2018-07-05T08:06:41.173" Title="What is D-Wave's &quot;Pegasus&quot; architecture?" Tags="&lt;quantum-computer&gt;&lt;architecture&gt;&lt;d-wave&gt;&lt;chimera&gt;&lt;pegasus&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="2537" PostTypeId="2" ParentId="2536" CreationDate="2018-06-29T20:34:22.713" Score="4" Body="&lt;p&gt;Pegasus is the first fundamental change in D-Wave's architecture since the D-Wave One.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The D-Wave Two, 2X, and 2000Q all used the &quot;Chimera&quot; architecture, which consisted of unit cells of $K_{4,4}$ graphs. The four generations of D-Wave machines just added more qubits by adding more and more unit cells that were the same.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In Pegasus, the actual structure of the unit cells has fundamentally changed for the first time. Instead of the Chimera graph where each qubit can have at most 6 qubits, the Pegasus graph allows each qubit to couple to 15 other qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A machine has been made already with 680 Pegasus qubits (compare this to 2048 Chimera qubits in the D-Wave 2000Q).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The work was presented by Trevor Lanting of D-Wave, four days ago:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/YGhJx.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/YGhJx.jpg&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&#xA;&lt;a href=&quot;https://i.stack.imgur.com/8uAqC.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/8uAqC.jpg&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-06-29T20:34:22.713" CommentCount="4" />
  <row Id="2538" PostTypeId="2" ParentId="2526" CreationDate="2018-06-29T22:03:21.600" Score="2" Body="&lt;p&gt;I'm assuming an initial state of the form $|a\rangle|b\rangle = |1\rangle|0\rangle$ for your simple case.  You first perform a QFT on the right qubit, obtaining $|1\rangle(\frac{|0\rangle+|1\rangle}{\sqrt{2}})$.  Next, you apply $A_0 = R_1$ to the right qubit to obtain $|1\rangle(\frac{|0\rangle-|1\rangle}{\sqrt{2}})$.  Finally, you apply an IQFT to the right qubit and obtain $|1\rangle|1\rangle$, thereby demonstrating that $1+0=1$.  As @DaftWullie noted, all the action happens on the &quot;$b$&quot; qubit; the $a$ qubit (or cbit in this case) acts only as a control.&lt;/p&gt;&#xA;" OwnerUserId="356" LastActivityDate="2018-06-29T22:03:21.600" CommentCount="1" />
  <row Id="2539" PostTypeId="2" ParentId="2530" CreationDate="2018-06-29T23:02:56.480" Score="2" Body="&lt;p&gt;Unitary operation is revesible, but measurement is a projection operation, which is not reveaible. Think about matrix inverse, projection matrix has lower rank and does not have inverse&lt;/p&gt;&#xA;" OwnerUserId="2854" LastActivityDate="2018-06-29T23:02:56.480" CommentCount="1" />
  <row Id="2540" PostTypeId="1" AcceptedAnswerId="2542" CreationDate="2018-06-30T01:00:47.627" Score="8" ViewCount="81" Body="&lt;p&gt;A universal set of gates are able to mimic the operation of any other gate type, given enough gates. For example, a universal set of quantum gates are the Hadamard(H), the pi/8 phase shift(T), and the CNOT gate. How would one disprove or prove universality of a set of gates such as {H,T}, {CNOT,T}, {CNOT, H}.&lt;/p&gt;&#xA;" OwnerUserId="2713" LastEditorUserId="26" LastEditDate="2018-06-30T06:01:56.540" LastActivityDate="2018-06-30T06:28:34.517" Title="How to prove/disprove universality for a set of gates?" Tags="&lt;quantum-gate&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="2541" PostTypeId="2" ParentId="2540" CreationDate="2018-06-30T01:19:45.857" Score="2" Body="&lt;p&gt;Nielsen and Chuang, pg 191 of the 10th anniversary edition:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;We have just shown that an arbitrary unitary matrix on a $d$-dimensional Hilbert space may be written as a product of two-level unitary matrices. Now we show that single qubit and CNOT gates together can be used to implement an arbitrary two-level unitary operation on the state space of $n$ qubits. Combining these results we see that single qubit and CNOT gates can be used to implement an arbitrary unitary operation on $n$ qubits and therefore are universal for quantum computation.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The first sentence there is an accepted result, so you must simply show that the combination of your gate set can implement &quot;an arbitrary two-level unitary operation&quot;. To quote Wikipedia:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Technically, this is impossible since the number of possible quantum gates is uncountable, whereas the number of finite sequences from a finite set is countable. To solve this problem, we only require that any quantum operation can be approximated by a sequence of gates from this finite set. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;See also &lt;a href=&quot;https://arxiv.org/abs/1610.00547&quot; rel=&quot;nofollow noreferrer&quot;&gt;this paper&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="91" LastActivityDate="2018-06-30T01:19:45.857" CommentCount="0" />
  <row Id="2542" PostTypeId="2" ParentId="2540" CreationDate="2018-06-30T05:41:35.557" Score="5" Body="&lt;p&gt;Universality can be a very subtle thing which is quite tricky to prove. There are usually two options for proving it:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;show directly, using your chosen gates, how to construct any arbitrary unitary of arbitrary size (there’s no constraint on the size of the construction, just that it can be done) to arbitrary accuracy (on some non-trivial sub space of the full Hilbert space).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;show how your chosen set of gates can be used to recreate (to arbitrary accuracy) an existing universal set.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Conversely, if you wish to disprove it, you show that the effect of your set of gates can always be simulated by an (assumed) lesser model of computation, usually classical computation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are a few heuristics that you can use for guidance:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;you must have a multi-qubit gate in your set. If all you have are single-qubit gates, you can simulate each qubit independently on a classical computer. So, if we believe that quantum computers are more powerful than classical, single qubit gates alone are not universal for quantum computation. This rules out {H,T}.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;you must have a gate that creates superpositions. This rules out {CNOT, T}. Again, this is a classical computation with the addition of an irrelevant global phase.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Of course, these are not sufficient conditions: the set {H,S,CNOT} can be efficiently simulated as well (see Gottesman-Knill theorem). This must also be true of {H,CNOT} as they are a subset and so the operations that they can create is no more than those of the original set.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One of the universal sets that I find most interesting is &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0301040&quot; rel=&quot;noreferrer&quot;&gt;{Toffoli,H}&lt;/a&gt;. It always feels surprising to me that this is enough (especially when you compare to the previous set). Note that it does not involve any complex numbers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is also possible to get universality from a &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0512058&quot; rel=&quot;noreferrer&quot;&gt;single two-qubit gate&lt;/a&gt; such as&#xA;$$&#xA;\left(\begin{array}{cccc} 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; \frac{1}{\sqrt{2}} &amp;amp; -\frac{1}{\sqrt{2}} \\ 0 &amp;amp; 0 &amp;amp; \frac{1}{\sqrt{2}} &amp;amp; \frac{1}{\sqrt{2}} \end{array}\right)&#xA;$$&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-06-30T06:28:34.517" LastActivityDate="2018-06-30T06:28:34.517" CommentCount="0" />
  <row Id="2543" PostTypeId="2" ParentId="2499" CreationDate="2018-06-30T10:58:44.880" Score="8" Body="&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;: I've been working on the theory of quantum computers for about 15 years. I've seen nothing convincing to say that they won't work. Of course, the only real proof that they can work is to make one. It's happening now. However, what a quantum computer will do and why we want it does not match up with the public perception.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Is quantum computing just pie in the sky? Is it all just jam-tomorrow woo peddled by quantum quacks to a gullible public?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;As a &quot;quantum quack&quot; (thanks for that), of course I'm going to tell you it's all realistic. But the theory &lt;em&gt;is&lt;/em&gt; sound. So long as quantum mechanics is correct, the theory of quantum computation is correct, and there are efficient algorithms for quantum computers for which we don't know how to efficiently compute the solution on a classical computer. But I don't think anything that I write here can convince a skeptic. Either, you have to sit down and learn all the details yourself, or wait and see.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Of course, quantum mechanics is only a theory which could be superseded at any time, but its predictions have already been applied to explain the world around us. Quantum computers are not pushing the theory into an untested regime where we might hope there are unexpected results (which is what physicists really hope for, because that's where you start to see hints at new physics). For example, quantum mechanics is already applied to condensed matter systems consisting of far more constituents than we're talking about qubits in a near-term quantum computer. It's just that we need an unprecedented level of control over them. A few people think they have arguments for why a quantum computer won't work, but I've not found anything particularly convincing in the arguments that I've read.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Is it all hype and hot air?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There is a lot of hype surrounding quantum computers. I would say that this comes from two main sources:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;the popular representation of quantum computing in the mainstream media and popular culture (e.g. science fiction books). Ask anybody actively working on quantum computation, I think they will all agree it's poorly represented, giving the impression that it's a universal solution that will make everything run quicker, which is, at least for now, not the case. There has been some jam-tomorrow woo peddled to a gullible public, but that's more through a &quot;lost in translation&quot; attempt to over-simplify what's going on, mostly by non-specialist intermediaries.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;researchers themselves. For the past 20(ish) years, people have been promising that quantum computing is just over the horizon, and its never quite materialized. It's quite reasonable that observers get sick of it at that point. However, my perspective from being within the field is that many people claiming to be working towards quantum computers haven't been. As funding bodies have got progressively more demanding with the &quot;why&quot; for research, and ensuring &quot;impact&quot;, quantum computing has become the go-to for many experimentalists, even if they aren't really interested in doing anything for a quantum computer. If there's been some way that they can twist what they're doing so that it sounds relevant to quantum computing, they've tended to do it. It doesn't mean that quantum computing can't be done, it just hasn't been as much of a focus as has been implied. Take, at a slightly different level, the explosion of quantum information theory. So few theorists within that have actively worked on the theory of quantum computers and how to make them work (that's not to say they've not been doing interesting things).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;However, we are now hitting a critical mass where there's suddenly a lot of research investment in making quantum computers, and associated technology, a reality, and things are starting to move. We seem to be just hitting the point, with devices of about 50 qubits, that we might be capable of achieving &quot;quantum supremacy&quot; - performing computations whose results we can't really verify on a classical computer. Part of the problem with achieving this has actually been the aforementioned rapid progress of classical computing. Given Moore's Law type of progress, yielding exponentially improving classical computational power, it's been a constantly shifting bar of what do we need to achieve to be convincing.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Quantum computers don't show similar progress. Au contraire, it looks like they haven't even got off the ground.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The point is, it's hard to do, and it's taken a long time to get the basic technology right. This is a slightly imperfect comparison, but it's not too bad: think about the lithography processes that are used for making processors. Their development has been progressive, making smaller and smaller transistors, but progress has been slowing as it's got harder and harder to deal with, for one, the quantum effects that are getting in the way. Quantum computers, on the other hand, are essentially trying to step over that whole progressive improvement thing and jump straight to the ultimate, final, result: single atom transistors (kind of). Perhaps that gives some level of insight into what the experimentalists are trying to deal with?&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;You won't be buying one in PC World any time soon. Will you ever be able to?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;It's not clear that you'd even want to. At the moment, we expect quantum computers to be useful for certain, very specific tasks. In that case, we perhaps envisage a few powerful centralized quantum computers that do those specific jobs, and most people will keep going with classical computers. But, since you want to draw analogies with the development of classical computers, then (according to Wikipedia) it is in 1946 that Sir Charles Darwin (grandson of the famous naturalist), head of Britain's National Physical Laboratory, wrote:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;it is very possible that ... one machine would suffice to solve all the problems that are demanded of it from the whole country&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;(variants of this are attributed to people like Watson). This very clearly is not the case. The reality was that once computers became widely available, further uses were found for them. It &lt;em&gt;might&lt;/em&gt; be the same for quantum computers, I don't know. One of the other reasons that you wouldn't buy a quantum computer in a shop is its size. Well, the actual devices are usually tiny, but it's all the interfacing equipment and, especially, cooling that takes up all the space. As the technology improves, it'll be able to operate at progressively higher temperatures (look, for example, at the progress of high temperature superconductivity compared to the original temperatures that had to be achieved) which will reduce cooling requirements.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-06-30T10:58:44.880" CommentCount="2" />
  <row Id="2544" PostTypeId="2" ParentId="2499" CreationDate="2018-06-30T11:27:49.613" Score="10" Body="&lt;p&gt;&lt;strong&gt;TL,DR:&lt;/strong&gt; Engineering and physics arguments have already been made. I add a historical perspective: I argue that the field of quantum computation is really only a bit more than two decades old and that it took us more than three decades to build something like the MU5.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Since you mention the timeline, let's have a closer look:&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;The beginnings&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;First of all, the mere possibility of something like a quantum computer was voiced by Richard Feynman in the west (1959 or 1981 if you wish) and Yuri Manin in the east (1980). But that's just having an idea. No implementation starts.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When did similar things happen with classical computing? Well, a very long time ago. Charles Babbage for instance already wanted to build computing machines in the early 19th century and he already had ideas. Pascal, Leibniz, they all had ideas. Babbage's &lt;a href=&quot;https://en.wikipedia.org/wiki/Analytical_Engine&quot; rel=&quot;nofollow noreferrer&quot;&gt;analytical machine&lt;/a&gt; of 1837 which was never built due to funding and engineering challenges (by the way, the precursor of the analytical machine &lt;a href=&quot;http://acarol.woz.org/difference_engine.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;was built with Lego&lt;/a&gt;) is definitely the most recent first idea that is already way ahead of what Feynman and Manin proposed for quantum computing, because it proposes a concrete implementation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The '70s don't see anything related to a quantum computer. Some codes are invented, some theoretical ground work is done (how much information can be stored?), which is necessary for qc, but it's not really pursuing the idea of a quantum computer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Codes and communication related ideas are to quantum computation what telephones and telegraph wires are to classical computing: an important precursor, but not a computer. As you know, Morse codes and telegraphs are technologies of the 19th century and more difficult codes for noisy channels were also studied. The mathematical groundwork (in terms of no-go-theorems and the like) was done in 1948 by Shannon. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Anyway, it can be argued that punch card computing was developed in 1804 &lt;a href=&quot;https://en.wikipedia.org/wiki/Joseph_Marie_Jacquard&quot; rel=&quot;nofollow noreferrer&quot;&gt;for weaving&lt;/a&gt;, but I don't want to claim that this was really the beginning of classical computation.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Universal (quantum) computers&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;So when did computation start? I'm going to argue that you need a number of things to get research for universal computing off the ground; before that, the amount of people and money invested there will be limited.&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;You need the notion of a universal computer and a theoretical model of what to achieve.&lt;/li&gt;&#xA;&lt;li&gt;You need an architecture of how to implement a universal computer - on a theoretical level.&lt;/li&gt;&#xA;&lt;li&gt;You need a real-life system where you could implement it. &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;When do we get those in quantum computation?&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Deutsch describes the universal quantum computer in 1985 (33 years ago). &lt;/li&gt;&#xA;&lt;li&gt;Circuit models and gates are developed around the same time.&lt;/li&gt;&#xA;&lt;li&gt;The first complete model of how to put everything together was proposed by Cirac and Zoller in 1994 (merely 24 years ago).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;All the other advances in quantum computation before or during that time were limited to cryptography, quantum systems in general or other general theory.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What about classical computation?&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;We have Turing's work on &lt;a href=&quot;https://en.wikipedia.org/wiki/Turing_machine&quot; rel=&quot;nofollow noreferrer&quot;&gt;Turing machines&lt;/a&gt; (1936) or &lt;a href=&quot;https://en.wikipedia.org/wiki/Lambda_calculus&quot; rel=&quot;nofollow noreferrer&quot;&gt;Church's work&lt;/a&gt; (same time frame).&lt;/li&gt;&#xA;&lt;li&gt;Modern architectures rely on &lt;a href=&quot;https://en.wikipedia.org/wiki/Von_Neumann_architecture&quot; rel=&quot;nofollow noreferrer&quot;&gt;von Neumann's model&lt;/a&gt; (1945); other architectures exist.&lt;/li&gt;&#xA;&lt;li&gt;As a model, the digital circuit model was designed in 1937 by Shannon.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;So, in 1994 we are in a comparable state to 1937:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;There are a few people doing theoretical groundwork, and the groundwork has now been done.&lt;/li&gt;&#xA;&lt;li&gt;There are a fair number of people doing engineering work on foundational issues not directly related but very helpful for building a (quantum) computer.&lt;/li&gt;&#xA;&lt;li&gt;And the field is generally not that big and well-funded.&lt;/li&gt;&#xA;&lt;li&gt;But: from that date, funding and people start pouring into the field.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;The field is taking off&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;For classical computing, this is illustrated by the amount of different &quot;first computer systems&quot; in the Wikipedia timeline. There were several research groups at least in Germany, England and the United States in several locations (e.g. Manchester and Bletchley Park in the UK, to name just a few). War-time money was diverted to computing, because it was necessary for e.g. the development of the nuclear bomb (see accounts at Los Alamos).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For quantum computation, see e.g. &lt;a href=&quot;https://www.nsf.gov/pubs/2000/nsf00101/nsf00101.htm&quot; rel=&quot;nofollow noreferrer&quot;&gt;this comment&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The field of QIS began an explosive growth in the early to mid 1990s as a consequence of several simultaneous stimuli: Peter Shor demonstrated that a quantum computer could factor very large numbers super-efficiently. The semiconductor industry realized that the improvement of computers according to Moore’s law would all too soon reach the quantum limit, requiring radical changes in technology. Developments in the physical sciences produced trapped atomic ions, advanced optical cavities, quantum dots, and many other advances that made it possible to contemplate the construction of workable quantum logic devices. Furthermore, the need for secure communications drove the investigations of quantum communication schemes that would be tamper proof.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;All in all, from the time that the theoretical groundwork of modern computers had been laid to the time that the first computers are available (Zuse 1941, Manchester 1948, to name just two) it took about a decade. Similarly, it took about a decade for the first systems doing some sort of universally programmable calculation with quantum systems. Granted, their capabilities are lower than the first Manchester computers, but still.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Twenty years later, we are slowly seeing an explosive growth in technology and a lot of firms get involved. We also see the advent of new technologies like the transistor (first discovered in 1947).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Similarly, 20 years after the beginning of quantum computation we see the serious entrance of private companies into the field, with Google, IBM, Intel and many others. When I was at my first conference in 2012, their involvement was still academic, today, it is strategic. Similarly, we saw a proposition of a wealth of different quantum computing systems during the 2000s such as superconducting qubits, which form the basis of the most advanced chips from the three companies mentioned above. In 2012, nobody could claim to have a somewhat reliable system with more than a couple of physical qubits. Today, only six years later, IBM lets you play with their very reliable 16 qubit (5 if you really only want to play around) and Google claims to test a 72 qubit system as we speak.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Yes, we have still some way to go to have a reliable large-scale quantum computer with error-correction capabilities, and the computers we currently have are weaker than the classical computers we had in the '60s, but I (as others explain in other answers) believe this is due to the unique engineering challenges. &#xA;There is a small chance that it's due to physical limitations we have no idea about but if it is, given current progress, we should know in a couple of years at the latest.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;What's my point here?&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;I argued that the reason that we don't see an MU5 quantum computer yet is also due to the fact that the field is just not that old, yet, and hasn't really achieved that much attention until recently.&lt;/li&gt;&#xA;&lt;li&gt;I argue that from a present day perspective, it seemed that classical computers became very good very quickly, but that this neglects decades of prior work where development and growth didn't seem as fast.&lt;/li&gt;&#xA;&lt;li&gt;I argue that if you believe (as almost everybody in the field does) that the initial engineering problems faced by quantum computers are harder than those faced by classical computers, then you see a very much comparable research and innovation trajectory to the one of classical computers. Of course they are somewhat different, but the basic ideas of how it goes are similar.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="1854" LastEditorUserId="-1" LastEditDate="2018-07-05T09:40:55.630" LastActivityDate="2018-07-05T09:40:55.630" CommentCount="2" />
  <row Id="2545" PostTypeId="2" ParentId="2521" CreationDate="2018-06-30T11:34:36.603" Score="0" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Known results on the field are the Hashing bound, which is a lower bound on such quantum capacity and which is given by the LSD (Lloyd-Shor-Devetak) theorem; or the HSW (Holevo-Schumacher-Westmoreland) theorem for classical capacity over quantum channels.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Those theorems are not very new, I was able to find some newer work.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A quick list of those theories and their dates:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;In &quot;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/9908043&quot; rel=&quot;nofollow noreferrer&quot;&gt;Ultimate physical limits to computation&lt;/a&gt;&quot; (13 Aug 1999, last revised 14 Feb 2000), by Seth Lloyd he determined:&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;... quantitative bounds are put to the computational power of an ‘ultimate laptop’ with a mass of one kilogram confined to a volume of one litre. ... Applying this result to a one kilogram computer with energy&#xA;  $E = mc^2 = 8.9874 × 10^{16}$ joules show that our ultimate laptop can perform a maximum of $5.4258 × 10^{50}$ operations per second.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There's no suggestion that is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Orders_of_magnitude_(numbers)#1042_to_10100&quot; rel=&quot;nofollow noreferrer&quot;&gt;reasonable&lt;/a&gt; and obtainable upper bound, it's simply a max limit.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www-math.mit.edu/~shor/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Dr. Shor's webpage&lt;/a&gt; at MIT and his &lt;a href=&quot;http://www-math.mit.edu/~shor/elecpubs.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;publications&lt;/a&gt; webpage, or &lt;a href=&quot;https://quantumcomputing.stackexchange.com/users/1765/peter-shor&quot;&gt;user profile @ QC.SE&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;Quantum Information Theory: Results and Open Problems&quot; (19 page preview: &lt;a href=&quot;http://www-math.mit.edu/~shor/papers/GAFA.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;.PDF&lt;/a&gt;) (&lt;a href=&quot;https://link.springer.com/chapter/10.1007/978-3-0346-0425-3_9&quot; rel=&quot;nofollow noreferrer&quot;&gt;GAFA 2000&lt;/a&gt;), by Peter Shor&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0206058&quot; rel=&quot;nofollow noreferrer&quot;&gt;The Adaptive Classical Capacity of a Quantum Channel, or Information Capacities of Three Symmetric Pure States in Three Dimensions&lt;/a&gt;&quot; (10 Jun 2002, last revised 22 May 2003) by Peter W. Shor&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;Quantum Information Theory: Results and Open Problems&quot; (52 pages: &lt;a href=&quot;https://www.researchgate.net/publication/226347542_Quantum_Information_Theory_Results_and_Open_Problems&quot; rel=&quot;nofollow noreferrer&quot;&gt;Paywall&lt;/a&gt;) (&lt;a href=&quot;https://link.springer.com/chapter/10.1007/978-3-0346-0425-3_9&quot; rel=&quot;nofollow noreferrer&quot;&gt;GAFA 2000&lt;/a&gt;), by Charles H. Bennett and Peter Shor &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/9706061&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Channel Capacity of Very Noisy Channels&lt;/a&gt;&quot; (27 Jun 1997, last revised 3 Nov 1998), by David P. DiVincenzo, Peter W. Shor, and John A. Smolin&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Dr Shor's papers should be consulted directly to derive his capacity formulas.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;In &quot;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0304127&quot; rel=&quot;nofollow noreferrer&quot;&gt;The private classical capacity and quantum capacity of a quantum channel&lt;/a&gt;&quot; (18 Apr 2003 (v1), last revised 21 Oct 2004), by I. Devetak, on page 14, he wrote:&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;... the quantum capacity $Q(\mathcal{N})$ of a quantum channel $\mathcal{N}$&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;$$\qquad\qquad\qquad Q( \mathcal{N} ) = \tilde{Q} ( \mathcal{N} ) = E( \mathcal{N} ) = \lim\limits_{l \to \infty} \frac{1}{l} \max\limits_{\rho \in \mathcal{H}^{\otimes l}_\mathcal{P}} \; I_c(\rho, \mathcal{N}^{\otimes l}). \qquad\qquad\qquad (53)$$&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;The Holevo-Schumacher-Westmoreland theorem is arguably over 50 years old, certainly 45.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;The paper &quot;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/9912122&quot; rel=&quot;nofollow noreferrer&quot;&gt;Optimal signal ensembles&lt;/a&gt;&quot; (Dec 31 1999, last updated Apr 4, 2018), by Benjamin Schumacher and Michael D. Westmoreland, on page 2, reads:&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;Holevo$^{[1]}$ proved (as Gordon$^{[2]}$ and Levitin$^{[3]}$ had previously conjectured) that the mutual information between the input and output of this channel, regardless of Bob’s choice of decoding observable, can never be greater than $\chi$, where:&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;$$\qquad\qquad\qquad\qquad\qquad \chi = S(\rho) - \sum_k p_kS(\rho_k) \qquad\qquad\qquad\qquad\qquad\qquad\qquad (1)$$&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;where $S(ρ) = −\text{Tr}\, \rho \, \text{log} \, \rho$ is the von Neumann entropy of the density operator $\rho$.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;More recently, it has been shown by Holevo$^{[4]}$ and by Schumacher and&#xA;  Westmoreland$^{[5]}$ that the Holevo bound is asymptotically achievable.&quot;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; A. S. Kholevo, Probl. Peredachi Inf. 9, 3 (1973) [Probl. Inf. Transm. (USSR) 9, 110 (1973)].&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;code&gt;[2]&lt;/code&gt; J. P. Gordon, in Quantum Electronics and Coherent Light, Proceedings of the International School of Physics “Enrico Fermi,” Course XXXI, edited by P. A. Miles (Academic, New York, &lt;strong&gt;1964&lt;/strong&gt;), pp. 156-181.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;code&gt;[3]&lt;/code&gt; L. B. Levitin, “On the quantum measure of the amount of information,” in Proceedings of the IV National Conference on Information Theory, Tashkent, 1969, pp. 111–115 (in Russian); “Information Theory for&#xA;  Quantum Systems,” in Information, Complexity, and Control in Quantum Physics, edited by A. Blaqui`ere, S. Diner, and G. Lochak (Springer,&#xA;  Vienna, 1987).&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;code&gt;[4]&lt;/code&gt; A. S. Holevo, IEEE Trans. Inform. Theory 44, 269 (1998).&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;code&gt;[5]&lt;/code&gt; B. Schumacher and M. Westmoreland, Phys. Rev. A 51, 2738 (1997).&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;I was wondering if there have been any advances in what a general expression for the quantum capacity [is] since the release of those theorems. A glimpse on the advance in such field is enough for me or references to papers where such task is developed.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Some of the more recent work is:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&quot;&lt;a href=&quot;https://arxiv.org/abs/1106.1445&quot; rel=&quot;nofollow noreferrer&quot;&gt;From Classical to Quantum Shannon Theory&lt;/a&gt;&quot; (7 Jun 2011, last revised 22 Mar 2016) by Mark M. Wilde&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The aim of this book is to develop &quot;from the ground up&quot; many of the major, exciting, pre- and post-millenium developments in the general area of study known as quantum Shannon theory. As such, we spend a significant amount of time on quantum mechanics for quantum information theory (Part II), we give a careful study of the important unit protocols of teleportation, super-dense coding, and entanglement distribution (Part III), and we develop many of the tools necessary for understanding information transmission or compression (Part IV). Parts V and VI are the culmination of this book, where all of the tools developed come into play for understanding many of the important results in quantum Shannon theory. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&quot;&lt;a href=&quot;https://arxiv.org/abs/1805.11965&quot; rel=&quot;nofollow noreferrer&quot;&gt;A Mini-Introduction To Information Theory&lt;/a&gt;&quot; (30 May 2018, last revised 3 Jun 2018) by Edward Witten - &lt;a href=&quot;https://medium.com/@_NicT_/information-theory-66ed47ddd96a&quot; rel=&quot;nofollow noreferrer&quot;&gt;Nicholas Teague's review and presentation&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;This article consists of a very short introduction to classical and quantum information theory. Basic properties of the classical Shannon entropy and the quantum von Neumann entropy are described, along with related concepts such as classical and quantum relative entropy, conditional entropy, and mutual information. A few more detailed topics are considered in the quantum case. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://www.researchgate.net/profile/Noboru_Watanabe&quot; rel=&quot;nofollow noreferrer&quot;&gt;Noboru Watanabe lists a number of papers on ReseachGate&lt;/a&gt; about key attacks and quantum communication. In particular, see:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&quot;&lt;a href=&quot;https://www.researchgate.net/publication/45267829_Quantum_Entropy_and_Its_Applications_to_Quantum_Communication_and_Statistical_Physics&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Entropy and Its Applications to Quantum Communication and Statistical Physics&lt;/a&gt;&quot; May 2010 in Entropy 12(5), by Masanori Ohya and Noboru Watanabe&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;... We will review the mathematical aspects of quantum entropy (entropies) and discuss some applications to quantum communication, statistical physics. All topics taken here are somehow related to the quantum entropy that the present authors have been studied. ...&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&quot;&lt;a href=&quot;https://www.researchgate.net/publication/266861204_Quantum_probability_from_classical_signal_theory&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum probability from classical signal theory&lt;/a&gt;&quot; Nov 2011, &#xA;Article in International Journal of Quantum Information 9(supp01), by Masanori Ohya, Andrei Khrennikov and Noboru Watanabe&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;We present quantum mechanics (QM) as theory of special classical random signals. On one hand, this approach provides a possibility to go beyond conventional QM: to create a finer description of micro-processes than given by the QM-formalism. In fact, we present a model with hidden variables of the wave-type. On the other hand, our approach establishes coupling between quantum and classical information theories. We recall that quantum information theory has already been used for description of the entropy of Gaussian input signals for noisy channels. The entropy of a classical random input was invented as the entropy of the quantum density operator corresponding to the covariance operator of the input process. In this paper, we proceed the other way around: we apply classical signal theory to create a measurement model which reproduces quantum probabilities.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&quot;On Treatment of Communication Processes by Quantum Entropies&quot; Mar 2012, Noboru Watanabe&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;In information communication theory, one can study the efficiency of information transmission of the communication processes by using the Shannon's type inequalities by means of the entropy and the mutual entropy. In this paper, we discuss about entropy type inequalities for treating the classical Gaussian communication processes consistently.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&quot;&lt;a href=&quot;https://www.researchgate.net/publication/268017422_An_Entropy_Based_Treatment_of_Gaussian_Communication_Process_for_General_Quantum_Systems&quot; rel=&quot;nofollow noreferrer&quot;&gt;An Entropy Based Treatment of Gaussian Communication Process for General Quantum Systems&lt;/a&gt;&quot; Sept 2013, by Noboru Watanabe&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The quantum entropy introduced by von Neumann around 1932 describes the amount of information of the quantum state itself. It was extended by Ohya for C * -systems before Conne-Narnhoffer-Thirring (CNT) entropy. The quantum relative entropy was first defined by Umegaki for σ-finite von Neumann algebras and it was subsequently extended by H. Araki [Publ. Res. Inst. Math. Sci. Kyoto Univ. 11, No. 3, 809–833 (1975/76; Zbl 0326.46031); ibid. 13, No. 1, 173–192 (1977/78; Zbl 0374.46055)] and A. Uhlmann [Comm. Math. Phys. 54, No. 1, 21–32 (1977; Zbl 0358.46026)] for general von Neumann algebras and * -algebras, respectively. By introducing a new notion, the so-called compound state, M. Ohya, IEEE Trans. Inf. Theory 29, 770–774 (1983; Zbl 0511.94007)] succeeded to construct the mutual entropy in a complete quantum mechanical system (i.e., input state, output state and channel are all quantum mechanical) describing the amount of information correctly transmitted through the quantum channel. In this paper, we briefly review Ohya’s S-mixing entropy and the quantum mutual entropy for general quantum systems. Based on a concept of structure equivalent, we apply the general framework of quantum communication to the Gaussian communication processes.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&quot;&lt;a href=&quot;https://www.researchgate.net/publication/270516138_Entropy_type_complexity_of_quantum_processes&quot; rel=&quot;nofollow noreferrer&quot;&gt;Entropy type complexity of quantum processes&lt;/a&gt;&quot; Nov 2014 in Physica Scripta T163(T163), by Noboru Watanabe&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;von Neumann entropy represents the amount of information in the quantum state, and this was extended by Ohya for general quantum systems &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9706061&quot; rel=&quot;nofollow noreferrer&quot;&gt;10&lt;/a&gt;. Umegaki first defined the quantum relative entropy for σ -finite von Neumann algebras, which was extended by Araki, and Uhlmann, for general von Neumann algebras and *-algebras, respectively. In 1983 Ohya introduced the quantum mutual entropy by using compound states; this describes the amount of information correctly transmitted through the quantum channel, which was also extended by Ohya for general quantum systems. In this paper, we briefly explain Ohyaʼs S-mixing entropy and the quantum mutual entropy for general quantum systems. By using structure equivalent class, we will introduce entropy type functionals based on quantum information theory to improve treatment for the Gaussian communication process.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Now back to papers by other authors.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&quot;&lt;a href=&quot;https://arxiv.org/abs/1510.08863&quot; rel=&quot;nofollow noreferrer&quot;&gt;Fundamental Limits of Repeaterless Quantum Communications&lt;/a&gt;&quot; (29 Oct 2015, last revised 24 Jan 2017) by Stefano Pirandola, Riccardo Laurenza, Carlo Ottaviani, and Leonardo Banchi&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Quantum communications promises reliable transmission of quantum information, efficient distribution of entanglement and generation of completely secure keys. For all these tasks, we need to determine the optimal point-to-point rates that are achievable by two remote parties at the ends of a quantum channel, without restrictions on their local operations and classical communication, which can be unlimited and two-way. These two-way assisted capacities represent the ultimate rates that are reachable without quantum repeaters. By constructing an upperbound based on the relative entropy of entanglement and devising a dimension-independent technique dubbed &quot;teleportation stretching&quot;, we establish these capacities for many fundamental channels, namely bosonic lossy channels, quantum-limited amplifiers, dephasing and erasure channels in arbitrary dimension. In particular, we determine the fundamental rate-loss trade-off affecting any protocol of quantum key distribution. Our findings set the ultimate limits of point-to-point quantum communications and provide the most precise and general benchmarks for quantum repeaters. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&quot;&lt;a href=&quot;http://www.theory.caltech.edu/people/preskill/ph219/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Information - Chapter 10. Quantum Shannon Theory&lt;/a&gt;&quot; (Jan 2018), by John Preskill (&lt;a href=&quot;http://www.theory.caltech.edu/~preskill/ph219/chap10_6A.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;.PDF&lt;/a&gt;)&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;This is the 10th and final chapter of my book Quantum Information, based on the course I have been teaching at Caltech since 1997. An early version of this chapter (originally Chapter 5) has been available on the course website since 1998, but this version is substantially revised and expanded. &#xA;  The level of detail is uneven, as I’ve aimed to provide a gentle introduction, but I’ve also tried to avoid statements that are incorrect or obscure. Generally speaking, I chose to include topics that are both useful to know and relatively easy to explain; I had to leave out a lot of good stuff, but on the other hand the chapter is already quite long. My version of Quantum Shannon Theory is no substitute for the more careful treatment in Wilde’s book &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9908043&quot; rel=&quot;nofollow noreferrer&quot;&gt;1&lt;/a&gt;, but it may be more suitable for beginners.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;I'll add a few more links if OP Josu Etxezarreta Martinez or anyone else runs out of reading, otherwise I'll review this in several months to ensure it remains correct and current.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;For &lt;a href=&quot;https://math.stackexchange.com/questions?sort=newest&quot;&gt;Math.SE&lt;/a&gt; / &lt;a href=&quot;https://english.stackexchange.com/questions?sort=newest&quot;&gt;English.SE&lt;/a&gt;: &quot;I have been reading about the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_capacity&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Channel Capacity&lt;/a&gt; and it seems to be an &lt;a href=&quot;https://en.wikipedia.org/wiki/Open_problem&quot; rel=&quot;nofollow noreferrer&quot;&gt;open problem&lt;/a&gt; to find such capacity in general.&quot; [See also: &lt;a href=&quot;https://en.wikipedia.org/wiki/Channel_capacity&quot; rel=&quot;nofollow noreferrer&quot;&gt;Channel Capacity&lt;/a&gt; and &lt;a href=&quot;https://www.encyclopediaofmath.org/index.php/Transmission_rate_of_a_channel&quot; rel=&quot;nofollow noreferrer&quot;&gt;Transmission rate of a channel&lt;/a&gt;].&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;In science and mathematics, an open problem or an open question is &lt;strong&gt;a known problem&lt;/strong&gt; which can be &lt;strong&gt;accurately stated&lt;/strong&gt;, and which is assumed to have an objective and verifiable solution, but which has &lt;strong&gt;not yet&lt;/strong&gt; been solved (&lt;strong&gt;no solution&lt;/strong&gt; for it is known).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's focus on quantum computing, leave that to &lt;a href=&quot;https://math.stackexchange.com/questions?sort=newest&quot;&gt;Math.SE&lt;/a&gt; / &lt;a href=&quot;https://english.stackexchange.com/questions?sort=newest&quot;&gt;English.SE&lt;/a&gt;, and limit QC.SE to answering QC questions. There are some open problems within some of the conjectures about channel capacity.&lt;/p&gt;&#xA;" OwnerUserId="278" LastEditorUserId="26" LastEditDate="2018-07-13T15:05:31.410" LastActivityDate="2018-07-13T15:05:31.410" CommentCount="2" />
  <row Id="2546" PostTypeId="2" ParentId="2525" CreationDate="2018-06-30T13:43:46.380" Score="5" Body="&lt;p&gt;The definition you give for a graph state, and in particular the quantum Fourier transform $F$ and the controlled-$Z$ operator &amp;mdash; where we take $ Z $ to be the unitary generalisation of the Pauli $Z$ operator, satisfying $Z = F XF^\dagger$ for $X$ a shift-by-one permutation operation &amp;mdash; are all well-defined even in composite dimension. The Fourier transform is certainly an operation of interest for arbitrary definition; the controlled-$Z$ operation is still diagonal and unitary, and still has the relevant connections to $F$ as a tensor; there is nothing about the mathematical objects themselves which become troublesome in composite dimension.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The reason why you see so much emphasis on prime dimension is essentially that composite dimension qudits are inconvenient to analyse. The reasons for this arise from number theory: particularly in the fact that in composite dimension one must worry about zero divisors. Frankly, there aren't many in the field who think of themselves as number theorists, and very few researchers (either among the authors or the readers of articles) have much patience for number systems which are not fields such as the well-loved examples of $\mathbb C$, $\mathbb R$, $\mathbb Q$, and of course the integers modulo a prime $p$, $\mathbb Z_p$. For this reason, you will rarely see references to qudits of composite dimension anywhere in the field. Even when you do, the major concern of mathematical convenience will usually motivate some other restriction.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quantum information theory may occasionally make use of number theory, and pure mathematics in general, but make no mistake: this field does not have much overlap with the priorities of pure mathematics. If a definition has been presented in a way that looks strangely restricted, it's reasonably likely that it's because it allows a result to be shown which would be much more challenging, or even just a little bit more awkward, to prove without that restriction &amp;mdash; and it is considered more important to publicise examples of striking-sounding results than to present reasonably complete mathematical theories.&lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-06-30T17:38:39.493" LastActivityDate="2018-06-30T17:38:39.493" CommentCount="0" />
  <row Id="2549" PostTypeId="1" AcceptedAnswerId="2563" CreationDate="2018-06-30T16:27:09.507" Score="2" ViewCount="59" Body="&lt;p&gt;I have had a few ideas for circuits that I would like to get feedback on (do such things already exist, what utility they serve, etc). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Any suggestions on how I might graphically render these?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Example:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&quot;https://i.stack.imgur.com/956tM.jpg&quot; alt=&quot;circuit sketch&quot;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here i is the input &amp;amp; o is the output. The slash directly to the right of the input is a 50/50 beam splitter. The remaining slashes are mirrors. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If a pulse were directed in, the output would first recieve 50% of the beam. The other half of the beam would pass through into the reflective chamber. Upon completion of the loop, the beam would again reach the splitter. Again, half the beam (25%) would pass to the output while the other half (25%) looped thru the circuit. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This process could be run thru $n$ times until some desired outcome is reached.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Does this already exist? What is the utility (if any)?&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-07-01T16:03:14.503" LastActivityDate="2018-07-02T05:47:52.317" Title="Photonic Circuit Idea (Does this already exist?)" Tags="&lt;circuit-model&gt;&lt;photonics&gt;" AnswerCount="1" CommentCount="3" />
  <row Id="2550" PostTypeId="2" ParentId="2483" CreationDate="2018-06-30T18:25:55.773" Score="3" Body="&lt;p&gt;Contrary to &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2484/23&quot;&gt;DaftWullie's answer&lt;/a&gt;, it &lt;em&gt;is&lt;/em&gt; possible to implement a CNOT gate in a photonic system with 100% efficiency.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, there are caveats to this - it depends on what's used as the qubits (or, as this is a photonic system, potentially &lt;em&gt;qudits&lt;/em&gt;) in the system.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;KLM: A photon as a qubit&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;The first thing that most people think of in terms of photonic qubits is polarisation. In this case, postselection (/heralding) is generally required. This was theoretical shown to be possible by &lt;a href=&quot;https://www.nature.com/articles/35051009&quot; rel=&quot;nofollow noreferrer&quot;&gt;Knill, Laflamme and Milburn (KLM)&lt;/a&gt; in 2001. Within a couple of years, the first probabilistic photonic CNOT gate was shown by &lt;a href=&quot;https://www.nature.com/articles/nature02054&quot; rel=&quot;nofollow noreferrer&quot;&gt;O'Brien et. al.&lt;/a&gt; (&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0403062v1&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv version&lt;/a&gt;) in an equivalent scheme, as shown in figure 1.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/1NAD4.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/1NAD4.jpg&quot; alt=&quot;Probabilistic CNOT&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Figure 1: Circuit diagram of probabilistic 2-photon CNOT gate. Each photon (control and target) is encoded from polarisation to spatial modes. After postselecting on a single photon in $C_{\text{out}}$ and a single photon in $T_{\text{out}}$, when the control photon, $C$, is in spatial mode $C_0$, the identity operation is performed on the target photon, $T$, while when $C$ is in $C_1$, the NOT (X) operation is performed on $T$ which has a probability of success of 1/9. Uses beamsplitters. Image taken from Figure 1a of &lt;a href=&quot;https://www.nature.com/articles/nature02054&quot; rel=&quot;nofollow noreferrer&quot;&gt;O'Brien et. al.&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One variation of this is to use a nonlinear phase shift to make a deterministic version of this.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;While the above may not sound overly great for the prospects of optical quantum computing, encoding a qubit as polarisation/2 spatial modes of a photon is far from the &lt;em&gt;only&lt;/em&gt; way to perform optical quantum computing.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Reck: Many modes makes... Many dimensions&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;One other such method was proposed before &lt;a href=&quot;https://www.nature.com/articles/35051009&quot; rel=&quot;nofollow noreferrer&quot;&gt;KLM&lt;/a&gt; by &lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.73.58&quot; rel=&quot;nofollow noreferrer&quot;&gt;Reck et. al.&lt;/a&gt; (shown in figure 2) and has since been improved upon by &lt;a href=&quot;https://www.osapublishing.org/optica/abstract.cfm?uri=optica-3-12-1460&quot; rel=&quot;nofollow noreferrer&quot;&gt;Clements et. al.&lt;/a&gt; In this a &lt;em&gt;single&lt;/em&gt; photon is encoded in some number, $d$, of spatial modes. This is equivalent to a $\log_2 d$ qubit system and can be used to implement any unitary. For a 2-qubit system, this is equivalent to having 4 spatial modes labelled $\left|00\right&amp;gt;, \left|01\right&amp;gt;, \left|10\right&amp;gt;$ and $\left|11\right&amp;gt;$ and a CNOT operation is equivalent to swapping the bottom 2 $\left(\left|10\right&amp;gt; \text{ and } \left|11\right&amp;gt;\right)$ modes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/pmUZG.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/pmUZG.png&quot; alt=&quot;6-mode Reck scheme&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Figure 2: Image of a 6-mode Reck scheme chip, which can be used to implement a deterministic 'CNOT' gate. Uses phase shifters and beam splitters to build up a unitary evolution over the modes of the system. Image taken from Figure 1 of &lt;a href=&quot;http://science.sciencemag.org/content/349/6249/711&quot; rel=&quot;nofollow noreferrer&quot;&gt;Carolan et. al.&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Of course, it's not quite that simple and, due to requiring an exponential number of modes, the Reck scheme isn't generally considered to be overly scalable.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;That leaves us with the (final) two options&lt;sup&gt;1&lt;/sup&gt;: &lt;em&gt;nonlinear&lt;/em&gt; optics (continuous variable) and measurement based quantum computing&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Continuous variable: Just keep squeezing&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;As detailed in my answer &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1530/23&quot;&gt;here&lt;/a&gt;, continuous variable QC also offers a universal gateset which can be used to make arbitrary unitaries, in theory at least. Unfortunately, as more squeezing is still required, an experimental realisation of this is yet to occur.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;And now for something completely different: Measurement based&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Another scheme that hasn't been experimentally achieved, yet shows potential, is measurement based QC. Instead of performing CNOT gates during unitary evolution that defines a circuit, the entangling operations occur as part of the state preparation of the system. As per &lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.113.140403&quot; rel=&quot;nofollow noreferrer&quot;&gt;Ewert and Loock&lt;/a&gt; (&lt;a href=&quot;https://arxiv.org/abs/1403.4841&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv version&lt;/a&gt;) the current idea of doing this involves generating small clusters of entangled photons, then entangling these into larger clusters using fusion gates, as shown in figure 3.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/TEP0H.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/TEP0H.png&quot; alt=&quot;Fusion gate&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Figure 3: Diagram of a 75% efficient fusion gate. Inputting the state $\left|\Upsilon_1\right&amp;gt; = \frac{1}{\sqrt 2}\left(\left|20\right&amp;gt; + \left|02\right&amp;gt;\right)$ allows for the detection of higher dimensional states. These can then be cascaded to detect larger and larger cluster states. The probabilistic measurement is equivalent to an entangling operation, similar to a CNOT gate. Image taken from Figure 1 of &lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.113.140403&quot; rel=&quot;nofollow noreferrer&quot;&gt;Ewert and Loock&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;1 Although there are a number of variations of the different schemes used and work is constantly being done to improve upon them&lt;/sup&gt;&lt;/p&gt;&#xA;" OwnerUserId="23" LastActivityDate="2018-06-30T18:25:55.773" CommentCount="2" />
  <row Id="2552" PostTypeId="2" ParentId="2499" CreationDate="2018-06-30T19:11:42.623" Score="2" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Is quantum computing just pie in the sky?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;So far it is looking this way. We have been reaching for this pie aggressively over the last three decades but with not much success. we do have quantum computers now, but they are not the pie we wanted, which is a quantum computer that can actually solve a problem faster or with better energetic efficiency than a classical computer. &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;You won't be buying one in PC World any time soon.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Will you ever be able to? &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;We cannot predict the future, but if I had to guess right now, I would say &quot;no&quot;. There is not yet any application for which quantum computing would be valuable enough. Instead we might have quantum computers at a small number of special institutes where very special calculations are done (like the supercomputer called Titan at Oak Ridge National Lab, or like a cyclotron particle accelerator where special experiments are done).  &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Is it all hype and hot air? &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Most of it is hype, unfortunately. &lt;br&gt;&#xA;But applications in quantum chemistry can indeed be game changing. Instead of doing physically laborious experiments on thousands of candidate molecules for a medicine or fertilizer, we can search for the best molecules on a computer. Molecules behave quantum mechanically, and simulating quantum mechanics is not efficient on classical computers, but is on quantum computers. Much of Google's investment in QC is for chemistry applications [&lt;a href=&quot;https://ai.googleblog.com/2016/07/towards-exact-quantum-description-of.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;1&lt;/a&gt;].&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Is it all just jam-tomorrow woo peddled by quantum quacks to a gullible public? If not, why not?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Much of it is, unfortunately.&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You were probably one of the more talented students in your class at Manchester University. You might have noticed that there was only a few of you and a larger number of mediocre and sub-mediocre students. There is a similar phenomenon at the professor level. Many professors don't find it easy or &quot;natural&quot; to write well-received grant proposals, but they need funding to keep their job, and to make sure their PhD students aren't starved of experiencing scientific conferences and having access to the software they need.&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When a professor becomes:&lt;br&gt;&#xA; - desperate for funding, or &lt;br&gt; &#xA; - caught up with other problems in life, such as having to take care of a child with cancer, or&lt;br&gt;&#xA; - aware that they won't make huge scientific discoveries like some scientists did 100s of years ago,&lt;br&gt;&#xA;life becomes more about surviving, keeping a happy family, and doing what they &lt;strong&gt;&lt;em&gt;enjoy&lt;/em&gt;&lt;/strong&gt; rather than making a better world for their grandchildrens' grandschildren. As a professor, I can tell you that many of my colleagues are not as &quot;noble&quot; as the public often perceives scientists to be.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;I know around 1000 people with funding to work in quantum computing, and not a single one seems to have ill intentions to fool a &quot;gullible public&quot; in some sinister way.&lt;/strong&gt; Most of us just apply for grants available through our universities or through our governments, and we don't intend to exaggerate the importance of our work any more than other scientists competing for the same money (we have to compete with molecular physicists pretending their work is important for fixing climate change just because the molecule they're working on is in our atmosphere, or biophysicists pretending their work might cure cancer just because they're working on a molecule that's prominent in the body). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;A lot of the &quot;hype&quot; around quantum computing comes from the media. Journalists have twisted the contents of my papers to make eye-catching headlines which will get more clicks on their ads, and their bosses give them pressure to do this or they'll lose their job to the other intern that doesn't care as much about being honest. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Some of the hype does come from scientists themselves, many who truly believe quantum computing will be revolutionary because their PhD supervisor didn't have a great education (remember that Manchester University is one of the best in the world, and &lt;strong&gt;&lt;em&gt;most&lt;/em&gt;&lt;/strong&gt; universities are not even close), or perhaps in rare cases there is hype from people desperate for funding, but not much for reasons other than these.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;I do believe the public should invest a bit in quantum computing, as they do for lots of other areas of research which have no guaranteed positive outcome.&lt;/strong&gt; The hype is often exaggerated by journalists, ignorant scientists, or non-ignorant scientists who think they need it for survival.  There is also unfairly harsh criticism from journalists and funding agencies. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Nothing you said in your question is wrong.&lt;/em&gt;&lt;/strong&gt; &lt;br&gt;&#xA;I have just given some reasons for why they are correct.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="26" LastEditDate="2018-07-14T18:27:43.770" LastActivityDate="2018-07-14T18:27:43.770" CommentCount="13" />
  <row Id="2553" PostTypeId="1" AcceptedAnswerId="2575" CreationDate="2018-06-30T19:36:29.877" Score="7" ViewCount="140" Body="&lt;p&gt;I have the following operation in my .qs files:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;operation myOp(qubits: Qubit[]) : () {&#xA;     // uses elements from the qubit array        &#xA; }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;How do I send an array of qubits to this in the driver file?&#xA;The following did not work:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Qubit[] qubits = new Qubit[2];&#xA;myOp.Run(sim, qubits);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;I got the following error:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Driver.cs(13,32): error CS1503: Argument 2: cannot convert from 'Microsoft.Quantum.Simulation.Core.Qubit[]' to 'Microsoft.Quantum.Simulation.Core.QArray&amp;lt;Microsoft.Quantum.Simulation.Core.Qubit&amp;gt;' [/home/tinkidinki/Quantum/Warmup_Contest/BellState/BellState.csproj]&#xA;&#xA;The build failed. Please fix the build errors and run again.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Also, as an aside: Would such a question be more suitable for this site, or for stack overflow?&lt;/em&gt; &lt;/p&gt;&#xA;" OwnerUserId="2832" LastActivityDate="2018-07-10T18:29:23.843" Title="How do you send an array of qubits to an operation in Q#?" Tags="&lt;q#&gt;" AnswerCount="3" CommentCount="2" />
  <row Id="2554" PostTypeId="1" AcceptedAnswerId="2571" CreationDate="2018-06-30T20:30:23.520" Score="5" ViewCount="105" Body="&lt;p&gt;If quantum computers advance to the point where they can defeat RSA, DSA, SHA (and really all existing classical public key encryption or and authentication) then it appears that it would be impossible to make secure transactions on the internet.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;It would be impossible to maintain the security of user accounts for social media, amazon, eBay, online banking, etc.  It seems that the economic repercussions of this would be catastrophic on a global scale.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What measures can be taken against attacks on cryptosystems by quantum computers?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;At lest for now, I see a big problem with giving an answer that involves saying we could just use quantum encryption algorithms.  The main reason is that in order for the encryption to be effective the end users would have to be in possession of a quantum encrypt/decrypt device.  Not a problem for a bank or Amazon on their end, but a big problem for a guy trying to order a pizza on his smart phone.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If end users were not actually in possession of a small quantum computer, and instead used a cloud based service to access a quantum device an attacker could just target the last segment of the transaction (between a cloud service and their device).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For end users to possess quantum crypto devices one would need to bring the cost down to a few hundred dollars max or the average person would not be able to afford it.  Right now most quantum systems are priced in the hundreds of thousands or millions of dollars range.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Also, all of the viable quantum systems I have seen run near absolute zero.  I don't know of anyone who makes a dilution refrigerator the size of a AA battery.  So you couldn't perform transactions on portable devices.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is the only option then to classify all quantum crypto research until these problems can be solved?&lt;/p&gt;&#xA;" OwnerUserId="2866" LastEditorUserId="2866" LastEditDate="2018-07-01T13:58:38.467" LastActivityDate="2018-07-02T09:33:00.210" Title="What measures can be taken against attacks on cryptosystems by quantum computers other than just classifying research?" Tags="&lt;cryptography&gt;" AnswerCount="2" CommentCount="3" FavoriteCount="1" />
  <row Id="2555" PostTypeId="2" ParentId="2521" CreationDate="2018-06-30T20:44:09.847" Score="2" Body="&lt;p&gt;Let's recap a bit:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In classical information theory, the analogous formula is the Shannon noisy channel coding theorem (&lt;a href=&quot;https://en.wikipedia.org/wiki/Noisy-channel_coding_theorem&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://en.wikipedia.org/wiki/Noisy-channel_coding_theorem&lt;/a&gt;). It's charming, because it is basically just a very simple optimization of the mutual information. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The quantum channel capacity is that it is given by&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ \lim\limits_{n\to\infty} \frac{1}{n}Q(T^{\otimes n}) $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;where $T$ is the quantum channel in question and $Q$ is the coherent information. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now let's try to answer your question:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Obviously, we'd want a formula that doesn't depend on $n$ just like in the classical case. The problem is: It's known that such an expression cannot exist (see &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9706061&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/quant-ph/9706061&lt;/a&gt;). It gets worse: You could hope that there is a maximal $n$ after which you at least know that the capacity is zero. But that's false (published recently: &lt;a href=&quot;https://www.nature.com/articles/ncomms7739.pdf?origin=ppub&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://www.nature.com/articles/ncomms7739.pdf?origin=ppub&lt;/a&gt;). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In addition, if you use two different channels, their capacity can both be zero while the capacity when used together is larger than zero (see &lt;a href=&quot;https://arxiv.org/abs/0807.4935&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/0807.4935&lt;/a&gt;), which makes it even more difficult to imagine simple formulas for channels.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This implies that the best we can hope for is formulas for particular channels or particular subclasses of channels. There are a few results scattered throughout the literature. For instance, capacities of certain Gaussian bosonic channels are known (&lt;a href=&quot;https://arxiv.org/pdf/quant-ph/0606132.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/pdf/quant-ph/0606132.pdf&lt;/a&gt;). &lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;However, please note that the quantum capacity is only one of many capacities defined and it's not necessarily the most interesting one. A different capacity which is often discussed in the literature is the classical capacity of a quantum channel (how much classical information can I send over a quantum channel?). Let me point you to a recent review providing a lot of pointers to the literature: &lt;a href=&quot;https://arxiv.org/pdf/1801.02019.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/pdf/1801.02019.pdf&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="1854" LastActivityDate="2018-06-30T20:44:09.847" CommentCount="1" />
  <row Id="2557" PostTypeId="2" ParentId="2554" CreationDate="2018-06-30T21:01:20.523" Score="0" Body="&lt;p&gt;We can always make larger and larger keys in RSA. If a quantum computer can factor numbers up to RSA-4096, then use RSA-131072, or better yet, some elliptic curve key big enough to be safe against the next 10 years of quantum computing hardware. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Or don't use public key cryptography but instead use standard passwords where the cost for a classical computer to break them is $M^n$ for $M$ characters and a password of length $n$, and the quantum computer's cost is at best $\mathcal{O}(M^{0.5n})$ which is not at all much better. &lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-07-02T05:42:02.463" LastActivityDate="2018-07-02T05:42:02.463" CommentCount="3" />
  <row Id="2558" PostTypeId="1" AcceptedAnswerId="2560" CreationDate="2018-06-30T22:51:32.637" Score="4" ViewCount="104" Body="&lt;p&gt;From a 9×9 Hamiltonian lying 9D space, I choose a certain subspace of 4D for designing a two qubit gate. Now the original unitary time evolution operator also lies in 9D space and it's a 9×9 size matrix. For action of unitary time evolution operator on the two qubit gate made out of 4D subspace it is required to project the unitary time evolution operator in the 4D subspace. After reviewing literature, I came across an article doing same thing with the use of projection operator.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question- How to find the projection operator on the subspace?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Also I guess projection operator will be 4×4 matrix, so how will it act on the unitary time evolution operator which is a 9×9 matrix.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;P.S.- I took the definition of projection operator from &quot;Quantum Computation and Quantum Information, Isaac Chuang and Michael Nielsen&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/L2P4I.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/L2P4I.jpg&quot; alt=&quot;Article&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="2817" LastActivityDate="2018-07-01T09:56:01.063" Title="Projection operator on Time evolution Operator" Tags="&lt;quantum-computer&gt;&lt;quantum-gate&gt;&lt;qubit&gt;" AnswerCount="1" CommentCount="5" />
  <row Id="2560" PostTypeId="2" ParentId="2558" CreationDate="2018-07-01T08:46:22.360" Score="2" Body="&lt;p&gt;A $9\times 9$ matrix $H$ can act on a $9$ dimensional state vector, say something like: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$|\Psi\rangle = a_0|0\rangle + a_1|1\rangle + .... + a_8|8\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, say you want to find the matrix which only acts on the subspace spanned by the basis $\{|0\rangle,|1\rangle\,|2\rangle,|3\rangle\}$, but has the same effect as the original $H$ matrix. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Find, $H|0\rangle$ and $H|1\rangle$ (where $|0\rangle = [1 \ 0 \ 0 \ 0 \ 0  \ 0 \ 0\ 0 \ 0 ]^{T}$, $|1\rangle = [0 \ 1 \ 0 \ 0 \ 0  \ 0 \ 0\ 0 \ 0 ]^{T}$, &#xA;$|2\rangle = [0 \ 0 \ 1 \ 0 \ 0  \ 0 \ 0\ 0 \ 0 ]^{T}$ and $|3\rangle = [0 \ 0 \ 0 \ 1 \ 0  \ 0 \ 0\ 0 \ 0 ]^{T}$)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then find the unique scalars $\alpha_{j,i}$ such that &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$H|0\rangle = \alpha_{0,0}|0\rangle + \alpha_{1,0}|1\rangle + \alpha_{2,0}|2\rangle+ \alpha_{3,0}|3\rangle$, &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$H|1\rangle = \alpha_{0,1}|0\rangle + \alpha_{1,1}|1\rangle + \alpha_{2,1}|2\rangle + \alpha_{3,1}|3\rangle$, &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$H|2\rangle =  \alpha_{0,2}|0\rangle + \alpha_{1,2}|1\rangle + \alpha_{2,2}|2\rangle + \alpha_{3,2}|3\rangle$ and &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$H|3\rangle = \alpha_{0,3}|0\rangle + \alpha_{1,3}|1\rangle + \alpha_{2,3}|2\rangle + \alpha_{3,3}|3\rangle$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, your required $4\times 4$ matrix is $\begin{bmatrix}\alpha_{0,0} &amp;amp; \alpha_{0,1} &amp;amp; \alpha_{0,2} &amp;amp; \alpha_{0,3}\\\alpha_{1,0} &amp;amp; \alpha_{1,1} &amp;amp; \alpha_{1,2} &amp;amp; \alpha_{1,3} \\ \alpha_{2,0} &amp;amp; \alpha_{2,1} &amp;amp; \alpha_{2,2} &amp;amp; \alpha_{2,3} \\ \alpha_{3,0} &amp;amp; \alpha_{3,1} &amp;amp; \alpha_{3,2} &amp;amp; \alpha_{3,3}\end{bmatrix}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let me know if you're confused about any particular step.&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-01T09:56:01.063" LastActivityDate="2018-07-01T09:56:01.063" CommentCount="1" />
  <row Id="2561" PostTypeId="1" AcceptedAnswerId="2583" CreationDate="2018-07-01T13:05:29.973" Score="5" ViewCount="95" Body="&lt;p&gt;A beginner question after watching few videos.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Say, &lt;code&gt;var=a&lt;/code&gt;; &lt;code&gt;var&lt;/code&gt; can be either of two values, &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt;. Check what is the value of &lt;code&gt;var&lt;/code&gt;, using &lt;code&gt;Q#&lt;/code&gt;, &lt;code&gt;QISKit&lt;/code&gt; or similar.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Any help/idea? &lt;/p&gt;&#xA;" OwnerUserId="2884" LastEditorUserId="26" LastEditDate="2018-07-01T13:10:20.377" LastActivityDate="2018-07-03T08:48:29.620" Title="Checking value of variable using quantum approach" Tags="&lt;quantum-programming&gt;&lt;qiskit&gt;&lt;q#&gt;" AnswerCount="3" CommentCount="0" FavoriteCount="1" />
  <row Id="2562" PostTypeId="1" AcceptedAnswerId="3798" CreationDate="2018-07-01T13:34:14.123" Score="8" ViewCount="66" Body="&lt;p&gt;This question is a follow-up to the previous QCSE question: &quot;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2525/are-qudit-graph-states-well-defined-for-non-prime-dimension&quot;&gt;Are qudit graph states well-defined for non-prime dimension?&lt;/a&gt;&quot;. From the question's answer, it appears that there is nothing wrong in &lt;em&gt;defining&lt;/em&gt; graph states using $d$-dimensional qudits, however, it seems that other definitional aspects of graph-states do not similarly extend to non-prime dimension.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Specifically, for qubit graph states, one key aspect to their prevalence and use is the fact that: &lt;em&gt;any two graph states are local Clifford equivalent if and only if there is some sequence of local complementations that takes one graph to the other&lt;/em&gt; (for simple, undirected graphs). Needless to say, this is an incredibly useful tool in analyses of quantum error correction, entanglement and network architectures.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When considering $n$-qudit graph states, the equivalent graph is now weighted with adjacency matrix $A \in \mathbb{Z}_d^{n \times n}$, where $A_{ij}$ is the weight of edge $(i,j)$ (with $A_{ij}=0$ indicating no edge exists).&#xA;In the qudit case, &lt;a href=&quot;https://arxiv.org/pdf/quant-ph/0610267.pdf&quot; rel=&quot;noreferrer&quot;&gt;it was shown&lt;/a&gt; that LC equivalence can similarly be extended by the generalisation of local complementation ($\ast_a v$) and inclusion of an edge multiplication operation ($\circ_b v$), where:&#xA;\begin{align}&#xA;\ast_a v &amp;amp;: A_{ij} \mapsto A_{ij} + aA_{vi}A_{vj} \quad \forall\;\; i,j \in N_G(v), \;i \neq j \\&#xA;\circ_b v &amp;amp;: A_{vi} \mapsto bA_{vi} \quad\forall\;\; i \in N_G(v),&#xA;\end{align}&#xA;where $a, b = 1, \ldots, d-1$ and all arithmetic is performed modulo $p$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Graphically, this is represented by the following operations (reproduced from &lt;a href=&quot;https://arxiv.org/pdf/quant-ph/0610267.pdf&quot; rel=&quot;noreferrer&quot;&gt;Ref. 2&lt;/a&gt;):&#xA;&lt;a href=&quot;https://i.stack.imgur.com/vHSj7.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/vHSj7.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, if the graph state is defined on qudits of non-prime dimension, then we can see these operations (seem to) fail to represent LC-equivalence.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, take the qudit state $|G\rangle$ depicted the graph $G$ in Fig. 1, defined for qudit dimension $d=4$, and let $x=y=z=2$, such that $A_{12}=A_{13}=A_{14}=2$.&#xA;In this case performing $\circ_2 1$ then $A_{1i} \mapsto 2 \times 2 = 4 \equiv 0 \bmod 4 \;\forall\; i$, and hence qudit $1$ is disentangled from all other qudits using only local operations.&#xA;Clearly this is wrong and occurs because of the problem of zero divisors as mentioned in the previous questions' &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2546/391&quot;&gt;answer&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is: &lt;strong&gt;is there &lt;em&gt;any&lt;/em&gt; set of graph operations that properly represent local Clifford equivalence for qudit graph states of non-prime dimension?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; I am primarily interested in operations that &lt;strong&gt;directly&lt;/strong&gt; apply to a state's representation as a single weighted graph, rather than possible decompositions into multiple prime-dimensional graph states, as suggested in Sec. 4.3 of &quot;&lt;a href=&quot;https://arxiv.org/pdf/1306.2879.pdf&quot; rel=&quot;noreferrer&quot;&gt;Absolutely Maximally Entangled Qudit Graph States&lt;/a&gt;&quot;.&lt;/p&gt;&#xA;" OwnerUserId="391" LastEditorUserId="391" LastEditDate="2018-07-01T13:40:30.080" LastActivityDate="2018-07-19T11:21:45.217" Title="Does local Clifford equivalence have a direct graphical representation for qudit graph states of non-prime dimension?" Tags="&lt;quantum-entanglement&gt;&lt;qudit&gt;&lt;graph-states&gt;" AnswerCount="1" CommentCount="1" FavoriteCount="1" />
  <row Id="2563" PostTypeId="2" ParentId="2549" CreationDate="2018-07-01T16:39:25.523" Score="2" Body="&lt;p&gt;To answer your first, general question: Optical circuits are usually drawn with a selection of conventional symbols, a directory of which to draw them can be found &lt;a href=&quot;http://www.gwoptics.org/ComponentLibrary/&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;With respect to that specific circuit, if a single photon was input, the output would produce a state in a decaying superposition of subsequent time bins. If you choose a temporal basis for your output photons $|t_k\rangle$, taking $|t_0\rangle$ as the time bin of your the first pass through the beamsplitter and $|t_1\rangle$ as the time bin of the next pass, etc, then the output state will be given by&#xA;$$&#xA;\sum_{k=0}^\infty \left(\frac{e^{-i\phi}}{\sqrt{2}}\right)^{k+1}|t_k\rangle,&#xA;$$&#xA;where $\phi$ is the phase shift imparted on each photon after a single pass of the loop.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Alternatively, if you only care about the input and output photons, this can be more generally be represented by the &lt;a href=&quot;https://www.wikiwand.com/en/Bogoliubov_transformation&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bogoliubov transformation&lt;/a&gt; on the optical mode operators&#xA;$$&#xA;a^\dagger_t \mapsto \sum_{k=0}^\infty \left(\frac{e^{-i\phi}}{\sqrt{2}}\right)^{k+1} b^\dagger_{t+k}&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;where $a_t^\dagger$ and $b^\dagger_t$ are the creation operators for photons in time bin $t$ in the optical input and output modes respectively.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Personally, I haven't seen this sort of state before and don't know any particular use for it. However, there may be some use for it in some sort of strange loop-based architecture for linear optical quantum computing, although I would doubt it.&lt;/p&gt;&#xA;" OwnerUserId="391" LastEditorUserId="391" LastEditDate="2018-07-02T05:47:52.317" LastActivityDate="2018-07-02T05:47:52.317" CommentCount="3" />
  <row Id="2564" PostTypeId="1" CreationDate="2018-07-01T17:07:49.533" Score="5" ViewCount="76" Body="&lt;p&gt;&lt;sup&gt;This is a sequel to  &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2490/how-are-two-different-registers-being-used-as-control&quot;&gt;How are two different registers being used as &amp;quot;control&amp;quot;?&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I found the following quantum circuit given in Fig 5 (page 6) of the same paper i.e. &lt;a href=&quot;https://arxiv.org/abs/1110.2232v2&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Circuit Design for Solving Linear Systems of Equations (Cao &lt;em&gt;et al.&lt;/em&gt;,2012)&lt;/a&gt;.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/pUVWa.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/pUVWa.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the above circuit $R_{zz}(\theta)$ is $\left(\begin{matrix}e^{i\theta} &amp;amp; 0 \\ 0 &amp;amp; e^{i\theta}\end{matrix}\right)$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2490/how-are-two-different-registers-being-used-as-control#comment3055_2494&quot;&gt;@DaftWullie mentions here&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Frankly, I've no chance of getting there because there's an earlier&#xA;  step that I don't understand: &lt;strong&gt;the output on registers $L, M$ after Figure&#xA;  5. The circuit diagram and the claimed output don't match up (the claimed output being separable between the $L$ and $M$ registers, when&#xA;  qubit $l−1$ of register $L$ should be entangled with those of register M.&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I understand that after the Walsh-Hadamard transforms the state of register $L$  is $$\frac{1}{\sqrt{2^l}}\sum_{s=0}^{2^l-1}|s\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;and that of register $M$ is &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\frac{1}{\sqrt{2^m}}\sum_{p=0}^{2^m-1}|p\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But after that, I'm not exactly sure how they're applying the $R_{zz}$ rotation gates to get to $$\sum_s\sum_p|p\rangle \exp(i p/2^m t_0)|s\rangle$$ &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Firstly, are all the $R_{zz}$ gates acting on a single qubit i.e. the $l-1$th qubit in the register $L$? (Seems so from the diagram, but I'm not sure).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Secondly, it would be very helpful if some can write down the steps for how're they're getting to $\sum_s\sum_p|p\rangle \exp(i p/2^m t_0)|s\rangle$ using the controlled rotation gates.&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-06T12:36:59.307" LastActivityDate="2018-07-06T12:36:59.307" Title="How exactly is the stated composite state of the two registers being produced using the $R_{zz}$ controlled rotations?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-gate&gt;&lt;controlled-gates&gt;&lt;hhl-algorithm&gt;" AnswerCount="0" CommentCount="10" />
  <row Id="2565" PostTypeId="1" AcceptedAnswerId="2568" CreationDate="2018-07-01T19:47:46.293" Score="7" ViewCount="123" Body="&lt;p&gt;I've probably read the chapter &lt;em&gt;The quantum Fourier transform and its applications&lt;/em&gt; from Nielsen and Chuang (10 th anniversary edition) a couple of times before and this took this thing for granted, but today, when I looked at it again, it doesn't seem obvious to me at all! &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here's the circuit diagram for the Phase estimation algorithm:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/7jgOV.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/7jgOV.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The first register having $t$ qubits is supposedly the &quot;control register&quot;. If any of the qubit in the first register is in state $|1\rangle$ the corresponding controlled unitary gate &lt;strong&gt;gets applied to the second register&lt;/strong&gt;. If it is in a state $|0\rangle$ then it doesn't get applied to the &lt;strong&gt;second register&lt;/strong&gt;. If it is in a superposition of the two states $|0\rangle$ and $|1\rangle$ the action of the corresponding unitary on the second register can be determined by &quot;linearity&quot;. Notice, that all the gates are acting only on the second register and none on the first register. The first register is supposed to be only a &lt;strong&gt;control&lt;/strong&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, they show that the final state of the &lt;strong&gt;first register&lt;/strong&gt; as:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\frac{1}{2^{t/2}}\left(|0\rangle+\text{exp}(2\pi i&#xA; 2^{t-1}\varphi)|1\rangle)(|0\rangle+\text{exp}(2\pi i&#xA; 2^{t-2}\varphi)|1\rangle)...(|0\rangle+\text{exp}(2\pi i&#xA; 2^{0}\varphi)|1\rangle\right)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I'm surprised as to why we consider there to be a change in the state of the first register of qubits at all, after the action of the Hadamard gates. The final state of the first register should just have been &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\left(\frac{|0\rangle+|1\rangle}{\sqrt 2}\right)^{\otimes t}$$ &lt;/p&gt;&#xA;&#xA;&lt;p&gt;isn't it? I say this because the first register is supposed to be a control only. I don't understand how or why the state of the first register should change when acting as a control. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I initially thought that considering the exponential factors to be part of the first register qubit states was only a mathematical convenience, but then it didn't make sense. &lt;em&gt;State of a qubit or a system of qubits shouldn't depend upon what is mathematically convenient to us!&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, could someone please explain &lt;strong&gt;why exactly the state of the first register of qubits changes, even when it simply acts as a &quot;control&quot; for the second register?&lt;/strong&gt; Is it just a mathematical convenience or is there something deeper? &lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-07T12:00:44.737" LastActivityDate="2018-07-07T12:00:44.737" Title="Why does the &quot;Phase Kickback&quot; mechanism work in the Quantum phase estimation algorithm?" Tags="&lt;quantum-gate&gt;&lt;qubit-state&gt;&lt;quantum-fourier-transform&gt;&lt;phase-estimation&gt;" AnswerCount="3" CommentCount="6" FavoriteCount="1" />
  <row Id="2566" PostTypeId="2" ParentId="2565" CreationDate="2018-07-02T05:19:38.267" Score="1" Body="&lt;p&gt;Great question. &lt;br&gt;&#xA;I once asked this too, but it is not just a matter of mathematical convenience.&lt;br&gt;&#xA;The controlled-U is an &quot;entangling&quot; gate.&lt;br&gt; &#xA;Once there's entanglement, you cannot separate the state into &quot;first register&quot; and &quot;second register&quot;. &lt;br&gt;&#xA;Only think of these registers separately at the beginning, or when there's no entanglement. After there's entanglement, your best bet is to work through the mathematics (matrix multiplications) thoroughly, and you will indeed get the state given by Nielsen and Chuang. &lt;/p&gt;&#xA;" OwnerUserId="2898" LastActivityDate="2018-07-02T05:19:38.267" CommentCount="4" />
  <row Id="2567" PostTypeId="2" ParentId="2561" CreationDate="2018-07-02T05:26:12.673" Score="0" Body="&lt;p&gt;You say there's two options:&lt;br&gt;&#xA;a=a; -&gt; &lt;strong&gt;output = true&lt;/strong&gt;&lt;br&gt;&#xA;b=a; -&gt; &lt;strong&gt;output = false&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This &quot;string comparison&quot; can be done on a classical computer, so you can use C++ (for example).&lt;/p&gt;&#xA;" OwnerUserId="2898" LastActivityDate="2018-07-02T05:26:12.673" CommentCount="1" />
  <row Id="2568" PostTypeId="2" ParentId="2565" CreationDate="2018-07-02T06:31:32.183" Score="4" Body="&lt;p&gt;Imagine you have an eigenvector $|u\rangle$ of $U$. If you have a state such as $|1\rangle|u\rangle$ and you apply controlled-$U$ to it, you get out $e^{i\phi}|1\rangle|u\rangle$. The phase isn't attached to a specific register, it's just an overall multiplicative factor.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now let's use a superposition on the first register:&#xA;$$&#xA;(|0\rangle+|1\rangle)|u\rangle\mapsto |0\rangle|u\rangle+e^{i\phi}|1\rangle|u\rangle&#xA;$$ &#xA;You can rewrite this as&#xA;$$&#xA;(|0\rangle+e^{i\phi}|1\rangle)|u\rangle&#xA;$$&#xA;so it appears on the first register, even though it was sort-of created on the second register. (Of course that interpretation isn't entirely true because it was created by a two-qubit gate acting on both qubits).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This step is at the heart of many quantum algorithms.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Why don't we write $|\Psi\rangle=|0\rangle|u\rangle+|1\rangle(e^{i\phi}|u\rangle)$ and just claim that it is not separable?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One can't just claim it, but must show it mathematically. For example, we can take the partial trace over the second qubit,&#xA;$$&#xA;\text{Tr}_B(|\Psi\rangle\langle\Psi|_{AB})=\text{Tr}_B(|0\rangle\langle 0|\otimes |u\rangle\langle u|+|1\rangle\langle 0|\otimes e^{i\phi}|u\rangle\langle u|+|0\rangle\langle 1|\otimes |u\rangle\langle u|e^{-i\phi}+|1\rangle\langle 1|\otimes e^{i\phi}|u\rangle\langle u|e^{-i\phi})&#xA;$$&#xA;To take the partial trace, we pick a basis to sum over. For simplicity, let's pick $\{|u\rangle,|u^\perp\rangle\}$ where $\langle u|u^\perp\rangle=0$ and $\langle u|(e^{i\phi}|u\rangle=e^{i\phi}$. Then you get&#xA;$$&#xA;\text{Tr}_B(|\Psi\rangle\langle\Psi|_{AB})=|0\rangle\langle 0|+e^{i\phi}|1\rangle\langle 1|+e^{-i\phi}|0\rangle\langle 1|+|1\rangle\langle 1|&#xA;$$&#xA;This is rank 1 (and you can see the phase has appeared on the first register), so the state is not entangled. It is separable.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-07-02T07:36:17.823" LastActivityDate="2018-07-02T07:36:17.823" CommentCount="6" />
  <row Id="2569" PostTypeId="2" ParentId="2524" CreationDate="2018-07-02T06:52:52.223" Score="1" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;how (do) engineers detect that the state function did not collapse due to the environment while a calculation is performed?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;In a sense, they don't. There's the possibility that you encode in an error correcting or error detecting code which permits the monitoring of errors. But really, before experimentalists want to run an algorithm, they've already done lots of tests on their system so they know how it works using a procedure called &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_tomography#Quantum_process_tomography&quot; rel=&quot;nofollow noreferrer&quot;&gt;process tomography&lt;/a&gt;. They've checked in great detail that each of their gates performs as they expect them to, so they already have a very accurate prediction of how much error there will be.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;how to detect that a calculation is finished?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;You don't need to detect that it has finished. The computation is made up of a definite set of quantum gates. All you do is apply each gate sequentially. You know when you've finished implementing them, so you know when to look at the answer.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;how is it even possible to check whether the experimenter produced a certain quantum state? Maybe all the bits have a totally different state right from the start and you just know about that afterwards.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Well, you can make sure you've got the correct starting state because you can measure it (you always start in a product state that you can easily measure). The final result is just about making sure all the individual steps do exactly what they're supposed to do. Again, if you can't do them perfectly, error correction (and more generally, fault tolerance) can beused to keep you on track. It is true that you can't use measurements to determine the state and copy it many times, as you might think to do with classical computation, but there are still good error correcting techniques. But that's another whole question...&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-07-02T06:52:52.223" CommentCount="0" />
  <row Id="2570" PostTypeId="2" ParentId="1937" CreationDate="2018-07-02T07:13:26.463" Score="1" Body="&lt;p&gt;Let's start with a simple example where $H_i$ and $H_f$ commute because they are both diagonal:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$H_i=&#xA;\begin{pmatrix}1 &amp;amp; 0\\&#xA;0 &amp;amp; -1&#xA;\end{pmatrix}&#xA;$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$H_p=&#xA;\begin{pmatrix}-1 &amp;amp; 0\\&#xA;0 &amp;amp; -0.1&#xA;\end{pmatrix}&#xA;$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The eigenvector with lowest eigenvalue (i.e. the ground state) of $H_i$ is $|1\rangle $ so we start in this state.&#xA;The ground state of $H_f$ is $|0\rangle$ so this is what we're looking for.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Remember the minimum runtime for the AQC to give the correct answer to within an error $\epsilon$:&lt;br&gt;&#xA;$\tau\ge \max_t\left(\frac{||H_i - H_f||^2}{\epsilon E_{\rm{gap}}(t)^3}\right)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is given and explained in Eq. 2 of &lt;a href=&quot;https://arxiv.org/pdf/1510.07420.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Tanburn &lt;em&gt;et al.&lt;/em&gt; (2015)&lt;/a&gt;. &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Let's say we want $\epsilon = 0.1$.&lt;/li&gt;&#xA;&lt;li&gt;Notice that $||H_i - H_f||^2 = 0.1 $ according Eq. 4 of the same paper.&lt;/li&gt;&#xA;&lt;li&gt;Notice that $\frac{||H_i - H_f||^2}{\epsilon}=1$ (I've chosen $\epsilon$ so that this would happen, but it doesn't matter).&lt;/li&gt;&#xA;&lt;li&gt;We now have $\tau \ge \max_t\left(\frac{1}{E_{\rm{gap}}(t)^3}\right)$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;So what is the minimum gap between ground and first excited state (which gives the $\max_t$) ?&lt;br&gt;&#xA;When $t=20\tau/29$, the Hamiltonian is:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$H=\frac{9}{29}H_i + \frac{20}{29}H_p$&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$H=\frac{9}{29}\begin{pmatrix}1 &amp;amp; 0\\&#xA;0 &amp;amp; -1&#xA;\end{pmatrix} + \frac{20}{29}\begin{pmatrix}-1 &amp;amp; 0\\&#xA;0 &amp;amp; -0.1&#xA;\end{pmatrix}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$&#xA;H=\begin{pmatrix}\frac{9}{29} &amp;amp; 0\\&#xA;0 &amp;amp; -\frac{9}{29}&#xA;\end{pmatrix}+\begin{pmatrix}-\frac{20}{29} &amp;amp; 0\\&#xA;0 &amp;amp; -\frac{2}{29}&#xA;\end{pmatrix}&#xA;$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$&#xA;H=\begin{pmatrix}\frac{-11}{29} &amp;amp; 0\\&#xA;0 &amp;amp; -\frac{11}{29}&#xA;\end{pmatrix}&#xA;$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So when $t=\frac{20}{29}\tau$, we have $E_{\rm{gap}}=0$ and the &lt;strong&gt;&lt;em&gt;lower bound&lt;/em&gt;&lt;/strong&gt; on $\tau$ is essentially $\infty$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So the adiabatic theorem still applies, but when it states that the Hamiltonian needs to change &quot;slowly enough&quot;, it turns out it needs to change &quot;infinitely slowly&quot;, which means you will not likely ever get the answer using AQC.  &lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-07-02T07:13:26.463" CommentCount="2" />
  <row Id="2571" PostTypeId="2" ParentId="2554" CreationDate="2018-07-02T09:33:00.210" Score="0" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;At least for now, I see a big problem with giving an answer that&#xA;  involves saying we could just use quantum encryption algorithms. The&#xA;  main reason is that in order for the encryption to be effective the&#xA;  end users would have to be in possession of a quantum encrypt/decrypt&#xA;  device. Not a problem for a bank or Amazon on their end, but a big&#xA;  problem for a guy trying to order a pizza on his smartphone.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Not really.  Current day cryptosystems are mostly based on &lt;a href=&quot;https://en.wikipedia.org/wiki/Integer_factorization&quot; rel=&quot;nofollow noreferrer&quot;&gt;integer factorization&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Discrete_logarithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;discrete logarithm&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic-curve_cryptography&quot; rel=&quot;nofollow noreferrer&quot;&gt;elliptic curve cryptography&lt;/a&gt;. I'd like to point out to you: &lt;a href=&quot;https://en.wikipedia.org/wiki/Post-quantum_cryptography&quot; rel=&quot;nofollow noreferrer&quot;&gt;Post-quantum cryptography&lt;/a&gt;. There are already a few cryptography algorithms which are resistant to quantum computer attacks. And you don't need &lt;em&gt;necessarily&lt;/em&gt; &quot;quantum computers&quot; on the sender's or receiver's end for using such cryptography techniques.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The cryptosystems which are quantum-resistant normally use problems which lie outside &lt;a href=&quot;https://en.wikipedia.org/wiki/BQP&quot; rel=&quot;nofollow noreferrer&quot;&gt;BQP&lt;/a&gt; rather than being &lt;a href=&quot;https://en.wikipedia.org/wiki/QMA#Problems_in_QMA&quot; rel=&quot;nofollow noreferrer&quot;&gt;QMA-hard&lt;/a&gt;. That implies, the owners of the private key (in this case the sender and receiver) can easily decrypt the message using a classical computer, whereas since the problem is QMA-hard without the private key, even using &quot;brute-force&quot;, it would be difficult for a quantum computer to hack. (see &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2518/26&quot;&gt;@DaftWullie's excellent answer&lt;/a&gt;) and his &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2516/what-classical-public-key-cryptography-protocols-exist-for-which-hacking-is-qma#comment3131_2518&quot;&gt;comment&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;For example, in the normal classical case of RSA, the central function&#xA;  is factoring. The problem is (assumed to be) outside P making it hard&#xA;  for a classical computer to hack, but inside NP (NOT NP-hard) so that&#xA;  the rightful receiver can decrypt it on a classical computer.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;To quote &lt;a href=&quot;https://en.wikipedia.org/wiki/Post-quantum_cryptography&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wikipedia&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;In contrast to the threat quantum computing poses to current&#xA;  public-key algorithms, most current &lt;strong&gt;symmetric cryptographic&#xA;  algorithms&lt;/strong&gt;, and &lt;strong&gt;hash functions&lt;/strong&gt; are considered to be relatively secure&#xA;  against attacks by quantum computers. While the &lt;strong&gt;quantum Grover's&#xA;  algorithm&lt;/strong&gt; does speed up attacks against &lt;strong&gt;symmetric ciphers&lt;/strong&gt;, doubling&#xA;  the key size can effectively block these attacks. &lt;strong&gt;Thus post-quantum&#xA;  symmetric cryptography does not need to differ significantly from&#xA;  current symmetric cryptography.&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;By the way, I should point out that we're still quite a long way away from having actual quantum computers which can break current-day cryptosystems. The quantum computers of today aren't capable of even factorizing very large numbers. The largest number factorized by a quantum computer till date is $291311$&lt;sup&gt;[1]&lt;/sup&gt; (as far as I know). That's something even your hand PC can do in milliseconds and that is nowhere close to breaking a cryptosystem. Presumably, by the time we will have such quantum computers, cryptography will have already progressed by leaps and bounds (and we wouldn't have to worry about &quot;quantum attacks&quot;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Moral of the story&lt;/strong&gt;: &lt;em&gt;Even in the future, your guy can still order pizzas using his &quot;classical&quot; smartphone without having to worry about hungry hackers stealing his pizzas using a quantum computer&lt;/em&gt;! ;)&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;[1]: &lt;strong&gt;High-fidelity adiabatic quantum computation using the intrinsic Hamiltonian of a spin system: Application to the experimental factorization of 291311&lt;/strong&gt; Li &lt;em&gt;et al.&lt;/em&gt; (2017)&lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-07-02T09:33:00.210" CommentCount="0" />
  <row Id="2572" PostTypeId="2" ParentId="2565" CreationDate="2018-07-02T12:10:56.200" Score="5" Body="&lt;h2&gt;A first remark&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;This same phenomenon of 'control' qubits changing states in some circumstances also occurs with controlled-NOT gates; in fact, this is the entire basis of eigenvalue estimation. So not only is it possible, it is an important fact about quantum computation that it is possible. It even has a name: a &quot;phase kick&quot;, in which the control qubits (or more generally, a control register) incurs relative phases as a result of acting through some operation on some target register.$\def\ket#1{\lvert#1\rangle}$&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;The reason why this happens&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Why&lt;/em&gt; should this be the case? Basically it comes down to the fact that the standard basis is not actually as important as we sometimes describe it as being.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Short version.&lt;/strong&gt; &lt;em&gt;Only the standard basis states&lt;/em&gt; on the control qubits are unaffected. If the control qubit is in a state which is &lt;em&gt;not&lt;/em&gt; a standard basis state, it can in principle be changed.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Longer version &amp;mdash;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Consider the Bloch sphere. It is, in the end, a sphere &amp;mdash; perfectly symmetric, with no one point being more special than any other, and no one &lt;em&gt;axis&lt;/em&gt; more special than any other. In particular, the standard basis is not particularly special.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The CNOT operation is in principle a physical operation. To describe it, we often &lt;em&gt;express it in terms of how it affects the standard basis&lt;/em&gt;, using the vector representations&#xA;$$ \ket{00} \to {\scriptstyle \begin{bmatrix} 1 \\ 0 \\ 0 \\ 0 \end{bmatrix}}\,,&#xA;\quad&#xA;\ket{01} \to {\scriptstyle \begin{bmatrix} 0 \\ 1  \\ 0 \\ 0 \end{bmatrix}}\,,&#xA;\quad&#xA;\ket{10} \to {\scriptstyle \begin{bmatrix} 0 \\ 0 \\ 1   \\ 0 \end{bmatrix}}\,,&#xA;\quad&#xA;\ket{11} \to {\scriptstyle \begin{bmatrix} 0 \\ 0 \\ 0 \\ 1   \end{bmatrix}}$$&#xA;&amp;mdash; but this is just a representation. This leads to a specific representation of the CNOT transformation:&#xA;$$&#xA;\mathrm{CNOT}&#xA;\to&#xA;{\scriptstyle \begin{bmatrix} 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \end{bmatrix}}\,.$$&#xA;and for the sake of brevity we say that those column vectors &lt;em&gt;are&lt;/em&gt; the standard basis states on two qubits, and that this matrix &lt;em&gt;is&lt;/em&gt; a CNOT matrix.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Did you ever do an early university mathematics class, or read a textbook, where it started to emphasise the difference between a linear transformation and matrices &amp;mdash; where it was said, for example, that a matrix could &lt;em&gt;represent&lt;/em&gt; a linear transformation, but was not &lt;em&gt;the same as&lt;/em&gt; a linear transformation? The situation with CNOT in quantum computation is one example of how this distinction is meaningful. The CNOT is a transformation of a &lt;em&gt;physical system&lt;/em&gt;, not of column vectors; the standard basis states are just &lt;em&gt;one basis&lt;/em&gt; of a physical system, which we &lt;em&gt;conventionally represent&lt;/em&gt; by $\{0,1\}$ column vectors.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What if we were to choose to represent a different basis &amp;mdash; say, the X eigenbasis &amp;mdash; by $\{0,1\}$ column vectors, instead? Suppose that we wish to represent $$&#xA;\begin{aligned}&#xA;\ket{++} \to{}&amp;amp; [\, 1 \;\; 0 \;\; 0 \;\; 0 \,]^\dagger\,,&#xA;\\&#xA;\ket{+-} \to{}&amp;amp; [\, 0 \;\; 1 \;\; 0 \;\; 0 \,]^\dagger\,,&#xA;\\&#xA;\ket{-+} \to{}&amp;amp; [\, 0 \;\; 0 \;\; 1 \;\; 0 \,]^\dagger\,,&#xA;\\&#xA;\ket{--} \to{}&amp;amp; [\, 0 \;\; 0 \;\; 0 \;\; 1 \,]^\dagger \,.&#xA;\end{aligned}$$&#xA;This is a perfectly legitimate choice mathematically, and because it is only a notational choice, it doesn't affect the physics &amp;mdash; it only affects the way that we would write the physics. It is not uncommon in the literature to do analysis in a way equivalent to this (though it is rare to explicitly write a different convention for column vectors as I have done here). We would have to represent the standard basis vectors by:&#xA;$$ \ket{00} \to \tfrac{1}{2}\,{\scriptstyle \begin{bmatrix} 1 \\ 1 \\ 1 \\ 1 \end{bmatrix}}\,,&#xA;\quad&#xA;\ket{01} \to \tfrac{1}{2}\,{\scriptstyle \begin{bmatrix} 1 \\ -1  \\ 1 \\ -1 \end{bmatrix}}\,,&#xA;\quad&#xA;\ket{10} \to \tfrac{1}{2}\,{\scriptstyle \begin{bmatrix} 1 \\ 1 \\ -1   \\ -1 \end{bmatrix}}\,,&#xA;\quad&#xA;\ket{11} \to \tfrac{1}{2}\,{\scriptstyle \begin{bmatrix} 1 \\ -1 \\ -1 \\ 1   \end{bmatrix}}\,.$$&#xA;Again, we're using the column vectors on the right &lt;em&gt;only to represent&lt;/em&gt; the states on the left. But this change in representation will affect how we want to represent the CNOT gate.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A sharp-eyed reader may notice that the vectors which I have written on the right just above are the columns of the usual matrix representation of $H \otimes H$. There is a good reason for this: what this change of representation amounts to is a change of reference frame in which to describe the states of the two qubits. In order to describe $\ket{++} = [\, 1 \;\; 0 \;\; 0 \;\; 0 \,]^\dagger$, $\ket{+-} = [\, 0 \;\; 1 \;\; 0 \;\; 0 \,]^\dagger$, and so forth, we have changed our frame of reference for each qubit by a rotation which is the same as the usual matrix representation of the Hadamard operator &amp;mdash; because that same operator interchanges the $X$ and $Z$ observables, by conjugation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This same frame of reference will apply to how we represent the CNOT operation, so in this shifted representation, we would have&#xA;$$&#xA;\begin{aligned}&#xA;\mathrm{CNOT} \to \tfrac{1}{4}{}\,{\scriptstyle&#xA;\begin{bmatrix} 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\ 1 &amp;amp; -1 &amp;amp; 1 &amp;amp; -1 \\ 1 &amp;amp; 1 &amp;amp; -1 &amp;amp; -1 \\ 1 &amp;amp; -1 &amp;amp; -1 &amp;amp; 1 \end{bmatrix}&#xA;\,\begin{bmatrix} 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \end{bmatrix}\,&#xA;\begin{bmatrix} 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\ 1 &amp;amp; -1 &amp;amp; 1 &amp;amp; -1 \\ 1 &amp;amp; 1 &amp;amp; -1 &amp;amp; -1 \\ 1 &amp;amp; -1 &amp;amp; -1 &amp;amp; 1 \end{bmatrix}&#xA;}\,&#xA;=&#xA;\,{\scriptstyle&#xA;\begin{bmatrix} 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \end{bmatrix}}&#xA;\end{aligned}$$&#xA;which &amp;mdash; remembering that the columns now represent $X$ eigenstates &amp;mdash; means that the CNOT performs the transformation&#xA;$$ \begin{aligned}&#xA;\mathrm{CNOT}\,\ket{++} &amp;amp;= \ket{++} , \\&#xA;\mathrm{CNOT}\,\ket{+-} &amp;amp;= \ket{--}, \\&#xA;\mathrm{CNOT}\,\ket{-+} &amp;amp;= \ket{-+} , \\&#xA;\mathrm{CNOT}\,\ket{--} &amp;amp;= \ket{+-} .&#xA;\end{aligned} $$&#xA;Notice here that it is &lt;em&gt;only&lt;/em&gt; the first, 'control' qubits whose state changes; the target is left unchanged.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, I could have shown this same fact a lot more quickly without all of this talk about changes in reference frame. In introductory courses in quantum computation in computer science, a similar phenomenon might be described without ever mentioning the words 'reference frame'. But I wanted to give you more than a mere calculation.  I wanted to draw attention to the fact that a CNOT is in principle not just a matrix; that the standard basis is not a special basis; and that when you strip these things away, it becomes clear that the operation realised by the CNOT clearly has the potential to affects the state of the control qubit, even if the CNOT is the only thing you are doing to your qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The very idea that there is  a 'control' qubit is one centered on the standard basis, and embeds a prejudice about the states of the qubits that  invites us to think of the operation as one-sided. But as a physicist, you should be deeply suspicious of one-sided operations. &lt;em&gt;For every action there is an equal and opposite reaction&lt;/em&gt;; and here the apparent one-sidedness of the CNOT on &lt;em&gt;standard basis states&lt;/em&gt; is belied by the fact that, for X eigenbasis states, it is the 'target' which unilaterally determines a possible change of state of the 'control'.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You wondered whether there was something at play which was only a mathematical convenience, involving a choice of notation. In fact, there is: the way in which we write our states with an emphasis on the standard basis, which may lead you to develop a &lt;em&gt;non-mathematical intuition&lt;/em&gt; of the operation &lt;em&gt;only in terms&lt;/em&gt; of the standard basis. But change the representation, and that non-mathematical intuition goes away.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The same thing which I have sketched for the effect of CNOT on X-eigenbasis states, is also going on in phase estimation, only with a different transformation than CNOT. The 'phase' stored in the 'target' qubit is kicked up to the 'control' qubit, because the target is in an eigenstate of an operation which is being coherently controlled by the first qubit. On the computer science side of quantum computation, it is one of the most celebrated phenomena in the field. It forces us to confront the fact that the standard basis is only special in that it is the one we prefer to describe our data with &amp;mdash; but not in how the physics itself behaves.&lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-07-02T12:30:42.240" LastActivityDate="2018-07-02T12:30:42.240" CommentCount="0" />
  <row Id="2573" PostTypeId="2" ParentId="2352" CreationDate="2018-07-02T13:53:55.143" Score="4" Body="&lt;p&gt;&lt;em&gt;Caveat.&lt;/em&gt; I can't be absolutely certain that no-one has contemplated a quantum XOR list before &amp;mdash; but I can be pretty confident. On the theory side, the idea of data structures as granular as linked lists (of any description) is pretty low-level, and to my knowledge is not really the subject of research; and people working on architectures only dream of the day in which they might worry about how to store data structures in their machines. So it's likely that there is no pre-defined art on the subject.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Before we consider &quot;quantum XOR linked lists&quot;, the main thing to consider is what a linked list &lt;em&gt;does&lt;/em&gt;. It is just a data structure which is used to maintain a list of data items, where the 'links' encode memory addresses for the next or previous item in the list. This idea is pretty generic (that's a compliment, not an insult): it can be applied to &lt;em&gt;any&lt;/em&gt; sort of data without modification. On the other hand, it is possible to contemplate ways to extend the addressing itself to the quantum regime: this is something which, at least in principle, you may want to do, for example if you are interested in superpositions of possible list values for some algorithm which relies on such a concept to work.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This motivates two concepts:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Classically linked lists of quantum data values&lt;/strong&gt;, in which the data is quantum but the memory addresses are classical pointers to definite qubits or other quantum registers. This is the application of the notion of &quot;linked list of [X]&quot; to the case where 'X' happens to be quantum data. The data structure doesn't care that the data itself is quantum: the data structure is there to act as a box in which to order your data, and is completely agnostic as to what is to be done with that data.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For this sort of linked list, the way to get an XOR linked list is simple: you do the same thing as for XOR Linked lists of classical data. The fact that the data is quantum doesn't make any difference to the data structure in this case, so you use the very same techniques.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Quantum-linked lists&lt;/strong&gt;, in which the data is quantum, and so are the encodings of the memory addresses. This is what you would do if you wanted to consider superposition of possible lists, including arbitrary variations in list-length. If you're wondering how you could possibly retrieve data from a superposition of memory addresses, it seems to me that the answer is the same as you would do with any&#xA;algorithm which queries a &quot;quantum database&quot; in superposition: you&#xA;require access to a qRAM, as a means to perform coherent queries of a data bank.&#xA;If the data stored at the address is &lt;em&gt;also&lt;/em&gt; quantum, you cannot clone it of course; but perhaps you can move that data (in a particular branch of the superposition) from the qRAM to your&#xA;active data qubits &amp;mdash; your 'cache', if you will &amp;mdash; in order to operate on it more&#xA;quickly. After you have performed the operations you intend to perform on that cached data, you might then swap it back to the qRAM.&#xA;In the meantime, the state of your working memory will be entangled with one or more registers of the qRAM, but there is nothing theoretically wrong with that, so long as you maintain the appropriate hygiene to keep from disrupting your data in ways that you do not intend. I have no specific suggestions for when you would actually want to do this, but as it is not an obviously ridiculous thing to want to do, I see no reason not to take this concept seriously.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In such a list, one should generally expect the pointer values of elements later in the list, to be entangled with pointer values earlier in the list.&#xA;You will have to be careful about how you store copies of memory addresses, as you compute them and (just as importantly!) &lt;strong&gt;uncompute&lt;/strong&gt; them, to traverse the quantum linked list.&#xA;The data structure might be represented almost as a decision tree, though there is likely some application of this data structure which would make the relative phases of the &lt;em&gt;pointer values&lt;/em&gt; important, and which would distinguish it from a decision tree. (These are features which one should generally expect of a data structure built from quantum registers for memory addresses.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If there is any reason at all to consider superpositions of memory addresses, then as soon as it becomes reasonable at all to realise data structures such as linked lists on quantum computers, an XOR-linked list seems a very sensible idea for a data structure. The savings in resources for the links would be a significant benefit for the foreseeable future, with only modest overhead in the additional cached data required to compute the addresses for the forward and backward links. The way one would realise these are &lt;em&gt;almost&lt;/em&gt; the same as for classical XOR-linked lists: the memory addresses are encoded as standard basis vectors, for which you may computer the XOR, and more generally you may take the superposition of the parities computed by XOR. The principle is essentially the same as for a more general quantum linked list; you just use a more elaborate encoding for the pointers. This may require a little bit more care to be taken to uncompute the links addresses as you traverse the list, but it seems likely that only a modest amount of additional work is required.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The major constraint that I see for quantum-linked lists &amp;mdash; whether singly-, doubly-, or XOR-linked &amp;mdash; is the uncomputation of memory addresses as you traverse the list. Whether this ever poses a significant problem would probably depend on &lt;em&gt;how&lt;/em&gt; and &lt;em&gt;why&lt;/em&gt; you would want to traverse a quantum-linked list, which is to say, what you want to accomplish with it. However, it seems clear in principle that one can define such quantum-linked lists, and the way they would be implemented would be similar to a reversible implementation of classical linked lists, assuming that there is the appropriate architecture (such as qRAM in this case) to support the question of fetching data from addresses stored in superposition.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="124" LastActivityDate="2018-07-02T13:53:55.143" CommentCount="0" />
  <row Id="2574" PostTypeId="2" ParentId="2499" CreationDate="2018-07-02T15:50:16.033" Score="5" Body="&lt;p&gt;When you ask whether it is pie in the sky, that rather depends on what promises you think quantum technologies are trying to fulfil. And that depends on who the people are making those promises.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Consider why you are even aware of quantum computation, given that it hasn't yet managed to produce any devices (or to be more fair, &lt;a href=&quot;https://www.dwavesys.com/sites/default/files/2000Q%20Systems%20in%20Lab%20website.jpeg&quot; rel=&quot;noreferrer&quot;&gt;not very many devices&lt;/a&gt;) which resemble muscular computer hardware. Where are you hearing about it from, whence the excitement? I'm willing to bet that even if you attend every academic talk about quantum computing that you can personally manage to, not very much of what you hear about quantum computing is coming from academics. Chances are you hear a lot about quantum computing from sources which are more interested in excitement than fact.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are some corporate sources who are making more or less grandiose claims about what their quantum hardware can do, or will be able to do; and there have been for well over a decade. Meanwhile, there is a large community of people who have simply been trying to make careful progress and not spend too much of their energy making promises they can't deliver. Whom will you have heard more from?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But even granting those, the parties most responsible for excitement about quantum computation are certain kinds of magazines and special-interest websites, which as sources of information are like market-square waffle vendors: they trade very much on sweet vaporous aromas rather than something with substance and bite. &#xA;The attention-seeking advertising industry, rather than academia, are the main reason why there are such puffed-up expectations of quantum computation. They don't even care about quantum computation in principle: it is one of several magical incantations with which to amaze the crowd, to evoke dreams of pie in the sky, and in the meantime make money from some other company for the mere possibility that an ad was seen for half a second. &lt;em&gt;That&lt;/em&gt; industry is very much in the business of selling airborne pastry, both to their clients and to their audience.  But does that mean that the world is owed flying fig rolls by those who are actually working on quantum technologies? It's hard enough to accomplish the things which &lt;em&gt;we&lt;/em&gt; think might be possible to accomplish &amp;mdash; which are more modest, but still worthwhile.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Among my academic peers (theoretical computer scientists and theoretical physicists), the blatant misinformation about quantum computation among the public is a source of significant frustration. Most of us believe that it will be possible to build a quantum computer, and most of those who do also believe that it will have significant economic impacts. But none of us expect that it would turn the world upside-down in five to ten years, nor have we been expecting that for any of the past fifteen years that it started to become fashionable to say that we would have massive quantum computers &quot;in five to ten years&quot;. I have always made it a point to say that I hope to see the impacts in my lifetime, and recent activity has made me hope to see it within twenty &amp;mdash; but even then you won't be going to the store to buy one, any more than you go down to the store to buy a Cray supercomputer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Nor do any of us expect that it will allow you to easily solve the Travelling Salesman Problem, or the like. Being able to analyse problems in quantum chemistry and quantum materials is the original, and in the short term still the best, prospective application of quantum computation, and it may be revolutionary there; and perhaps in the longer term we can provide robust and significant improvements in practise for optimisation problems. (D-Wave claims they can already do this in practise with their machines: the jury is still out among academics whether this claim is justified.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The devil of it is, to explain what you can actually expect out of the theory and development of quantum computation, you have to somehow explain a little quantum mechanics. This Is Not An Easy Thing To Do, and as with anything complicated, there is little patience in the larger world for nuanced understanding, especially when &quot;alternative facts&quot; in the form of candy-flavoured 'yakawow' hype is striding mightily around in seven league boots.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The truth &amp;mdash; about what quantum computation can do, and that it likely won't allow you to teleport across the world, nor solve world hunger or airline chaos at a stroke &amp;mdash; is boring. But making significant advances in chemistry and materials science is not. To say nothing of applications not yet developed: how easily can you extrapolate from gear-based computers to &lt;a href=&quot;https://en.wikipedia.org/wiki/Pascal%27s_calculator&quot; rel=&quot;noreferrer&quot;&gt;help reliably compute taxes&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Difference_engine&quot; rel=&quot;noreferrer&quot;&gt;compute logarithm-tables&lt;/a&gt; to &lt;a href=&quot;https://en.wikipedia.org/wiki/Aircraft_design_process#Computer-aided_design_of_aircraft&quot; rel=&quot;noreferrer&quot;&gt;designing aircraft&lt;/a&gt;?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The timeline of classical computing technology extends well before even the 19th century. We have some idea of how to try to re-tread this path with quantum technologies, and we have an idea of the sorts of dividends which may be possible if we do so. For that reason, we hope to reproduce the development to useful computing technology in a much, much faster amount of time than the 370-plus years from Pascal's adders to the modern day. But it's not going to be quite as fast as some people have been promising, particularly those people who are not actually responsible for delivering on those 'promises'. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Some remarks.&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;em&gt;Where's the parallel adder?&lt;/em&gt;&quot;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;We  don't have large devices which carry out addition by quantum computers, but we do have some people working on fast addition circuits in quantum computers &amp;mdash; some of what quantum computers will have to do would involve more conventional operations on data in superposition. &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;em&gt;Where's the equivalent of Atlas, or the MU5?&lt;/em&gt;&quot;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;To be frank, we're still working on the first reliable quantum analogue of Pascal's adder. I'm hopeful that the approach of the &lt;a href=&quot;https://nqit.ox.ac.uk&quot; rel=&quot;noreferrer&quot;&gt;NQIT project&lt;/a&gt; (disclosure: I'm involved in it, but not as an experimentalist) of making small, high-quality modules which can exchange entanglement will be a route to rapid scaling via mass-production of the modules, in which case we might go from Pascal's adder, to the Collosus, to the Atlas, and beyond in a matter of a few years. But only time will tell.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;em&gt;It looks like they haven't even got off the ground. You won't be buying one in PC World any time soon.&lt;/em&gt;&quot;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;That is perfectly true. However, if you were ever told to expect otherwise, this is more likely to be the fault of PC World (or to be fair, PC World's competitors in the market for your subscription money as a tech enthusiast) than it is ours. Any responsible researcher would tell you that we're striving hard to make the first serious prototype devices. &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;em&gt;Will you ever be able to [buy a quantum computer in PC World]?&lt;/em&gt;&quot; &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Will you ever be able to buy a Cray in PC World? Would you want to? Maybe not. But your university may want to, and serious businesses may want to. Beyond that is wild speculation &amp;mdash; I don't see how a quantum computer would improve word-processing. But then again, I doubt that Babbage ever imagined that anything akin to his Difference Engine would be used to compose letters.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-07-02T16:07:40.120" LastActivityDate="2018-07-02T16:07:40.120" CommentCount="2" />
  <row Id="2575" PostTypeId="2" ParentId="2553" CreationDate="2018-07-02T19:17:56.293" Score="4" Body="&lt;p&gt;In general, &lt;a href=&quot;https://docs.microsoft.com/en-us/quantum/quantum-techniques-5-workingwithqubits?view=qsharp-preview#allocating-qubits&quot; rel=&quot;nofollow noreferrer&quot;&gt;there are exactly two ways to allocate qubits in Q#&lt;/a&gt;: the &lt;code&gt;using&lt;/code&gt; statement, and the &lt;code&gt;borrowing&lt;/code&gt; statement.&#xA;Both can only be used from within Q#, and can't be directly used from within C#.&#xA;Thus, you'd likely want to make a new Q# operation to serve as the &quot;entry point&quot; from C#; this new operation would then be responsible for allocating qubits and passing them down.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For instance:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// MyOp.qs&#xA;operation EntryPoint() : () {&#xA;    body {&#xA;        using (register = Qubit[2]) {&#xA;            myOp(register);&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;&#xA;// Driver.cs&#xA;EntryPoint.Run().Wait();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="1978" LastActivityDate="2018-07-02T19:17:56.293" CommentCount="0" />
  <row Id="2576" PostTypeId="2" ParentId="2553" CreationDate="2018-07-02T19:18:34.197" Score="2" Body="&lt;p&gt;All qubits must be allocated by the &lt;code&gt;Simulator&lt;/code&gt;, so you can't create an instance and pass it down to your Operation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Why do you want to create the &lt;code&gt;Qubits&lt;/code&gt; on the driver? If anything, you should create an &quot;entry&quot; method on Q# that just allocates your qubits and then call your &lt;code&gt;operation&lt;/code&gt;, and call that from the Driver.&lt;/p&gt;&#xA;" OwnerUserId="2918" LastActivityDate="2018-07-02T19:18:34.197" CommentCount="0" />
  <row Id="2577" PostTypeId="1" AcceptedAnswerId="2579" CreationDate="2018-07-02T19:26:24.927" Score="3" ViewCount="92" Body="&lt;p&gt;What exactly &lt;em&gt;is&lt;/em&gt; a logical (non-physical? error corrected?) qunit? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Can quantum systems be built exclusively w/ logical qunits?&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-07-02T22:02:06.753" LastActivityDate="2018-07-03T07:21:04.813" Title="Computing with Logical Qunits" Tags="&lt;quantum-computer&gt;&lt;quantum-error-correction&gt;&lt;qudit&gt;&lt;emulation&gt;" AnswerCount="2" CommentCount="2" />
  <row Id="2578" PostTypeId="1" CreationDate="2018-07-02T19:30:11.040" Score="-4" ViewCount="133" Body="&lt;p&gt;Does something &lt;em&gt;like&lt;/em&gt; Mohs' scale exist for quantum computing? (eg. classical=0, hybrid=5, pure quantum=10)&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;Mohs' scale:&lt;/strong&gt; a scale of hardness used in classifying minerals. It runs from 1 to 10 using a series of reference minerals, and a position on the scale depends on the ability to scratch minerals rated lower.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The idea came from seeing &lt;a href=&quot;https://worldbuilding.stackexchange.com/questions/51028/knowledge-about-science-really-necessary-for-sci-fi/51030#51030&quot;&gt;this answer&lt;/a&gt; which mentions &quot;Mohs' scale of Sci-fi hardness.&quot;&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-07-10T07:09:43.077" LastActivityDate="2018-07-19T01:40:56.247" Title="Scale for Quantum Computing" Tags="&lt;quantum-computer&gt;&lt;quantum-algorithms&gt;&lt;measurement&gt;&lt;randomised-benchmarking&gt;" AnswerCount="2" CommentCount="2" ClosedDate="2018-07-27T18:40:30.107" />
  <row Id="2579" PostTypeId="2" ParentId="2577" CreationDate="2018-07-02T19:45:12.133" Score="4" Body="&lt;p&gt;A logical qubit is made out of many physical qubits (or qudits), simply selecting a particular two-dimensional subspace. So you can’t make it “exclusively” out of logical qubits because they sit on top of real physical qubits. In fact, if you're thinking about a terminology of &quot;virtual qubits&quot;, that is actually best thought of as a synonym for &quot;logical qubits&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Remember what should almost be the mantra of quantum computing: &quot;information is physical&quot;. Information doesn't exist unless it is recorded somewhere, so it must be recorded on something physical and the physical operations that can be performed on that information carrier determine the nature of the information theory. So if you want a logical qubit you'd better be using quantum information carriers at the physical level. It doesn't matter what quantum information carrier you use as your physical qubit, whether that's a spin or a photon, or any type of two-level system.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There is no particular relation between the number of physical qubits and the number of logical qubits (so long as the size of the space for logical qubits $\leq$ size of space for physical qubits). You might, however, use the relation as some sort of measure of efficiency. For example, we often talk about error correcting codes as defining a logical qubit. They’re defined on multiple physical qubits and give you a smaller number of “useful” qubits. Most critically, when you start talking about fault-tolerance, you have two parameters: $p_c$, the critical error rate above which the fault tolerant scheme cannot achieve arbitrary accuracy, and $p_a&amp;lt;p_c$, the actual error rate that you can achieve. The variation of the number of physical qubits you require to achieve a single error corrected logical qubit as $p_a$ approaches $p_c$ tells you a lot about the feasibility of fault-tolerance and the accuracy we need to aim for to get good quality quantum computing on modestly sized quantum computer..&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-07-03T07:21:04.813" LastActivityDate="2018-07-03T07:21:04.813" CommentCount="5" />
  <row Id="2580" PostTypeId="2" ParentId="2561" CreationDate="2018-07-02T20:01:14.357" Score="1" Body="&lt;p&gt;In Q# you use either the &lt;a href=&quot;https://docs.microsoft.com/en-us/qsharp/api/prelude/microsoft.quantum.primitive.m?view=qsharp-preview&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;M&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;https://docs.microsoft.com/en-us/qsharp/api/prelude/microsoft.quantum.primitive.measure?view=qsharp-preview&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;Measure&lt;/code&gt;&lt;/a&gt; operations to measure a qubit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Once you have the measurement of the Qubit, you can use things like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; or other &lt;a href=&quot;https://docs.microsoft.com/en-us/quantum/quantum-qr-statements?view=qsharp-preview#control-flow&quot; rel=&quot;nofollow noreferrer&quot;&gt;control flow statements&lt;/a&gt; to control your program execution based on the variable values.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Does that answer your question?&lt;/p&gt;&#xA;" OwnerUserId="2918" LastActivityDate="2018-07-02T20:01:14.357" CommentCount="0" />
  <row Id="2581" PostTypeId="2" ParentId="2499" CreationDate="2018-07-02T20:22:37.987" Score="4" Body="&lt;p&gt;Like all good questions, the point is what you mean. As the CTO of a startup developing a quantum computer, I have to emphatically disagree with the proposition that quantum computing is just pie in the sky.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But then you assert &quot;You won't be buying one in PC World any time soon.&quot; This I not only agree with but would suggest that in the foreseeable future, you won't be able to, which is as close to &quot;never&quot; as you'll get me to assert.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Why is that? To the first point, it is valid because there are no engineering reasons to prevent us from building a quantum computer and in fact there are no reasons that will continue to prevent us from building one for much longer. To the second point, it is because it is harder to build a quantum computer than it is to build a classical computer (you need special conditions such as extremely cold temperatures or a very good vacuum, and they are slower) yet there are only certain problems that quantum computers excel at. You don't need any laptops to do drug discovery by computation or breaking outdated crypto or to accelerate inverting some function (especially not if they come with wardrobe sized support equipment), but you need one or a few supercomputers to do it.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Why can I say there are no engineering issues that prevent (large, universal) quantum computers? Note that a single example would suffice, hence I choose the technology I know best, the one I am pursuing professionally. In ion trap based quantum computing, all the ingredients one needs have been demonstrated: There are high-fidelity, universal quantum gates. There are successful attempts to move ions (separate and recombine them from strings of ions, move them along paths, and through intersections of paths), with suitable performance. Plus initializing, measuring, etc. is possible at a fidelity comparable to gate operations. The only thing that prevents large, universal ion trap based quantum computers from being built are related to getting the scientists that made the individual contributions together with the right engineers, serious engineering indeed, and finance.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I'm itching to even tell you just how one might go about getting the feat done soon, technically, but I fear I'd make our patent attorney (and my CEO and everyone else in the company) a bit mad. What it boils down to is this:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If quantum computing is indeed a pie in the sky, then looking back, people in the future will perceive it as just such a low hanging fruit as the first microcomputers.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-07-02T20:22:37.987" CommentCount="0" />
  <row Id="2582" PostTypeId="2" ParentId="2578" CreationDate="2018-07-02T20:30:32.973" Score="2" Body="&lt;p&gt;We used Mohs' scale in Earth Science class to measure the hardness of rocks. If we could scratch it with our finger nail it meant the rock had a hardness of 2 or less. If not it had a hardness of 3 or more. Then if that rock could be scratched by another rock we would assign something greater and if it could scratch softer rocks we'd give it something less. Eventually we were able to come up with a self-consistent order of hardness for all rocks in the data set.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I do not see why you are comparing this to quantum computers.&#xA;Why Mohs' scale and not the Richter scale or the Kinsey scale or the pH scale?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To answer your question: There is no such scale I know of for quantum, classical, hybrid computers. The reason why is probably the fact that those three (quantum, classical, hybrid) are the only things on the scale worth mentioning, so it is a ternary scale (1,2, or 3) not something more sophisticated like a 1-10. We therefore don't have to use numbers and can just use the names, which are more descriptive, self-explanatory, and therefore clear.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-07-02T22:06:32.787" LastActivityDate="2018-07-02T22:06:32.787" CommentCount="4" />
  <row Id="2583" PostTypeId="2" ParentId="2561" CreationDate="2018-07-02T20:37:47.890" Score="2" Body="&lt;p&gt;You can check for state equality with the SWAP test.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0102001&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum fingerprinting (Buhrman, Cleve, Watrous &amp;amp; de Wolf, 2001)&lt;/a&gt; seems to be the first paper to introduce the SWAP test.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The idea behind this test is:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Encode the 2 quantum states using quantum error correction codes to &quot;increase the difference between them&quot;.&lt;/li&gt;&#xA;&lt;li&gt;Test the 2 code words by using an ancilla register and the procedure below.&lt;/li&gt;&#xA;&lt;li&gt;Read the ancilla register. If it is $\left\vert 0 \right\rangle$ then the 2 states are probably equal. Else, they are probably different. &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/W45h1.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/W45h1.png&quot; alt=&quot;SWAP test&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can repeat the procedure multiple times to ensure that the 2 states are equal up to a given probability.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can implement by yourself the test on QISKit:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import qiskit&#xA;&#xA;register_size = 2&#xA;&#xA;Q_SPECS = {&#xA;    &quot;name&quot;: &quot;SWAP-test&quot;,&#xA;    &quot;circuits&quot;: [&#xA;        {&#xA;            &quot;name&quot;: &quot;simple_SWAP_test&quot;,&#xA;            &quot;quantum_registers&quot;: [&#xA;                {&#xA;                    &quot;name&quot;: &quot;psi&quot;,&#xA;                    &quot;size&quot;: register_size&#xA;                },                {&#xA;                    &quot;name&quot;: &quot;phi&quot;,&#xA;                    &quot;size&quot;: register_size&#xA;                },&#xA;                {&#xA;                    &quot;name&quot;: &quot;ancilla&quot;,&#xA;                    &quot;size&quot;: 1&#xA;                },&#xA;            ],&#xA;            &quot;classical_registers&quot;: [&#xA;                {&#xA;                    &quot;name&quot;: &quot;equal&quot;,&#xA;                    &quot;size&quot;: 1&#xA;                },&#xA;            ]&#xA;        },&#xA;    ],&#xA;}&#xA;Q_program = qiskit.QuantumProgram(specs=Q_SPECS)&#xA;&#xA;circuit = Q_program.get_circuit(&quot;simple_SWAP_test&quot;)&#xA;ancilla = Q_program.get_quantum_register(&quot;ancilla&quot;)&#xA;psi = Q_program.get_quantum_register(&quot;psi&quot;)&#xA;phi = Q_program.get_quantum_register(&quot;phi&quot;)&#xA;cequal = Q_program.get_classical_register('equal')&#xA;&#xA;def cswap(circuit, ctrl, q1, q2) -&amp;gt; None:&#xA;    assert(len(q1) == len(q2), &quot;The swapped register sizes should match&quot;)&#xA;    for i in range(len(q1)):&#xA;        # Controlled swap&#xA;        circuit.ccx(ctrl, q1[i], q2[i])&#xA;        circuit.ccx(ctrl, q2[i], q1[i])&#xA;        circuit.ccx(ctrl, q1[i], q2[i])&#xA;&#xA;def equality_test(circuit, ancilla, q1, q2, classical_register) -&amp;gt; None:&#xA;    assert(len(q1) == len(q2), &quot;The swapped register sizes should match&quot;)&#xA;    circuit.h(ancilla[0])&#xA;    cswap(circuit, ancilla[0], q1, q2)&#xA;    circuit.h(ancilla[0])&#xA;    circuit.measure(ancilla[0], classical_register[0])&#xA;&#xA;## Initialisation&#xA;# Psi&#xA;circuit.h(psi)&#xA;# Phi&#xA;circuit.h(phi)&#xA;&#xA;## SWAP test&#xA;equality_test(circuit, ancilla, psi, phi, cequal)&#xA;&#xA;qasm_sim = qiskit.get_backend('local_qasm_simulator')&#xA;res_qasm = qiskit.execute([circuit], qasm_sim, shots=10**5).result()&#xA;counts = res_qasm.get_counts()&#xA;&#xA;print(counts)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;You can convince yourself that the method works with high probability by changing the initialisation step of the two registers and check the results when the 2 register match or don't match.&lt;/p&gt;&#xA;" OwnerUserId="1386" LastEditorUserId="1386" LastEditDate="2018-07-03T08:48:29.620" LastActivityDate="2018-07-03T08:48:29.620" CommentCount="0" />
  <row Id="2584" PostTypeId="2" ParentId="2577" CreationDate="2018-07-02T21:10:25.507" Score="2" Body="&lt;p&gt;&lt;strong&gt;Short answer:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Logical qubits are just an abstraction above physical qubits. A logical qubit is &lt;em&gt;something&lt;/em&gt; (see after for examples) that acts like a qubit. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Some examples&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A logical qubit can be:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;A single physical qubit. This is the case for most of (all?) the quantum chips currently available. In this case, the logical qubit has no advantage over the physical one (they are the same qubits).&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Multiple qubits used for quantum error correction code. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In this case, the user sees the logical qubit as a &lt;strong&gt;single&lt;/strong&gt; qubit and does not need to know the underlying error correction scheme because the logical qubit behaves &lt;strong&gt;like&lt;/strong&gt; a physical one. This case is quite interesting for quantum computing because we could &quot;hide&quot; the complexity of quantum error correction algorithm behind logical qubits. The user will only see one qubit with low error rates, but the physical setup will be composed of multiple qubits.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;As of today, the term &quot;logical qubit&quot; is mostly used in quantum error correction but may be used in other fields in the future.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Side note&lt;/em&gt;: to answer your question in comment:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Is there any sort of generalization as to how physical &amp;amp; logical qubits correlate? (eg. n logical qubits requires $n^2$ physical qubits) Although they tend to be made of physical qubits, can they be made of other things? (eg. how could they be made photonicly or could they be purely virtual)&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There is no generalisation on the number of physical qubits needed to encode one logical qubit. This is entirely dependant on the error correction algorithm used.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A purely virtual qubit does not exists. Logical qubits are necessarily composed of physical qubits. Note that a &quot;qubit&quot; is already an abstraction: it abstract the physical representation used. As a logical qubit is defined in term of &quot;qubits&quot;, logical qubits are independant of the physical implementation of the underlying qubits.&lt;/p&gt;&#xA;" OwnerUserId="1386" LastActivityDate="2018-07-02T21:10:25.507" CommentCount="2" />
  <row Id="2585" PostTypeId="2" ParentId="2578" CreationDate="2018-07-02T22:10:54.177" Score="2" Body="&lt;p&gt;This is not exactly like Mohs' hardness scale, but it's a series of 5 different definitions of quantum comptuers by Michele Mosca:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;Definition 1:&lt;/strong&gt; Since the world is quantum, any computer is a quantum computer. Conventional computers are just weak quantum&#xA;  computers, since they don’t exploit intrinsically quantum effects,&#xA;  such as superposition and entanglement.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;strong&gt;Definition 2:&lt;/strong&gt; A quantum computer is a computer that uses intrinsically quantum effects that cannot naturally be modeled by&#xA;  classical physics. Classical computers may be able to mathematically&#xA;  simulate instances of such computers, but they are not implementing&#xA;  the same kinds of quantum operations.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;strong&gt;Definition 2’:&lt;/strong&gt; Definition 2, where there are strong tests or proofs of the quantum effects at play (e.g. by doing Bell tests).&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;strong&gt;Definition 3:&lt;/strong&gt; A quantum computer is a computer that uses intrinsically quantum effects to gain some advantage over the best&#xA;  known classical algorithms for some problem.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;strong&gt;Definition 4:&lt;/strong&gt; A quantum computer is a computer that uses intrinsically quantum effects to gain an asymptotic speed-up over the&#xA;  best known classical algorithms for some problem. (The difference with&#xA;  definition 3 is that the advantage is a fundamental algorithmic one&#xA;  that grows for larger instances of the problem; versus advantages more&#xA;  closely tied to hardware or restricted to instances of some bounded&#xA;  size.)&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;strong&gt;Definition 5:&lt;/strong&gt; A quantum computer is a computer that is able to capture the full computational power of quantum mechanics, just as&#xA;  conventional computers are believed to capture the full computational&#xA;  power of classical physics. This means, e.g. that it could implement&#xA;  any quantum algorithm specified in any of the standard quantum&#xA;  computation models. It also means that the device is in principle&#xA;  scalable to large sizes so that larger instances of computational&#xA;  problems may be tackled.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Source: &lt;a href=&quot;https://qz.com/194738/why-nobody-can-tell-whether-the-worlds-biggest-quantum-computer-is-a-quantum-computer/#footnote&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://qz.com/194738/why-nobody-can-tell-whether-the-worlds-biggest-quantum-computer-is-a-quantum-computer/#footnote&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-07-02T22:10:54.177" CommentCount="0" />
  <row Id="2586" PostTypeId="1" CreationDate="2018-07-03T00:41:59.707" Score="6" ViewCount="80" Body="&lt;p&gt;The traditional definition of a nonlocal game is restricted to having two players and one round (e.g., &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0404076&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;), but it is natural to consider a more general class of games that may have more than two players and more than one round of questions. While there has been a lot of work dealing with games with more than two players, I have found very little on multi-round games. For instance, there is &lt;a href=&quot;https://arxiv.org/abs/1801.04598&quot; rel=&quot;noreferrer&quot;&gt;a recent preprent of Crépeau and Yang&lt;/a&gt; that gives a definition of a multi-party, multi-round non-signaling distribution and seems to describe a multi-round game (although the paper is written in the language of commitment schemes rather than games, so I'm not entirely sure my interpretation is correct).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Has there been any other work dealing with multi-round games? And is there a reason so much of the literature has focused on single-round games? Are multi-round games inherently &quot;no more interesting&quot; than single-round games from the perspective of understanding nonlocality?&lt;/p&gt;&#xA;" OwnerUserId="2547" LastActivityDate="2018-07-03T19:42:14.950" Title="Has anyone analyzed multi-round nonlocal games?" Tags="&lt;quantum-information&gt;&lt;non-locality&gt;&lt;nonlocal-games&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="1" />
  <row Id="2587" PostTypeId="1" CreationDate="2018-07-03T01:54:26.753" Score="5" ViewCount="114" Body="&lt;p&gt;One of the novel features of Bitcoin and other cryptocurrencies is that coins can be irrefutably &quot;burned&quot; or destroyed, by creating a transaction to send the money to a junk burn address.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thinking similarly about quantum money - from knots, or hidden subspaces, Wiesner's currency, BBBW, etc. - has an &quot;obvious&quot; way to be destroyed.  For example, given a legitimate Wiesner coin, by measuring in the &quot;wrong&quot; basis, the currency would be destroyed.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But it's not clear how to irrefutably prove that the coin was destroyed.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;For example, if I have a Wiesner coin, and I tell the world that I've burned it, is there a way that I can do it so that others will believe me?  Even if I'm the bank?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I think I first heard of this question in a fascinating and stimulating lecture by Or Sattath - &lt;a href=&quot;https://www.youtube.com/watch?v=Zd5tDyPXsIM&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://www.youtube.com/watch?v=Zd5tDyPXsIM&lt;/a&gt; - at around 59:20.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;As Meowwzz suggests, clearly measuring a coin in a burn basis will burn it.  That burn basis can even be orthogonal to the valid basis, maximally destroying the coin, I think.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Another option that comes to mind is for the bank to publish and broadcast, on a public classical channel, the &lt;strong&gt;correct&lt;/strong&gt; basis for a serial number $s$. Thus, the secret is released, enabling anyone to clone the coin at will, and effectively destroying the unclonability, and hence uniqueness and value, of the coin. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Such an option (on a classical channel) is viable for Wiesner's coin, and the Hidden Subspaces coin, but I don't think for the Quantum Knots coin - there's no secret to be released on the Knots coin.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, such an option can only be done by the bank or whoever knows the classical secret, whereas I think Meowzz's approach can be done by anyone, including the holder of the coin of interest.&lt;/p&gt;&#xA;" OwnerUserId="2927" LastEditorUserId="2927" LastEditDate="2018-07-25T23:15:44.530" LastActivityDate="2018-07-25T23:15:44.530" Title="Can quantum money be reliably &quot;burned?&quot;" Tags="&lt;quantum-algorithms&gt;&lt;cryptography&gt;&lt;cryptocurrency&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="2588" PostTypeId="1" AcceptedAnswerId="2608" CreationDate="2018-07-03T02:47:41.783" Score="2" ViewCount="55" Body="&lt;p&gt;Google returns &quot;About 1 results&quot; for &lt;a href=&quot;https://www.google.com/search?q=%22quantum%20computing%20with%20sound%22&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Computing with Sound&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The sole result links to &lt;a href=&quot;https://www.nextbigfuture.com/2012/08/physicists-have-designed-building.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;an article&lt;/a&gt; entitled &quot;Physicists have designed the building blocks of quantum computer that works using sound&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;From the abstract:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Sound can be just as quantum as light. But our toolbox for single quanta of sound, i.e. phonons, is currently insufficient. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Has anyone seen something like this before? &lt;em&gt;Sounds&lt;/em&gt; interesting to me &amp;amp; am curious to find out more about &quot;phononic quantum computing&quot; &amp;amp; what advantages / disadvantages it has to offer.&lt;/p&gt;&#xA;" OwnerUserId="2645" LastActivityDate="2018-07-04T15:42:44.080" Title="Phononic Quantum Computing" Tags="&lt;quantum-algorithms&gt;&lt;quantum-computer&gt;&lt;resource-request&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="2589" PostTypeId="1" AcceptedAnswerId="2602" CreationDate="2018-07-03T06:35:11.707" Score="3" ViewCount="148" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;Negative energies and probabilities should not be considered as nonsense. They are well-defined concepts mathematically, like a negative of money.&quot; -&lt;a href=&quot;https://en.wikipedia.org/wiki/Negative_probability&quot; rel=&quot;nofollow noreferrer&quot;&gt;Paul Dirac&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The abstract from &lt;a href=&quot;https://www.nature.com/articles/srep46764&quot; rel=&quot;nofollow noreferrer&quot;&gt;Photon-phonon-photon transfer in optomechanics&lt;/a&gt; states:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;the Wigner function of the recovered state can have negative values at the origin, which is a manifest of nonclassicality of the quantum state&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I recently learned about the Wigner function from &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2479/2645&quot;&gt;this answer&lt;/a&gt; to a question I had asked about quantum shadowgraphy in which &lt;a href=&quot;https://quantumcomputing.stackexchange.com/users/2558/ernesto-galv%C3%A3o&quot;&gt;Ernesto&lt;/a&gt; says:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;there are quantum states for which the Wigner function may be negative in some phase-space regions! This is an indication of non-classicality&#xA;  ... this negativity has been linked to contextuality&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;From &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1641/2645&quot;&gt;an answer&lt;/a&gt; by &lt;a href=&quot;https://quantumcomputing.stackexchange.com/users/278/rob&quot;&gt;Rob&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;experimental schemes to reconstruct the generalized Wigner representation of a given density operator (representing mixed or pure quantum states)&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The abstract from &lt;a href=&quot;https://arxiv.org/abs/0710.5549&quot; rel=&quot;nofollow noreferrer&quot;&gt;Negativity and contextuality are equivalent notions of nonclassicality&lt;/a&gt; states&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;We also demonstrate the impossibility of noncontextuality or nonnegativity in quantum theory&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;What is negative probability?&lt;/strong&gt; Non-classicality? (Non)contextuality? Quasiprobability? &lt;strike&gt;Arbitrary multispin quantum states?&lt;/strike&gt;&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-07-03T07:01:43.130" LastActivityDate="2018-07-05T00:21:39.467" Title="What does negative probability represent?" Tags="&lt;quantum-state&gt;&lt;photonics&gt;&lt;contextuality&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="2590" PostTypeId="2" ParentId="2587" CreationDate="2018-07-03T06:48:17.227" Score="2" Body="&lt;p&gt;If each coin is entangled w/ the &lt;a href=&quot;https://en.wikipedia.org/wiki/Blockchain&quot; rel=&quot;nofollow noreferrer&quot;&gt;ledger&lt;/a&gt;, burning a coin via measuring it in the 'burn' (or 'wrong') basis would create an update in the ledger which could then be verified by anyone who had access to the ledger. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;See this paper: &lt;a href=&quot;https://arxiv.org/abs/1804.05979&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Blockchain using entanglement in time&#xA;&lt;/a&gt; for more info on one approach.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I also posted a question about &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/2366/2645&quot;&gt;time entangled blockchains&lt;/a&gt; which includes a couple links:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1705.09258&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Secured Blockchain&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.researchgate.net/publication/299749136_Quantum_Bitcoin_An_Anonymous_and_Distributed_Currency_Secured_by_the_No-Cloning_Theorem_of_Quantum_Mechanics&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Bitcoin&lt;/a&gt;: An Anonymous and Distributed Currency Secured by the No-Cloning Theorem of Quantum Mechanics&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-07-03T07:17:20.323" LastActivityDate="2018-07-03T07:17:20.323" CommentCount="4" />
  <row Id="2591" PostTypeId="2" ParentId="2586" CreationDate="2018-07-03T13:07:15.840" Score="3" Body="&lt;p&gt;It seems that using more rounds &lt;strong&gt;will not be such helpful&lt;/strong&gt; for us to get something more powerful from complexity perspectives. There are a few comments about the number of rounds and the number of players for $\mathsf{MIP}^*$ in &lt;a href=&quot;http://users.cms.caltech.edu/~vidick/ucsd_mip.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Thomas Vidick's lecture note&lt;/a&gt; regarding quantum mutli-prover interactive proofs. Note that the non-local games are $\mathsf{MIP^*}$ protocols. &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;If we allow an extra prover and &lt;strong&gt;quantum messages&lt;/strong&gt; (i.e. a $\mathsf{QMIP^*}$ protocol), then non-local games with polynomially many rounds can be parallelized to one round, which it proved by &lt;a href=&quot;https://arxiv.org/pdf/0711.3715.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Kempe-Kobayashi-Matsumoto-Vidick&lt;/a&gt;. But as @John Watrous mentioned, we don't know how to do that for non-local games with classical messages, i.e. $\mathsf{MIP^*}$ protocol. &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;More details see section 6.3.2 in &lt;a href=&quot;https://arxiv.org/abs/1610.01664&quot; rel=&quot;nofollow noreferrer&quot;&gt;Watrous-Vidick's survey&lt;/a&gt; about quantum proofs, or the KKMV paper mentioned above. &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;But we did not know something similar for the number of provers, even the following could be true $\mathsf{MIP^*}(2,\mathrm{poly}) \subsetneq \mathsf{MIP^*}(3,\mathrm{poly}) \subsetneq \cdots$, where $\mathsf{MIP^*}(r,k)$ denote $r$-round $k$-prover non-local games. Namely, we may get something more powerful by adding new provers. &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="1777" LastEditorUserId="1777" LastEditDate="2018-07-03T19:42:14.950" LastActivityDate="2018-07-03T19:42:14.950" CommentCount="3" />
  <row Id="2592" PostTypeId="5" CreationDate="2018-07-03T18:31:34.737" Score="0" Body="&lt;p&gt;More information can be found in the following links:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;The Wikipedia page &quot;Quantum phase estimation algorithm&quot;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/9708016&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Algorithms Revisited (Cleve, Ekert, Macchiavello &amp;amp; Mosca, 1997)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;QPE&lt;/strong&gt; or &lt;strong&gt;QPEA&lt;/strong&gt; are commonly used as abbreviations of the &lt;strong&gt;Q&lt;/strong&gt;uantum &lt;strong&gt;P&lt;/strong&gt;hase &lt;strong&gt;E&lt;/strong&gt;stimation (&lt;strong&gt;A&lt;/strong&gt;lgorithm).&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="1386" LastEditDate="2018-07-09T13:32:48.927" LastActivityDate="2018-07-09T13:32:48.927" CommentCount="0" />
  <row Id="2593" PostTypeId="4" CreationDate="2018-07-03T18:31:34.737" Score="0" Body="Refers to the quantum algorithm used to estimate the eigenvalue corresponding to an eigenvector of a unitary operator." OwnerUserId="26" LastEditorUserId="1386" LastEditDate="2018-07-09T13:32:54.043" LastActivityDate="2018-07-09T13:32:54.043" CommentCount="0" />
  <row Id="2594" PostTypeId="1" AcceptedAnswerId="2596" CreationDate="2018-07-03T21:50:54.957" Score="4" ViewCount="134" Body="&lt;p&gt;See title. Mostly I'm confused over whether the common convention is to use +$i$ or -$i$ along the anti-diagonal of the middle $2\times 2$ block.&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-07-03T22:29:53.843" LastActivityDate="2018-07-04T10:45:08.777" Title="What is the matrix of the iSwap gate?" Tags="&lt;quantum-gate&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="2595" PostTypeId="1" CreationDate="2018-07-03T22:06:36.817" Score="14" ViewCount="459" Body="&lt;p&gt;The intuition I have for why quantum computing can perform better than classical computing is that the wavelike nature of wavefunctions allow you to interfere multiple states of information with a single operation, which theoretically could allow for exponential speedup. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;But if it really is just constructive interference of complicated states, why not just perform this interference with classical waves?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And on that matter, if the figure-of-merit is simply how few steps something can be calculated in, why not start with a complicated dynamical system that has the desired computation embedded in it. (ie, why not just create &quot;analog simulators&quot; for specific problems?) &lt;/p&gt;&#xA;" OwnerUserId="2660" LastEditorUserId="26" LastEditDate="2018-07-05T09:06:38.540" LastActivityDate="2018-08-10T20:06:33.773" Title="If quantum speed-up is due to the wave-like nature of quantum mechanics, why not just use regular waves?" Tags="&lt;quantum-computer&gt;&lt;classical-computing&gt;" AnswerCount="6" CommentCount="4" FavoriteCount="2" />
  <row Id="2596" PostTypeId="2" ParentId="2594" CreationDate="2018-07-03T22:09:00.307" Score="2" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Mostly I'm confused over whether the common convention is to use +i or&#xA;  -i along the anti-diagonal of the middle 2x2 block.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The former. There are two $+i$'s along the anti-diagonal of the middle $2\times 2$ block of the iSWAP gate. See page 95 &lt;a href=&quot;https://link.springer.com/chapter/10.1007%2F978-1-84628-887-6_2&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;&lt;sup&gt;[$\dagger$]&lt;/sup&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/v2vAP.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/v2vAP.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[$\dagger$]: &lt;em&gt;Explorations in Computer Science (Quantum Gates)&lt;/em&gt; - Colin P. Williams&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-03T22:17:09.180" LastActivityDate="2018-07-03T22:17:09.180" CommentCount="0" />
  <row Id="2597" PostTypeId="1" CreationDate="2018-07-04T01:31:20.010" Score="8" ViewCount="75" Body="&lt;p&gt;I’m trying to grok quantum walks, and would like to create an example that walks a perfect binary tree to find the one and only marked leaf node. Is this possible? If so, suppose the depth of the tree is five. Would that require a circuit with five wires? Would it best be realized with a Discrete Time Quantum Walk, flipping a Hadamard Coin five times? Regardless of whether these questions are on the right track, and although I’ve read a lot of papers on the subject, I’m currently at a loss for how to implement what I’ve described. Any concrete pointers?&lt;/p&gt;&#xA;" OwnerUserId="2421" LastEditorUserId="55" LastEditDate="2018-07-04T22:30:30.960" LastActivityDate="2018-07-04T22:30:30.960" Title="Quantum walk with binary tree" Tags="&lt;quantum-algorithms&gt;&lt;quantum-walks&gt;" AnswerCount="0" CommentCount="0" FavoriteCount="1" />
  <row Id="2598" PostTypeId="2" ParentId="2595" CreationDate="2018-07-04T01:37:49.293" Score="0" Body="&lt;p&gt;&quot;why not just perform this interference with classical waves?&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Yes this is one way we can simulate quantum computers on regular digital computers. We simulate the &quot;waves&quot; using floating point arithmetic. The problem is that it does not scale. Every qubit &lt;em&gt;doubles&lt;/em&gt; the number of dimensions. For 30 qubits you already need about 8 gigabytes of ram just to store the &quot;wave&quot; aka state vector. At around 40 qubits we run out of computers big enough to do this.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A similar question was asked here: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2225/whats-the-difference-between-a-set-of-qubits-and-a-capacitor-with-a-subdivided&quot;&gt;What&amp;#39;s the difference between a set of qubits and a capacitor with a subdivided plate?&lt;/a&gt; &lt;/p&gt;&#xA;" OwnerUserId="263" LastEditorUserId="26" LastEditDate="2018-07-13T15:09:51.297" LastActivityDate="2018-07-13T15:09:51.297" CommentCount="2" />
  <row Id="2599" PostTypeId="2" ParentId="2589" CreationDate="2018-07-04T04:08:16.247" Score="2" Body="&lt;p&gt;My personal view is:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Probabilities are numbers between zero and one so they are like the normalized magnitude of a wave. On the other hand, negative probability amplitudes, and more generally, complex probability amplitudes, tell us the magnitude and phase of a wave. One could say that classical physics gives a flat picture of reality, representing magnitude by different shades of gray from 0=black to 1=white, whereas quantum physics gives a holographic picture of reality, meaning one that carries both magnitude and phase information.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Pseudo probabilities are an attempt to represent a hologram by a flat picture. It fails in certain regions.&lt;/p&gt;&#xA;" OwnerUserId="1974" LastEditorUserId="1974" LastEditDate="2018-07-05T00:21:39.467" LastActivityDate="2018-07-05T00:21:39.467" CommentCount="2" />
  <row Id="2601" PostTypeId="2" ParentId="2595" CreationDate="2018-07-04T05:29:38.170" Score="-1" Body="&lt;p&gt;Regular waves can interfere, but cannot be entangled. &lt;br&gt;&#xA;An example of an entangled pair of qubits, that cannot happen with classical waves, is given in the first sentence of my answer to this question: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2225/whats-the-difference-between-a-set-of-qubits-and-a-capacitor-with-a-subdivided/2226#2226&quot;&gt;What&amp;#39;s the difference between a set of qubits and a capacitor with a subdivided plate?&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Entanglement is considered to be the crucial thing that gives quantum computers advantage over classical ones, since superposition alone can be simulated by a probabilistic classical computer (i.e. a classical computer plus a coin flipper).  &lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-07-13T15:10:26.933" LastActivityDate="2018-07-13T15:10:26.933" CommentCount="8" />
  <row Id="2602" PostTypeId="2" ParentId="2589" CreationDate="2018-07-04T07:00:01.027" Score="4" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;What is non-classicality?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I'm not sure if there's a universally accepted definition, but the way that I'd define it is: if all possible outcomes of experiments on a particular quantum system can be described by a probability distribution, then the system is classical. Otherwise, it is non-classical. In alternative terminology, for a classical system, people say that there's a (local) hidden variable model that explains the experimental outcomes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A trivial example is a diagonal density matrix when measured in the computational basis. The diagonal elements just give the probabilities of the different outcomes, so the state is classical.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;What is negative probability?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;This is rather loose terminology. For a true probability distribution (in the discrete setting, a set $\{p_i\}$ such that $p_i\geq 0$ and $\sum_ip_i=1$) never contains negative probabilities by definition.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You only get &quot;negative probability&quot; in some quasi-probability distributions, and so it should probably be called &quot;negative quasi-probability&quot; to avoid misunderstandings. As stated in the question, this is one way of detecting non-classicality. That leads us to...&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;What is quasi-probability?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;(which may be what you're meaning by pseudoprobability). These are distributions that behave a lot like probabilities in many ways, but relax at least one of the constraints in the definition, usually the non-negativity of the elements. According to &lt;a href=&quot;https://en.wikipedia.org/wiki/Quasiprobability_distribution&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wikipedia&lt;/a&gt;, any density matrix can be written as a diagonal matrix using an over-complete basis. Those diagonal elements then form a quasi-probability distribution - some of the elements can be negative.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;What is (non)-contextuality?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Contextuality is another test that can be used to prove the non-classicality of a quantum system. This is a substantial topic that I'm not inclined to address in answer to small part of a question. You probably want to start finding out about the &lt;a href=&quot;https://en.wikipedia.org/wiki/Kochen%E2%80%93Specker_theorem&quot; rel=&quot;nofollow noreferrer&quot;&gt;Kochen-Specker Theorem&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is worth noting that Bell tests, such as the &lt;a href=&quot;https://en.wikipedia.org/wiki/CHSH_inequality&quot; rel=&quot;nofollow noreferrer&quot;&gt;CHSH test&lt;/a&gt;, can be considered as contextuality tests, they're just made a little simpler because they're supplemented with some extra information about non-locality between certain measurement operators, ensuring their commutation. So, with CHSH, you evaluate some expectation value $S$. If $|S|\leq 2$, the state is classical, while if $|S|&amp;gt;2$, it cannot be explained by a local hidden variable model; the state is non-classical.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-07-04T07:00:01.027" CommentCount="0" />
  <row Id="2603" PostTypeId="1" CreationDate="2018-07-04T07:08:15.630" Score="7" ViewCount="165" Body="&lt;p&gt;Most of us on this site believe that quantum computing will work. However, let's play devil's advocate. Imagine that we suddenly hit some fundamental stumbling block that prevented further development towards a universal quantum computer. Perhaps we're limited to a NISQ device (Noisy, Intermediate Scale Quantum) of 50-200 qubits, for the sake of argument. The study of (experimental) quantum computing suddenly stops and no further progress is made.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;What good has already come out of the study of quantum computers?&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;By this, I mean realisable quantum technologies, the most obvious candidate being Quantum Key Distribution, but also technical results that feed into other fields. Rather than simply a list of items, a brief description of each would be appreciated.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-07-15T16:26:38.963" Title="What use has quantum computing been?" Tags="&lt;quantum-computer&gt;&lt;applications&gt;&lt;quantum-technologies&gt;" AnswerCount="2" CommentCount="1" FavoriteCount="1" />
  <row Id="2604" PostTypeId="1" AcceptedAnswerId="2605" CreationDate="2018-07-04T09:01:53.217" Score="9" ViewCount="132" Body="&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm&quot; rel=&quot;noreferrer&quot;&gt;quantum phase estimation algorithm&lt;/a&gt; (QPE) computes an approximation of the eigenvalue associated to a given eigenvector of a quantum gate $U$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Formally, let $\left|\psi\right&amp;gt;$ be an eigenvector of $U$, QPE allows us to find $\vert\tilde\theta\rangle$, the best $m$ bit approximation of $\lfloor2^m\theta\rfloor$ such that $\theta \in [0,1)$ and &#xA;$$U\vert\psi\rangle = e^{2\pi i \theta} \vert\psi\rangle.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_algorithm_for_linear_systems_of_equations&quot; rel=&quot;noreferrer&quot;&gt;HHL algorithm&lt;/a&gt; (&lt;a href=&quot;https://arxiv.org/abs/0811.3171&quot; rel=&quot;noreferrer&quot;&gt;original paper&lt;/a&gt;) takes as input a matrix $A$ that satisfy $$e^{iAt} \text{ is unitary } $$ and a quantum state $\vert b \rangle$ and computes $\vert x \rangle$ that encodes the solution of the linear system $Ax = b$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Remark&lt;/strong&gt;: Every hermitian matrix statisfy the condition on $A$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To do so, HHL algorithm uses the QPE on the quantum gate represented by $U = e^{iAt}$. Thanks to linear algebra results, we know that if $\left\{\lambda_j\right\}_j$ are the eigenvalues of $A$ then $\left\{e^{i\lambda_j t}\right\}_j$ are the eigenvalues of $U$. This result is also stated in &lt;a href=&quot;https://arxiv.org/abs/1802.08227&quot; rel=&quot;noreferrer&quot;&gt;Quantum linear systems algorithms: a primer (Dervovic, Herbster, Mountney, Severini, Usher &amp;amp; Wossnig, 2018)&lt;/a&gt; (page 29, between equations 68 and 69).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;With the help of QPE, the first step of HLL algorithm will try to estimate $\theta \in [0,1)$ such that $e^{i2\pi \theta} = e^{i\lambda_j t}$. This lead us to the equation&#xA;$$2\pi \theta = \lambda_j t + 2k\pi, \qquad k\in \mathbb{Z}, \ \theta \in [0,1)$$&#xA;i.e.&#xA;$$\theta = \frac{\lambda_j t}{2\pi} + k, \qquad k\in \mathbb{Z}, \ \theta \in [0,1)$$&#xA;By analysing a little the implications of the conditions $k\in \mathbb{Z}$ and $\theta \in [0,1)$, I ended up with the conclusion that if $\frac{\lambda_j t}{2\pi} \notin [0,1)$ (i.e. $k \neq 0$), the phase estimation algorithm fails to predict the right eigenvalue.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But as $A$ can be any hermitian matrix, we can choose freely its eigenvalues and particularly we could choose arbitrarily large eigenvalues for $A$ such that the QPE will fail ($\frac{\lambda_j t}{2\pi} \notin [0,1)$).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In &lt;a href=&quot;https://arxiv.org/abs/1110.2232v2&quot; rel=&quot;noreferrer&quot;&gt;Quantum Circuit Design for Solving Linear Systems of Equations (Cao, Daskin, Frankel &amp;amp; Kais, 2012)&lt;/a&gt; they solve this problem by simulating $e^{\frac{iAt}{16}}$, knowing that the eigenvalues of $A$ are $\left\{ 1, 2, 4, 8 \right\}$. They &lt;strong&gt;normalised&lt;/strong&gt; the matrix (and its eigenvalues) to avoid the case where $\frac{\lambda_j t}{2\pi} \notin [0,1)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;On the other side, it seems like parameter $t$ could be used to do this normalisation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; Do we &lt;strong&gt;need&lt;/strong&gt; to know a upper-bound of the eigenvalues of $A$ to normalise the matrix and be sure that the QPE part of the HHL algorithm will succeed? If not, how can we ensure that the QPE will succeed (i.e. $\frac{\lambda_j t}{2\pi} \in [0,1)$)?&lt;/p&gt;&#xA;" OwnerUserId="1386" LastEditorUserId="26" LastEditDate="2018-08-24T18:22:02.337" LastActivityDate="2018-08-24T18:24:45.557" Title="Quantum phase estimation and HHL algorithm - knowledge of eigenvalues required?" Tags="&lt;quantum-algorithms&gt;&lt;hhl-algorithm&gt;&lt;phase-estimation&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2605" PostTypeId="2" ParentId="2604" CreationDate="2018-07-04T09:36:13.563" Score="3" Body="&lt;p&gt;You should know a bound on the eigenvalues (both upper and lower). As you say, you can then normalise $A$ by rescaling $t$. Indeed, you should do this to get the most accurate estimate possible, spreading the values $\lambda t$ over the full $2\pi$ range. Bounding the eigenvalues is not typically a problem. For example, you're probably requiring your matrix $A$ to be sparse, so that there aren't too many non-zero matrix elements on each row. Indeed, the problem specification probably gives you a bound on the number $N$ of non-zero entries per row, and the maximum value of any entry $Q$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then you could apply something like Gershgorin's circle theorem. This states that the maximum eigenvalue is upper bounded by&#xA;$$&#xA;\max_i a_{ii}+\sum_{j\neq i}|a_{ij}|\leq NQ,&#xA;$$&#xA;and the minimum is lower bounded by&#xA;$$&#xA;\min_ia_{ii}-\sum_{j\neq i}|a_{ij}|\geq -NQ.&#xA;$$&#xA;The $a_{ij}$ are the matrix elements of $A$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Within the values of $N$, $Q$, if you're worrying that for a large matrix (say $n$ qubits), while the row sum might be easy to calculate (because there's not many entries), the max over all rows might take a long time (because there's $2^n$ rows), there will be a variety of ways to get good approximations to it (e.g. sampling, or using knowledge of the problem structure). Worst case, you can probably use &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/2004/1837&quot;&gt;Grover's search&lt;/a&gt; to speed it up a bit.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="26" LastEditDate="2018-08-24T18:24:45.557" LastActivityDate="2018-08-24T18:24:45.557" CommentCount="2" />
  <row Id="2606" PostTypeId="2" ParentId="2594" CreationDate="2018-07-04T10:45:08.777" Score="2" Body="&lt;p&gt;Whether you use $+i$ or $-i$ is entirely up to you.  After all, your definition of $\pm i$ is merely a convention.  On the other hand, I think I've only ever seen it with $+i$.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;On a more general footing, you can consider that iSWAP is the gate obtained by time-evolving with an XX interaction ($H=-\sigma_x\otimes\sigma_x - \sigma_y\otimes\sigma_y$), in which case it depends on which sign of $i$ in the Schrödinger equation and for the Hamiltonian you prefer.  (You get $+i$ if you evolve with $\exp[-iHt]$, $t=\pi/4$, and chose the minus sign in the Hamiltonian as above, i.e. a ferromagnet).&lt;/p&gt;&#xA;" OwnerUserId="491" LastActivityDate="2018-07-04T10:45:08.777" CommentCount="2" />
  <row Id="2607" PostTypeId="1" AcceptedAnswerId="2673" CreationDate="2018-07-04T14:02:39.323" Score="8" ViewCount="185" Body="&lt;p&gt;As a non-mathematician/software programmer I'm trying to grasp how QFT (Quantum Fourier Transformation) works.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Following this YouTube video: &lt;a href=&quot;https://www.youtube.com/watch?v=wUwZZaI5u0c&quot; rel=&quot;noreferrer&quot;&gt;https://www.youtube.com/watch?v=wUwZZaI5u0c&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And this blogpost: &lt;a href=&quot;https://www.scottaaronson.com/blog/?p=208&quot; rel=&quot;noreferrer&quot;&gt;https://www.scottaaronson.com/blog/?p=208&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I've got a basic understanding on how you can calculate/construct the period using interference. But while trying to explain this to a colleague I ran into a problem. I used the following examples, N=15, a=7, so the period I'll need to find is r=4.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The pattern is:&#xA;&lt;code&gt;7, 4, 13, 1, 7, 4, 13, 1, 7, 4, 13, 1 (etc)&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If I imagine the wheel (like in the YouTube video) or a clock (like the blogpost) I can see that the circle with 4 dots/clock with 4 hours creates a constructive pattern and the others do not.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But what happens with a circle with 2 dots, or a clock with 2 hours, those will have get the same magnitude/constructive pattern as 4? It loops twice as fast, but other than that, same result?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;How does the QFT cope with this?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(Bonus: Can you explain in laymans terms without too much complicated math?)&lt;/p&gt;&#xA;" OwnerUserId="2972" LastActivityDate="2018-07-08T23:54:10.947" Title="Simplified explanation of Shor/QFT transformation as thumbtack" Tags="&lt;shors-algorithm&gt;&lt;quantum-fourier-transform&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="4" />
  <row Id="2608" PostTypeId="2" ParentId="2588" CreationDate="2018-07-04T15:42:44.080" Score="1" Body="&lt;p&gt;Yes other papers have studied phononic qubits after that one. I could just list them here, but I think it would be better for you to learn how to find such papers yourself, so here is how I found the papers:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Find the paper on Google, then click the link I have highlighted in yellow:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/6IwmB.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/6IwmB.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Out of the 39 papers that cited this one, I have listed some (but not all) of the relevant ones below:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://aip.scitation.org/doi/abs/10.1063/1.4919584&quot; rel=&quot;nofollow noreferrer&quot;&gt;Splash, pop, sizzle: Information processing with phononic computing&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://journals.aps.org/prb/abstract/10.1103/PhysRevB.88.134511&quot; rel=&quot;nofollow noreferrer&quot;&gt;Toward engineered quantum many-body phonon systems&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://aip.scitation.org/doi/abs/10.1063/1.4972568&quot; rel=&quot;nofollow noreferrer&quot;&gt;Phonon-based scalable platform for chip-scale quantum computing&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;As for advantages and disadvantages, perhaps the only advantage would be robustness to decoherence, which is claimed in the paper you mentioned, but not yet backed up very much.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are lots of disadvantages though:&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Phonons are quasi-particles, not fundamental particles. This gives phonons a similar disadvantage as anyons. &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2054/what-is-the-status-of-confirming-the-existence-of-anyons&quot;&gt;We all know how hard it is to build a quantum computer with anyons&lt;/a&gt;. &lt;/li&gt;&#xA;&lt;li&gt;You almost never find one isolated phonon, you get a huge spectrum of phonons at the same time.&lt;/li&gt;&#xA;&lt;li&gt;The technology required for phononic qubits seems to have had its beginnings in 2012, whereas for NMR qubits it goes back to at least the 1940s and for superconducting qubits it goes back to at least the 1960s. Phononic qubits are far behind any other candidate for quantum computers, so there is lot of catching up to do.   &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-07-04T15:42:44.080" CommentCount="0" />
  <row Id="2609" PostTypeId="1" AcceptedAnswerId="2610" CreationDate="2018-07-04T17:35:08.130" Score="4" ViewCount="67" Body="&lt;p&gt;I want to express the square root of NOT as a time-dependent unitary matrix such that each $n$ units of time, the square root of NOT is produced.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;More precisely, I want to find a $U(t_0,t_1)$ such that $U(t_0,t_1) = \sqrt{\text{NOT}}$, if $t_1-t_0=n$ for some $n$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One possible solution is to express $\sqrt{\text{NOT}}$ as a product of rotation matrices, and then, parametrize the angles in a clever way to depend on the time. But I do not know how to express $\sqrt{\text{NOT}}$ as a product of rotation matrices.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Any help?&lt;/p&gt;&#xA;" OwnerUserId="2978" LastEditorUserId="26" LastEditDate="2018-07-05T07:56:57.523" LastActivityDate="2018-07-05T07:56:57.523" Title="Square root of not as a time-dependent unitary matrix" Tags="&lt;quantum-gate&gt;&lt;gate-synthesis&gt;" AnswerCount="1" CommentCount="1" FavoriteCount="1" />
  <row Id="2610" PostTypeId="2" ParentId="2609" CreationDate="2018-07-04T18:20:47.607" Score="3" Body="&lt;p&gt;$$&#xA;\sqrt{NOT} = e^{(\frac{i \pi}{4} I_2 - \frac{i \pi}{4} \sigma_x)}\\&#xA;U(t) = e^{\frac{t-t_0}{t_1 - t_0} (\frac{i \pi}{4} I_2 - \frac{i \pi}{4} \sigma_x)}&#xA;$$&lt;/p&gt;&#xA;" OwnerUserId="434" LastActivityDate="2018-07-04T18:20:47.607" CommentCount="5" />
  <row Id="2611" PostTypeId="5" CreationDate="2018-07-05T08:02:35.083" Score="0" Body="" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-05T08:02:35.083" LastActivityDate="2018-07-05T08:02:35.083" CommentCount="0" />
  <row Id="2612" PostTypeId="4" CreationDate="2018-07-05T08:02:35.083" Score="0" Body="For questions related to D-Wave's Pegasus architecture. It has been the first fundamental change in D-Wave's architecture since D-Wave One. In Pegasus, the actual structure of the unit cells has fundamentally changed for the first time. Instead of the Chimera graph where each qubit can have at most 6 qubits, the Pegasus graph allows each qubit to couple to 15 other qubits. (Source: https://quantumcomputing.stackexchange.com/a/2537/26)" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-05T08:02:35.083" LastActivityDate="2018-07-05T08:02:35.083" CommentCount="0" />
  <row Id="2613" PostTypeId="2" ParentId="2595" CreationDate="2018-07-05T08:31:36.503" Score="1" Body="&lt;p&gt;I don't claim to have a full answer (yet! I hope to update this, as it's an interesting issue to try and explain well). But let me start with a few clarifying comments...&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;But if it really is just constructive interference of complicated states, why not just perform this interference with classical waves?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The glib answer is that it's not &lt;em&gt;just&lt;/em&gt; interference. I think what it really comes down to is that quantum mechanics uses different axioms of probability (probability amplitudes) to classical physics, and these are not reproduced in the wave scenario.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When someone writes about &quot;waves&quot;, I naturally think about water waves, but that may not be the most helpful picture to have. Let's think instead about an ideal guitar string. On a string of length $L$ (pinned at both ends), this has wavefunctions&#xA;$$&#xA;y_n(x,t)=A_n\sin\left(\omega_nt\right)\cos\left(\frac{n\pi x}{L}\right).&#xA;$$&#xA;Let's define the concept of a w-bit (&quot;wave bit&quot;). We can limit ourselves to, say, 4 modes, on the string, so you can associate&#xA;$$&#xA;|00\rangle\equiv y_1 \qquad |01\rangle\equiv y_2\qquad |10\rangle\equiv y_3 \qquad |11\rangle\equiv y_4&#xA;$$&#xA;Now since we can prepare the initial shape of the string to be anything we want (subject to the boundary conditions), we can create any arbitrary superposition of those 4 states. So, the theory certainly includes things that look like superposition and entanglement.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, they are not superposition and entanglement as we understand them in quantum theory. A key feature of quantum theory is that it contains &lt;em&gt;indeterminism&lt;/em&gt; - that the results of some outcomes are inherently unpredictable. We don't start or end our computation from these points, but we must go through them somewhere during the computation$^*$. For example, experimental tests of &lt;a href=&quot;https://en.wikipedia.org/wiki/Bell%27s_theorem&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bell's Theorem&lt;/a&gt; have proven that the world is not deterministic (and, so far, conforms to what quantum theory predicts). The wave-bit theory is entirely deterministic: I can look at the string of my guitar, whatever weird shape it might be in, and my looking at it does not change its shape. Moreover, I can even determine the values of the $\{A_n\}$ in a single shot, and therefore know what shape it will be in at all later times. This is very different to quantum theory, where there are different bases that can give me different information, but I can never access all of it (indeterminism).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$^*$ I don't have a complete proof of this. We know that &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2674/is-entanglement-necessary-for-quantum-computation&quot;&gt;entanglement is necessary for quantum computation&lt;/a&gt;, and that entanglement can demonstrate indeterminism, but that's not quite enough for a precise statement. Contextuality is a similar measure of indeterminism but for single qubits, and results along those lines have started to become available recently, see &lt;a href=&quot;https://arxiv.org/abs/1610.08529&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;, for broad classes of computations.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Another way to think about this might be to ask what computational operations we can perform with these waves? Presumably, even if you allow some non-linear interactions, the operations can be simulated by a classical computer (after all, classical gates include non-linearity). I assume that the $\{A_n\}$ function like classical probabilities, not probability amplitudes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This might be one way of seeing the difference (or at least heading in the right direction). There's a way of performing quantum computation classed measurement-based quantum computation. You prepare your system in some particular state (which, we've already agreed, we could do with our w-bits), and then you measure the different qubits. Your choice of measurement basis determines the computation. But we can't do that here because we don't have that choice of basis.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;And on that matter, if the figure-of-merit is simply how few steps something can be calculated in, why not start with a complicated dynamical system that has the desired computation embedded in it. (ie, why not just create &quot;analog simulators&quot; for specific problems?) &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;This is not the figure of merit. The figure of merit is really &quot;How long does it take to perform the computation&quot; and &quot;how does that time scale as the problem size changes?&quot;. If we choose to break everything down in terms of elementary gates, then the first question is essentially how many gates are there, and the second is how does the number of gates scale. But we don't have to break it down like that. There are plenty of &quot;analog quantum simulators&quot;. Feynman's original specification of a quantum computer was one such analogue simulator. It's just that the time feature manifests in a different way. There, you're talking about implementing a Hamiltonian evolution $H$ for a particular time $t_0$, $e^{iHt_0}$. Now, sure, you could implement $2H$, and replace $t_0$ with $t_0/2$, but practically, the coupling strengths in $H$ are limited, so there's a finite time that things take, and we can still demand how that scales with the problem size. Similarly, there's adiabatic quantum computation. There, the time required is determined by the energy gap between the ground and the first excited state. The smaller the gap, the longer your computation takes. We know that all 3 models are equivalent in the time they take (up to polynomial conversion factors, which are essentially irrelevant if you're talking about an exponential speed-up).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, analog quantum simulators are certainly a thing, and there are those of us who think they're a very sensible thing at least in the short-term. My research, for example, is very much about &quot;how do we design Hamiltonians $H$ so that their time evolution $e^{-iHt_0}$ creates the operations that we want?&quot;, aiming to do everything we can in a language that is &quot;natural&quot; for a given quantum system, rather than having to coerce it into performing a whole weird sequence of quantum gates.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-07-09T07:02:50.773" LastActivityDate="2018-07-09T07:02:50.773" CommentCount="9" />
  <row Id="2614" PostTypeId="5" CreationDate="2018-07-05T08:32:05.767" Score="0" Body="" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-05T08:32:05.767" LastActivityDate="2018-07-05T08:32:05.767" CommentCount="0" />
  <row Id="2615" PostTypeId="4" CreationDate="2018-07-05T08:32:05.767" Score="0" Body="For questions about the D-Wave Chimera architecture. The increase in qubit count for the D-Wave Two was accomplished by tiling qubit pattern of the D-Wave One. This pattern, named Chimera by D-Wave Systems, has a limited connectivity such that a given qubit can only interact with at most six other qubits. As with the D-Wave One, this restricted connectivity greatly limits the optimization problems that can be approached with the hardware. (from Wikipedia)" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-05T08:32:05.767" LastActivityDate="2018-07-05T08:32:05.767" CommentCount="0" />
  <row Id="2616" PostTypeId="5" CreationDate="2018-07-05T08:33:27.080" Score="0" Body="" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-05T08:33:27.080" LastActivityDate="2018-07-05T08:33:27.080" CommentCount="0" />
  <row Id="2617" PostTypeId="4" CreationDate="2018-07-05T08:33:27.080" Score="0" Body="For questions related to the Bloch sphere. In quantum mechanics, the Bloch sphere is a geometrical representation of the pure state space of a two-level quantum mechanical system (qubit), named after the physicist Felix Bloch. (from Wikipedia)" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-05T08:33:27.080" LastActivityDate="2018-07-05T08:33:27.080" CommentCount="0" />
  <row Id="2618" PostTypeId="5" CreationDate="2018-07-05T08:55:00.323" Score="0" Body="" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-05T08:55:00.323" LastActivityDate="2018-07-05T08:55:00.323" CommentCount="0" />
  <row Id="2619" PostTypeId="4" CreationDate="2018-07-05T08:55:00.323" Score="0" Body="For questions related to quantum multiplexer/demultiplexer circuits. In quantum communication, all of the system channels can be accommodated into a single channel in a larger Hilbert space. In the scheme, a single line combines the information of all the users, and, at the receiver, the original quantum channels are recovered. A multiplexer/demultiplexer circuit can perform this n qubits to qudit transformation. [https://arxiv.org/abs/quant-ph/0701145]" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-05T08:55:00.323" LastActivityDate="2018-07-05T08:55:00.323" CommentCount="0" />
  <row Id="2620" PostTypeId="5" CreationDate="2018-07-05T08:56:36.803" Score="0" Body="" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-05T08:56:36.803" LastActivityDate="2018-07-05T08:56:36.803" CommentCount="0" />
  <row Id="2621" PostTypeId="4" CreationDate="2018-07-05T08:56:36.803" Score="0" Body="For questions related to Controlled quantum gates. Controlled gates act on 2 or more qubits, where one or more qubits act as a control for some operation. (from Wikipedia)" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-05T08:56:36.803" LastActivityDate="2018-07-05T08:56:36.803" CommentCount="0" />
  <row Id="2622" PostTypeId="1" CreationDate="2018-07-05T09:26:05.297" Score="5" ViewCount="54" Body="&lt;p&gt;&lt;sup&gt; This question is a continuation of &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2604/quantum-phase-estimation-and-hhl-algorithm-knowledge-on-eigenvalues-required&quot;&gt;Quantum phase estimation and HHL algorithm - knowledge on eigenvalues required?&lt;/a&gt;. &lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;In the question linked above, I asked about the necessity for HHL to have information on the eigenspectrum of the matrix $A$ considered.&#xA;It came out that the HHL algorithm &lt;strong&gt;needs&lt;/strong&gt; a matrix with eigenvalues $\lambda_j \in [0,1)$ to work correctly. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Following this condition, given a matrix $A$, in order to apply the HHL algorithm we need to check one of the condition below:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;The eigenvalues of the matrix are all within $[0,1)$.&lt;/li&gt;&#xA;&lt;li&gt;A pair $(L,M) \in \mathbb{R}^2$ that bound (from below for $L$ and from above for $M$) the eigenvalues $\lambda_j$ of the matrix $A$. These bounds can be then used to rescale the matrix $A$ such that condition 1. is validated.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;First group of questions:&lt;/strong&gt; I read plenty of papers on HHL and none of them even mentioned this restriction. Why? Is this restriction known but considered weak (i.e. it's easy to have this kind of information)? Or the restriction was not known? Is there any research paper that mention this restriction?&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Let's talk now about the complexity analysis of HHL. From &lt;a href=&quot;https://arxiv.org/abs/1802.08227&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum linear systems algorithms: a primer (Dervovic, Herbster, Mountney, Severini, Usher &amp;amp; Wossnig, 2018)&lt;/a&gt;, the complexity of HHL (and several improvements) is written in the image below.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/QhuVC.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/QhuVC.png&quot; alt=&quot;complexity of HHL&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The complexity analysis does not take into account (at least I did not find it) the necessary knowledge on the eigenspectrum.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The case where the considered matrix has sufficiently good properties to estimate its eigenvalues analytically is uncommon (at least for real-world matrices) and is ignored.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2605/1386&quot;&gt;this answer&lt;/a&gt;, @DaftWullie uses the &lt;a href=&quot;https://en.wikipedia.org/wiki/Gershgorin_circle_theorem&quot; rel=&quot;nofollow noreferrer&quot;&gt;Gershgorin's circle theorem&lt;/a&gt; to estimate the upper and lower bounds of the eigenspectrum. The problem with this approach is that it takes $\mathcal{O}(N)$ operations ($\mathcal{O}(\sqrt{N})$ if amplitude amplification is applicable). This number of operation destroys the logarithmic complexity of HHL (and it's only advantage over classical algorithms in the same time).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Second group of questions:&lt;/strong&gt; Is there a better algorithm in term of complexity? If not, then why is the HHL algorithm still presented as an exponential improvement over classical algorithms?&lt;/p&gt;&#xA;" OwnerUserId="1386" LastEditorUserId="1386" LastEditDate="2018-07-05T09:46:49.727" LastActivityDate="2018-07-05T09:46:49.727" Title="HHL algorithm -- why isn't the required knowledge on eigenspectrum a major drawback?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-speedup&gt;&lt;hhl-algorithm&gt;" AnswerCount="0" CommentCount="2" />
  <row Id="2623" PostTypeId="2" ParentId="1500" CreationDate="2018-07-05T09:33:21.663" Score="4" Body="&lt;p&gt;The device works at cryogenic temperatures, which is so cold that all the gasses would freeze on the experiment device. And before they do so they would conduct heat from the walls of the chamber to the experiment device thus making it hard to cool down. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thus you need vacuum for being able to cool things down to a very low temperature and once the device is cold the presence of cold elements even improves the vacuum as the little rest gas you were unable to pump out before will freeze - effect known as cryopumping.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;See also&#xA;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/105/1989&quot;&gt;Why must quantum computers be kept near absolute zero?&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="1989" LastEditorUserId="1989" LastEditDate="2018-07-16T09:05:20.603" LastActivityDate="2018-07-16T09:05:20.603" CommentCount="0" />
  <row Id="2624" PostTypeId="2" ParentId="117" CreationDate="2018-07-05T09:39:41.033" Score="1" Body="&lt;p&gt;DanielSank is correct, but I think the answer is actually even more subtle. If there was no loss there would also be no way the background radiation leaking into your quantum device. Even if it was initially thermally excited one could actively reset the state of qubits. Thus in addition to thermal excitations of microwave qubits the fundamental reason for them being cooled down to so low temperature is really the loss of the materials the quantum state lives in. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Air imposes almost no loss to optical photons, but the electric circuits do attanuate the microwave frequency plasmons carrying the quantum information. So far the only way to get rid of these losses is to use supperconductors and to go to cryogenic temperatuers, but &lt;strong&gt;there is no fundamental reasons for not using lowloss materials at higher temperatures in future&lt;/strong&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1989" LastActivityDate="2018-07-05T09:39:41.033" CommentCount="0" />
  <row Id="2625" PostTypeId="1" AcceptedAnswerId="2626" CreationDate="2018-07-05T10:27:56.043" Score="6" ViewCount="135" Body="&lt;p&gt;I read the Solovay-Kitaev algorithm for approximation of arbitrary single-qubit unitaries.  However, while implementing the algorithm, I got stuck with the basic approximation of depth 0 of the recursion.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Can someone help me on how to implement the basic approximation such that, given any $2 {\times} 2$ matrix in $\operatorname{SU}\left(2\right)$, it will return the sequence of gates from the set $\left\{H,T,S\right\}$ which approximate to about 0.00001 trace-norm distance of the arbitrary matrix?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Also, if I am using brute-force or kd trees, up to what gate length $l_0$ should I consider to obtain initial approximation of $0.00001$ for any arbitrary matrix in $\operatorname{SU}\left(2\right)$?&lt;/p&gt;&#xA;" OwnerUserId="2771" LastEditorUserId="26" LastEditDate="2018-07-07T16:38:48.530" LastActivityDate="2018-07-09T09:19:45.597" Title="Basic approximation in Solovay-Kitaev algorithm" Tags="&lt;quantum-algorithms&gt;&lt;gate-synthesis&gt;&lt;solovay-kitaev-algorithm&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2626" PostTypeId="2" ParentId="2625" CreationDate="2018-07-05T11:32:16.923" Score="3" Body="&lt;p&gt;I don't pretend that this is optimal in the sense of minimal number of applications, but here's one method that comes from the universality proof...&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;The unitary that you want to implement can be parametrised by $U=\cos\gamma\mathbb{I}-i\sin\gamma\ \underline{m}\cdot\underline{\sigma}$ where $\underline\sigma$ is the vector of Pauli matrices $X$, $Y$, $Z$. If you don't know the values you can get them from e.g. $\cos\gamma=\text{Tr}(U)/2$, $\sin\gamma\ m_X=\text{Tr}(XU)/2$ and so on.&lt;/li&gt;&#xA;&lt;li&gt;You can implement two unitaries $HTHT=\cos\theta\mathbb{I}-i\sin\theta \underline{n}_1\cdot\underline{\sigma}=R_1(\theta)$ and $THTH=\cos\theta\mathbb{I}-i\sin\theta \underline{n}_2\cdot\underline{\sigma}=R_2(\theta)$. Make sure you know what $\theta$, $\underline{n}_1$ and $\underline{n}_2$ are.&lt;/li&gt;&#xA;&lt;li&gt;Your first goal is to work out how to express $U$, your target unitary, in the form $e^{i\alpha}R_1(\phi_1)R_2(\phi_2)R_1(\phi_3)$. Again, evaluate things like $\text{Tr}(U),\ \text{Tr}(\underline{n_1}\cdot\underline{\sigma} U)$, but using the new decomposition, and you'll have a set of 3 simultaneous equations to solve for 3 parameters. For example (you'll need to check these!),&#xA;$$&#xA;e^{i\alpha}\cos\gamma=\cos\phi_2\cos(\phi_1+\phi_3)-\sin\phi_2\sin(\phi_1+\phi_3)\underline{n}_1\cdot\underline{n}_2\\&#xA;e^{i\alpha}\sin\gamma \underline{m}\cdot\underline{n}_1=\cos\phi_2\sin(\phi_1+\phi_3)-\sin\phi_2\cos(\phi_1+\phi_3)\underline{n}_1\cdot\underline{n}_2&#xA;$$&lt;/li&gt;&#xA;&lt;li&gt;Now, you want to create a good approximation to the angle $\phi_i$, but you can only repeat sequences such as $HTHT$ an integer number of times, $q_i$. Thus we can create angles $q_i\theta$, but angles are only important modulo $2\pi$. Thus, for each $\phi_i$, find the smallest positive integer $q_i$ such that $|q_i\theta \text{ mod }2\pi-\phi_i|&amp;lt;\epsilon$ for some small parameter $\epsilon$. This means that by repeating $HTHT$ $q_3$ times, then $THTH$ $q_2$ times, then $HTHT$ $q_1$ times, you create each of the 3 rotations about the correct axis, to an angle that is within $\epsilon$ accuracy for each.&lt;/li&gt;&#xA;&lt;li&gt;You final task is to work out how the accuracy $\epsilon$ on each angle corresponds to an overall accuracy on the unitary If you think about a perturbative expansion of each term, the error is probably about $3\epsilon$. So, now you can work backwards to find $\epsilon$ and know what you need.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-07-09T09:19:45.597" LastActivityDate="2018-07-09T09:19:45.597" CommentCount="7" />
  <row Id="2627" PostTypeId="1" CreationDate="2018-07-05T15:35:14.193" Score="4" ViewCount="118" Body="&lt;p&gt;I want to run a experiment like this:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Generate a bunch of random  12-character passwords like $``\texttt{&amp;lt;Bb\{Q,r2Qp8`}&quot;.$&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Write an algorithm to randomly generate &amp;amp; compare value on quantum computer.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;If the value was found, return number of time it take to generate, let's say $6102111820800.$&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;The only available quantum computer I know of is IBM's quantum computing cloud service.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Questions:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Is it possible to run this program on existing quantum computers?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;If so, how fast would it be?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="2994" LastEditorUserId="15" LastEditDate="2018-07-05T17:05:07.297" LastActivityDate="2018-07-08T03:23:36.117" Title="Is running a large random brute force on quantum computer possible at the moment?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-computer&gt;&lt;quantum-speedup&gt;" AnswerCount="2" CommentCount="6" />
  <row Id="2628" PostTypeId="5" CreationDate="2018-07-05T15:58:58.620" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-07-05T15:58:58.620" LastActivityDate="2018-07-05T15:58:58.620" CommentCount="0" />
  <row Id="2629" PostTypeId="4" CreationDate="2018-07-05T15:58:58.620" Score="0" Body="Quantum walks are the quantum mechanical counterpart of classical random walks. This tag should be used for any question related to quantum walk models." OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-07-06T01:08:08.747" LastActivityDate="2018-07-06T01:08:08.747" CommentCount="0" />
  <row Id="2630" PostTypeId="5" CreationDate="2018-07-05T16:00:50.893" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-07-05T16:00:50.893" LastActivityDate="2018-07-05T16:00:50.893" CommentCount="0" />
  <row Id="2631" PostTypeId="4" CreationDate="2018-07-05T16:00:50.893" Score="0" Body="For questions related to the quantum algorithm for inverting linear systems of equations, developed by Harrow, Hassidim and Lloyd in 2009." OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-07-05T23:21:55.347" LastActivityDate="2018-07-05T23:21:55.347" CommentCount="0" />
  <row Id="2632" PostTypeId="2" ParentId="2607" CreationDate="2018-07-05T20:51:18.300" Score="2" Body="&lt;p&gt;In your example the pattern is made by a modular multiplication function or circuit f(x) = ax (mod N) This quantum circuit and pattern is also given in the IBM Q manual of the &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/tutorial?sectionId=full-user-guide&amp;amp;page=004-Quantum_Algorithms~2F110-Shor%27s_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;IBM Q Experience&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/GCB9l.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/GCB9l.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So in a loop with start input x = 1&lt;/p&gt;&#xA;&#xA;&lt;p&gt;x=1 f(x) = 7 * 1 (mod 15)  = 7&lt;/p&gt;&#xA;&#xA;&lt;p&gt;x=7  f(x) = 7 * 7 (mod 15) = 4 &lt;/p&gt;&#xA;&#xA;&lt;p&gt;x=4                        =&gt; 13&lt;/p&gt;&#xA;&#xA;&lt;p&gt;x=13                       =&gt;1&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The pattern 1 7 4 13 1 is repeated every 4th time. &#xA;So the circuit is fixed for a given a and mod 15 and always returns r = 4. If you want r = 2, you need another multiplier function &lt;/p&gt;&#xA;" OwnerUserId="1773" LastEditorUserId="1773" LastEditDate="2018-07-05T20:57:45.180" LastActivityDate="2018-07-05T20:57:45.180" CommentCount="0" />
  <row Id="2633" PostTypeId="5" CreationDate="2018-07-05T23:18:41.417" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-07-05T23:18:41.417" LastActivityDate="2018-07-05T23:18:41.417" CommentCount="0" />
  <row Id="2634" PostTypeId="4" CreationDate="2018-07-05T23:18:41.417" Score="0" Body="It is the branch of physics and engineering concerned with the properties and transmission of photons. Use this tag for those questions about photonics which are relevant to quantum computing." OwnerUserId="-1" LastEditorUserId="26" LastEditDate="2018-07-06T08:32:52.987" LastActivityDate="2018-07-06T08:32:52.987" CommentCount="0" />
  <row Id="2635" PostTypeId="2" ParentId="2603" CreationDate="2018-07-06T04:57:26.777" Score="4" Body="&lt;p&gt;There are a lot of interesting applications that use similar technology. A lot of labs that work towards quantum computing also publish papers with these applications. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here are some: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;All-optical computation. Personally, I think this has more potential than quantum computing, as it has already been shown to be useful for quickly &lt;a href=&quot;https://www.nature.com/articles/nphoton.2017.93&quot; rel=&quot;nofollow noreferrer&quot;&gt;processing neural networks&lt;/a&gt; (and other algorithms involving matrix multiplication and nonlinear functions). These on-chip systems are made in the same labs (and same people) as &lt;a href=&quot;https://arxiv.org/pdf/1507.03406.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;measurement-based linear quantum computing&lt;/a&gt;. Designing systems capable of operating faster than semi-conductor clock speeds, lowering the minimum power-per operation using light, and increasing parallelization will probably get us very far without needing to change algorithmic architectures. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1308.6253.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum simulation&lt;/a&gt;. Richard Feynman's original dream of &quot;quantum computers&quot; are now what are referred to as &quot;quantum analog simulators.&quot; Nature acts like nature. It can be hard to compute analytically or digitally how a Hydrogen atom behaves, but using a system with a similar Hamiltonian can &quot;do the math for you.&quot; Optical lattices (which are &lt;a href=&quot;https://www.nature.com/articles/nature24654&quot; rel=&quot;nofollow noreferrer&quot;&gt;sometimes&lt;/a&gt; used for &lt;a href=&quot;http://iontrap.umd.edu/wp-content/uploads/2012/12/s41467-017-01904-7.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum computing of ions&lt;/a&gt;) can be used for these quantum simulators. It is very difficult to do calculations of molecules using fundamental physics and chemistry is full of heuristics to deal with these difficulties.     &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;http://research.physics.illinois.edu/QI/Photonics/tomography-files/tomo_chapter_2004.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum state reconstruction&lt;/a&gt;. A usually unmentioned open problem in quantum information and computing is how to reconstruct high qbit entangled states. Even if quantum computing doesn't work out, advances made in these open questions might be helpful in the future (for, for instance, key distribution protocols and information theory). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quantum Communication. &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_key_distribution&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Key distribution&lt;/a&gt; is probably the only working practical application created so far from quantum information. It allows information to be transferred safely without the possibility of eavesdroppers. High-fidelity photon gate operations (created for quantum computers) could allow for &lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.81.052329&quot; rel=&quot;nofollow noreferrer&quot;&gt;efficient quantum repeaters&lt;/a&gt;, which could extend the maximum distance that can be traveled.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Extra Fun Things. Personally, I think the most interesting thing is answering if the brain is a quantum computer. The possiblity of the brain being a quantum computer has been eye-rolled by many physicists for the last decade, dismissing the high temperatures the brain to destroy coherence, but highly reputable (and commendable) physicists have recently challenged this notion. One discussing how &lt;a href=&quot;https://arxiv.org/abs/1508.05929&quot; rel=&quot;nofollow noreferrer&quot;&gt;nuclear spins&lt;/a&gt; could be the mediator of quantum information, &lt;a href=&quot;https://arxiv.org/abs/1607.02969&quot; rel=&quot;nofollow noreferrer&quot;&gt;another&lt;/a&gt; discussing how experiments could be carried to investigate if axons are operating as waveguides.    &lt;/p&gt;&#xA;" OwnerUserId="2660" LastEditorUserId="55" LastEditDate="2018-07-15T16:26:38.963" LastActivityDate="2018-07-15T16:26:38.963" CommentCount="0" />
  <row Id="2636" PostTypeId="2" ParentId="2627" CreationDate="2018-07-06T07:52:16.853" Score="3" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;I want to run a experiment like this:&lt;/p&gt;&#xA;  &#xA;  &lt;ol&gt;&#xA;  &lt;li&gt;Generate a bunch of random 12-character passwords like &quot;;Bb{Q,r2Qp8`&quot; (&lt;em&gt;changed the first character because it interefed with the citation style&lt;/em&gt;).&lt;/li&gt;&#xA;  &lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Let's say your characters are encoded in &lt;a href=&quot;https://en.wikipedia.org/wiki/Extended_ASCII&quot; rel=&quot;nofollow noreferrer&quot;&gt;extended ASCII&lt;/a&gt;, i.e. they have a value between 0 and 255. You need 8 classical bits to represent one character. One could expect that you could encode this value on 3 qubits ($2^3$), but you need to do a compromise here:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;If you have access to an external source of randomness, then you can use it to generate a random quantum state (by applying random gates to the initial quantum state for example). In this case, the amplitudes of the obtained quantum state &lt;em&gt;may&lt;/em&gt; represent your character (you still need to find how to represent a random character from complex non-integer numbers) and depending on the encoding you use you may need less than 8 qubits.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;If you don't have access to an external source of randomness or if you want your random numbers to be &quot;perfect&quot;, you can use quantum superposition and measurement to generate perfect random integers. This can be done by taking 8 qubits, applying the &lt;code&gt;H&lt;/code&gt; gate to the 8 qubits and measuring them in the computational basis. With this algorithm, you will have 8 qubits in the state $\vert0\rangle$ &lt;strong&gt;or&lt;/strong&gt; $\vert1\rangle$ (i.e. a random number on 8 qubits). With this method, 1 character = 8 qubits.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;ol start=&quot;2&quot;&gt;&#xA;  &lt;li&gt;Write an algorithm to randomly generate &amp;amp; compare value on quantum computer.&lt;/li&gt;&#xA;  &lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The generation can be done in the same way as above. For the comparison, it depends on the method you used for the generation and how you represent your characters:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;As the characters are encoded in the amplitudes, you can use the &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2561/checking-value-of-variable-using-quantum-approach/2583#2583&quot;&gt;SWAP test&lt;/a&gt; to check for closeness.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Here, the qubits are just classical bits so you could just measure them and check classically for equality.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;ol start=&quot;3&quot;&gt;&#xA;  &lt;li&gt;If the value was found, return number of time it take to generate, let's say 6102111820800.&lt;/li&gt;&#xA;  &lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Again, depending on what you want (but the bullet points here are not related to the methods above):&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;You could count the try-fails in a classical register, just by incrementing a classical counter at each fail. If you used the SWAP test, you can measure the ancillary qubits and update the counter.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;If you want to encode your counter in a quantum state, you need a circuit that will increment the value of a register. You can find a way to construct such a circuit &lt;a href=&quot;http://algassert.com/circuits/2015/06/12/Constructing-Large-Increment-Gates.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt; for example. Then, if you used the SWAP test you can either read the qubit and apply the increment operation or directly apply the increment operation controlled by the state of the ancillary qubit.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The only available quantum computer I know of is IBM's quantum computing cloud service.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Questions:&lt;/p&gt;&#xA;  &#xA;  &lt;ol&gt;&#xA;  &lt;li&gt;Is it possible to run this program on existing quantum computers?&lt;/li&gt;&#xA;  &lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;It depends on the method you take: the first method &lt;em&gt;may&lt;/em&gt; be able to run on an existing chips, but the second one would need at least $96 = 12*8$ qubits to store the 12 characters, which is above the maximum number of qubits currently available.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;ol start=&quot;2&quot;&gt;&#xA;  &lt;li&gt;If so, how fast would it be?&lt;/li&gt;&#xA;  &lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;It will be sloooooooooooow. The first method &lt;em&gt;may&lt;/em&gt; be able to use quantum superposition to speed-up the computations, but the second method uses quantum superposition only to generate random numbers, and then treat them classically. &lt;/p&gt;&#xA;" OwnerUserId="1386" LastActivityDate="2018-07-06T07:52:16.853" CommentCount="5" />
  <row Id="2637" PostTypeId="5" CreationDate="2018-07-06T08:50:09.920" Score="0" Body="&lt;h2&gt;&lt;strong&gt;Quantum Parallelism&lt;/strong&gt;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Given that our quantum memory register differs from a classical one in that it can store a superposition of the base states of the register, one might wonder what this implies as to the efficiency of quantum computing. The study of quantum computing is relatively new, most give credit to Richard Feynman for being the first to suggest that there were tasks that a quantum computer could perform exponentially better than a classical computer. Feynman observed that a classical computer could not simulate a quantum mechanical system without suffering from exponential slowdown. At the same time, he hinted that perhaps by using a device whose behavior was inherently quantum in nature one could simulate such a system without this exponential slowdown. (Feynman)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Several quantum algorithms rely on something called quantum parallelism. Quantum parallelism arises from the ability of a quantum memory register to exist in a superposition of base states. A quantum memory register can exist in a superposition of states, each component of this superposition may be thought of as a single argument to a function. A function performed on the register in a superposition of states is thus performed on each of the components of the superposition, but this function is only applied one time. Since the number of possible states is $2^n$ where $n$ is the number of qubits in the quantum register, you can perform in one operation on a quantum computer what would take an exponential number of operations on a classical computer. This is fantastic, but the more superposed states that exist in your register, the smaller the probability that you will measure any particular one will become. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;As an example suppose that you are using a quantum computer to calculate the function $\mathcal {F}(x) = 2x \pmod 7$, for $x$ integers between $0$ and $7$ inclusive. You could prepare a quantum register that was in an equally weighted superposition of the states $0 - 7$. Then you could perform the $2x \pmod 7$ operation once, and the register would contain the equally weighted superposition of $0,2,4,6,1,3,5,0$ states, these being the outputs of the function $2x \pmod 7$ for inputs $0 - 7$. When measuring the quantum register you would have a $2/8$ chance of measuring $0$, and a $1/8$ chance of measuring any of the other outputs. It would seem that this sort of parallelism is not useful, as the more we benefit from parallelism the less likely we are to measure a value of a function for a particular input. Some clever algorithms have been devised, most notably by Peter Shor and L. K. Grover which succeed in using quantum parallelism on a function where they are interested in some property of all the inputs, not just a particular one. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Source:&lt;/strong&gt; &lt;a href=&quot;https://quantum-algorithms.herokuapp.com/299/paper/node16.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://quantum-algorithms.herokuapp.com/299/paper/node16.html&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-06T08:50:09.920" LastActivityDate="2018-07-06T08:50:09.920" CommentCount="0" />
  <row Id="2638" PostTypeId="4" CreationDate="2018-07-06T08:50:09.920" Score="0" Body="The idea that a quantum computer can simultaneously explore many possible solutions to a problem since quantum memory register can exist in a superposition of states, each component of this superposition may be thought of as a single argument to a function. A function performed on the register in a superposition of states is thus performed on each of the components of the superposition, but this function is only applied one time.  " OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-06T08:50:09.920" LastActivityDate="2018-07-06T08:50:09.920" CommentCount="0" />
  <row Id="2639" PostTypeId="5" CreationDate="2018-07-06T08:53:44.067" Score="0" Body="&lt;h2&gt;Boson Sampling&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Boson sampling constitutes a restricted model of non-universal quantum computation introduced by S. Aaronson and A. Arkhipov. It consists of sampling from the probability distribution of identical bosons scattered by a linear interferometer. Although the problem is well defined for any bosonic particles, its photonic version is currently considered as the most promising platform for a scalable implementation of a boson sampling device, which makes it a non-universal approach to linear optical quantum computing. Moreover, while not universal, the boson sampling scheme is strongly believed to implement a classically hard task using far fewer physical resources than a full linear-optical quantum computing setup. This makes it an outstanding candidate for demonstrating the power of quantum computation in the near term.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Read more on Wikipedia: &lt;a href=&quot;https://en.wikipedia.org/wiki/Boson_sampling&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://en.wikipedia.org/wiki/Boson_sampling&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-06T08:53:44.067" LastActivityDate="2018-07-06T08:53:44.067" CommentCount="0" />
  <row Id="2640" PostTypeId="4" CreationDate="2018-07-06T08:53:44.067" Score="0" Body="Boson sampling constitutes a restricted model of non-universal quantum computation introduced by S. Aaronson and A. Arkhipov. It consists of sampling from the probability distribution of identical bosons scattered by a linear interferometer. (from Wikipedia)" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-06T08:53:44.067" LastActivityDate="2018-07-06T08:53:44.067" CommentCount="0" />
  <row Id="2641" PostTypeId="5" CreationDate="2018-07-06T08:56:21.837" Score="0" Body="" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-06T08:56:21.837" LastActivityDate="2018-07-06T08:56:21.837" CommentCount="0" />
  <row Id="2642" PostTypeId="4" CreationDate="2018-07-06T08:56:21.837" Score="0" Body="The toric code is a topological quantum error correcting code, and an example of a stabilizer code defined on a two-dimensional spin-lattice. It is the simplest and most well studied of the quantum double models (first studied in the context of Z2 spin liquid in 1991). It is also the simplest example of topological order—Z2 topological order. The toric code can also be considered to be a Z2 lattice gauge theory in a particular limit. (from Wikipedia)" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-06T08:56:21.837" LastActivityDate="2018-07-06T08:56:21.837" CommentCount="0" />
  <row Id="2643" PostTypeId="2" ParentId="2439" CreationDate="2018-07-06T09:30:16.743" Score="0" Body="&lt;p&gt;HHL algorithm with a 4 x 4 matrix A might be to large for the IBM computer. I tried a smaller toy version of the algorithm according with arXiv 1302.1210 link &lt;a href=&quot;https://arxiv.org/abs/1302.1210&quot; rel=&quot;nofollow noreferrer&quot;&gt;Solving systems of linear equations&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I explained a little bit about this circuit here at stackexchange:&#xA;&lt;a href=&quot;https://cs.stackexchange.com/questions/76525/could-a-quantum-computer-perform-linear-algebra-faster-than-a-classical-computer/77036#77036&quot;&gt;https://cs.stackexchange.com/questions/76525/could-a-quantum-computer-perform-linear-algebra-faster-than-a-classical-computer/77036#77036&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Unfortunately it is only a 1 qubit input with A = 2 x 2 matrix, in the answer a link to the IBM circuit is given.&lt;/p&gt;&#xA;" OwnerUserId="1773" LastActivityDate="2018-07-06T09:30:16.743" CommentCount="2" />
  <row Id="2644" PostTypeId="5" CreationDate="2018-07-06T11:21:51.703" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-07-06T11:21:51.703" LastActivityDate="2018-07-06T11:21:51.703" CommentCount="0" />
  <row Id="2645" PostTypeId="4" CreationDate="2018-07-06T11:21:51.703" Score="0" Body="For questions related to the quantum phase estimation algorithm, which approximates the eigenvalue associated with a given eigenvector&#xD;&#xA;" OwnerUserId="1386" LastEditorUserId="23" LastEditDate="2018-07-06T12:04:00.387" LastActivityDate="2018-07-06T12:04:00.387" CommentCount="0" />
  <row Id="2646" PostTypeId="5" CreationDate="2018-07-06T11:27:18.833" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-07-06T11:27:18.833" LastActivityDate="2018-07-06T11:27:18.833" CommentCount="0" />
  <row Id="2647" PostTypeId="4" CreationDate="2018-07-06T11:27:18.833" Score="0" Body="Hamiltonian simulation is a class of algorithms that, given a Hermitian matrix A, output a quantum circuit implementing an approximation to the unitary exp[iAt]. " OwnerUserId="1386" LastEditorUserId="26" LastEditDate="2018-08-02T15:42:26.913" LastActivityDate="2018-08-02T15:42:26.913" CommentCount="0" />
  <row Id="2648" PostTypeId="5" CreationDate="2018-07-06T11:38:24.577" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-07-06T11:38:24.577" LastActivityDate="2018-07-06T11:38:24.577" CommentCount="0" />
  <row Id="2649" PostTypeId="4" CreationDate="2018-07-06T11:38:24.577" Score="0" Body="Ancillas or &quot;ancilla qubits&quot; are qubits used internally in a quantum circuit. They are only used during the computations and their input and output states should be fixed (the convention in the quantum circuit model is |0&gt;)" OwnerUserId="1386" LastEditorUserId="1386" LastEditDate="2018-07-06T12:01:11.880" LastActivityDate="2018-07-06T12:01:11.880" CommentCount="0" />
  <row Id="2650" PostTypeId="2" ParentId="2603" CreationDate="2018-07-06T11:54:29.567" Score="1" Body="&lt;p&gt;&lt;strong&gt;Perform and checking basic quantum-mechanic experiments&lt;/strong&gt;&#xA;Before the IBM and alibaba quantum cloud computers, you would need an expensive lab to do simple CHSH or GHZ experiments. Of course the qubits in the IBM computer are not loophole free but many institutes and also collegeschools could not have better experiment facilities purchased within their physics budget. So basic quantum mechanic experiments can be done very easily. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Quantum programming tools and experiments&lt;/strong&gt;&#xA;Furthermore basic research in programming quantum computer tools like compilers and mapping algorithms can now be tested on real machines &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This has lead to 113 papers with real and tested quantum algorithms for the ibm computer alone and many more in general.&#xA;&lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/community?channel=papers&quot; rel=&quot;nofollow noreferrer&quot;&gt;qc papers&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="1773" LastActivityDate="2018-07-06T11:54:29.567" CommentCount="0" />
  <row Id="2651" PostTypeId="1" CreationDate="2018-07-06T14:31:41.693" Score="8" ViewCount="183" Body="&lt;p&gt;What are the prominent visualisations used to depict large, entangled states and in what context are they most commonly applied?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What are their advantages and disadvantages?&lt;/p&gt;&#xA;" OwnerUserId="391" LastEditorUserId="391" LastEditDate="2018-07-06T14:44:12.950" LastActivityDate="2018-08-07T21:18:34.053" Title="What are the possible ways to visualise large, entangled states?" Tags="&lt;quantum-entanglement&gt;&lt;quantum-state&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="2" />
  <row Id="2652" PostTypeId="2" ParentId="2458" CreationDate="2018-07-06T15:20:03.390" Score="3" Body="&lt;p&gt;The numbers you are describing are &lt;em&gt;very very large&lt;/em&gt;. To the point, it appears that they are numbers whose representation in decimal (or binary) are large enough that it there is little to no prospect of there being enough matter in the entire universe to store those numbers, in a place-value representation such as those. This being the case, no technology &amp;mdash; quantum or otherwise &amp;mdash; will be able to produce a representation (or anything which can be described as a conventional 'estimate') of those numbers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Furthermore, it appears that these functions are faster growing than any provably total function (&lt;em&gt;e.g.&lt;/em&gt;,&amp;nbsp;faster than any function which we know to be computable even in exponential time) relative to some more-or-less sensible model of set theory. If you are interested in things which you can compute in a reasonable time-bound with quantum computers &amp;mdash; &lt;em&gt;e.g.&lt;/em&gt;&amp;nbsp;in polynomial time, which can be simulated in at worst exponential time on a conventional computer &amp;mdash; it follows that on mathematical grounds as well as physical grounds, you should expect these functions not to be practically computable even on an idealised quantum computer.&lt;/p&gt;&#xA;" OwnerUserId="124" LastActivityDate="2018-07-06T15:20:03.390" CommentCount="7" />
  <row Id="2653" PostTypeId="2" ParentId="2651" CreationDate="2018-07-06T16:52:31.677" Score="1" Body="&lt;p&gt;My personal view:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Yes, large entangled states can be visualized using quantum bayesian networks. See&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0701201&quot; rel=&quot;nofollow noreferrer&quot;&gt;Factorization of Quantum Density Matrices According to Bayesian and Markov Networks, by Robert R. Tucci&lt;/a&gt; (obviously I am the author here)&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/artiste-qb-net/quantum-fog&quot; rel=&quot;nofollow noreferrer&quot;&gt;Python tools for analyzing both classical and quantum Bayesian Networks&lt;/a&gt; (Disclaimer: artiste-qb.net is my company)&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Other people will probably advise using Tensor Networks instead of quantum Bayesian nets. This begs the question: How do Quantum Bayesian Networks and Tensor Networks compare? I have thought about that and gathered my thoughts in &lt;a href=&quot;https://qbnets.wordpress.com/2015/03/26/tensor-networks-versus-quantum-bayesian-networks-and-the-winner-is/&quot; rel=&quot;nofollow noreferrer&quot;&gt;this&lt;/a&gt; blog post.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;First lines of blog post: &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;A question I am often asked is what is the difference between tensor&#xA;  networks and quantum Bayesian networks, and is there any advantage to&#xA;  using one over the other.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;When dealing with probabilities, I prefer quantum Bayesian networks&#xA;  because b nets are a more natural way of expressing probabilities (and&#xA;  probability amplitudes) whereas tensor nets can be used to denote many&#xA;  physical quantities other than probabilities so they are not tailor&#xA;  made for the job as b nets are. Let me explain in more detail for the&#xA;  technically inclined.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;One can consider bipartite entanglement for the two sides of a partition, of a quantum bayesian network. One can write nice inequalities for such bipartite entanglements. See, for example, &lt;a href=&quot;https://arxiv.org/abs/1806.08415&quot; rel=&quot;nofollow noreferrer&quot;&gt;Entanglement Polygon Inequality in Qubit Systems,&#xA;Xiao-Feng Qian, Miguel A. Alonso, Joseph H. Eberly&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One can also try to define a measure of n-partite entanglement for n&gt;2, where n is the number of nodes of a quantum Bayesian net.&#xA;See, for example, &lt;a href=&quot;https://arxiv.org/abs/1011.5012&quot; rel=&quot;nofollow noreferrer&quot;&gt;Verifying Genuine High-Order Entanglement, Che-Ming Li, Kai Chen, Andreas Reingruber, Yueh-Nan Chen, Jian-Wei Pan&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1974" LastEditorUserId="91" LastEditDate="2018-08-07T21:18:34.053" LastActivityDate="2018-08-07T21:18:34.053" CommentCount="0" />
  <row Id="2654" PostTypeId="1" CreationDate="2018-07-07T09:43:07.033" Score="11" ViewCount="235" Body="&lt;p&gt;In the recent Question &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2499/is-quantum-computing-just-pie-in-the-sky&quot;&gt;&quot;Is Quantum Computing just Pie in the Sky&quot;&lt;/a&gt; there are many responses regarding the improvements in quantum capabilities, however all are focussed on the current 'digital' computing view of the world.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Analog computers of old could simulate and compute many complex problems that fitted their operating modes that were not suitable for digital computing for many many years (and some are still 'difficult'). Before the wars (~I &amp;amp; II) everything was considered to be 'clockwork' with mechanical Turk brains. Have we fallen into the same 'everything digital' bandwagon trap that keeps recurring (there are no tags related to 'analog')?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What work has been done on the mapping of quantum phenomena to analog computing, and learning from that analogy? Or is it all a problem of folk having no real idea how to program the beasts.&lt;/p&gt;&#xA;" OwnerUserId="3021" LastEditorUserId="26" LastEditDate="2018-07-15T13:56:54.403" LastActivityDate="2018-07-15T13:56:54.403" Title="Are quantum computers just a variant on Analog computers of the 50's &amp; 60's that many have never seen nor used?" Tags="&lt;classical-computing&gt;&lt;quantum-programming&gt;&lt;adiabatic-model&gt;&lt;quantum-technologies&gt;" AnswerCount="4" CommentCount="1" FavoriteCount="2" />
  <row Id="2655" PostTypeId="1" CreationDate="2018-07-07T17:29:41.613" Score="5" ViewCount="56" Body="&lt;p&gt;Existing superconducting quantum computers need to be cooled near absolute zero.  For example, some of D-Wave's machines are cooled to about $20 \ \mathrm {mK}$.  Their design uses a dilution refrigerator.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Are there any other cooling methods for superconducting quantum computers besides dilution refrigerators which are capable of achieving such low temperatures?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Are there any specific commercial quantum computer designs or research projects using these other cooling methods?&lt;/p&gt;&#xA;" OwnerUserId="2866" LastEditorUserId="26" LastEditDate="2018-07-08T10:12:39.450" LastActivityDate="2018-07-08T10:12:39.450" Title="What methods exist for cooling superconducting quantum computers?" Tags="&lt;d-wave&gt;&lt;superconducting-quantum-computing&gt;&lt;dilution-refrigerator&gt;" AnswerCount="0" CommentCount="0" />
  <row Id="2656" PostTypeId="2" ParentId="2654" CreationDate="2018-07-08T01:44:09.800" Score="6" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;What work has been done on the mapping of quantum phenomena to analog computing, and learning from that analogy?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;A starting place (with a lot of good references) to learn about analog quantum computing (also known as &quot;quantum analogue computing&quot; and &quot;continuous variable quantum computing&quot;) is &lt;a href=&quot;https://arxiv.org/abs/1001.2215&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;. Note that analog classical computing is not as powerful as analog quantum computing, for a reason similar to what I explained in my &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2226/2293&quot;&gt;answer to this question&lt;/a&gt;: quantum computers (whether digital or analog) can take advantage of quantum entanglement.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Have we fallen into the same 'everything digital' bandwagon trap that keeps recurring (there are no tags related to 'analog')? &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;A lot of people unfortunately have, and this might be part of the reason why &quot;adiabatic quantum computing&quot; struggled to get the respect it deserved in its early years (and even now). Adiabatic quantum computing is a specific type of analog quantum computing which certainly does have a &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/tagged/adiabatic-model&quot;&gt;tag&lt;/a&gt; on this Stack Exchange and a fair number of questions (but not enough, in my opinion). It has been proven that &quot;adiabatic quantum computing&quot;, which is completely analog and does not involve any &lt;em&gt;gates&lt;/em&gt;, &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0405098&quot; rel=&quot;nofollow noreferrer&quot;&gt;can do anything that a digital quantum computer can do&lt;/a&gt; with the same computational efficiency, so while it is true that many people in quantum computing have fallen into the 'everything digital' bandwagon trap, there are some people that appreciate analog quantum computing (for example adiabatic quantum computing).  &lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-07-13T15:12:45.560" LastActivityDate="2018-07-13T15:12:45.560" CommentCount="1" />
  <row Id="2657" PostTypeId="2" ParentId="2627" CreationDate="2018-07-08T03:23:36.117" Score="1" Body="&lt;p&gt;From the question title, it sounds like you're interested in brute-force password cracking.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There is a quantum algorithm for this that outperforms brute force, in principle. It's called &lt;a href=&quot;https://en.wikipedia.org/wiki/Grover&amp;#39;s_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;Grover's algorithm&lt;/a&gt; and it was one of the earliest quantum algorithms to be discovered.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, to crack a password, you need as many qubits in your quantum computer as you'd need bits in a traditional computer to hash the passwords (actually more, since you have to hash them &lt;a href=&quot;https://en.wikipedia.org/wiki/Reversible_computing&quot; rel=&quot;nofollow noreferrer&quot;&gt;reversibly&lt;/a&gt;, and that involves some overhead). This is orders of magnitude more qubits than any present-day quantum computer has, even for simple password hashing techniques. Also, the computation lasts for far longer than any present-day quantum computer can maintain the integrity of its qubits. And even if it worked, it's not very fast: testing $n$ passwords with Grover's algorithm takes about as long as testing $\sqrt{n}$ passwords by brute force.&lt;/p&gt;&#xA;" OwnerUserId="3030" LastActivityDate="2018-07-08T03:23:36.117" CommentCount="1" />
  <row Id="2658" PostTypeId="2" ParentId="2595" CreationDate="2018-07-08T03:50:31.753" Score="2" Body="&lt;p&gt;What makes quantum wave mechanics different from classical is that the wave is defined over a configuration space with a huge number of dimensions. In nonrelativistic undergraduate quantum mechanics (which is good enough for a theoretical discussion of quantum computing), a system of $n$ spinless point particles in 3D space is described by a wave in $\mathbb{R}^{3n}$, which for $n=2$ already has no analogue in classical mechanics. All quantum algorithms exploit this. It may be possible to exploit classical wave mechanics to improve certain calculations (analog computing), but not using quantum algorithms.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The usual model of quantum computing uses qubits that can only be in two states ($\{0,1\}$), not a continuum of states ($\mathbb{R}^3$). The closest classical analogue to that is coupled pendulums, not continuous waves. But there's still an exponential difference between the classical and quantum cases: the classical system of n pendulums is described by $n$ positions and momenta (or $n$ complex numbers), while the quantum system is described by $2^n$ complex numbers (or $2^n$ abstract &quot;positions&quot; and &quot;momenta&quot;, but quantum physicists never talk that way).&lt;/p&gt;&#xA;" OwnerUserId="3030" LastActivityDate="2018-07-08T03:50:31.753" CommentCount="0" />
  <row Id="2659" PostTypeId="1" CreationDate="2018-07-08T06:08:14.047" Score="4" ViewCount="87" Body="&lt;p&gt;I'm trying to implement Majorana's &quot;stellar representation&quot; of a spin-$j$ system as $2j$ points on the $2$-sphere in python. Consulting papers including &lt;a href=&quot;https://arxiv.org/abs/1503.03446&quot; rel=&quot;nofollow noreferrer&quot;&gt;Extremal quantum states and their Majorana constellations (Bjork et al., 2015)&lt;/a&gt;, I convert a complex state vector (nominally indexed from -$j$ to $j$) to its corresponding polynomial with:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;def vector_to_polynomial(vector):&#xA;    components = vector.tolist()&#xA;    j = (len(components)-1.)/2.&#xA;    coeffs = []&#xA;    i = 0&#xA;    for m in numpy.arange(-1*j, j+1, 1):&#xA;        coeff = math.sqrt(math.factorial(2*j)/(math.factorial(j-m)*math.factorial(j+m)))*components[i]&#xA;        coeffs.append(coeff)&#xA;        i += 1&#xA;    return coeffs[::-1]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;I use a polynomial solver to determine the roots, and stereographically project them to the $2$-sphere, taking into account when the degree of the polynomial is less than $2j$ by adjoining some poles (latter code not included).&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;def root_to_xyz(root):&#xA;    if root == float('inf'):&#xA;        return [0,0,1]&#xA;    x = root.real&#xA;    y = root.imag&#xA;    return [(2*x)/(1.+(x**2)+(y**2)),\&#xA;            (2*y)/(1.+(x**2)+(y**2)),\&#xA;            (-1.+(x**2)+(y**2))/(1.+(x**2)+(y**2))]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;See Wikipedia. Now QuTiP has an implementation of the Husimi Q function aka &lt;code&gt;qutip.spin_q_function(state, theta, phi)&lt;/code&gt;, evaluated at points on the sphere. The zeros of Husimi Q coincide with the Majorana stars. Comparing the results of the above with the QuTiP implementation, however, I find that they only match for integer spins, but not half-integer spins, aka for odd-dimensional systems, but not even dimensional systems. I've tried to code up a few other versions of the Majorana polynomial given in other papers, but the same problem seems to recur. Am I missing something more fundamental? Any advice is welcome!&lt;/p&gt;&#xA;" OwnerUserId="456" LastEditorUserId="26" LastEditDate="2018-07-08T09:39:58.000" LastActivityDate="2018-07-08T09:39:58.000" Title="Computing Majorana &quot;Stars&quot;" Tags="&lt;bloch-sphere&gt;&lt;majorana-particle&gt;&lt;qutip&gt;" AnswerCount="0" CommentCount="2" />
  <row Id="2660" PostTypeId="5" CreationDate="2018-07-08T09:44:59.777" Score="0" Body="" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-08T09:44:59.777" LastActivityDate="2018-07-08T09:44:59.777" CommentCount="0" />
  <row Id="2661" PostTypeId="4" CreationDate="2018-07-08T09:44:59.777" Score="0" Body="QuTiP is open-source software for simulating the dynamics of open quantum systems. The QuTiP library depends on the excellent Numpy, Scipy, and Cython numerical packages. " OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-08T09:44:59.777" LastActivityDate="2018-07-08T09:44:59.777" CommentCount="0" />
  <row Id="2662" PostTypeId="2" ParentId="2654" CreationDate="2018-07-08T12:56:45.927" Score="1" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Are quantum computers just a variant on Analog computers of the 50's &amp;amp; 60's that many have never seen nor used?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;No, they are not.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The digital vs analog factor is not the point here,&#xA;the difference between quantum and classical devices lies at a more fundamental level.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A quantum device cannot, in general, be simulated efficiently by a classical device, be it &quot;analog&quot; or &quot;digital&quot; (or at least, this is strongly believed to be the case). In this sense, quantum computers are really radically different from any variation of classical analog computers, or other forms of classical computing for that matter.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Indeed, the most popularized architectures for quantum computing, those operating on sets of &quot;qubits&quot;, are the quantum counterparts of &lt;em&gt;digital&lt;/em&gt; classical computers. Analog devices also have their quantum counterparts (see for example &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous-variable_quantum_information&quot; rel=&quot;nofollow noreferrer&quot;&gt;continuous-variable quantum information&lt;/a&gt;).&lt;/p&gt;&#xA;" OwnerUserId="55" LastActivityDate="2018-07-08T12:56:45.927" CommentCount="4" />
  <row Id="2663" PostTypeId="1" AcceptedAnswerId="2666" CreationDate="2018-07-08T14:55:51.033" Score="5" ViewCount="271" Body="&lt;p&gt;Many texts (especially meant for public consumption) discussing quantum mechanics tend to skim over exactly how entanglement is achieved. Even the Wikipedia article on quantum entanglement describes the phenomenon as follows:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;Quantum entanglement is a physical phenomenon which occurs when pairs or groups of particles are generated, interact, or share spatial proximity in ways such that the quantum state of each particle cannot be described independently of the state of the other(s)...&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This doesn't explain how the process actually comes into being. How are these particles &quot;generated,&quot; &quot;interact,&quot; or &quot;share spatial-proximity&quot; such that we can claim that two particles are entangled? What is the process?&lt;/p&gt;&#xA;" OwnerUserId="3035" LastActivityDate="2018-07-08T20:16:15.623" Title="How is entanglement achieved between two particles in quantum computing?" Tags="&lt;quantum-computer&gt;&lt;quantum-entanglement&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="2664" PostTypeId="1" AcceptedAnswerId="2668" CreationDate="2018-07-08T15:10:25.443" Score="3" ViewCount="64" Body="&lt;p&gt;Can someone show to me the steps to derive the joint state at the bottom of this image, please? &lt;a href=&quot;https://i.stack.imgur.com/PM5UB.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/PM5UB.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I tried to follow his explanation but I didn't get the same results…&#xA;This is taken from the lecture notes of Ronald de Wolf in case it may help&lt;/p&gt;&#xA;" OwnerUserId="3036" LastEditorUserId="26" LastEditDate="2018-07-11T19:24:20.930" LastActivityDate="2018-07-11T19:24:20.930" Title="How the joint state of these qubits is derived?" Tags="&lt;quantum-gate&gt;&lt;qubit-state&gt;&lt;quantum-state&gt;" AnswerCount="1" CommentCount="2" />
  <row Id="2665" PostTypeId="2" ParentId="2663" CreationDate="2018-07-08T15:18:29.340" Score="2" Body="&lt;p&gt;You can easily create an EPR pair by means of a circuit consisting of a Hadamard gate on the first qubit, followed by a CNOT gate, having two $|0\rangle$ states as an input. The calculations would be:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;$(H\otimes I)(|0\rangle\otimes|0\rangle)=H|0\rangle\otimes|0\rangle=\frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)\otimes|0\rangle$&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;$CNOT\frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)\otimes|0\rangle=\frac{1}{\sqrt{2}}(|0\rangle\otimes|0\rangle+|1\rangle\otimes|1\rangle)=\frac{1}{\sqrt{2}}(|00\rangle+|11\rangle)=|\Psi^+\rangle$&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;The ending state consequently is the EPR pair called $|\Psi^+\rangle$, which is a classical example of a entangled pair.&lt;/p&gt;&#xA;" OwnerUserId="2371" LastEditorUserId="45" LastEditDate="2018-07-08T20:16:15.623" LastActivityDate="2018-07-08T20:16:15.623" CommentCount="0" />
  <row Id="2666" PostTypeId="2" ParentId="2663" CreationDate="2018-07-08T15:27:14.087" Score="3" Body="&lt;p&gt;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/users/2371/josu-etxezarreta-martinez&quot;&gt;Josu&lt;/a&gt; has given an &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2665/26&quot;&gt;example&lt;/a&gt; of how using quantum gates you can get an entangled state. However, quantum gates are sort of &quot;black-boxes&quot;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The physical methods for creating entangled states and testing for entangled states are covered well on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_entanglement&quot; rel=&quot;nofollow noreferrer&quot;&gt;relevant Wikipedia page&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_entanglement#Methods_of_creating_entanglement&quot; rel=&quot;nofollow noreferrer&quot;&gt;Methods of creating entanglement&lt;/a&gt;&lt;/strong&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Entanglement is usually created by direct interactions between&#xA;  subatomic particles. These interactions can take numerous forms. One&#xA;  of the most commonly used methods is spontaneous parametric&#xA;  down-conversion to generate a pair of photons entangled in&#xA;  polarisation. Other methods include the use of a fiber coupler to&#xA;  confine and mix photons, photons emitted from decay cascade of the&#xA;  bi-exciton in a quantum dot, the use of the Hong–Ou–Mandel effect,&#xA;  etc., In the earliest tests of Bell's theorem, the entangled particles&#xA;  were generated using atomic cascades.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;It is also possible to create entanglement between quantum systems&#xA;  that never directly interacted, through the use of entanglement&#xA;  swapping. Two independently-prepared, identical particles may also be&#xA;  entangled if their wave functions merely spatially overlap, at least&#xA;  partially.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_entanglement#Testing_a_system_for_entanglement&quot; rel=&quot;nofollow noreferrer&quot;&gt;Testing a system for entanglement:&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Systems which contain no entanglement are said to be separable. For $2$-Qubit and Qubit-Qutrit systems ($2 × 2$ and $2 × 3$ respectively) the simple Peres–Horodecki criterion provides both a necessary and a sufficient criterion for separability, and thus for detecting entanglement. However, for the general case, the criterion is merely a sufficient one for separability, as the problem becomes NP-hard. A numerical approach to the problem is suggested by Jon Magne Leinaas, Jan Myrheim and Eirik Ovrum in their paper &quot;Geometrical aspects of entanglement&quot;. Leinaas et al. offer a numerical approach, iteratively refining an estimated separable state towards the target state to be tested, and checking if the target state can indeed be reached. An implementation of the algorithm (including a built-in Peres-Horodecki criterion testing) is brought in the &quot;StateSeparator&quot; web-app.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;In 2016 China launched the world’s first quantum communications satellite. The $100m Quantum Experiments at Space Scale (QUESS) mission was launched on Aug 16, 2016, from the Jiuquan Satellite Launch Center in northern China at 01:40 local time.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;For the next two years, the craft – nicknamed &quot;Micius&quot; after the ancient Chinese philosopher – will demonstrate the feasibility of quantum communication between Earth and space, and test quantum entanglement over unprecedented distances.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;In the June 16, 2017, issue of Science, Yin et al. report setting a new quantum entanglement distance record of $1203$ km, demonstrating the survival of a $2$-photon pair and a violation of a Bell inequality, reaching a CHSH valuation of $2.37 ± 0.09$, under strict Einstein locality conditions, from the Micius satellite to bases in Lijian, Yunnan and Delingha, Quinhai, increasing the efficiency of transmission over prior fiberoptic experiments by an order of magnitude.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;You might also want to see: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2263/how-do-i-show-that-a-two-qubit-state-is-an-entangled-state&quot;&gt;How do I show that a two-qubit state is an entangled state?&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2413/how-to-show-that-an-n-level-system-is-entangled/2419&quot;&gt;How to show that an n-level system is entangled?&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-07-08T15:27:14.087" CommentCount="0" />
  <row Id="2667" PostTypeId="1" AcceptedAnswerId="2669" CreationDate="2018-07-08T15:53:34.887" Score="14" ViewCount="3416" Body="&lt;p&gt;As we make inroads into Machine Learning, there seem to be plenty of respectable courses available online via Coursera, edX, etc. on the topic. As quantum computing is still in its infancy, not to mention, incredibly daunting, it is vital that easy to understand, introductory courses are made available.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I was able to find these courses:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://www.edx.org/course/quantum-information-science-i&quot; rel=&quot;noreferrer&quot;&gt;Quantum Information Science I, Part 1&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://www.coursera.org/learn/quantum-optics-single-photon&quot; rel=&quot;noreferrer&quot;&gt;Quantum Optics 1 : Single Photons&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, I am not certain how relevant the second course might be.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Obviously, this question may benefit from receiving answers in the near future as the topic steadily becomes mainstream.&lt;/p&gt;&#xA;" OwnerUserId="3035" LastEditorUserId="3035" LastEditDate="2018-07-08T16:49:35.583" LastActivityDate="2018-07-13T23:31:04.927" Title="Currently, what are the best structured courses available online on quantum computing?" Tags="&lt;resource-request&gt;" AnswerCount="3" CommentCount="2" FavoriteCount="9" />
  <row Id="2668" PostTypeId="2" ParentId="2664" CreationDate="2018-07-08T16:04:29.700" Score="2" Body="&lt;p&gt;Since this is a homework-type question, I'll just outline the method:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You begin in the state $(\alpha_0|0\rangle + \alpha_1|1\rangle) \otimes \frac{1}{\sqrt{2}}(|00\rangle + |11\rangle)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It can be written as $(\alpha_0|0\rangle_{A1}) \otimes \frac{1}{\sqrt{2}}(|0\rangle_{A2}  |0\rangle_B + |1\rangle_{A2} |1\rangle_{B}) +  (\alpha_1|1\rangle_{A1}) \otimes \frac{1}{\sqrt{2}}(|0\rangle_{A2}  |0\rangle_B + |1\rangle_{A2} |1\rangle_{B})$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Apply the CNOT to qubits $\text{A1}$ and $\text{A2}$. If $\text{A1}$ is in $|0\rangle$, $\text{A2}$ remains unchanged or else it flips. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;You get to the state:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$(\alpha_0|0\rangle_{A1}) \otimes \frac{1}{\sqrt{2}}(|0\rangle_{A2}  |0\rangle_B + |1\rangle_{A2} |1\rangle_{B}) +  (\alpha_1|1\rangle_{A1}) \otimes \frac{1}{\sqrt{2}}(|1\rangle_{A2}  |0\rangle_B + |0\rangle_{A2} |1\rangle_{B})$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then apply the Hadamard gate on $\text{A1}$. Remember that the Hadamard gate maps $|0\rangle_{A1}$ to $\frac{|0\rangle + |1\rangle}{\sqrt 2}$ and $|1\rangle_{A1}$ to $\frac{|0\rangle - |1\rangle}{\sqrt 2}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You finally get to the state shown in the diagram.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note: $\text{A1}$ refers to Alice's first qubit. $\text{A2}$ refers to Alice's second qubit. $\text{B}$ refers to Bob's qubit. &lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-07-08T16:04:29.700" CommentCount="2" />
  <row Id="2669" PostTypeId="2" ParentId="2667" CreationDate="2018-07-08T16:11:03.857" Score="11" Body="&lt;p&gt;I personally took the course &lt;a href=&quot;https://www.edx.org/course/quantum-mechanics-quantum-computation-uc-berkeleyx-cs-191x&quot; rel=&quot;noreferrer&quot;&gt;Quantum Mechanics and Quantum Computation on EdX (UC Berkeley) by Professor Vazirani&lt;/a&gt;. The course is now archived, however, you can still access the lectures &lt;a href=&quot;https://www.youtube.com/playlist?list=PL2jykFOD1AWap0r8WOuZ-08BFgMyx-5RT&quot; rel=&quot;noreferrer&quot;&gt;on YouTube&lt;/a&gt;. It covers the basics of quantum mechanics and gives a nice overview of some of the most popular quantum algorithms. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;About this course (from the course page):&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Quantum computation is a remarkable subject building on the great&#xA;  computational discovery that computers based on quantum mechanics are&#xA;  exponentially powerful. This course aims to make this cutting-edge&#xA;  material broadly accessible to undergraduate students, including&#xA;  computer science majors who do not have any prior exposure to quantum&#xA;  mechanics. The course starts with a simple introduction to the&#xA;  fundamental principles of quantum mechanics using the concepts of&#xA;  qubits (or quantum bits) and quantum gates. This treatment emphasizes&#xA;  the paradoxical nature of the subject, including entanglement,&#xA;  non-local correlations, the no-cloning theorem and quantum&#xA;  teleportation. The course covers the fundamentals of quantum&#xA;  algorithms, including the quantum fourier transform, period finding,&#xA;  Shor's quantum algorithm for factoring integers, as well as the&#xA;  prospects for quantum algorithms for NP-complete problems. It also&#xA;  discusses the basic ideas behind the experimental realization of&#xA;  quantum computers, including the prospects for adiabatic quantum&#xA;  optimization and the D-Wave controversy.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-08T16:33:33.290" LastActivityDate="2018-07-08T16:33:33.290" CommentCount="4" />
  <row Id="2670" PostTypeId="2" ParentId="2654" CreationDate="2018-07-08T17:47:28.290" Score="4" Body="&lt;p&gt;Here is a quick list of notable differences between analog and quantum computers:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Analog computers can't pass Bell tests.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;The state space of an analog computer with N sliders is N dimensional. The state space of a quantum computer with N qubits is $2^N$ dimensional.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Error correct an analog computer and what you've got is a digital computer (i.e. not fundamentally analog anymore). Quantum computers are still quantum after being error corrected.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Analog computers aren't sensitive to decoherence errors. They don't break if you make accidental copies of the data. Quantum computations do break if that happens.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Analog computers can't (efficiently) run Shor's algorithm. Or Grover's algorithm. Or basically any other quantum algorithm.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="119" LastActivityDate="2018-07-08T17:47:28.290" CommentCount="2" />
  <row Id="2671" PostTypeId="1" AcceptedAnswerId="2672" CreationDate="2018-07-08T18:14:05.187" Score="6" ViewCount="338" Body="&lt;p&gt;I am learning to manipulate Qbits and recently I saw the teleportation algorithm. I read about it in two places: &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_teleportation#Formal_presentation&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wikipedia&lt;/a&gt; and &lt;a href=&quot;https://homepages.cwi.nl/~rdewolf/qcnotes.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Lecture Notes from Ronald de Wolf&lt;/a&gt; (Page 7, &lt;strong&gt;1.5 Example: Quantum Teleportation&lt;/strong&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I'd like to understand how to operate with Qbits using linear algebra when an entanglement is present. In this case, we have 3 Qbits.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Qbit 1: in possession of Alice and is going to be teleported to Bob&lt;/li&gt;&#xA;&lt;li&gt;Qbit 2: in possession of Alice&lt;/li&gt;&#xA;&lt;li&gt;Qbit 3: in possession of Bob&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Qbit 2 and 3 are in Bell state: $\frac{1}{\sqrt{2}}(|00\rangle + |11\rangle)$. &#xA;The full state of three Qbits 1, 2, 3 is $(\alpha_0 |0\rangle+\alpha_1|1\rangle) \otimes \frac{1}{\sqrt2}(|00\rangle+|11\rangle)$. In an extended (more painful) notation it would be:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\frac{\alpha_0}{\sqrt2}|000\rangle + 0 \cdot |001\rangle + 0 \cdot|010\rangle+ \frac{\alpha_0}{\sqrt2}|011\rangle + $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\frac{\alpha_1}{\sqrt2}|100\rangle + 0 \cdot|101\rangle + 0 \cdot|110\rangle+ \frac{\alpha_1}{\sqrt2}|111\rangle + $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now I'd like to apply a &lt;strong&gt;CNOT&lt;/strong&gt; gate (Controlled Not) to Qbits 1 and 2, and finally &lt;strong&gt;H&lt;/strong&gt; gate (Hadamard transform) to Qbit 1. I know how &lt;strong&gt;CNOT&lt;/strong&gt; operation affects Qbit 1 and 2, but it's not completely clear how does it affect Qbit 3. I'm wondering what is the $8 \times 8$ Matrix that is applied to the state (in extended notation) when is applied &lt;strong&gt;CNOT&lt;/strong&gt; on Qbit 1 and 2.&lt;/p&gt;&#xA;" OwnerUserId="3037" LastEditorUserId="2293" LastEditDate="2018-07-08T20:24:42.987" LastActivityDate="2018-07-08T20:24:42.987" Title="When you act on a multi-qubit system with a 2-qubit gate, what happens to the third qubit?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-entanglement&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="2672" PostTypeId="2" ParentId="2671" CreationDate="2018-07-08T19:14:41.887" Score="6" Body="&lt;p&gt;Whenever you have a quantum gate (like a CNOT) acting on some qubits but not others, it is assumed that the other qubits are acted on with the identity operator. This is done using the &quot;Left Kronecker product&quot; or the &quot;tensor product&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So the 8x8 matrix is made by applying CNOT to qubits 1 &amp;amp; 2 and the identity matrix to qubit 3:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;\begin{bmatrix}&#xA;    1       &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA;    0       &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\&#xA;    0       &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\&#xA;    0       &amp;amp; 0  &amp;amp; 1 &amp;amp; 0&#xA;\end{bmatrix}\otimes &#xA;\begin{bmatrix}&#xA;1 &amp;amp; 0\\ &#xA;0 &amp;amp; 1&#xA;\end{bmatrix}&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you do: &lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;kron([1 0 0 0 ; 0 1 0 0 ; 0 0 0 1; 0 0 1 0],eye(2))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;in MATLAB or Octave, you get the following 8x8 matrix:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/AegMt.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/AegMt.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Explanation of the code: &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&quot;kron&quot; means &quot;left Kronecker product&quot;&lt;/li&gt;&#xA;&lt;li&gt;The first argument to the &quot;kron&quot; function is the CNOT gate in matrix form&lt;/li&gt;&#xA;&lt;li&gt;The second argument is &quot;eye(2)&quot; which means 2x2 identity &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Here is an example of how to do a &quot;left Kronecker product&quot; without MATLAB:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/502oZ.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/502oZ.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-07-08T19:22:48.697" LastActivityDate="2018-07-08T19:22:48.697" CommentCount="1" />
  <row Id="2673" PostTypeId="2" ParentId="2607" CreationDate="2018-07-08T23:54:10.947" Score="2" Body="&lt;p&gt;Let me attempt to give a rather unconventional answer to this question:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;As a non-mathematician/software programmer I'm trying to grasp&#xA;how QFT (Quantum Fourier Transformation) works.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Suppose that we have a quantum computer which is able to manipulate $n$ qubits. The &lt;em&gt;quantum state&lt;/em&gt; of such a quantum computer precisely describes the current state of this quantum computer. It is pretty well-known that we can express this quantum state as a vector of $2^n$ complex numbers. Let's try to visualize these complex numbers in a compact way.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To that end, consider a horizontal line, on which $2^n$ points are depicted. They are labeled corresponding to their respective position on the line, i.e., the first point is labeled with $|0\rangle$, and the last points is labeled by $|2^n-1\rangle$. We can see this in the picture below.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/hQSOr.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/hQSOr.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, try to picture that at every point, depicted above, this line punctures a circle of radius $1$ right through the middle. That is, there are $2^n$ circles placed exactly at the points depicted above, and the line connects the middles of all these circles. I have tried to depict this in the image below, but my 3D drawing skills are not exactly top-notch, so you will have to excuse me for that.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/DksQu.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/DksQu.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The nice thing of this picture above is that it can uniquely represent the state of any $n$-qubit quantum computer by marking exactly one point in all of the circles. More explicitly, any quantum state of a $n$-qubit quantum computer can be depicted in the above picture by drawing one cross ($\times$) in all of the circles. Conversely, any such drawing represents a quantum state, as long as the squares of the distances of the crosses to the center point sum to $1$. In other words, if we calculate all the distances of the marked points to the center points, then square these distances, and then add them all up, we require that the result equals $1$. An example state is shown below:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/hryjI.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/hryjI.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Throughout the execution of a program, the state of the quantum computer is constantly changing, and as such, so is the visual representation. Hence, throughout the execution of a quantum program, the marked points (the $\times$s), are constantly moving around, within the boundaries of their respective circles.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Within this framework, the Quantum Fourier Transform is just a very specific way to move the marked vertices around. We will make this explicit in the case of a $3$-qubit quantum computer, on which a $3$-qubit Quantum Fourier Transform is executed.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To that end, suppose that we have the $3$-qubit system in the following state, i.e., where the cross is all the way at the edge in the $|0\rangle$ circle, and all the others are exactly at the center. It is an exercise for the OP to check that indeed the square of the distances of the marked points to the center points sum to $1$. We refer to this state as the $|0\rangle$ state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/Bm25S.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/Bm25S.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The question is now what happens to the quantum state when we apply the Quantum Fourier Transform. It turns out that, when the Quantum Fourier Transform is applied to the state shown above, the resulting state of the quantum system becomes:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/Le8vr.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/Le8vr.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here I added the red dashed line passing through all the marked points just for extra convenience. All the marked points are on the exact same location in the circles, namely precisely above the center point at a height of $1/\sqrt{8}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Similarly, we can have a look at the action of the Quantum Fourier Transform on other states. Consider for example the $|1\rangle$ state:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/Lv0AM.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/Lv0AM.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, if we apply the Quantum Fourier Transform, the resulting state becomes:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/4t87o.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/4t87o.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We can see that the resulting state becomes some kind of helix shape. Moreover, observe that if we were to add one extra circle to the right of the rightmost state, then the helix would complete exactly one revolution.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It turns out that the other states behave similarly under the Quantum Fourier Transform, but that the period of the helix changes. More precisely, if we start out with the state $|j\rangle$, then the number of revolutions that the Quantum Fourier Transform makes is $j$. I.e., if we consider the initial state $|3\rangle$, then we obtain the following image under the Fourier transform:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/dc1H7.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/dc1H7.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here, we can easily see that the helix completes $3$ full revolutions if we were to add one more circle on the right hand side.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is important to note that we can also reverse the order of things. That is to say, if we have a quantum computer, whose state can be pictured as a helix, similar to the ones shown above, then we can obtain the period of this helix by implementing the &lt;em&gt;inverse&lt;/em&gt; Quantum Fourier Transform. In doing so, we essentially map the helix with $j$ revolutions to the state $|j\rangle$, which is the exact opposite direction from the mapping we considered before.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is this idea that is the crucial component in Shor's algortihm. The central idea is to take the sequence of numbers you describe:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;7, 4, 13, 1, 7, 4, 13, 1, 7, 4, 13, 1 (etc)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;and use these to create a helix whose period is equal to the period in this sequence. Next, we apply the inverse Quantum Fourier Transform to obtain the state $|4\rangle$, i.e., the period of this sequence.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;NOTE 1: There are a lot of details that I skipped over in the final paragraph. This answer already contains a lot of information, though, which I think needs to sink in before one can attempt to add these details to the picture. If anyone wants me to add these details, I might do so at a later stage.&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;NOTE 2: The OP mentioned that he is not a mathematician. To the mathematicians out there, this visual representation is just an array of $2^n$ unit circles in the complex plane, where the marked points are the representation of the amplitudes as vectors in the complex plane.&lt;/em&gt;&lt;/p&gt;&#xA;" OwnerUserId="24" LastActivityDate="2018-07-08T23:54:10.947" CommentCount="1" />
  <row Id="2674" PostTypeId="1" AcceptedAnswerId="2675" CreationDate="2018-07-09T06:45:15.050" Score="8" ViewCount="107" Body="&lt;p&gt;Entanglement is often discussed as being one of the essential components that makes quantum different from classical. But is entanglement really necessary to achieve a speed-up in quantum computation?&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-07-09T06:45:15.050" Title="Is entanglement necessary for quantum computation?" Tags="&lt;quantum-computer&gt;&lt;quantum-entanglement&gt;&lt;quantum-speedup&gt;" AnswerCount="1" CommentCount="6" FavoriteCount="2" />
  <row Id="2675" PostTypeId="2" ParentId="2674" CreationDate="2018-07-09T06:45:15.050" Score="6" Body="&lt;p&gt;Short answer: yes&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One has to be a little bit more careful setting up the question. Thinking about a circuit as being composed of state preparation, unitaries, and measurements, it is always in principle possible to &quot;hide&quot; anything we want, such as entangling operations, inside the measurement. So, let us be precise. We want to start from a separable state of many qubits, and the final measurements should consist of single-qubit measurements. Does the computation have to transition through an entangled state at some point in the computation?&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;Pure states&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Let's make the one further assumption that the initial state is a pure (product) state. In that case, the system must go through an entangled state. If it didn't, it is easy to simulate the computation on a classical computer because all you have to do is hold $n$ single-qubit pure states in memory, and update them one at a time as the computation proceeds.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One can even ask how much entanglement is necessary. Again, there are many different ways that entanglement can be moved around at different times. A good model that provides a reasonably fair measure of the entanglement present is &lt;a href=&quot;https://en.wikipedia.org/wiki/One-way_quantum_computer&quot; rel=&quot;noreferrer&quot;&gt;measurement-based quantum computation&lt;/a&gt;. Here, we prepare some initial resource state, and it is single-qubit measurements that define the computation that happens. This lets us ask about the entanglement of the resource state. There has to be entanglement and, in some sense, it has to be at least &quot;two-dimensional&quot;, it cannot just be the entanglement generated between nearest neighbours of a system on a line&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0504097&quot; rel=&quot;noreferrer&quot;&gt; [ref]&lt;/a&gt;. Moreover, one can show that most states of $n$ qubits are &lt;a href=&quot;https://arxiv.org/abs/0810.4331&quot; rel=&quot;noreferrer&quot;&gt;too entangled&lt;/a&gt; to permit computation in this way.&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;Mixed states&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;The caveat in all that I've said so far is that we're talking about pure states. For example, we can easily simulate a non-entangling computation on pure product states. But what about mixed states? A mixed state is separable if it can be written in the form&#xA;$$&#xA;\rho=\sum_{i=1}^Np_i\rho^{(1)}_i\otimes\rho^{(2)}_i\otimes\ldots\otimes\rho^{(n)}_i.&#xA;$$&#xA;Importantly, there is no limit on the value $N$, the number of terms in the sum. If the number of terms in the sum is small, then by the previous argument, we can simulate the effects of a non-entangling circuit. But if the number of terms is large, then (to my knowledge) it remains an open question as to whether it can be classically simulated, or whether it can give enhanced computation.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-07-09T06:45:15.050" CommentCount="2" />
  <row Id="2676" PostTypeId="2" ParentId="2595" CreationDate="2018-07-09T06:46:24.143" Score="6" Body="&lt;p&gt;Your primary assertion that the mathematics of waves mimic that of quantum mechanics is the right one. In fact, many of the pioneers of QM used to refer to it as wave mechanics for this precise reason. Then it is natural to ask, &quot; Why can't we do quantum computing with waves ?&quot;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The short answer is that quantum mechanics allows us to work with an exponentially large Hilbert space while spending only polynomial resources. That is, the state space of $n$ qubits is a $2^n$ dimensional Hilbert space.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One cannot construct an exponentially large Hilbert space from polynomially many classical resources. To see why this is the case let us look at two different kinds of wave mechanics based computers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The first way to build such a computer would be to take $n$ number of two-level classical systems. Each system then by itself could be represented by a 2D Hilbert space. For example, one could imagine $n$ guitar strings with only the first two harmonics excited. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This setup will not be able to mimic quantum computing because there is no entanglement. So any state of the system will be a product state and the combined system of $n$  guitar strings cannot be used to make a $2^n$ dimensional Hilbert space.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The second way one could attempt to construct an exponentially large Hilbert space is to use a single guitar sting and to identify its first $2^n$ harmonics with the basis vectors of the Hilbert space. This is done in @DaftWullie 's answer. The problem with this approach is that the frequency of the highest harmonic one needs to excite to make this happen will scale as $O(2^n)$. And since the energy of a vibrating string scales quadratically with its frequency, we will need an exponential amount of energy to excite the string. So in the worst case, the energy cost of the computation can scale exponentially with the problem size. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;So the key point here is that classical systems lack entanglement between physically separable parts. And without entanglement, we cannot construct exponentially large Hilbert spaces with polynomial overhead.&lt;/p&gt;&#xA;" OwnerUserId="2663" LastEditorUserId="26" LastEditDate="2018-08-10T20:06:33.773" LastActivityDate="2018-08-10T20:06:33.773" CommentCount="0" />
  <row Id="2677" PostTypeId="2" ParentId="2595" CreationDate="2018-07-09T10:57:17.773" Score="3" Body="&lt;p&gt;I myself often describe the source of the power of quantum mechanics as being due to 'destructive interference', which is to say the wave-like nature of quantum mechanics. From a standpoint of computational complexity, it is clear that this is one of the most important and interesting features of quantum computation, as &lt;a href=&quot;https://www.scottaaronson.com/democritus/lec9.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Scott Aronson (for example) notes&lt;/a&gt;. But when we describe it in this very brief way  &amp;mdash; that &quot;the power of quantum computation is in destructive interference / the wave-like nature of quantum mechanics&quot; &amp;mdash; it is important to notice that this sort of statement is a short-hand, and necessarily incomplete.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Whenever you make a statement about &quot;the power&quot; or &quot;the advantage&quot; of something, it is important to bear in mind: &lt;em&gt;compared to what&lt;/em&gt;?&#xA;In this case, what we are comparing to is specifically probabilistic computing: and what we have in mind is not just that 'something' is acting like a wave, but specifically that &lt;em&gt;something which is otherwise like a probability&lt;/em&gt; is acting like a wave.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It must be said that probability itself, in the classical world, already does act a bit like a wave: specifically, it obeys a sort of Huygen's Principle (that you can understand the propagation of probabilities of things by summing over the contributions from individual initial conditions &amp;mdash; or in other words, by a &lt;em&gt;superposition principle&lt;/em&gt;). The difference, of course, is that probability is non-negative, and so can only accumulate, and its evolution will be essentially a form of diffusion.&#xA;Quantum computation manages to exhibit wave-like behaviour with probability-like amplitudes, which can be non-positive; and so it is possible to see destructive interference of these amplitudes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In particular, because the things which are acting as waves are things like probabilities, the 'frequency space' in which the system evolves can be exponential in the number of particles you involve in the computation. This general sort of phenomenon is necessary if you want to get an advantage over conventional computation: if the frequency space scaled polynomially with the number of systems, and the evolution itself obeyed a wave equation, the obstacles to simulation with classical computers would be easier to overcome. If you wanted to consider how to achieve similar computational advantages with other kinds of waves, you have to ask yourself how you intend to squeeze in an exponential amount of distinguishable 'frequencies' or 'modes' into a bounded energy space.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Finally, on a practical note, there is a question of fault-tolerance. Another side-effect of the wave-like behaviour being exhibited by probability-like phenomena is that you can perform error correction by testing parties, or more generally, coarse-trainings of marginal distributions. Without this facility, quantum computation would essentially be limited to a form of analog computation, which is useful for some purposes but which is limited to the problem of sensitivity to noise. We do not yet have fault-tolerant quantum computation in built computer systems, but we know that it is possible in principle and we are aiming for it; whereas it is unclear how any similar thing could be achieved with water waves, for instance.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2658/124&quot;&gt;Some&lt;/a&gt; of &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2601/124&quot;&gt;the&lt;/a&gt; &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2598/124&quot;&gt;other&lt;/a&gt; &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2600/124&quot;&gt;answers&lt;/a&gt; touch on this same feature of quantum mechanics: 'wave-particle duality' is a way of expressing the fact that we have something probabilistic about the behaviour of individual particles which are are acting like waves, and remarks about scalability / the exponentially of the configuration space follow from this. But underlying these slightly higher-level descriptions is the fact that we have quantum amplitudes, behaving like elements of a multi-variate probability distribution, evolving linearly with time and accumulating but which can be negative as well as positive.&lt;/p&gt;&#xA;" OwnerUserId="124" LastActivityDate="2018-07-09T10:57:17.773" CommentCount="0" />
  <row Id="2678" PostTypeId="5" CreationDate="2018-07-09T12:17:21.137" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-07-09T12:17:21.137" LastActivityDate="2018-07-09T12:17:21.137" CommentCount="0" />
  <row Id="2679" PostTypeId="4" CreationDate="2018-07-09T12:17:21.137" Score="0" Body="For questions about the Solovay-Kitaev algorithm, a proof that quantum computers can efficiently simulate any 1-qubit quantum gate using a restricted set of quantum gates, as well as the generalisation allowing for the efficient creation of gates with some arbitrarily number of dimensions" OwnerUserId="1386" LastEditorUserId="23" LastEditDate="2018-07-09T17:05:22.197" LastActivityDate="2018-07-09T17:05:22.197" CommentCount="0" />
  <row Id="2680" PostTypeId="5" CreationDate="2018-07-09T13:05:36.720" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-07-09T13:05:36.720" LastActivityDate="2018-07-09T13:05:36.720" CommentCount="0" />
  <row Id="2681" PostTypeId="4" CreationDate="2018-07-09T13:05:36.720" Score="0" Body="Graph-states are a class of quantum state that can be efficiently and uniquely represented by graphs. In the case of qubit graph states, each edge corresponds to a CZ operation applied between two qubits in the +1 X eigenstate. Graph states have a number of useful properties that make them useful objects for the analysis of large quantum systems and play a prominent role in the analysis of quantum computation and communication architectures and protocols." OwnerUserId="391" LastEditorUserId="391" LastEditDate="2018-07-09T17:05:48.737" LastActivityDate="2018-07-09T17:05:48.737" CommentCount="0" />
  <row Id="2682" PostTypeId="1" AcceptedAnswerId="2684" CreationDate="2018-07-09T14:56:27.723" Score="4" ViewCount="162" Body="&lt;p&gt;All the references in this question refer to &lt;a href=&quot;https://arxiv.org/abs/0811.3171&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum algorithm for solving linear systems of equations (Harrow, Hassidim &amp;amp; Lloyd, 2009)&lt;/a&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The question I have is about the step where they apply controlled-rotations to transfer the eigenvalue encoded in a quantum register to the amplitudes of a state:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;After the quantum phase estimation, the state of the quantum registers is (see page 3):&#xA;$$&#xA;\sum_{j=1}^{N} \sum_{k=0}^{T-1} \alpha_{k|j}\beta_j \vert \tilde\lambda_k\rangle \vert u_j \rangle&#xA;$$&#xA;Then, the HHL algorithm consists in applying rotations controlled by $\vert\tilde\lambda_k\rangle$ to produce the state&#xA;$$&#xA;\sum_{j=1}^{N} \sum_{k=0}^{T-1} \alpha_{k|j}\beta_j \vert \tilde\lambda_k\rangle \vert u_j \rangle \left( \sqrt{1 - \frac{C^2}{\tilde\lambda_k^2}} \vert 0 \rangle + \frac{C}{\tilde\lambda_k}\vert 1 \rangle \right)&#xA;$$&#xA;where &quot;$C = O(1/\kappa)$&quot; (still page 3).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;My question&lt;/strong&gt;: why do they introduce $C$? Isn't $C=1$ valid? &lt;/p&gt;&#xA;" OwnerUserId="1386" LastActivityDate="2018-07-09T15:28:32.633" Title="HHL algorithm -- controlled-by-eigenvalues rotations" Tags="&lt;quantum-algorithms&gt;&lt;hhl-algorithm&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2683" PostTypeId="1" AcceptedAnswerId="2685" CreationDate="2018-07-09T15:15:01.957" Score="5" ViewCount="68" Body="&lt;p&gt;&lt;em&gt;See edit at the end of the question&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;All the references in this question refer to &lt;a href=&quot;https://arxiv.org/abs/0811.3171&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum algorithm for solving linear systems of equations (Harrow, Hassidim &amp;amp; Lloyd, 2009)&lt;/a&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;HHL algorithm consists in an application of the quantum phase estimation algorithm (QPE), followed by rotations on an ancilla qubit controlled by the eigenvalues obtained as output of the QPE. The state of the quantum registers after the rotations is&#xA;$$&#xA;\sum_{j=1}^{N} \sum_{k=0}^{T-1} \alpha_{k|j}\beta_j \vert \tilde\lambda_k\rangle \vert u_j \rangle \left( \sqrt{1 - \frac{C^2}{\tilde\lambda_k^2}} \vert 0 \rangle + \frac{C}{\tilde\lambda_k}\vert 1 \rangle \right).&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then, the algorithm just uncomputes the first register containing the eigenvalues ($\vert \tilde\lambda_k \rangle$) to give the state&#xA;$$&#xA;\sum_{j=1}^{N}\beta_j \vert u_j \rangle \left( \sqrt{1 - \frac{C^2}{\lambda_j^2}} \vert 0 \rangle + \frac{C}{\lambda_j}\vert 1 \rangle \right).&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here, the notation used assumes that the QPE was perfect, i.e. the approximations were the exact values.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The next step of the algorithm is to measure the ancilla qubit (the right-most one in the sum above) and to select the output only when the ancilla qubit is measured to be $\vert 1 \rangle$. This process is also called &quot;post-selection&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The state of the system after post-selecting (i.e. after ensuring that the measurement returned $\vert 1 \rangle$) is written&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;\frac{1}{D}\sum_{j=1}^{N}\beta_j \frac{C}{\lambda_j} \vert u_j \rangle &#xA;$$&#xA;where $D$ is a normalisation constant (the exact expression can be found in the HHL paper, page 3).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;My question&lt;/strong&gt;: Why is the $\frac{C}{\lambda_j}$ coefficient still in the expression? From what I understood, measuring &#xA;$$&#xA;\left( \sqrt{1 - \frac{C^2}{\lambda_j^2}} \vert 0 \rangle + \frac{C}{\lambda_j}\vert 1 \rangle \right)&#xA;$$&#xA;should output $\vert 0 \rangle$ or $\vert 1 \rangle$ and destroy the amplitudes in front of those states. &lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;EDIT: Specifying the question.&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Following &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2686/1386&quot;&gt;@glS' answer&lt;/a&gt;, here is the updated question:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Why does the post-selection works like described by &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2686/1386&quot;&gt;@glS' answer&lt;/a&gt; and not like above?&lt;/p&gt;&#xA;" OwnerUserId="1386" LastEditorUserId="1386" LastEditDate="2018-07-09T20:27:22.907" LastActivityDate="2018-07-10T01:18:34.003" Title="HHL algorithm -- problem with the outcome of postselection" Tags="&lt;quantum-algorithms&gt;&lt;hhl-algorithm&gt;&lt;postselection&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="2684" PostTypeId="2" ParentId="2682" CreationDate="2018-07-09T15:21:09.703" Score="4" Body="&lt;p&gt;If $\tilde{\lambda_{k}} &amp;lt; C$, the controlled rotation becomes non-physical since you have coeffecient greater than 1 on your $|1\rangle$ state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As a result $C &amp;lt; \lambda_{min}$ is a safer choice, and that is $O(1/\kappa)$ according to the 4th paragraph in the intro.&lt;/p&gt;&#xA;" OwnerUserId="3056" LastEditorUserId="3056" LastEditDate="2018-07-09T15:28:32.633" LastActivityDate="2018-07-09T15:28:32.633" CommentCount="0" />
  <row Id="2685" PostTypeId="2" ParentId="2683" CreationDate="2018-07-09T15:37:36.833" Score="3" Body="&lt;p&gt;Your intuition is correct for a single qubit, in that if I measure $$\alpha\vert 0 \rangle + \beta\vert 1 \rangle$$ I would get either $\vert 0 \rangle$ or $\vert 1 \rangle$. But since the qubits are in a large entangled state, the relevant information stored in the ratios of different probabilities is still held fixed, and the $\frac{C}{\lambda_j}$ factors are part of that overall coeffecient on each $\vert u_j \rangle$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In essence, you can't think of the process as if you are measuring just &#xA;$$&#xA; \sqrt{1 - \frac{C^2}{\lambda_j^2}} \vert 0 \rangle + \frac{C}{\lambda_j}\vert 1 \rangle &#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;because then you are ignoring the entanglement of the qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;EDIT: To go into more detail. The distiction is between how the one renormalizes after a measurement. So in the beginning if you have a normalized state &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\alpha\vert a\rangle + \beta\vert b\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;and you measure it and get $\vert b \rangle$, you are essentially saying that &quot;My measurement returned b, so only states which are consistent with my measurement can exist&quot; and then normalizing the superposition of all of those states. But only $\vert b\rangle$ is consistent and as such you end up with it, and a prefactor of 1 out front. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;However imagine an entagled state of the following:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\alpha_{00}\vert 00\rangle + \alpha_{01}\vert 01\rangle + \alpha_{10}\vert 10\rangle + \alpha_{11}\vert 11\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If I measure the first qubit and get $\vert 0\rangle$, there are two states, $\vert 01\rangle$ and $\vert 00\rangle$ which are consistent, and so your state must be a superposition of those two. In this example that leads to a final state of &#xA;$$A\left(\alpha_{00}\vert 00\rangle + \alpha_{01}\vert 01\rangle\right)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;where A is the overall factor to bring the normalization back to 1. The important thing to see is that the ratio between the two remaining probabilities remains constant at $\alpha_{00}/\alpha_{01}$. This ratio would, in the HHL example, be the factors containing different $\frac{C}{\lambda_j}$ values, and as such they must remain. Physically this correspond to the states which are &quot;still viable&quot; being unaltered relative to eachother, which those which have now been ruled out have their probability set to 0.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In terms of more natural language, imagine I give you 4 scenarios and their likelihoods. If I was to specify their relative probabilities, and then rule out 2 of them, it should be natural that the two which have not been ruled out would still have the same relative probability, as whatever extra information has been added was already assumed in order for those scenarios to have been true. &lt;/p&gt;&#xA;" OwnerUserId="3056" LastEditorUserId="3056" LastEditDate="2018-07-10T01:18:34.003" LastActivityDate="2018-07-10T01:18:34.003" CommentCount="4" />
  <row Id="2686" PostTypeId="2" ParentId="2683" CreationDate="2018-07-09T15:39:13.777" Score="2" Body="&lt;p&gt;You are half right, in that the $C$ factor is only kept there for (what I assume being) explanatory purposes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, the $1/\lambda_j$ factors definitely stays there after postselection. One way to see this is that you can think of those factors as attached to the other registers, so that the state is equivalently written as&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;\left(\sum_j\beta_j\sqrt{1-\frac{C^2}{\lambda_j^2}} |u_j\rangle\right)|0\rangle +&#xA;\left(\sum_j\beta_j\frac{C}{\lambda_j} |u_j\rangle\right)|1\rangle.\tag1&#xA;$$&#xA;Keeping only the term on the right we get a normalised version of &#xA;$$\sum_j\beta_j\frac{C}{\lambda_j} |u_j\rangle|1\rangle.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As an analogy, it's like having the state&#xA;$$(a|0\rangle+b|1\rangle)|0\rangle.$$&#xA;By your reasoning, postselecting on $|0\rangle$ (which here trivially happens with 100% probability) should lead to something like $|0\rangle+|1\rangle$, which is clearly not correct.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Stated in yet another way, you are basically applying the measurement postulate wrong.&#xA;The state remaining after postselection is the sum of all states with ancilla in the state $|1\rangle$, which results in (1). The factors disappear only if you consider postselection over the ancilla alone, which neglects the fact that the ancilla is entangled with the other registers.&#xA;Mathematically, you can see it in the fact that the postselected state is the one obtained applying the projector $\mathbb 1\otimes |1\rangle\langle1|$, and renormalizing the result.&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-07-09T20:28:22.957" LastActivityDate="2018-07-09T20:28:22.957" CommentCount="3" />
  <row Id="2687" PostTypeId="2" ParentId="2667" CreationDate="2018-07-09T15:45:43.410" Score="4" Body="&lt;p&gt;If you are looking for reading material instead of videos, I read &lt;a href=&quot;http://www.theory.caltech.edu/people/preskill/ph229/&quot; rel=&quot;nofollow noreferrer&quot;&gt;John Preskill's Lecture Notes&lt;/a&gt; in undergrad to learn more about the subject, and thought they were really informative and well developed. They were initially written in 1997, but have modern updates from 2015. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;From the website:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Course Description&lt;/p&gt;&#xA;  &#xA;  &lt;blockquote&gt;&#xA;    &lt;p&gt;The theory of quantum information and quantum computation. Overview of classical information theory, compression of quantum information, transmission of quantum information through noisy channels, quantum entanglement, quantum cryptography. Overview of classical complexity theory, quantum complexity, efficient quantum algorithms, quantum error-correcting codes, fault-tolerant quantum computation, physical implementations of quantum computation.&lt;/p&gt;&#xA;  &lt;/blockquote&gt;&#xA;  &#xA;  &lt;p&gt;Prerequisites&lt;/p&gt;&#xA;  &#xA;  &lt;blockquote&gt;&#xA;    &lt;p&gt;The course material should be of interest to physicists, mathematicians, computer scientists, and engineers, so we hope to make the course accessible to people with a variety of backgrounds.&lt;/p&gt;&#xA;    &#xA;    &lt;p&gt;Certainly it would be useful to have had a previous course on quantum mechanics, though this may not be essential. It would also be useful to know something about (classical) information theory,  (classical) coding theory,  and (classical) complexity theory, since a central goal of the course will be generalize these topics to apply to quantum information. But we will review this material when we get to it, so you don't need to worry if you haven't seen it before. In the discussion of quantum coding, we will use some rudimentary group theory.&lt;/p&gt;&#xA;  &lt;/blockquote&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="3056" LastActivityDate="2018-07-09T15:45:43.410" CommentCount="0" />
  <row Id="2688" PostTypeId="1" CreationDate="2018-07-09T22:03:05.570" Score="7" ViewCount="89" Body="&lt;p&gt;I am relatively new to quantum computing and I feel like I don't fully understand the power of quantum computing due to a lack of understanding of how amplitude amplification works. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;What is confusing me is that the amplitude of the qubit is the square root of the probability and so in amplitude amplification, how is the amplitude of the &quot;correct answer&quot; changed to negative (before then being reflected across the average)? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I understand that it is a gate and the gate is a series of complex operations but at the same time I fail to understand physically how do the gates change the amplitude of the qubit. I am referencing this in response to the webpage: &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/proxy/tutorial/full-user-guide/004-Quantum_Algorithms/070-Grover&amp;#39;s_Algorithm.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;IBM Q Experience Documentation - Grover's algorithm&lt;/a&gt;. Any help is greatly appreciated. Thank you!&lt;/p&gt;&#xA;" OwnerUserId="3061" LastEditorUserId="1386" LastEditDate="2018-07-10T02:04:36.797" LastActivityDate="2018-07-10T15:14:47.850" Title="In amplitude amplification, how are the amplitudes of qubits changed?" Tags="&lt;grovers-algorithm&gt;" AnswerCount="1" CommentCount="1" FavoriteCount="1" />
  <row Id="2689" PostTypeId="2" ParentId="2688" CreationDate="2018-07-10T04:32:25.260" Score="2" Body="&lt;p&gt;EDIT: I completely misunderstood your question and thought that you were confused about what a negative amplitude means, and not about physical mechanisms. I'm leaving this up in case that actually was what you meant. whoops. For the implementation question, how a reflection is implemented physically depends on the qubit implementation you are using.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I think the main confusion you're having is from thinking about the relationship between amplitudes and probabilities in the wrong direction.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You say that the amplitudes are the square root of the probability, but a safer way of thinking, which might help in building intuition, is to say that the amplitude norm squared is the probability.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ \vert A\vert^2 = P$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;if this is inverted in its most general form, you get&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$A = \sqrt{P} e^{i\theta}$$ for some $\theta$. This additional phase is where your confusion is coming from, as it allows for both negative amplitudes as you are encountering in your example, as well as in many other very important states like &#xA;$$H\vert 1 \rangle = \vert -\rangle = \frac{1}{\sqrt{2}}\vert 0\rangle - \frac{1}{\sqrt{2}}\vert 1\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Without this possibility for negative states, quantum mechanical phenomena like constructive and destructive interference of wave functions would be impossible.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Hope that helps!&lt;/p&gt;&#xA;" OwnerUserId="3056" LastEditorUserId="3056" LastEditDate="2018-07-10T15:14:47.850" LastActivityDate="2018-07-10T15:14:47.850" CommentCount="2" />
  <row Id="2690" PostTypeId="1" AcceptedAnswerId="2702" CreationDate="2018-07-10T05:05:21.303" Score="3" ViewCount="191" Body="&lt;p&gt;In a recent question about &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2595/if-quantum-speed-up-is-due-to-the-wave-like-nature-of-quantum-mechanics-why-not&quot;&gt;quantum speed-up&lt;/a&gt; @DaftWullie &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2613/2645&quot;&gt;says&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;My research, for example, is very much about &quot;how do we design Hamiltonians $H$ so that their time evolution $e^{-iHt_0}$ creates the operations that we want?&quot;, aiming to do everything we can in a language that is &quot;natural&quot; for a given quantum system, rather than having to coerce it into performing a whole weird sequence of quantum gates.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;This makes me think of &lt;a href=&quot;https://en.wikipedia.org/wiki/Chronon&quot; rel=&quot;nofollow noreferrer&quot;&gt;chronons&lt;/a&gt;, which are a &lt;a href=&quot;http://samvak.tripod.com/time.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;proposed&lt;/a&gt; quantum of time. &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;There are physical limits that prevent the distinction of arbitrarily close successive states in the time evolution of a quantum system. &lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;If a discretization is to be introduced in the description of a quantum system, it cannot possess a universal value, since those limitations depend on the characteristics of the particular system under consideration. In other words, the value of the fundamental interval of time has to change a priori from system to system.&quot;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/9706059&quot; rel=&quot;nofollow noreferrer&quot;&gt;Introduction of a Quantum of Time&lt;/a&gt; (&quot;chronon&quot;), and its Consequences for Quantum Mechanics&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Is universal chrononic computing possible?&lt;/strong&gt;&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-07-11T13:19:31.200" LastActivityDate="2018-08-17T03:09:21.093" Title="Chrononic Computing (Time Evolution Systems)" Tags="&lt;quantum-computer&gt;&lt;quantum-computing-models&gt;" AnswerCount="2" CommentCount="6" FavoriteCount="1" />
  <row Id="2691" PostTypeId="1" AcceptedAnswerId="2709" CreationDate="2018-07-10T07:05:52.297" Score="6" ViewCount="132" Body="&lt;p&gt;It seems that quantum computers can be classified by the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum&quot; rel=&quot;nofollow noreferrer&quot;&gt;type of quantum&lt;/a&gt; they operate on. Not entirely sure what category most common current systems fall into (eg. D-Wave, Google, IBM, Microsoft).  Photonic computing seems to be one of the more 'popular' alternative methods. Curious about other forms of &lt;a href=&quot;https://en.wikipedia.org/wiki/Unconventional_computing&quot; rel=&quot;nofollow noreferrer&quot;&gt;unconventional&lt;/a&gt; quantum computing.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quasiparticle#Examples_of_quasiparticles_and_collective_excitations&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quasi&lt;/a&gt; interested in a few &lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_quasiparticles&quot; rel=&quot;nofollow noreferrer&quot;&gt;different cases&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Phonon - sound based&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Roton - vortex based&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Dropleton - quantum droplet&lt;a href=&quot;https://en.wikipedia.org/wiki/Dropleton&quot; rel=&quot;nofollow noreferrer&quot;&gt;*&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Fracton - fractal analog of phonons&lt;a href=&quot;https://en.wikipedia.org/wiki/Fracton&quot; rel=&quot;nofollow noreferrer&quot;&gt;*&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Plasmon - plasma based&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Also curious about &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2690/chrononic-computing-quantum-computing-w-chronons&quot;&gt;chronons&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://en.wikipedia.org/wiki/Virtual_particle&quot; rel=&quot;nofollow noreferrer&quot;&gt;virtual particles&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Have significant breakthroughs in quantum computing been made using non-standard quanta?&lt;/strong&gt;&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="23" LastEditDate="2018-07-19T12:56:09.077" LastActivityDate="2018-07-19T12:56:09.077" Title="Breakthroughs in quantum computing using non-standard quanta" Tags="&lt;quantum-computer&gt;&lt;quantum-information&gt;&lt;experimental-results&gt;&lt;quantum-technologies&gt;&lt;anyons&gt;" AnswerCount="2" CommentCount="9" FavoriteCount="1" ClosedDate="2018-07-16T18:41:08.907" />
  <row Id="2692" PostTypeId="1" CreationDate="2018-07-10T08:19:05.793" Score="5" ViewCount="70" Body="&lt;p&gt;As in the title, I have a doubt regarding the implementation of a boolean formula used as an oracle for a quantum algorithm.&#xA;The problem is that so far I could reproduce the formula as a quantum circuit relatively easily and then solve the related SAT using Grover search. However, if for instance I have 8 variables, I would need more or less twice the number of qubits to reproduce the formula (8 for introducing the variables, the others as workspace to perform the logic operations). Even though Grover search allows a quadratic speed up, I feel that implementing the oracle in this classical way is still a big hindrance in terms of qubits needed, given the fact that they are limited to small amounts.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am trying to see if it is possible to encapsulate the 8 variables in 3 qubits so that using a Walsh-Hadamard transform I would have a superposition with $2^3=8$ possible states. 2 problems arise:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1) How could i perform the logical operations needed to represent the boolean formula?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2) Given a single qubit, I can look at it as a variable and assign true and false values to the states $\left|1\right&amp;gt;$ and $\left|0\right&amp;gt;$ respectively; however, if I use multiple qubits and put all of them in a superposition, when assigning each state to a specific variable I can no longer see if they are true or false by looking at the output states! How could I decide a true/false output in this case?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Do you guys think this is something feasible? I feel I am missing a key point in the process.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For instance $\left(x_1\cdot x_2\right)+\left(x_3\cdot x_1\cdot x_4\right)+\left(x_5\cdot x_6\right)$, where every variable $x_i \in \left\lbrace 0,1\right\rbrace$ and &quot; $\cdot$ &quot; stands for the logic AND operation and &quot;$+$&quot; for the logic OR. &lt;/p&gt;&#xA;" OwnerUserId="2648" LastEditorUserId="23" LastEditDate="2018-07-11T09:00:44.313" LastActivityDate="2018-07-11T09:00:44.313" Title="Compact encoding of Boolean formula as oracle" Tags="&lt;quantum-algorithms&gt;&lt;quantum-entanglement&gt;&lt;qubit-state&gt;&lt;quantum-speedup&gt;&lt;superposition&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="2" />
  <row Id="2693" PostTypeId="2" ParentId="2651" CreationDate="2018-07-10T09:59:33.603" Score="0" Body="&lt;p&gt;In &lt;a href=&quot;https://www.researchgate.net/publication/49751841_Verifying_Genuine_High-Order_Entanglement?_sg=EMjw2Jt54efwaihq3BCmAnkPUnwDg7x075lZmU-0x5tjFm1J9bXMWMx1CPI2ooEh6ir6OPcZrg&quot; rel=&quot;nofollow noreferrer&quot;&gt;Verifying Genuine High-Order Entanglement&lt;/a&gt; the following graphs represent entangled qudits&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/AIypU.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/AIypU.png&quot; alt=&quot;10-qudit state&quot;&gt;&lt;/a&gt;&#xA;&lt;a href=&quot;https://i.stack.imgur.com/e3U1O.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/e3U1O.png&quot; alt=&quot;qudit graph states&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;In &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1641/2645&quot;&gt;an answer&lt;/a&gt; to 'Alternative to Bloch sphere to represent a single qubit' @Rob references &lt;a href=&quot;https://arxiv.org/abs/1703.06102&quot; rel=&quot;nofollow noreferrer&quot;&gt;Majorana representation, qutrit Hilbert space and NMR implementation of qutrit gates&lt;/a&gt; which states&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The Majorana representation for spin−$s$ systems has found widespread applications such as determining geometric phase of spins, representing $N$ spinors by $N$ points, geometrical representation of multi-qubit entangled states, statistics of chaotic quantum dynamical systems and characterizing polarized light. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The paper also includes this style of representation for qudits&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/5a7HX.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/5a7HX.jpg&quot; alt=&quot;majorana representation&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;I recently asked about how to &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2456/how-to-represent-a-qubyte&quot;&gt;visually represent a qubyte&lt;/a&gt;. In the comments of @DaftWullie's answer I proposed an 8-cube (&lt;a href=&quot;https://en.wikipedia.org/wiki/Hypercube#Graphs&quot; rel=&quot;nofollow noreferrer&quot;&gt;hypercube graph&lt;/a&gt;):&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/UivIl.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/UivIl.png&quot; alt=&quot;8-cube&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;An n-cube can be projected inside a regular 2n-gonal polygon by a skew orthogonal projection&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;This method seems to allow for the &lt;a href=&quot;https://upload.wikimedia.org/wikipedia/commons/2/2f/13-cube.svg&quot; rel=&quot;nofollow noreferrer&quot;&gt;complexity&lt;/a&gt; of entanglement to be visualized in a scalable fashion.&lt;/p&gt;&#xA;" OwnerUserId="2645" LastActivityDate="2018-07-10T09:59:33.603" CommentCount="3" />
  <row Id="2694" PostTypeId="2" ParentId="2654" CreationDate="2018-07-10T10:30:53.910" Score="0" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Have we fallen into the same 'everything digital' bandwagon trap that keeps recurring?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;What I have noticed is more the 'everything binary' bandwagon trap; which reminds me of the &lt;a href=&quot;https://www.snopes.com/fact-check/grandmas-cooking-secret/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Grandma's cooking secret&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Once upon a time, a mother was teaching her daughter the family recipe for making a whole baked ham. It was the very best ham anybody had ever had so they always followed that recipe carefully.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;They prepared the marinade, scored the skin, put in the cloves, and then came a step the daughter didn't understand.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&quot;Why do we cut off the ends of the ham?&quot; she said. &quot;Doesn't that make it dry out?&quot;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&quot;You know, I don't know,&quot; said the mother. &quot;That's just the way grandma taught me. We should call grandma and ask.&quot;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;So they called grandma and asked, &quot;why do we cut off the ends of the ham? Is it to let the marinade in, or what?&quot;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&quot;No,&quot; said Grandma. &quot;To be honest, I cut the ends off because that's how my mother taught me. I added the marinade step later, because I was worried about the ham drying out. Let's call great grandma and ask her.&quot;&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;So they called the assisted living facility where great grandma was living, and the old woman listend to their questions, and then said.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;&quot;Oh, for land sakes! I cut off the ends because I didn't have a pan big enough for a whole ham!&quot;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;I was recently thinking about qubytes &amp;amp; wondering if they really needed to be defined as 8 qubits. An 8-level quantum system (qunit) would have an &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2417/2645&quot;&gt;8 dimensional space&lt;/a&gt; &amp;amp; could in theory encode a byte (8 bits). Is this a better definition of a qubyte (quantum byte)? &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Or is it all a problem of folk having no real idea how to program the beasts.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="2645" LastActivityDate="2018-07-10T10:30:53.910" CommentCount="2" />
  <row Id="2695" PostTypeId="2" ParentId="2690" CreationDate="2018-07-10T12:34:10.867" Score="-4" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Is universal chrononic computing possible?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;No. That's because there are no time quanta. I should explain I suppose:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are &lt;em&gt;electromagnetic&lt;/em&gt; quanta in the form of virtual photons, but these are not actual photons. See &lt;a href=&quot;https://physics.stackexchange.com/a/185139/76162&quot;&gt;this physics&lt;/a&gt; answer by anna v, a retired particle physicist. Note this: &lt;em&gt;&quot;virtual particles exist only in the mathematics of the model&quot;&lt;/em&gt;. Hence while you may see people  on the Discovery Channel saying photons flit back and forth between the electron and the proton in the hydrogen atom, actually, they don't. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Real photons have a quantum nature which is to do with &lt;a href=&quot;https://en.wikipedia.org/wiki/Planck_constant&quot; rel=&quot;nofollow noreferrer&quot;&gt;Planck's constant&lt;/a&gt; of action h in E=hf. No problem there. Then when you're considering the electron and the proton, you can divvy up each electromagnetic field and treat each portion thereof as if it was a photon. Then when the electron and the proton move towards one another you can say they &quot;exchange field&quot; such that the resulting hydrogen atom has no electromagnetic field to speak of. Hence the exchange mechanism* looks reasonable. But there are no photons flying back and forth. Virtual particles are &lt;em&gt;virtual&lt;/em&gt;, as in not real. They aren't short-lived real particles that pop in and out of existence like magic, and they aren't the same thing as vacuum fluctuations. Hydrogen atoms don't twinkle!   &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Anyway, there are no electromagnetic quanta the way they're portrayed in the popular press, and there's absolutely no evidence of any time quanta either. A photon doesn't approach you in steps. Bubble-chamber pictures do not consist of dotted lines. See the Wikipedia &lt;a href=&quot;https://en.wikipedia.org/wiki/Talk%3AChronon&quot; rel=&quot;nofollow noreferrer&quot;&gt;talk page&lt;/a&gt; to appreciate just how speculative the chronon is. So no, universal chrononic computing is not possible.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;*As an aside, take a look at &lt;a href=&quot;http://sci-hub.tw/10.1016/1355-2198(95)00021-6&quot; rel=&quot;nofollow noreferrer&quot;&gt;the peculiar notion of exchange forces part I&lt;/a&gt; and &lt;a href=&quot;http://sci-hub.tw/10.1016/1355-2198(95)00003-8&quot; rel=&quot;nofollow noreferrer&quot;&gt;part II&lt;/a&gt; by Cathryn Carson dating from 1996. She says &lt;em&gt;“for such a central concept, the historical origins of exchange forces are distinctly unclear”&lt;/em&gt;. She refers to a 1927 chemistry &lt;a href=&quot;http://sci-hub.tw/10.1142/9789812795762_0009&quot; rel=&quot;nofollow noreferrer&quot;&gt;paper&lt;/a&gt; by Walter Heitler and Fritz London &lt;a href=&quot;http://www.worldscientific.com/doi/abs/10.1142/9789812795762_0009&quot; rel=&quot;nofollow noreferrer&quot;&gt;on the interaction between neutral atoms and homopolar binding according to quantum mechanics&lt;/a&gt;. And to a 1928 magnetism paper by Heisenberg &lt;a href=&quot;http://www.neo-classical-physics.info/uploads/3/4/3/6/34363841/heisenberg_-_on_the_theory_of_ferromagnetism.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;on the theory of ferromagnetism&lt;/a&gt;. She says the exchange-particle idea began to work its way into QED from the mid-to-late 1930s. And that Heisenberg’s importation of exchange forces into nuclear physics depended essentially on a model of the neutron that was later retracted. She says &lt;em&gt;“the idea now taken as definitional of the concept of force - for quantum field theory, the all-important idea of particle exchange - was not in fact there from the start, but rather worked its way in from somewhere outside”&lt;/em&gt;. Interesting stuff. &lt;/p&gt;&#xA;" OwnerUserId="1905" LastEditorUserId="1905" LastEditDate="2018-07-11T12:55:25.680" LastActivityDate="2018-07-11T12:55:25.680" CommentCount="13" />
  <row Id="2696" PostTypeId="2" ParentId="2691" CreationDate="2018-07-10T15:20:21.293" Score="0" Body="&lt;p&gt;I'm not sure if you count adiabatic quantum computing as fringe, but there was a &lt;a href=&quot;https://arxiv.org/pdf/1806.03295.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;paper&lt;/a&gt; using 4 NMR qubits to implement a adiabatic analogue to HHL which allowed them to invert an 8x8 operator with 98.4% fidelity which got put on arXiv a couple weeks ago. I thought that was pretty neat.&lt;/p&gt;&#xA;" OwnerUserId="3056" LastEditorUserId="3056" LastEditDate="2018-07-10T15:44:07.833" LastActivityDate="2018-07-10T15:44:07.833" CommentCount="5" />
  <row Id="2697" PostTypeId="1" CreationDate="2018-07-10T15:42:37.447" Score="12" ViewCount="217" Body="&lt;p&gt;&lt;sup&gt; Note on the vocabulary: the word &quot;hamiltonian&quot; is used in this question to speak about hermitian matrices.&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;The HHL algorithm seems to be an active subject of research in the field of quantum computing, mostly because it solve a very important problem which is finding the solution of a linear system of equations.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;According to the original paper &lt;a href=&quot;https://arxiv.org/abs/0811.3171&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum algorithm for solving linear systems of equations (Harrow, Hassidim &amp;amp; Lloyd, 2009)&lt;/a&gt; and some questions asked on this site&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2604/quantum-phase-estimation-and-hhl-algorithm-knowledge-on-eigenvalues-required&quot;&gt;Quantum phase estimation and HHL algorithm - knowledge on eigenvalues required?&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2439/quantum-algorithm-for-linear-systems-of-equations-hhl09-step-2-preparation&quot;&gt;Quantum algorithm for linear systems of equations (HHL09): Step 2 - Preparation of the initial states $\vert \Psi_0 \rangle$ and $\vert b \rangle$&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;the HHL algorithm is limited to some specific cases. Here is a summary (that may be incomplete!) of the characteristics of the HHL algorithm:&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h1&gt;HHL algorithm&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;The HHL algorithm solves a linear system of equation&#xA;$$A \vert x \rangle = \vert b \rangle$$&#xA;with the following limitations:&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Limitations on $A$:&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$A$ needs to be Hermitian (and only Hermitian matrix works, see &lt;a href=&quot;https://chat.stackexchange.com/transcript/message/45511015#45511015&quot;&gt;this discussion in the chat&lt;/a&gt;).&lt;/li&gt;&#xA;&lt;li&gt;$A$'s eigenvalues needs to be in $[0,1)$ (see &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2604/quantum-phase-estimation-and-hhl-algorithm-knowledge-on-eigenvalues-required&quot;&gt;Quantum phase estimation and HHL algorithm - knowledge on eigenvalues required?&lt;/a&gt;)&lt;/li&gt;&#xA;&lt;li&gt;$e^{iAt}$ needs to be efficiently implementable. At the moment the only known matrices that satisfy this property are:&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;local hamiltonians (see &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.654.7909&amp;amp;rep=rep1&amp;amp;type=pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Universal Quantum Simulators (Lloyd, 1996)&lt;/a&gt;).&lt;/li&gt;&#xA;&lt;li&gt;$s$-sparse hamiltonians (see &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0301023v2&quot; rel=&quot;nofollow noreferrer&quot;&gt;Adiabatic Quantum State Generation and Statistical Zero Knowledge (Aharonov &amp;amp; Ta-Shma, 2003)&lt;/a&gt;).&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;Limitations on $\vert b \rangle$:&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$\vert b \rangle$ should be efficiently preparable. This is the case for:&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Specific expressions of $\vert b \rangle$. For example the state $$\vert b \rangle = \bigotimes_{i=0}^{n} \left( \frac{\vert 0 \rangle + \vert 1 \rangle}{\sqrt{2}} \right)$$&#xA;is efficiently preparable.&lt;/li&gt;&#xA;&lt;li&gt;$\vert b \rangle$ representing the discretisation of an efficiently integrable probability distribution (see &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0208112&quot; rel=&quot;nofollow noreferrer&quot;&gt;Creating superpositions that correspond to efficiently integrable probability distributions (Grover &amp;amp; Rudolph, 2002)&lt;/a&gt;).&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;Limitations on $\vert x \rangle$ (output):&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$\vert x \rangle$ cannot be recovered fully by measurement. The only information we can recover from $\vert x \rangle$ is a &quot;general information&quot; (&quot;expectation value&quot; is the term employed in the original HHL paper) such as $$\langle x\vert M\vert x \rangle$$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; &#xA;Taking into account &lt;strong&gt;all&lt;/strong&gt; of these limitations and imagining we are in 2050 (or maybe in 2025, who knows?) with fault-tolerant large-scale quantum chips (i.e. we are not limited by the hardware), what real-world problems could HHL algorithm solve (including problems where HHL is only used as a subroutine)?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am aware of the paper &lt;a href=&quot;https://arxiv.org/abs/1505.06552&quot; rel=&quot;nofollow noreferrer&quot;&gt;Concrete resource analysis of the quantum linear system algorithm used to compute the electromagnetic scattering cross section of a 2D target (Scherer, Valiron, Mau, Alexander, van den Berg &amp;amp; Chapuran, 2016)&lt;/a&gt; and of the &lt;a href=&quot;https://www.mathstat.dal.ca/~selinger/quipper/doc/Algorithms-QLS-Main.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;corresponding implementation&lt;/a&gt; in the &lt;a href=&quot;https://www.mathstat.dal.ca/~selinger/quipper/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quipper programming language&lt;/a&gt; and I am searching for other real-world examples where HHL would be applicable in practice. I do not require a published paper, not even an unpublished paper, I just want to have some examples of &lt;em&gt;real-world&lt;/em&gt; use-cases.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;EDIT: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Even if I am interested in every use-case, I would prefer some examples where HHL is directly used, i.e. not used as a subroutine of an other algorithm. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am even more interested in examples of linear systems resulting of the discretisation of a differential operator that could be solved with HHL. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;But let me emphasise one more time &lt;strong&gt;I'm interested by every use-case (subroutines or not) you know about&lt;/strong&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1386" LastEditorUserId="1386" LastEditDate="2018-07-13T13:38:46.667" LastActivityDate="2018-07-20T11:20:36.070" Title="What could be the possible future applications for HHL algorithm?" Tags="&lt;quantum-algorithms&gt;&lt;hhl-algorithm&gt;&lt;applications&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="2" />
  <row Id="2698" PostTypeId="1" CreationDate="2018-07-10T16:37:21.980" Score="5" ViewCount="46" Body="&lt;p&gt;In (&lt;a href=&quot;https://arxiv.org/abs/1307.0401&quot; rel=&quot;noreferrer&quot;&gt;Lloyd et al. 2013&lt;/a&gt;), the authors write (beginning of page 3) that the quantum matrix inversion techniques presented by some of the same authors in (&lt;a href=&quot;https://arxiv.org/abs/0811.3171&quot; rel=&quot;noreferrer&quot;&gt;Harrow et al. 2008&lt;/a&gt;) allow to efficiently implement $e^{-ig(\rho)}$ for any &lt;em&gt;simply computable&lt;/em&gt; function $g(x)$, using multiple copies of the density matrix $\rho$ &lt;em&gt;(see &lt;strong&gt;(1)&lt;/strong&gt; below for a bit more context)&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Given that (&lt;a href=&quot;https://arxiv.org/abs/0811.3171&quot; rel=&quot;noreferrer&quot;&gt;Harrow et al. 2008&lt;/a&gt;) presents a quantum algorithm to obtain a state $|x\rangle$ proportional to $A^{-1}|b\rangle$ for a given $A$ and $|b\rangle$, it doesn't seem obvious to me how this can be used to compute $e^{-ig(\rho)}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To which techniques exactly are the authors referring to? And how are they applied to get the stated result?&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;(1)&lt;/strong&gt; &#xA;More precisely, in the (&lt;a href=&quot;https://arxiv.org/abs/1307.0401&quot; rel=&quot;noreferrer&quot;&gt;Lloyd et al. 2013&lt;/a&gt;) paper, before making the statement that is the object of this question, the authors describe a method to construct $e^{-i\rho t}$, to accuracy $\epsilon$, using $n$ copies of $\rho$ with $n=O(t^2 \epsilon^{-1})$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Moreover, what is meant by &lt;em&gt;simply computable function&lt;/em&gt; does not seem to be explained in the paper.&lt;/p&gt;&#xA;" OwnerUserId="55" LastActivityDate="2018-07-11T07:17:21.397" Title="Why does the quantum linear inversion algorithm allow to implement $e^{-ig(\rho)}$ efficiently using multiple copies of $\rho$?" Tags="&lt;quantum-algorithms&gt;&lt;hhl-algorithm&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2699" PostTypeId="2" ParentId="2553" CreationDate="2018-07-10T18:17:45.280" Score="0" Body="&lt;p&gt;Of course you can allocate qubits from C#! After all, Q# compiles to C#, so it's not possible for something to be doable &lt;em&gt;only&lt;/em&gt; from Q#.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://tio.run/##tZLBTsMwDIbPzVNYYlK3Q5NtCIRgcBuI05jEDe2QpW4XrU3SxB0a0GcfbacBRyTEwVGc3/ZnR34Lm4OSBHfgvM29LHkVYDaL54v7@CDE8gweLAbQBmijA2Qai5QzZmSJwUmF8Py4YO8ssg69JG0NzA35/ZPVhoYjuIb2aOVobdN9f4nqoE0OQ4@5DoQebmFZrzW9TFfHyCgq9wv3pY9uureG9dYwFmW1UT2oD6u63NByjkVWJ2TDmkM7A0stGSQQ1pEotfI22IzExpYouKlzJNFOsZU5hm@ZV7U0VJc8xR0W1pVoiG81iTGf8snV@JJPLsbnifO40/gqyNoiiCqoznhaFJAkHjP0aFT7dYNhpk36rx0Ueg0fkHt0ELf8QTz6G1VJY83vWUmijavpxwYx1u3Uyc@5CodP&quot; rel=&quot;nofollow noreferrer&quot;&gt;Here's a small script I wrote that will show you the C# generated from a Q# file.&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The relevant bit is &lt;code&gt;Allocate.Apply&lt;/code&gt;, which allocates the qubits, and you can read the rest of the produced code to see where &lt;code&gt;Allocate&lt;/code&gt; comes from.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;With that in mind, &lt;em&gt;should&lt;/em&gt; you be allocating qubits from C#? Well, no, probably not. It's annoyingly difficult, and it's best to leave the quantum stuff for a quantum language.&lt;/p&gt;&#xA;" OwnerUserId="70" LastEditorUserId="70" LastEditDate="2018-07-10T18:29:23.843" LastActivityDate="2018-07-10T18:29:23.843" CommentCount="0" />
  <row Id="2701" PostTypeId="2" ParentId="2698" CreationDate="2018-07-11T07:12:04.267" Score="1" Body="&lt;p&gt;One way to go about this is using the Linear Combination of Unitaries (LCU) algorithm. The LCU algorithm simulates the action of any operator that can be written as a linear combination of simulatable unitary operators. A full treatment of this can be found in &lt;a href=&quot;https://uwspace.uwaterloo.ca/bitstream/handle/10012/8625/Kothari_Robin.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Kothari's thesis&lt;/a&gt;. Using LCU algorithm, given the ability to apply $e^{i \rho t}$ to the state, the action of $f(\rho)$ on a state can be simulated. You do this by first writing $f(\rho)$ in Fourier space,&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ f(\rho) =  \int^{+\infty}_{-\infty} dt~ \hat{f}(t) ~e^{i\rho t}.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can already see that this represents $f(\rho)$ as a sum of simulatable unitaries. But this is a continuous and infinite sum. For many functions this integral can be truncated and discretized to approximate $f(\rho)$ well. Kothari's thesis has some examples of such functions, including $A^{-1}$. See also &lt;a href=&quot;https://arxiv.org/pdf/1603.02940.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;this work&lt;/a&gt;, that uses this technique to simulate the action of $e^{-\beta H}$ on a state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I don't think that this is the technique Llyod et.al has in their mind. But the LCU algorithm is a more recently developed technique that solves the problem. &lt;/p&gt;&#xA;" OwnerUserId="2663" LastEditorUserId="2663" LastEditDate="2018-07-11T07:17:21.397" LastActivityDate="2018-07-11T07:17:21.397" CommentCount="0" />
  <row Id="2702" PostTypeId="2" ParentId="2690" CreationDate="2018-07-11T07:36:35.430" Score="3" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Is universal chrononic computing possible?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There is no consensus that chronons even exist.&lt;br&gt;&#xA;See the first line of &lt;a href=&quot;https://en.wikipedia.org/wiki/Chronon&quot; rel=&quot;nofollow noreferrer&quot;&gt;this&lt;/a&gt;, for example.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However time (and space) is quantized in one of the most popular generalizations of quantum mechanics called &lt;a href=&quot;https://en.wikipedia.org/wiki/Loop_quantum_gravity&quot; rel=&quot;nofollow noreferrer&quot;&gt;loop quantum gravity&lt;/a&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;If&lt;/em&gt;&lt;/strong&gt; loop quantum gravity is an accurate description of the universe (which is not something we will be able to test for a very long time, until we can observe for example, Hawking radiation), then universal quantum computation with chronons would be possible as long as we can find a way to implement a &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_logic_gate#Universal_quantum_gates&quot; rel=&quot;nofollow noreferrer&quot;&gt;universal set of gates&lt;/a&gt; such as {H,CNOT,R($\pi$/4)}. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is hard enough to implement a useful number of {H,CNOT,R($\pi$/4)} gates with ordinary quanta that we've been working with for a century (such as spin quanta or atomic energy level quanta or photon quanta), so don't be disappointed if you don't see universal chrononic quantum computers on the market during your lifetime. But it is possible, provided that quanta of time actually do exist, which would be true if loop quantum gravity were to be true.  &lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="26" LastEditDate="2018-07-14T18:21:27.927" LastActivityDate="2018-07-14T18:21:27.927" CommentCount="15" />
  <row Id="2703" PostTypeId="1" AcceptedAnswerId="2704" CreationDate="2018-07-11T08:12:01.023" Score="6" ViewCount="43" Body="&lt;p&gt;The Pauli group for $n$-qubits is defined as $G_n=\{I,X,Y,Z \}^{\otimes n}$, that is as the group containing all the possible tensor products between $n$ Pauli matrices. It is clear that the Pauli matrices form a basis for the $2\times 2$ complex matrix vector spaces, that is $\mathbb{C}^{2\times 2}$. Apart from it, from the definition of the tensor product, it is known that the $n$-qubit Pauli group will form a basis for the tensor product space $(\mathbb{C}^{2\times 2})^{\otimes n}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am wondering if the Pauli group in $n$-qubits forms a basis for the complex vector space where the elements of this tensor product space act, that is $\mathbb{C}^{2^n\times 2^n}$. Summarizing, the question would be, is $(\mathbb{C}^{2\times 2})^{\otimes n}=\mathbb{C}^{2^n\times 2^n}$ true?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I have been trying to prove it using arguments about the dimensions of both spaces, but I have not been able to get anything yet.&lt;/p&gt;&#xA;" OwnerUserId="2371" LastEditorUserId="2371" LastEditDate="2018-07-11T08:18:49.273" LastActivityDate="2018-07-11T08:26:54.047" Title="Is the Pauli group for $n$-qubits a basis for $\mathbb{C}^{2^n\times 2^n}$?" Tags="&lt;quantum-error-correction&gt;&lt;pauli-matrices&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2704" PostTypeId="2" ParentId="2703" CreationDate="2018-07-11T08:26:54.047" Score="5" Body="&lt;p&gt;Yes, the set of tensor products of all possible $n$ Pauli operators (including $I$)  forms an orthogonal basis for  the vector space of $2^n \times 2^n$ complex matrices. So see this first we notice that the space has a dimension of $4^n$  and we also have $4^n$ vectors ( the vectors are operators in this case). So we only need to show that they are linearly independent.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We can actually show something stronger. It can be easily seen that the members of the Pauli group are orthogonal under the Hilbert-Schmidt inner product. The H-S inner product of two matrices is defined as $Tr(AB^\dagger)$. We can easily verify from the definition that the Pauli group is a mutually orthogonal set under this inner product. We simply have to use the elementary property $Tr(C \otimes D) = Tr(C)Tr(D)$.    &lt;/p&gt;&#xA;" OwnerUserId="2663" LastActivityDate="2018-07-11T08:26:54.047" CommentCount="2" />
  <row Id="2705" PostTypeId="2" ParentId="2692" CreationDate="2018-07-11T08:27:34.653" Score="1" Body="&lt;p&gt;Boolean variables can be represented by the matrix, $b=\frac{z+1}{2}$, where:&lt;br&gt;&#xA;$$&#xA;z=\begin{pmatrix}1 &amp;amp; 0 \\ 0 &amp;amp; -1 &#xA;\end{pmatrix}.&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Notice that the eigenvalues of $b$ are {0,1}, which is exactly what you want. This is explained on Pg. 1 of this &lt;a href=&quot;https://github.com/k-local-quadratization/review/blob/master/k-local-review.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;book on quantum mechanics and Boolean functions&lt;/a&gt; (see Eq. 3).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Pg. 2 of the same book refers to this &lt;a href=&quot;https://arxiv.org/pdf/1508.04816.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;paper&lt;/a&gt; which explains the connection between Boolean variables and quantum operators in even more detail in Eqs 8-9. In the paper, Eq. 13 is an example of exactly the type of function you have.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So for your example:&#xA;$x_1x_2+ x_3x_1x_4+x_5x_6$ &lt;/p&gt;&#xA;&#xA;&lt;p&gt;We have: $\frac{(z_1+1)(z_2+1)}{4} + \frac{(z_3+1)(z_1+1)(z_4+1)}{8} + \frac{(z_5+1)(z_6+1)}{4}$.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-07-11T08:27:34.653" CommentCount="3" />
  <row Id="2707" PostTypeId="1" AcceptedAnswerId="2708" CreationDate="2018-07-11T11:04:36.873" Score="5" ViewCount="86" Body="&lt;p&gt;I was reading the documentation for &lt;a href=&quot;https://qiskit.org/documentation/ja/_autodoc/qiskit.QuantumCircuit.html&quot; rel=&quot;noreferrer&quot;&gt;qiskit.QuantumCircuit&lt;/a&gt; and came across the functions &lt;code&gt;cu1(theta, ctl, tgt)&lt;/code&gt; and &lt;code&gt;cu3(theta, phi, lam, ctl, tgt)&lt;/code&gt;. Looking at the names they seem to be controlled rotations. &lt;code&gt;ctrl&lt;/code&gt; represents the controlled qubit and &lt;code&gt;tgt&lt;/code&gt; represents the target qubit. However, what are &lt;code&gt;theta&lt;/code&gt;, &lt;code&gt;lambda&lt;/code&gt; and &lt;code&gt;phi&lt;/code&gt;? They're rotations about which axes? Also, which rotation matrices are being used for &lt;code&gt;cu1&lt;/code&gt; and &lt;code&gt;cu3&lt;/code&gt;?&lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-07-11T11:36:18.760" Title="What are theta, phi and lambda in cu1(theta, ctl, tgt) and cu3(theta, phi, lam, ctl, tgt)? What are the rotation matrices being used?" Tags="&lt;qiskit&gt;&lt;controlled-gates&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2708" PostTypeId="2" ParentId="2707" CreationDate="2018-07-11T11:36:18.760" Score="5" Body="&lt;p&gt;From &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/tutorial?sectionId=full-user-guide&amp;amp;page=002-The_Weird_and_Wonderful_World_of_the_Qubit~2F004-advanced_qubit_gates&quot; rel=&quot;noreferrer&quot;&gt;IBM Q Documentation&lt;/a&gt; (the link is hard to find) here is the definition of the generic gate:&#xA;$$&#xA;U(\theta, \phi, \lambda) = &#xA;\begin{pmatrix} &#xA;\cos\left(\frac{\theta}{2}\right) &amp;amp; -e^{i\lambda} \sin\left(\frac{\theta}{2}\right) \\&#xA;e^{i\phi} \sin\left(\frac{\theta}{2}\right) &amp;amp; e^{i(\lambda + \phi)} \cos\left(\frac{\theta}{2}\right)&#xA;\end{pmatrix}&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;With this gate, they define the following gates:&#xA;$$&#xA;\begin{split}&#xA;U_1(\lambda) &amp;amp;= U(0, 0, \lambda) = \begin{pmatrix}&#xA;1 &amp;amp; 0 \\ 0 &amp;amp; e^{i\lambda}&#xA;\end{pmatrix} \\&#xA;U_2(\phi, \lambda) &amp;amp;= U\left(\frac{\pi}{2}, \psi, \lambda\right) = \frac{1}{\sqrt{2}}\begin{pmatrix}&#xA;1 &amp;amp; -e^{i\lambda} \\ e^{i\phi} &amp;amp; e^{i(\lambda+\phi)}&#xA;\end{pmatrix} \\&#xA;U_3(\theta, \phi, \lambda) &amp;amp;= U(\theta, \phi, \lambda) = \text{see above}&#xA;\end{split}&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;These gates are the basis (with &lt;code&gt;CX&lt;/code&gt;) of the IBM Q online backends (i.e. the real chips).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &lt;code&gt;cu1&lt;/code&gt; and &lt;code&gt;cu3&lt;/code&gt; are the controlled operations associated with the matrices above.&lt;/p&gt;&#xA;" OwnerUserId="1386" LastActivityDate="2018-07-11T11:36:18.760" CommentCount="0" />
  <row Id="2709" PostTypeId="2" ParentId="2691" CreationDate="2018-07-11T12:41:00.260" Score="4" Body="&lt;p&gt;The only two quasi-particle quanta for which I know there to be active research in quantum computing are phonons and anyons.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Phonons:&lt;/strong&gt; That state-of-the-art is given my answer here: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2588/phononic-quantum-computing/2608#2608&quot;&gt;Phononic Quantum Computing&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Anyons:&lt;/strong&gt; Synthesizing the first anyonic qubit is still an outstanding goal, but major milestones have been discussed &lt;a href=&quot;https://journals.aps.org/prx/abstract/10.1103/PhysRevX.6.031016&quot; rel=&quot;nofollow noreferrer&quot;&gt;very recently&lt;/a&gt;. This paper was the topic of an article with the very promising title &quot;&lt;a href=&quot;https://quantumfrontiers.com/2017/08/16/topological-qubits-arriving-in-2018/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Topological qubits arriving in 2018?&lt;/a&gt;&quot; &lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="26" LastEditDate="2018-07-14T18:24:17.217" LastActivityDate="2018-07-14T18:24:17.217" CommentCount="1" />
  <row Id="2711" PostTypeId="1" CreationDate="2018-07-11T17:52:42.857" Score="4" ViewCount="60" Body="&lt;p&gt;I am wondering if there exists a common library or a set of modules for user-defining-quantum-gate for QISKit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If it does, could you tell me?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;By referring to &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/community/question?questionId=5b3ba83d77993f003c6952dd&quot; rel=&quot;nofollow noreferrer&quot;&gt;Define Quantum Gates&lt;/a&gt; and &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/community/question?questionId=5ae975660f020500399ed22d&amp;amp;answerId=5ae975760f020500399ee66e&quot; rel=&quot;nofollow noreferrer&quot;&gt;How to define user's quantum gates?&lt;/a&gt;, I have created 6 modules for IBM Q simulator such as CZ gate and CCZ gate (&lt;a href=&quot;https://github.com/bick-jp/ibmq/tree/master/grovers_algorithm/original_gate_test/original_gate&quot; rel=&quot;nofollow noreferrer&quot;&gt;uploaded here&lt;/a&gt;) since they were not built in &lt;a href=&quot;https://github.com/Qiskit/qiskit-terra/tree/master/qiskit/extensions/standard&quot; rel=&quot;nofollow noreferrer&quot;&gt;QISKit standard gates&lt;/a&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, since the gates such as CZ gate and CCZ gate seems pretty common to use, I am wondering if anybody already opens their gates to the public.&lt;/p&gt;&#xA;" OwnerUserId="2100" LastActivityDate="2018-07-12T08:22:14.030" Title="Is there a common set of modules for user-defining-quantum-gate for QISKit" Tags="&lt;qiskit&gt;&lt;ibm-q-experience&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2712" PostTypeId="1" AcceptedAnswerId="2721" CreationDate="2018-07-11T23:03:07.153" Score="5" ViewCount="80" Body="&lt;p&gt;Referring to Farhi, Gosset, Hassidim, Lutomirski, and Shor's &quot;Quantum Money from Knots,&quot; a &lt;em&gt;mint&lt;/em&gt; $\mathcal{M}$ generates a run of coins, including, say,  $(s,|\$\rangle)$, using a quantum computer to mint $|\$\rangle$ while publishing the public serial number $s$.  A &lt;em&gt;merchant&lt;/em&gt; $\mathcal{V}$  is able to verify that $|\$\rangle$ corresponds to $s$, and is a valid money state.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The merchant $\mathcal{V}$ is required to perform quantum operations on $|\$\rangle$ to make sure that $|\$\rangle$ corresponds to $s$ and is a valid money state.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;But if the merchant $\mathcal{V}$ is capable of performing the verification, then would she not have all quantum capability to mint her own coin in the first place?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The barrier to entry to minting quantum coins does not seem that much different to verifying quantum coins. Thus, we have a situation wherein anyone with a quantum computer capable of verifying such quantum coins can mint their own coins.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If so, a question becomes, how would the market determine the value of a quantum coin, potentially from different merchants or minters?  Would the &quot;oldest&quot; quantum coin be valued more than newer coins?  Or would a coin with an interesting serial number $s$ be valued more?  Or the coin used in some famous transaction?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I would imagine a number of publicly available lists of serial numbers, one for each mint/verifier.  If I have a quantum computer, I would be motivated to mint my own coin and publish the serial number.  The market can decide that &quot;this coin from this mint is worth more than that coin from that mint,&quot; but how would the market decide? It seems interesting.&lt;/p&gt;&#xA;" OwnerUserId="2927" LastActivityDate="2018-07-13T11:41:38.217" Title="Can a merchant who accepts a knot-based quantum coin mint her own knot-based coin?" Tags="&lt;cryptocurrency&gt;" AnswerCount="2" CommentCount="1" FavoriteCount="1" />
  <row Id="2713" PostTypeId="2" ParentId="2711" CreationDate="2018-07-12T08:22:14.030" Score="1" Body="&lt;p&gt;For the moment, there is no publicly available repository of custom gates to my knowledge. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you want I have defined some for my own use. You can find the implementation &lt;a href=&quot;https://github.com/nelimee/quantum-tools/tree/master/gates&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt; but:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;The &quot;gates&quot; implemented are more algorithms than gates.&lt;/li&gt;&#xA;&lt;li&gt;If you plan to re-use some of the gates, take a look at the license.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Be also aware of the fact that the gate hierarchy will probably change in a near future (see &lt;a href=&quot;https://github.com/Qiskit/qiskit-terra/issues/316&quot; rel=&quot;nofollow noreferrer&quot;&gt;#316&lt;/a&gt;, &lt;a href=&quot;https://github.com/Qiskit/qiskit-terra/issues/476&quot; rel=&quot;nofollow noreferrer&quot;&gt;#476&lt;/a&gt;, &lt;a href=&quot;https://github.com/Qiskit/qiskit-terra/issues/591&quot; rel=&quot;nofollow noreferrer&quot;&gt;#591&lt;/a&gt;). Even if the changes should be backward compatible, we don't know how the &lt;code&gt;CompositeGate&lt;/code&gt; class will be changed at the moment.&lt;/p&gt;&#xA;" OwnerUserId="1386" LastActivityDate="2018-07-12T08:22:14.030" CommentCount="1" />
  <row Id="2714" PostTypeId="1" AcceptedAnswerId="2715" CreationDate="2018-07-12T12:22:53.143" Score="7" ViewCount="74" Body="&lt;p&gt;Lets say we have a fully working quantum computer. I give it a problem to solve and measure how long it takes to solve it. I repeat the process. Would it take the exact same time to solve the same problem?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I have read that a quantum computer's solution process could be seen as all the potential answers are already calculated but to get it out of an entangled state without changing the result, you would use Grover's algorithm that reduces the answer set. You then repeat Grover's algorithm to keep on reducing the answer set. Now you could repeat Grover's algorithm to get a single answer or just start up classical computing to test answers once the answer set is small enough.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This could possibly mean that the same problem could have a different answer set on first iteration of Grover's algorithm which could cascade on how many times it needs to run to get to a reasonably small answer set to test with classical computing.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Did I misunderstand something or is it reasonable that same problem could have varying calculation time on same hardware?&lt;/p&gt;&#xA;" OwnerUserId="3011" LastEditorUserId="3011" LastEditDate="2018-07-12T12:42:15.960" LastActivityDate="2018-07-13T07:43:20.910" Title="Does a fully working quantum computer solve a specific problem at varying speeds every time?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-computer&gt;" AnswerCount="1" CommentCount="3" />
  <row Id="2715" PostTypeId="2" ParentId="2714" CreationDate="2018-07-12T14:14:20.123" Score="5" Body="&lt;p&gt;It depends upon the algorithm that you're running as to whether it will always take the same length of time to run or not. Many of the well-known (often oracle-based) algorithms, such as Deutsch-Jozsa have fixed running times, i.e. they will always take the same time to run because it is exactly the same steps that have to be run every time.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Other algorithms (Simon's, Shor, HHL, Grover...) have some probability of failure, but a way of easily recognising a correct answer. So, if it fails, you just repeat. This means that there's a discrete set of running times, and an expected running time. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, I must emphasise that your understanding of how quantum algorithms work is not very accurate.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;I have read that a quantum computer's solution process could be seen as all the potential answers are already calculated but to get it out of an entangled state without changing the result, you would use Grover's algorithm that reduces the answer set.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Usually, you do not use Grover's algorithm, unless the specific thing you're doing is a quantum search (or a related &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/2004/1837&quot;&gt;set of applications&lt;/a&gt;). Even Grover's is almost deterministic (if the number of solutions is known). As the size of the set you're searching over increases, the probability of failure tends to 0 so, to all intents and purposes, you run the algorithm exactly once and effectively have a deterministic running time.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;While the first step of a quantum function can generally be thought of as calculating all possible answers in parallel, the secret sauce of quantum algorithms is very much the special tricks that can be leveraged to get a sensible answer out (for the very limited set of problems for which we know such tricks). But these depend extensively on the specific structure of the problem being solved. Grover's search is kind of the brute force option: if all you know about the problem structure is that you'll be able to recognise an answer when you get it, Grover's the one you want, but the point of quantum algorithms generally is to use further properties of the problem structure and get much greater speed-ups.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-07-13T07:43:20.910" LastActivityDate="2018-07-13T07:43:20.910" CommentCount="2" />
  <row Id="2716" PostTypeId="1" AcceptedAnswerId="2720" CreationDate="2018-07-12T19:37:40.197" Score="5" ViewCount="61" Body="&lt;p&gt;For Shor's error correcting code, what is the intuition behind saying that the following circuit corrects the phase flip error? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I realize that the circuit is trying to compare phases of the three 3-qubit blocks, two at a time. But I don't understand how the Hadamards and CNOTs help in that task. It seems different from the general method followed for phase error correction with three qubits encoded in the Hadamard basis. It also seems to entangle the two ancillas at the end with the encoded 9 qubit code.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/CBT7u.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/CBT7u.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="1351" LastEditorUserId="1351" LastEditDate="2018-07-12T20:03:17.120" LastActivityDate="2018-07-13T01:18:43.793" Title="Shor code: phase flip error" Tags="&lt;quantum-error-correction&gt;" AnswerCount="1" CommentCount="1" />
  <row Id="2717" PostTypeId="1" AcceptedAnswerId="3917" CreationDate="2018-07-12T21:15:06.683" Score="7" ViewCount="145" Body="&lt;p&gt;In the &lt;a href=&quot;https://strawberryfields.readthedocs.io/en/latest/introduction.html&quot; rel=&quot;noreferrer&quot;&gt;introduction&lt;/a&gt; to continuous-variable quantum computing by Strawberry Fields (Xanadu), it lists the primary &lt;a href=&quot;https://strawberryfields.readthedocs.io/en/latest/introduction.html#cv-gates&quot; rel=&quot;noreferrer&quot;&gt;CV gates&lt;/a&gt; (rotation, displacement, squeezing, beamsplitter, cubic phase) along with their unitary:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/9FIam.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/9FIam.png&quot; alt=&quot;cv gates w/ unitary&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;What are the matrix representations of these gates?&lt;/strong&gt;&lt;/p&gt;&#xA;" OwnerUserId="2645" LastActivityDate="2018-08-01T22:27:52.640" Title="Matrix representation of continuous-variable gates" Tags="&lt;quantum-gate&gt;&lt;matrix-representation&gt;&lt;continuous-variable&gt;" AnswerCount="2" CommentCount="3" FavoriteCount="1" />
  <row Id="2718" PostTypeId="1" CreationDate="2018-07-12T21:32:29.900" Score="6" ViewCount="97" Body="&lt;h2&gt;Context:&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;On the 5th page of the paper &lt;a href=&quot;https://www.tandfonline.com/doi/abs/10.1080/00268976.2012.668289&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum circuit design for solving linear systems of equations (Cao et al, 2012)&lt;/a&gt; there's this circuit:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/RXIP6.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/RXIP6.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/9HAJ3.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/9HAJ3.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/vTUos.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/vTUos.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Schematic:&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;A brief schematic of what's actually happening in the circuit is:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/rMzOI.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/rMzOI.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Question:&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Cao et al.'s circuit (in Figure 4) is specifically made for the matrix:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$A = \frac{1}{4} \left(\begin{matrix} 15 &amp;amp; 9 &amp;amp; 5 &amp;amp; -3 \\ 9 &amp;amp; 15 &amp;amp; 3 &amp;amp; -5 \\ 5 &amp;amp; 3 &amp;amp; 15 &amp;amp; -9 \\ -3 &amp;amp; -5 &amp;amp; -9 &amp;amp; 15 \end{matrix}\right)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;whose eigenvalues are $\lambda_1 = 2^{1-1}=1,\lambda_2 = 2^{2-1}=2,\lambda_3 = 2^{3-1}=4$ and $\lambda_4 = 2^{4-1} = 8$ and corresponding eigenvectors are $|u_i\rangle = \frac{1}{2}\sum_{j=1}^{4}(-1)^{\delta_{ij}}|j\rangle^C$. In this case since there are $4$ qubits in the clock register, the $4$ eigenvalues can be represented as states of the clock register itself (no approximation involved) i.e. as $|0001\rangle$ (binary representation of $1$),  $|0010\rangle$ (binary representation of $2$), $|0100\rangle$ (binary representation of $4$) and $|1000\rangle$ (binary representation of $8$).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;After the first Quantum phase estimation step, the circuit's (in Fig. 4) state is &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$|0\rangle_{\text{ancilla}} \otimes \sum_{j=1}^{j=4} \beta_j |\lambda_j\rangle |u_j\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Everything is fine till here. However, after this, to produce the state &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\sum_{j=1}^{j=4} \beta_j |u_j\rangle_I |\lambda_j\rangle^C ((1-C^2/\lambda_j^2)^{1/2}|0\rangle + C/\lambda_j|1\rangle)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;it seems necessary to get to the state $$\sum_{j=1}^{j=4} \beta_j |u_j\rangle_I |\frac{2^{3}}{\lambda_j}\rangle^C\otimes |0\rangle_{\text{ancilla}}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;That is, the following mappings seem necessary in the $R(\lambda^{-1})$ rotation step:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$|0001\rangle \mapsto |1000\rangle, |0010\rangle \mapsto |0100\rangle, |0100\rangle \mapsto |0010\rangle \ \&amp;amp; \ |1000\rangle \mapsto |0001\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;which implies that the middle two qubits in the clock register need to be swapped as well as the two end qubits. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;But, in the circuit diagram they seem to be swapping the first and third qubit in the clock register! That doesn't seem reasonable to me. In the paper (Cao et al.) claim that the transformation they're doing using their SWAP gate is &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\sum_{j=1}^{j=4} \beta_j |u_j\rangle_I |\lambda_j\rangle^C\otimes |0\rangle_{\text{ancilla}} \mapsto \sum_{j=1}^{j=4} \beta_j |u_j\rangle_I |\frac{2^{4}}{\lambda_j}\rangle^C\otimes |0\rangle_{\text{ancilla}}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;According to their &lt;em&gt;scheme&lt;/em&gt;, $|1000\rangle \to |0010\rangle$ (see the third page). This scheme doesn't make sense to me because the state $|0001\rangle$ (representing the eigenvalue $1$) would have to be transformed to $|2^4/1\rangle$. But the decimal representation of $16$ would be $|10000\rangle$ which is a 5-qubit state! However, our clock register has only $4$ qubits in total. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, basically I think that their SWAP gates are wrong. The SWAPs should actually have been applied between the middle qubits and the two end qubits. Could someone verify?&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Supplementary question&lt;/strong&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;This is not a compulsory part of the question. Answers addressing &lt;strong&gt;only&lt;/strong&gt; the previous question are also welcome. &lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/users/1386/nelimee&quot;&gt;@Nelimee&lt;/a&gt; wrote a &lt;a href=&quot;https://github.com/nelimee/quantum-tools&quot; rel=&quot;nofollow noreferrer&quot;&gt;program&lt;/a&gt; (&lt;code&gt;4x4_system.py&lt;/code&gt; in &lt;code&gt;HHL&lt;/code&gt;) in QISKit to simulate the circuit (Figure 4) in Cao et al's paper. Strangely, his program works only if the SWAP gate is &lt;a href=&quot;https://github.com/nelimee/quantum-tools/blob/master/HHL/4x4_system.py#L149&quot; rel=&quot;nofollow noreferrer&quot;&gt;applied between the middle two qubits but not in between the two end qubits&lt;/a&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The output of his program is as follows:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;class 'numpy.ndarray'&amp;gt;&#xA;Exact solution: [-1  7 11 13]&#xA;Experimental solution: [-0.84245754+0.j  6.96035067+0.j 10.99804383+0.j 13.03406367+0.j]&#xA;Error in found solution: 0.16599956439346453&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;That is, in his program only the mapping $|0100\rangle \mapsto |0010\rangle$ takes place in the clock register in the $R(\lambda^{-1})$ step. There's no mapping $|1000\rangle \mapsto |0001\rangle$ taking place. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Just in case anyone figures out why this is happening please let me know in the comments (or in an answer). &lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-15T16:34:49.327" LastActivityDate="2018-07-15T16:34:49.327" Title="SWAP gate(s) in the $R(\lambda^{-1})$ step of the HHL circuit for $4\times 4$ systems" Tags="&lt;quantum-gate&gt;&lt;circuit-model&gt;&lt;qiskit&gt;&lt;hhl-algorithm&gt;&lt;phase-estimation&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="2719" PostTypeId="2" ParentId="2717" CreationDate="2018-07-13T00:11:05.580" Score="1" Body="&lt;p&gt;The link you gave says:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The CV model is a natural fit for simulating bosonic systems (electromagnetic fields, harmonic oscillators, phonons, Bose-Einstein condensates, or optomechanical resonators) and for settings where continuous quantum operators – such as position &amp;amp; momentum – are present. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Which means you can have many different different matrix representations for the CV gates. They then point out: &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The most elementary CV system is the &lt;strong&gt;bosonic harmonic oscillator&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;This means that for any values of the scalar (non-matrix) parameters $\alpha, \gamma, \phi, z, \theta, \gamma$, you can just calculate the formula they gave you, using the following matrix representations for the creation and annihilation operators for a &lt;strong&gt;bosonic harmonic oscillator&lt;/strong&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/QuFcg.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/QuFcg.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The number operator $\hat{n}$ is just $a^\dagger a$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Keep in mind that any matrix representation is basis-dependent, meaning that you can take these matrix representations and (for example) diagonalize them, and they would be a perfectly valid matrix representation in a new basis. However the matrices I gave you here are quite &quot;standard&quot; for quantum harmonic oscillators.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-07-16T01:13:58.667" LastActivityDate="2018-07-16T01:13:58.667" CommentCount="16" />
  <row Id="2720" PostTypeId="2" ParentId="2716" CreationDate="2018-07-13T01:18:43.793" Score="2" Body="&lt;p&gt;The circuit &lt;strong&gt;detects&lt;/strong&gt; an error, by producing a measurement outcome representing a syndrome that indicates which of three blocks of three qubits was affected by a phase error (or that indicates that no phase error occurred). Once you know this, you still have to correct the phase error if there was one, by applying a phase flip to any one of the three qubits in the affected block.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The context here is that you've already corrected for a possible bit flip error, so that the input to the circuit is a state that resulted from at most one phase error being applied to a vector in the code space of Shor's 9 qubit code. Vectors in this code space look like&#xA;$$&#xA;\alpha |\phi_0\rangle |\phi_0\rangle |\phi_0\rangle +&#xA;\beta |\phi_1\rangle |\phi_1\rangle |\phi_1\rangle,&#xA;$$&#xA;where&#xA;$$&#xA;|\phi_0\rangle = \frac{|000\rangle + |111\rangle}{\sqrt{2}} \quad \text{and} \quad |\phi_1\rangle = \frac{|000\rangle - |111\rangle}{\sqrt{2}}.&#xA;$$&#xA;A phase error on the first block (i.e., qubit 1, 2, or 3), for instance, would result in the state&#xA;$$&#xA;\alpha |\phi_1\rangle |\phi_0\rangle |\phi_0\rangle +&#xA;\beta |\phi_0\rangle |\phi_1\rangle |\phi_1\rangle.&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, the reasoning behind the circuit is that applying Hadamard gates to each qubit of $|\phi_0\rangle$ gives a uniform superposition over even-parity strings, while applying Hadamard gates to each qubit of $|\phi_1\rangle$ gives a uniform superposition over odd-parity strings. Each set of three controlled-NOT gates will therefore induce a bit flip on one of the syndrome qubits when the three corresponding qubits are in the $|\phi_1\rangle$ state but not in the $|\phi_0\rangle$ state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, in the example suggested above where a phase error touched qubit 1, 2, or 3, the first six controlled-NOT gates have the combined effect of flipping the second syndrome qubit, while the remaining controlled-NOT gates collectively do nothing. This results in the syndrome 01, which indicates a phase flip in block number 1 (i.e., the first three qubits). You can check that a phase error in a different block gives an appropriate outcome, and that if no phase errors occurred, the syndrome 00 is obtained, indicating no phase errors.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that this does not entangle the syndrome qubits with the other qubits, so when you do all of the Hadamard gates again, you recover the original input state. Of course this assumes an input of the special form described above; if you put in an arbitrary state, you might very well end up with something entangled with the syndrome.&lt;/p&gt;&#xA;" OwnerUserId="1764" LastActivityDate="2018-07-13T01:18:43.793" CommentCount="0" />
  <row Id="2721" PostTypeId="2" ParentId="2712" CreationDate="2018-07-13T01:46:51.180" Score="2" Body="&lt;p&gt;In complexity theory (quantum and classical) the distinction between construction and verification is very important, and the ability to verify certainly does not imply the ability to construct. For example, it is easy to verify that a satisfying assignment to a Boolean formula really is a satisfying assignment, but finding such an assignment given only the formula is a computationally hard problem (assuming $\text{P}\not=\text{NP}$).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Obviously, the situation with quantum money is a very different one, but there is a similar principle at work, and perhaps the Boolean formula example helps to invalidate any generic sort of intuition stating that having the capacity to verify something (in this case that a quantum money state corresponds to a particular serial number) automatically provides the capacity to construct the same thing (which in this case means constructing a money state with the given serial number).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the case of quantum money (of the sort that the paper you referred to considers), there are some important additional constraints. One is that it should actually &lt;strong&gt;not be difficult&lt;/strong&gt; for the mint to produce money. The key here is that the production of money will result in a random choice of $s$; neither the mint nor a would-be counterfeiter would be capable of first choosing $s$ and then creating the corresponding money state. The requirement is actually much stronger: even given one copy of the money state corresponding to serial number $s$, a counterfeiter should not be able to produce two or more states that are likely to pass independent verifications for that serial number.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, anyone with a quantum computer would indeed be able to produce as much money as they want, but presumably nobody would care; people would only assign value to those money states whose serial numbers are authenticated in some way by the mint.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Addendum:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Concerning issues such as the market value of money states, over-minting, and so on, the only answer I can offer is that quantum money, as a concept in quantum information science, does not address these issues -- it simply provides a protocol whereby states can be efficiently produced and verified but not copied. Individuals and governments could choose to use a quantum money protocol as they choose, and in a situation in which this is done it is up to each participant to decide what value to assign to each state. In this regard, the issues do not seem to me to be specific to quantum money, but are shared by all forms of currency.&lt;/p&gt;&#xA;" OwnerUserId="1764" LastEditorUserId="1764" LastEditDate="2018-07-13T11:41:38.217" LastActivityDate="2018-07-13T11:41:38.217" CommentCount="1" />
  <row Id="2722" PostTypeId="1" CreationDate="2018-07-13T02:59:55.450" Score="5" ViewCount="65" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;What level of trust in the bank is needed in &quot;Quantum Money from Hidden Subspaces&quot; of &lt;a href=&quot;https://arxiv.org/abs/1203.4740v3&quot; rel=&quot;nofollow noreferrer&quot;&gt;Aaronson and Christiano&lt;/a&gt;?  &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The bank's mint works by first generating a uniformly random classical secret string $r$, and &lt;em&gt;then&lt;/em&gt; generating a banknote $\$_r=(S_r,\rho_r)$.  The authors state that the bank can generate many identical banknotes by simply reusing the secret $r$.  &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;But after the currency is distributed, is $r$ needed, either by the bank or by the users, ever again?  If so, does the bank need to keep it safe and secure?  If not, should the bank &quot;forget&quot; or destroy the secret $r$ used in the mini-scheme, lest it fall into a forger's hand?  &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Can the mint use $r$ to produce many coins with a specific serial number $S_r$, potentially targeting a specific holder of currency for devaluation?  &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Can the users of the currency know how many coins are actively in circulation,  without having to trust the mint?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;The authors of Hidden Subspaces note that in &quot;Quantum Money from Knots&quot; of &lt;a href=&quot;https://arxiv.org/abs/1004.5127&quot; rel=&quot;nofollow noreferrer&quot;&gt;Farhi, Gosset, Hassidim, Lutomirski, and Shor&lt;/a&gt;, &lt;em&gt;not even the mint&lt;/em&gt; is likely able to generate two identical banknotes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;But I think that the inability of banks to copy their own currency is a&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;feature&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;not a&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;bug&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;of &quot;Quantum Money from Knots&quot;&lt;/strong&gt;, because the actions of the mint are public and known.  The total amount of currency is known; no secret $r$ is needed to be kept safe or destroyed; the mint can &quot;destroy&quot; a coin by removing it from the public list of serial numbers (Alexander polynomials,) but cannot target a coin for devaluation by minting many copies.&lt;/p&gt;&#xA;" OwnerUserId="2927" LastEditorUserId="2927" LastEditDate="2018-07-16T21:01:30.187" LastActivityDate="2018-07-16T21:01:30.187" Title="Do we have to trust the bank in &quot;Quantum Money from Hidden Subspaces?&quot;" Tags="&lt;cryptocurrency&gt;" AnswerCount="0" CommentCount="3" FavoriteCount="1" />
  <row Id="2723" PostTypeId="2" ParentId="2712" CreationDate="2018-07-13T03:39:20.163" Score="1" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;How would the market determine the value of a quantum coin, potentially from different merchants or minters?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;tl;dr: by trading!&lt;/h2&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Disclaimer: I am working on a startup that is addressing this problem&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;I curated some thoughts on blockchain in an article entitled &lt;a href=&quot;https://medium.com/kloutcoin/tokenizing-global-otc-derivatives-8a0330dd29dc&quot; rel=&quot;nofollow noreferrer&quot;&gt;Tokenize Everything (&amp;amp; the Decentralized P2P Global Market)&lt;/a&gt; at the end of last year. A few relevant snippets include:&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Decentralization&lt;/h2&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The technological quantum leap here is not necessarily a new type of money. Rather, it is the ability to now achieve global consensus over a decentralized and distributed network without a trusted third party. This has many potential applications for various fields of endeavour.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;A ‘decentralised funfair’ would actually be one where anyone can participate as a ‘fun provider’ (earning Funcoins for that service) and/or ‘fun beneficiary’ (giving out Funcoins to receive it), with the economics flowing directly between the two parties. The decentralised funfair would have no employees nor middlemen, only utilitarian participants; there would actually be no end to it, as long as the economic incentives on both sides remain attractive enough.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;Liquidity&lt;/h2&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Because such economies are decentralised, i.e. they have no central authority taking a toll, the most liquid tokens in any economy should in theory ultimately prevail and that would constitute the best outcome for its participants.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Imagine there are multiple funfairs where a fun provider or a fun beneficiary can participate: inevitably they would choose the one that provides the most attractive incentives (i.e. more fun, higher rewards). So ultimately there will only be one decentralised funfair left and its “fun token”, the most liquid one that delivers the most value to its participants&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;Qlout&lt;/h2&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The barrier to entry to minting quantum coins does not seem that much different to verifying quantum coins. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Precisely! Given a quantum computer (network), anyone could easily access it via 'the cloud' to mint &amp;amp;/or trade coins. Initially, only a few devices will be able to serve as nodes in the network. However, once advancements are made &amp;amp; quantum devices (QPUs) are commercially available, network size will increase accordingly (&amp;amp; allow for individuals to self host). &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Would the &quot;oldest&quot; quantum coin be valued more than newer coins? Or would a coin with an interesting serial number s be valued more? Or the coin used in some famous transaction?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;These are all really great ideas! Clearly (as is the case in all markets) individuals would assign value to different coins in different ways (utility, collectability, etc). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The concept of &lt;strong&gt;Qlout&lt;/strong&gt; is that each coin would be given a score based on an algorithm (secret sauce). This would only serve as a 'market score'; individuals would still be free to trade at any &lt;em&gt;agreeable&lt;/em&gt; rate.&lt;/p&gt;&#xA;" OwnerUserId="2645" LastActivityDate="2018-07-13T03:39:20.163" CommentCount="0" />
  <row Id="2724" PostTypeId="1" AcceptedAnswerId="3833" CreationDate="2018-07-13T03:55:48.787" Score="5" ViewCount="207" Body="&lt;p&gt;I am new to Stack Exchange and am working on a Quantum learning platform for minority youth groups (LGBTQ, low-income, at risk, etc).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the question below they are looking for courses on the subject, which I am also interested in, and do plan on checking those links out for ideas.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2151/introductory-material-for-quantum-machine-learning&quot;&gt;Introductory material for Quantum machine learning&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;What I am looking for are simple videos, articles, or even games, that cover basic Quantum Theory at an introductory level.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are some games I have looked into and played. &#xA;Hello Quantum! was fun and informative, though on my end there was still a lack of comprehension on how the Quantum computer (or anything else Quantum) would actually function and play out. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;My focus for the educational platform is more directed towards the software side of quantum computing. Is there anything &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1474/what-programming-languages-are-available-for-quantum-computers&quot;&gt;on software&lt;/a&gt; that gives a good introduction to the functions and uses a quantum computer will have? As well as what language would be best to program one? Also, would there be a way to program a quantum computer through a classical computer? And, is there a simple introduction to any of this already existing?&lt;/p&gt;&#xA;" OwnerUserId="3088" LastEditorUserId="26" LastEditDate="2018-07-16T19:42:33.990" LastActivityDate="2018-07-22T00:08:00.650" Title="What would be an informative introduction to Quantum?" Tags="&lt;resource-request&gt;" AnswerCount="5" CommentCount="0" FavoriteCount="1" />
  <row Id="2725" PostTypeId="2" ParentId="2718" CreationDate="2018-07-13T07:15:36.377" Score="2" Body="&lt;p&gt;I don't see the need for the swap gate either. Although I also don't think you need the set of swap gates that you're wanting. Remember that the standard implementation of the Fourier transform outputs the binary string $j\in\{0,1\}^4$ where the eigenvalues are of the form $2\pi j/16$ &lt;em&gt;but in reverse order&lt;/em&gt;, so the least significant bit is at the top, and the most significant bit is at the bottom. Thus, $|1000\rangle$ already corresponds to $j=1$, and so the rotation that you want is with an angle $8\pi/2^m$, and $|0100\rangle$ corresponds to $j=2$, requiring angle $4\pi/2^m$, and so on.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, I have to emphasise that what I see here is something of a fudge. It seems to be that the authors have very much built in the knowledge of the eigenvalues - not just that they're of the form $2\pi j/16$, but specifically that they are 1,2,4,8. It looks to me like, if one had a matrix that also contained a $j=4$ term, for example, that the inverse would not be correctly calculated because the angle of rotation actually created (LHS)&#xA;$$&#xA;\frac{8\pi}{2^m}+\frac{4\pi}{2^m}=\frac{12\pi}{2^m}\neq\frac{8\pi}{3\cdot 2^m}&#xA;$$&#xA;does not match the required angle for the inverse (RHS). Perhaps that was already clear to you, but it was not clear to me in trying to understand the circuit in order to answer your question!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In terms of testing with QISKit, it's not something that I use myself. However, can I suggest trying a different $|b\rangle$ as input? It is &lt;em&gt;possible&lt;/em&gt; (perhaps not likely, however) that some of what's going on is masked slightly because the $|b\rangle$ chosen in the paper is an equally weighted superposition of the 4 eigenvectors. I'd want to chose something with different amplitudes for each eigenvector, just to be sure.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-07-13T07:15:36.377" CommentCount="0" />
  <row Id="2726" PostTypeId="2" ParentId="2724" CreationDate="2018-07-13T07:32:19.880" Score="9" Body="&lt;p&gt;Introductory Quantum Computation, which seems to be what you're asking for (rather than Quantum Theory more generically) is a bit of a tough ask. As you say, there are a few games around, such as &lt;a href=&quot;http://quantumgame.io/&quot; rel=&quot;noreferrer&quot;&gt;this one&lt;/a&gt;, but they don't really go far enough to explain quantum algorithms and the functioning of a quantum computer, because that really has to be backed up by quite a lot of maths and notation, which means that one is rapidly getting away from introductory material.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I was actually trying to think at some point about how to make a good, accessible, video introduction to quantum computation, and have to admit to having stalled somewhat. What I did manage to produce was something reasonably introductory but about &lt;a href=&quot;https://vimeo.com/quantummechanic/qkdintro&quot; rel=&quot;noreferrer&quot;&gt;quantum cryptography&lt;/a&gt;, which I think is much more accessible than the computation side of things.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You linked to a question about software. Things like QISKit have an &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/tutorial?sectionId=full-user-guide&amp;amp;page=introduction&quot; rel=&quot;noreferrer&quot;&gt;extensive set of documentation&lt;/a&gt; that give a good introduction. The &lt;a href=&quot;https://github.com/Qiskit/qiskit-tutorial&quot; rel=&quot;noreferrer&quot;&gt;tutorials&lt;/a&gt; on github may also be of interest to you. Moreover, things like QISKit are precisely a way of programming a QC through a CC. You give a generic quantum circuit, and it is 'compiled' for a specific hardware implementation.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-07-13T07:32:19.880" CommentCount="3" />
  <row Id="2727" PostTypeId="1" CreationDate="2018-07-13T08:04:52.623" Score="4" ViewCount="171" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;The question whether surreal or hyperreal numbers (that both contain the reals, even if they have the same cardinality) could be useful to provide a more satisfactory theory of QM is maybe more interesting. -&lt;a href=&quot;https://physics.stackexchange.com/a/342021/198219&quot;&gt;yuggib&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;Background&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;I &lt;a href=&quot;https://mathoverflow.net/questions/300861/surreal-form-star-is-a-xor-cipher&quot;&gt;indirectly&lt;/a&gt; ended up on this stack, &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2333/quantum-xnor-gate-construction&quot;&gt;much to my surprise&lt;/a&gt;. &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2352/quantum-xor-linked-list-construction&quot;&gt;Little&lt;/a&gt; by &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2466/expressing-square-root-of-swap-gate-in-terms-of-cnot&quot;&gt;little&lt;/a&gt; I have been working to piece the &lt;a href=&quot;https://math.stackexchange.com/questions/1199477/pseudo-surreal-numbers-are-analogous-to/2792351#2792351&quot;&gt;puzzle&lt;/a&gt; together. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I have been pondering this question for a while now, but was not able to formulate it so succinctly until I saw the above quote.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I still don't feel able to properly convey my intuition around why this is a good approach..&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Abstract&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Star_(game_theory)&quot; rel=&quot;nofollow noreferrer&quot;&gt;Star&lt;/a&gt;&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;is not zero, but neither positive nor negative, and is therefore said to be fuzzy and confused with (a fourth alternative that means neither &quot;less than&quot;, &quot;equal to&quot;, nor &quot;greater than&quot;) 0&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Fuzzy_logic&quot; rel=&quot;nofollow noreferrer&quot;&gt;Fuzzy logic&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;is a form of many-valued logic in which the truth values of variables may be any real number between 0 and 1. It is employed to handle the concept of partial truth, where the truth value may range between completely true and completely false. By contrast, in Boolean logic, the truth values of variables may only be the integer values 0 or 1&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Qubit&quot; rel=&quot;nofollow noreferrer&quot;&gt;Qubit&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;—usually taken to have the value “0” and “1”, like a bit. However, whereas the state of a bit can only be either 0 or 1, the general state of a qubit according to quantum mechanics can be a superposition of both.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;Motivation&lt;/h2&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;It is likely to be a fresh research question, and you the person one most interested in the entire world in finding an answer --- in which case it is most probably up to you (and your opportunity!) to obtain the answer first.&quot; -Niel&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;While the motivation to wanting to make this work may not be apparent at first, a big piece of what I'm wanting to accomplish is creating a quantum algorithm based on surreal constructions for a quantum intelligence that can use game theory for computation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I have placed a &lt;a href=&quot;https://cstheory.stackexchange.com/questions/25943/implementation-of-surreal-numbers-for-games&quot;&gt;couple&lt;/a&gt; different &lt;a href=&quot;https://physics.stackexchange.com/questions/215532/renormalization-and-conway-surreal-numbers&quot;&gt;bounties&lt;/a&gt; in an attempt to push along this research.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Question&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;How can surreal maths be used in quantum computing?&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-07-19T02:09:29.493" LastActivityDate="2018-07-19T02:09:29.493" Title="How can surreal maths be used in quantum computing?" Tags="&lt;quantum-theory&gt;&lt;quantum-foundations&gt;&lt;nonlocal-games&gt;" AnswerCount="1" CommentCount="21" FavoriteCount="2" ClosedDate="2018-07-16T18:38:29.690" />
  <row Id="2728" PostTypeId="2" ParentId="1385" CreationDate="2018-07-13T08:53:19.913" Score="0" Body="&lt;p&gt;I find a graphical approach quite good for giving some insight without getting too technical. We need some inputs:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;we can produce a state $|\psi\rangle$ with non-zero overlap with the 'marked' state $|x\rangle$: $\langle x|\psi\rangle\neq 0$.&lt;/li&gt;&#xA;&lt;li&gt;we can implement an operation $U_1=-(\mathbb{I}-2|\psi\rangle\langle\psi|)$&lt;/li&gt;&#xA;&lt;li&gt;we can implement an operation $U_2=\mathbb{I}-2|x\rangle\langle x|$.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;This last operation is the one that can mark our marked item with a -1 phase. We can also define a state $|\psi^\perp\rangle$ to be orthonormal to $|x\rangle$ such that the $\{|x\rangle,|\psi^\perp\rangle\}$ forms an orthonormal basis for the span of $\{|x\rangle,|\psi\rangle\}$. Both the operations that we have defined preserve this space: you start with some state in the span of $\{|x\rangle,|\psi^\perp\rangle\}$, and they return a state within the span. Moreover, both are unitary, so the length of the input vector is preserved.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A vector of fixed length within a two-dimensional space can be visualised as the circumference of a circle. So, let's set up a circle with two orthogonal directions corresponding to $|\psi^\perp\rangle$ and $|x\rangle$.&#xA;&lt;a href=&quot;https://i.stack.imgur.com/sGwD3.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/sGwD3.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Our initial state $|\psi\rangle$ will have small overlap with $|x\rangle$ and large overlap with $|\psi^\perp\rangle$. If it were the other way around, search would be easy: we'd just prepare $|\psi\rangle$, measure, and test the output using the marking unitary, repeating until we got the marked item. It wouldn't take long. Let's call the angle between $|\psi\rangle$ and $|\psi^\perp\rangle$ the angle $\theta$.&#xA;&lt;a href=&quot;https://i.stack.imgur.com/u0OTk.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/u0OTk.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now let's take a moment to think about what our two unitary actions do. Both have a -1 eigenvalue, and all other eigenvalues +1. In our two-dimensional subspace, that reduces to a +1 eigenvalue and a -1 eigenvalue. Such an operation is a reflection in the axis defined by the +1 eigenvector. So, $U_1$ is a reflection in the $|\psi\rangle$ axis, while $U_2$ is a reflection in the $|\psi^\perp\rangle$ axis.&#xA;&lt;a href=&quot;https://i.stack.imgur.com/nE2ps.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/nE2ps.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, take an arbitrary vector in this space, and apply $U_2$ followed by $U_1$. The net effect is that the vector is rotated by an angle $2\theta$ towards the $|x\rangle$ axis.&#xA;&lt;a href=&quot;https://i.stack.imgur.com/ofkHu.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/ofkHu.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, if you start from $|\psi\rangle$, you can repeat this sufficiently many times, and get to within an angle $\theta$ of $|x\rangle$. Thus, when we measure that state, we get the value $x$ with high probability.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now we need a little care to find the speed-up. Assume that the probability of finding $|x\rangle$ in $|\psi\rangle$ is $p\ll 1$. So, classically, we'd need $O(1/p)$ attempts to find it. In our quantum scenario, we have that $\sqrt{p}=\sin\theta\approx\theta$ (since $\theta$ is small), and we want a number of runs $r$ such that $\sin((2r+1)\theta)\approx 1$. So, $r\approx \frac{\pi}{2\theta}\approx \frac{\pi}{2\sqrt{p}}$. You can see the square-root speed-up right there.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-07-13T08:53:19.913" CommentCount="0" />
  <row Id="2729" PostTypeId="1" AcceptedAnswerId="2732" CreationDate="2018-07-13T11:43:57.257" Score="11" ViewCount="2357" Body="&lt;p&gt;The most general definition of a quantum state I found is (rephrasing the definition from &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_state#Pure_states&quot; rel=&quot;noreferrer&quot;&gt;Wikipedia&lt;/a&gt;)&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Quantum states are represented by a ray in a finite- or infinite-dimensional Hilbert space over the complex numbers.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Moreover, we know that in order to have a useful representation we need to ensure that the vector representing the quantum state is a &lt;em&gt;unit vector&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But in the definition above, they don't precise the norm (or the scalar product) associated with the Hilbert space considered. At first glance I though that the norm was not really important, but I realised yesterday that the norm was &lt;em&gt;everywhere&lt;/em&gt; chosen to be the Euclidian norm (2-norm).&#xA;Even the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation&quot; rel=&quot;noreferrer&quot;&gt;bra-ket&lt;/a&gt; notation seems to be made specifically for the euclidian norm.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;My question:&lt;/strong&gt; Why is the Euclidian norm used everywhere? Why not using an other norm? Does the Euclidian norm has useful properties that can be used in quantum mechanics that others don't?&lt;/p&gt;&#xA;" OwnerUserId="1386" LastEditorUserId="26" LastEditDate="2018-07-15T13:14:16.257" LastActivityDate="2018-07-15T13:14:16.257" Title="Quantum states are unit vectors... with respect to which norm?" Tags="&lt;quantum-state&gt;&lt;notation&gt;&lt;unitarity&gt;&lt;mathematics&gt;" AnswerCount="6" CommentCount="1" FavoriteCount="2" />
  <row Id="2730" PostTypeId="2" ParentId="2729" CreationDate="2018-07-13T12:07:49.743" Score="7" Body="&lt;p&gt;Some terminology seems a little bit jumbled here. Quantum states are represented (within a finite dimensional Hilbert space) by complex vectors of length 1, where length is measured by the Euclidean norm. They are not unitary, because unitary is a classification of a matrix, not a vector.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quantum states are changed/evolved according to some matrix. Given that quantum states have length 1, it turns out to be necessary and sufficient that the maps of pure states to pure states are described by unitary matrices. These are the only matrices that preserve the (Euclidean) norm.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is certainly a valid question &quot;could we use a different ($p$) norm  for our quantum states?&quot; If you then classify the operations that map normalised states to normalised states, they are incredibly limited. If $p\neq 2$, the only valid operations are permutation matrices (with different phases on each element). Physics would be a whole lot more boring.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A good way to get a feel for this is to try drawing a 2D set of axes. Draw on it the shapes corresponding to the set of points of length 1 under different $p$-norms. $p=2$ gives you the circle, $p=1$ gives you a diamond, and $p\rightarrow\infty$ gives a square. What operations can you do that map the shape onto itself? For the circle, it's any rotation. For anything else, it's just rotations by multiples of $\pi/2$. The following comes from Wikipedia:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/SEEdJ.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/SEEdJ.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you want more details, you might want to look &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0401062&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-07-13T14:42:14.350" LastActivityDate="2018-07-13T14:42:14.350" CommentCount="7" />
  <row Id="2731" PostTypeId="2" ParentId="2729" CreationDate="2018-07-13T12:20:29.400" Score="-1" Body="&lt;p&gt;The Euclidean norm on an $n$-dimensional space, as defined &lt;a href=&quot;https://en.wikipedia.org/wiki/Norm_(mathematics)#Euclidean_norm&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;, is &lt;strong&gt;not&lt;/strong&gt; the only norm used for quantum states.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A quantum state doesn't have to be defined on an n-dimensional Hilbert space, for example the quantum states for a 1D harmonic oscillator are functions $\psi_i(x)$ whose ortho-normality is defined by:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;\int \psi_i(x)\psi_j^*(x)dx.&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If $i=j$ we get:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;\int |\psi(x)|^2dx = \int P(x)dx = 1,&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;because the total probability must be 1.&lt;br&gt;&#xA;If $i\ne j$, we get 0, meaning that the functions are orthogonal.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Euclidean norm, as defined in the link I gave, is more for quantum states on discrete variables where $n$ is some countable number. In the above case, $n$ (which is the number of possible values that $x$ can be) is uncountable, so the norm doesn't fit into the definition given for a Euclidean norm on an $n$-dimensional pace.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We could also apply a square root operator to the above norm, and still we'd have the required property that $\int P(x)dx=1$, and the Euclidean norm can then be thought of as a special case of this norm though, for the case where $x$ can only be chosen from some countable number of values. The reason why we use the above norm in quantum mechanics is because it guarantees that the probability function $P(x)$ integrates to 1, which is a mathematical law based on the &lt;em&gt;definition&lt;/em&gt; of probability. If you had some other norm which can guarantee that all laws of probability theory are satisfied, you would be able to use that norm too.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-07-13T12:54:13.593" LastActivityDate="2018-07-13T12:54:13.593" CommentCount="18" />
  <row Id="2732" PostTypeId="2" ParentId="2729" CreationDate="2018-07-13T13:10:14.310" Score="5" Body="&lt;p&gt;Born's rule states that $|\psi(x)|^2 = P(x)$ which is the probability of finding the quantum system in the state $|x\rangle$ after a measurement. We need the sum (or integral!) over all $x$ to be 1:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{align}&#xA;\sum_x P_x &amp;amp;= \sum_x |\psi_x|^2 = 1,\\&#xA;\int P(x)dx &amp;amp;= \int |\psi(x)|^2 dx= 1.&#xA;\end{align}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Neither of these are valid norms because they are not &lt;a href=&quot;https://en.wikipedia.org/wiki/Norm_(mathematics)#Definition&quot; rel=&quot;nofollow noreferrer&quot;&gt;homogenous&lt;/a&gt;.&#xA;You can make them homogenous simply by doing the square root:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{align}&#xA;\sqrt{\sum_x |\psi_x|^2} = 1,\\&#xA;\sqrt{\int |\psi(x)|^2dx} = 1.&#xA;\end{align}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;and you may recognize this as the Euclidean norm and a generalization of the Euclidean norm to a non-discrete domain. We could also use a different norm:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{align}&#xA;\sqrt{\sum_x \psi_x A \psi_x^*} = 1,\\&#xA;\sqrt{\int \psi(x)A\psi^*(x)} = 1,&#xA;\end{align}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;for some positive definite matrix/function A.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;However&lt;/em&gt;&lt;/strong&gt; a $p$-norm with $p&amp;gt;2$ would not be as useful because for example:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{align}&#xA;\sqrt[5]{\sum_x |\psi_x|^5} \\&#xA;\end{align}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;does not have to be 1. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;In this way the Euclidean norm is special because 2 is the power in Born's rule, which is one of the postulates of quantum mechanics.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-07-14T07:38:36.727" LastActivityDate="2018-07-14T07:38:36.727" CommentCount="18" />
  <row Id="2733" PostTypeId="2" ParentId="2727" CreationDate="2018-07-13T14:39:47.357" Score="1" Body="&lt;p&gt;In quantum field theory there are Feynman path integrals that diverge and for this there is a concept of &quot;renormalization&quot;. At least &lt;a href=&quot;https://physics.stackexchange.com/questions/215532/renormalization-and-conway-surreal-numbers&quot;&gt;one approach to this uses surreal numbers&lt;/a&gt; but it is not very mainstream.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-07-13T14:50:04.847" LastActivityDate="2018-07-13T14:50:04.847" CommentCount="2" />
  <row Id="2734" PostTypeId="5" CreationDate="2018-07-13T15:56:40.077" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-07-13T15:56:40.077" LastActivityDate="2018-07-13T15:56:40.077" CommentCount="0" />
  <row Id="2735" PostTypeId="4" CreationDate="2018-07-13T15:56:40.077" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-07-13T15:56:40.077" LastActivityDate="2018-07-13T15:56:40.077" CommentCount="0" />
  <row Id="2736" PostTypeId="2" ParentId="2729" CreationDate="2018-07-13T17:01:46.920" Score="4" Body="&lt;p&gt;More mathematically, because $\mathbb{R}^n$ with an $L^p$ norm is a Hilbert space only for $p=2$.&lt;/p&gt;&#xA;" OwnerUserId="3097" LastActivityDate="2018-07-13T17:01:46.920" CommentCount="6" />
  <row Id="2737" PostTypeId="2" ParentId="2729" CreationDate="2018-07-13T18:53:51.197" Score="2" Body="&lt;p&gt;The other answers addressed why $p=2$ in terms of which $L^p$ space to use, but not the weighting.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You could put in a Hermitian positive definite matrix $M_{ij}$ so that that the inner product is $\sum x_i^* M_{ij} y_j$. But that doesn't gain you much. This is because you might as well change variables. For ease, consider the case when $M$ is diagonal. with the diagonal case that would be interpreting $M_{ii} \mid x_i \mid^2$ as a probability instead of $\mid x_i \mid^2$. $M_{ii}&amp;gt;0$ so why not just change variables to $\tilde{x}_i = \sqrt{M_{ii}} x_i$. You can think of this as $L^2$ functions on the space of $n$ points where each point is weighted by $M_{ii}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For the continuous 1 variable case, yes you could use $L^2 (\mathbb{R} , w(x) dx)$ as well. $w(x)$ just reweights the lengths. That's still a perfectly good Hilbert space. But the problem is that translation $x \to x+a$ was supposed to be a symmetry and $w(x)$ breaks that. So might as well not use $w(x)$. For some purposes, that symmetry is not present, so you do have a $w(x) \neq 1$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In some cases it is useful not to move to standard form. It shuffles around how you do some calculations. For example, if you're doing some numerics, then you can reduce your errors by this sort of reshuffling to avoid really small or large numbers that your machine finds difficult.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A tricky thing is to make sure you keep track of when you changed your variables and when you didn't. You don't want to get confused between changing to the standard inner product doing some unitary and changing variables back vs trying to do that in one step. You are likely to drop factors of $\sqrt{M_{ii}}$ etc by mistake, so be careful.&lt;/p&gt;&#xA;" OwnerUserId="434" LastActivityDate="2018-07-13T18:53:51.197" CommentCount="0" />
  <row Id="2738" PostTypeId="2" ParentId="2667" CreationDate="2018-07-13T20:01:37.790" Score="3" Body="&lt;p&gt;Relatedly, there is also an &lt;a href=&quot;https://www.edx.org/course/quantum-cryptography-caltechx-delftx-qucryptox-0&quot; rel=&quot;nofollow noreferrer&quot;&gt;EdX course&lt;/a&gt; on quantum cryptography. The main instructors are Stephanie Wehner and Thomas Vidick, with guest lectures by Ronald Hanson, Nicolas Gisin and David Elkouss. Its description is the following:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;How can you tell a secret when everyone is able to listen in? In this course, you will learn how to use quantum effects, such as quantum entanglement and uncertainty, to implement cryptographic tasks with levels of security that are impossible to achieve classically.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;This interdisciplinary course is an introduction to the exciting field of quantum cryptography, developed in collaboration between QuTech at Delft University of Technology and the California Institute of Technology. By the end of the course you will:&lt;/p&gt;&#xA;  &#xA;  &lt;ul&gt;&#xA;  &lt;li&gt;&lt;p&gt;Be armed with a fundamental toolbox for understanding, designing and analyzing quantum protocols.&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Understand quantum key distribution protocols.&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Understand how untrusted quantum devices can be tested.&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;li&gt;&lt;p&gt;Be familiar with modern quantum cryptography – beyond quantum key distribution.&lt;/p&gt;&lt;/li&gt;&#xA;  &lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="1825" LastEditorUserId="1825" LastEditDate="2018-07-13T23:31:04.927" LastActivityDate="2018-07-13T23:31:04.927" CommentCount="0" />
  <row Id="2740" PostTypeId="1" CreationDate="2018-07-13T22:30:05.923" Score="7" ViewCount="73" Body="&lt;p&gt;For two-qubit states, represented by a $4\times 4$ density matrix, the generic state is described by 15 real parameters. For ease of calculation, it can help to consider restricted families of states, such as the &quot;$X$&quot;-states, where any matrix elements not on either the main diagonal or anti-diagonal are 0 (requiring 7 real parameters), or rebits, where the matrix elements are all real (requiring 9 real parameters).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For any given density matrix of two qubits, it is easy to tell if it's entangled: we just test the partial transpose criterion, and the presence of negative eigenvalues. One might like to measure the &lt;a href=&quot;https://arxiv.org/abs/quant-ph/9804024&quot; rel=&quot;nofollow noreferrer&quot;&gt;fraction of the space that is entangled&lt;/a&gt;, and for that, one must pick a particular measure.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The probability with respect to Hilbert-Schmidt measure that generic two-qubit $X$-states are separable has been shown to be $\frac{2}{5}$ (&lt;a href=&quot;https://arxiv.org/abs/1408.3666v2&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv:1408.3666v2&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1501.02289v2&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv:1501.02289v2&lt;/a&gt;). Additionally, Lovas and Andai have demonstrated  that the corresponding probability for the two-rebit  density matrices is $\frac{29}{64}$ (&lt;a href=&quot;https://arxiv.org/abs/1610.01410&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/1610.01410&lt;/a&gt;).  Additionally, a strong body of various forms of evidence (though yet no formal proof) has been developed that the probabilities &#xA;for the arbitrary two-qubit  and (27-dimensional) two-``quater”[nionic]bit'' density matrices &#xA;are $\frac{8}{33}$ and $\frac{26}{323}$, respectively (&lt;a href=&quot;https://arxiv.org/abs/1701.01973&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv:1701.01973&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, analogous results with respect to the important Bures (minimal monotone) measure are presently unknown.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Now, in what manner, if any, might these known Hilbert-Schmidt results be employed to assist in the further estimation/determination of their Bures counterparts?&lt;/strong&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Perhaps useful in such an undertaking would be the procedures for the generation of random density matrices with respect to &#xA;Bures and Hilbert-Schmidt measure outlined in &lt;a href=&quot;https://arxiv.org/abs/0909.5094v1&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv:0909.5094v1&lt;/a&gt;. Further, Chapter 14 of &quot;Geometry of Quantum States&quot; of Bengtsson and Zyczkowski presents formulas for the two measures, among a wide literature of related analyses.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It seems a particularly compelling conjecture that the two-qubit Bures separability probability assumes some yet unknown simple, elegant form ($\approx 0.073321$), as has been demonstrated do its counterparts, also based on fundamental quantum information-theoretic measures. A value of $\frac{11}{150) =\frac{11}{2 \cdot 3 cdot 5^2}  \approx 0.07333...$ is an interesting candidate in this matter.&lt;/p&gt;&#xA;" OwnerUserId="3089" LastEditorUserId="3089" LastEditDate="2018-08-06T20:13:36.497" LastActivityDate="2018-08-06T20:13:36.497" Title="Estimate/determine Bures separability probabilities making use of corresponding Hilbert-Schmidt probabilities" Tags="&lt;quantum-entanglement&gt;&lt;quantum-information&gt;" AnswerCount="0" CommentCount="5" />
  <row Id="2742" PostTypeId="2" ParentId="2729" CreationDate="2018-07-14T08:32:58.047" Score="4" Body="&lt;p&gt;An elegant argument can be derived by asking which theories can we build which are described by vectors $\vec v = (v_1,\dots,v_N)$, where the allowed transformations are linear maps $\vec v\to L\vec v$, probabilities are given by some norm, and probabilities must be preserved by those maps.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It turns out that there are basically only three options: &lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Deterministic theories.&lt;/strong&gt; Then we don't need those vectors, since we are always in one specific state, i.e. the vectors are $(0,1,0,0,0)$ and the like, and the $L$'s are only permutations.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Classical probabilistic theories.&lt;/strong&gt;  Here, we use the $1$-norm and stochastic maps. The $v_i$ are probabilities.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Quantum mechanics.&lt;/strong&gt; Here, we use the $2$-norm and unitary transformations. The $v_i$ are amplitudes.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;These are the only possibilities. For other norms no interesting transformations exist.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you want a more detailed and nice explanation of this, Scott Aaronson's &quot;Quantum Computing since Democritus&quot; has &lt;a href=&quot;https://www.scottaaronson.com/democritus/lec9.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;a Lecture on this&lt;/a&gt;, as well as &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0401062&quot; rel=&quot;nofollow noreferrer&quot;&gt;a paper&lt;/a&gt;. &lt;/p&gt;&#xA;" OwnerUserId="491" LastEditorUserId="491" LastEditDate="2018-07-14T09:04:00.450" LastActivityDate="2018-07-14T09:04:00.450" CommentCount="0" />
  <row Id="3743" PostTypeId="1" CreationDate="2018-07-14T23:03:21.847" Score="5" ViewCount="123" Body="&lt;p&gt;Following &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2725/26&quot;&gt;@DaftWullie's answer&lt;/a&gt; I tried to simulate the circuit given in Fig. 4 of the paper (arXiv pre-print): &lt;a href=&quot;https://arxiv.org/abs/1110.2232v2&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum circuit design for solving linear systems of equations (Cao et al, 2012)&lt;/a&gt;, on &lt;a href=&quot;https://algassert.com/quirk&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quirk&lt;/a&gt;. &lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;The relevant circuit in the arXiv pre-print by Cao et al is:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/Rj7HR.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/Rj7HR.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;Please note that (I think) the $e^{-iAt_0/2^s}$ (s.t. $1\leq s \leq 4$) gates in the circuit should actually be $e^{+iAt_0/2^s}$ gates instead. That's &lt;em&gt;probably&lt;/em&gt; a misprint in the paper.&lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;You will find the equivalent Quirk simulated circuit &lt;a href=&quot;https://goo.gl/wu6jZW&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;.&lt;/strong&gt; The labellings of the gates (along with the matrix entries) can be seen from the dashboard by hovering over them. The matrix entries may also be obtained from the JSON code in the URL. You might want to use a &lt;a href=&quot;http://jsonviewer.stack.hu&quot; rel=&quot;nofollow noreferrer&quot;&gt;JSON formatter&lt;/a&gt; for that purpose. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The rotation gates used in the paper are $R(8\pi/2^{r-1}),R(4\pi/2^{r-1}),R(2\pi/2^{r-1}),R(\pi/2^{r-1})$. On page 4 they mentioned that higher the value of $r$ they greater is the accuracy. So I took $r=7$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I created the custom gates $R_y(8\pi/2^{r-1})$, $R_y(4\pi/2^{r-1})$, $R_y(2\pi/2^{r-1})$ &amp;amp; $R_y(\pi/2^{r-1})$, using the definition of the $R_y$ matrices as:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$R_y(\theta) = \left(\begin{matrix}\cos(\theta/2) &amp;amp; \sin(\theta/2) \\ -\sin(\theta/2) &amp;amp; \cos(\theta/2) \end{matrix}\right)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, the output state of the &quot;input register&quot; should have been &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\frac{-|00\rangle + 7|01\rangle + 11|10\rangle + 13|11\rangle}{\sqrt{340}}$$&#xA;i.e. $$-0.0542326|00\rangle + 0.379628|01\rangle + 0.596559|10\rangle + 0.705024|11\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, I'm getting the output state of the input register as &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$-(-0.05220|00\rangle+0.37913|01\rangle+0.59635|10\rangle+0.70562|11\rangle)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;That is, there's a extraneous global phase of $-1$ in the final output. &lt;strong&gt;I'm not sure whether I have made a mistake in the implementation of the circuit OR whether the output of the circuit actually &lt;em&gt;supposed&lt;/em&gt; to be accompanied with the global phase.&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/3743/error-simulation-of-quantum-algorithm-for-linear-systems-of-equations-for-4#comment3726_3743&quot;&gt;@DaftWullie mentions&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;If it's a global phase, what does it matter? Everything is always &quot;up&#xA;  to a global phase&quot;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;That sure is logical! However, I want to be sure that I'm not making any silly error in the implementation itself. I wonder that if there's actually &lt;em&gt;supposed&lt;/em&gt; to be a global phase of $-1$, why they didn't explicitly mention it in the paper? I find that a bit surprising. (Indeed, yes, I should perhaps directly contact the authors, but maybe someone here might be able to spot the silly mistake (on my part) quicker! :)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In case you have any questions about my simulation, please feel free to ask in the comments. I'll be happy to clarify. &lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-16T19:39:11.277" LastActivityDate="2018-07-16T19:39:11.277" Title="Error: Simulation of &quot;Quantum algorithm for linear systems of equations&quot; for $4\times 4$ systems on Quirk (without SWAP) - Global phase" Tags="&lt;quantum-gate&gt;&lt;simulation&gt;&lt;hhl-algorithm&gt;&lt;quirk-simulator&gt;" AnswerCount="0" CommentCount="9" FavoriteCount="1" />
  <row Id="3745" PostTypeId="1" AcceptedAnswerId="3747" CreationDate="2018-07-15T06:15:47.523" Score="3" ViewCount="129" Body="&lt;p&gt;From what I have seen so far, there is a lot of linear algebra. Curious what other kinds of maths are used in QC &amp;amp; the specific fields in which they are most predominately invoked.&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="23" LastEditDate="2018-07-19T12:46:25.927" LastActivityDate="2018-07-19T12:46:25.927" Title="What kind of mathematics is common in quantum computing?" Tags="&lt;quantum-theory&gt;&lt;mathematics&gt;" AnswerCount="1" CommentCount="5" FavoriteCount="2" ClosedDate="2018-07-16T18:17:11.303" />
  <row Id="3746" PostTypeId="1" CreationDate="2018-07-15T07:06:20.873" Score="5" ViewCount="63" Body="&lt;p&gt;For quantum error correction, the necessary and sufficient condition is given in standard texts as:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\langle \phi| E^{\dagger}_{a} E_{b} |\psi \rangle = C_{ab} \langle \phi|\psi \rangle $&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$|\psi\rangle$ and $|\phi\rangle$ are codewords. $E_{a}$ and $E_b$ are arbitrary errors that can occur.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My queries would be:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Why is $C_{ab}$ independent of the codewords and only dependant on the errors? Intuitively, I realize this is because otherwise, we gain some information about the codeword by detecting the error and run the risk of disturbing the superposition of the codeword. Is there a more formal mathematical explanation for the same?&lt;/li&gt;&#xA;&lt;li&gt;I realize that $C$ is a Hermitian matrix which can be diagonalized. What does it mean in terms of the codewords and the errors to diagonalize the matrix $C$?&lt;/li&gt;&#xA;&lt;li&gt;Why is it the case that the state $|\psi\rangle$ is always an eigenstate of $ E^{\dagger}_{a} E_{b}$ with $C_{ab}$ as an eigenvalue? It doesn't seem intuitive to me.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="1351" LastEditorUserId="1351" LastEditDate="2018-07-15T09:22:49.413" LastActivityDate="2018-07-15T09:54:14.720" Title="Quantum error correction: necessary and sufficient condition" Tags="&lt;quantum-error-correction&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="3747" PostTypeId="2" ParentId="3745" CreationDate="2018-07-15T08:03:56.123" Score="3" Body="&lt;ul&gt;&#xA;&lt;li&gt;Calculus (e.g. $\int |\psi(x)|^2dx = 1$ ) &lt;/li&gt;&#xA;&lt;li&gt;Differential Equations (e.g. Schroedinger equation)&lt;/li&gt;&#xA;&lt;li&gt;Complex analysis&lt;/li&gt;&#xA;&lt;li&gt;Statistics/Probability theory&lt;/li&gt;&#xA;&lt;li&gt;Stochastics (especially in studying open quantum systems)&lt;/li&gt;&#xA;&lt;li&gt;Information theory &lt;/li&gt;&#xA;&lt;li&gt;Topology (e.g. &lt;a href=&quot;https://en.wikipedia.org/wiki/Topological_quantum_computer&quot; rel=&quot;nofollow noreferrer&quot;&gt;topological quantum computing&lt;/a&gt;)&lt;/li&gt;&#xA;&lt;li&gt;Group theory (e.g. in stabilizer codes)&lt;/li&gt;&#xA;&lt;li&gt;Representation theory (e.g. in stabilizer codes)&lt;/li&gt;&#xA;&lt;li&gt;Graph theory (e.g. &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0509209&quot; rel=&quot;nofollow noreferrer&quot;&gt;graph state quantum computing&lt;/a&gt;)&lt;/li&gt;&#xA;&lt;li&gt;Functional analysis (e.g. &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2729/quantum-states-are-unit-vectors-with-respect-to-which-norm&quot;&gt;Quantum states are unit vectors... with respect to which norm?&lt;/a&gt;)&lt;/li&gt;&#xA;&lt;li&gt;Algebraic geometry (e.g. &lt;a href=&quot;https://www.nature.com/articles/srep43048&quot; rel=&quot;nofollow noreferrer&quot;&gt;for factoring numbers using quantum annealing&lt;/a&gt;)&lt;/li&gt;&#xA;&lt;li&gt;Discrete optimization (e.g. &lt;a href=&quot;https://arxiv.org/abs/1411.6758&quot; rel=&quot;nofollow noreferrer&quot;&gt;for factoring numbers using quantum annealing&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/abs/1706.08061&quot; rel=&quot;nofollow noreferrer&quot;&gt;also&lt;/a&gt;.)&lt;/li&gt;&#xA;&lt;li&gt;Optimal control theory (here's a review on &lt;a href=&quot;https://arxiv.org/abs/0707.1883&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum optimal control theory&lt;/a&gt;)&lt;/li&gt;&#xA;&lt;li&gt;Game theory (for quantum games)&lt;/li&gt;&#xA;&lt;li&gt;Boolean algebra (see this book on &lt;a href=&quot;https://github.com/k-local-quadratization/review/blob/master/k-local-review.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Boolean functions and quantum mechanics&lt;/a&gt;)&lt;/li&gt;&#xA;&lt;li&gt;Coding theory (e.g. Quantum Error Correcting codes)&lt;/li&gt;&#xA;&lt;li&gt;Number theory (e.g. Shor's algorithm)&lt;/li&gt;&#xA;&lt;li&gt;Category theory (e.g. &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1988/what-is-the-use-of-categorical-quantum-mechanics&quot;&gt;What is the use of Categorical quantum mechanics?&lt;/a&gt;)&lt;/li&gt;&#xA;&lt;li&gt;Differential geometry (for quantum information theorists working on quantum gravity)&lt;/li&gt;&#xA;&lt;li&gt;Formal Language Theory (in studying QC as a computation model)&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Amazingly&lt;/strong&gt;, I've even seen &lt;a href=&quot;https://en.wikipedia.org/wiki/Fractional_calculus&quot; rel=&quot;nofollow noreferrer&quot;&gt;fractional calculus&lt;/a&gt; come up for sub-Ohmic baths (s=1/2 in &lt;a href=&quot;https://arxiv.org/pdf/1205.4651.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;this&lt;/a&gt;)&#xA;&#xA;&lt;hr&gt;&lt;/li&gt;&#xA;&lt;li&gt;Basically any area of mathematics because we would like to make quantum algorithms to do things more efficiently, regardless of the mathematical field. For example &quot;semi-definite programming&quot; could be added to the list, because quantum algorithms for semi-definite programming is a very active current area of research. &#xA;&#xA;&lt;hr&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;sup&gt;A better question might be &quot;is there any area of mathematics for which you cannot see any possible connection to quantum computing?&quot;&lt;/sup&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-07-15T08:33:38.217" LastActivityDate="2018-07-15T08:33:38.217" CommentCount="3" />
  <row Id="3748" PostTypeId="2" ParentId="3746" CreationDate="2018-07-15T09:54:14.720" Score="1" Body="&lt;p&gt;&lt;strong&gt;General Comment&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For errors to be correctable, they must not cause us to mistake one codeword for an orthogonal one. So if two codewords are orthogonal, and they are acted upon by correctable errors, the result will remain orthogonal&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ \langle \phi|\psi \rangle =0 \,\,\implies\,\, \langle \phi| E^{\dagger}_{a} E_{b} |\psi \rangle = 0 $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Answer to 1&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;By setting $|\phi \rangle = |\psi \rangle$, your condition gives us&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$C_{ab} = \langle \psi | E^{\dagger}_{a} E_{b} |\psi \rangle.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The only case for which this would have no $ |\psi \rangle$ dependence is if $E^{\dagger}_{a} E_{b}=I$, which is clearly not an interesting case!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Perhaps your source assumes that a choice of an orthonormal basis for the codewords has been made, and then all else is basis dependent. Or perhaps I misunderstood the question.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Answer to 3&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Even if the errors are not unitary, the operator $E^{\dagger}_{a} E_{b}$ can be decomposed as a linear superposition of unitary operators. Since the condition in your question is linear, it therefore must be as true for non-unitary errors as for unitary errors.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-07-15T09:54:14.720" CommentCount="1" />
  <row Id="3749" PostTypeId="5" CreationDate="2018-07-15T13:03:46.310" Score="0" Body="" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-15T13:03:46.310" LastActivityDate="2018-07-15T13:03:46.310" CommentCount="0" />
  <row Id="3750" PostTypeId="4" CreationDate="2018-07-15T13:03:46.310" Score="0" Body="For general questions about quantum theory (quantum mechanics and quantum field theories), as relevant to quantum computing and/or quantum information." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-15T13:03:46.310" LastActivityDate="2018-07-15T13:03:46.310" CommentCount="0" />
  <row Id="3751" PostTypeId="5" CreationDate="2018-07-15T13:09:23.077" Score="0" Body="" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-15T13:09:23.077" LastActivityDate="2018-07-15T13:09:23.077" CommentCount="0" />
  <row Id="3752" PostTypeId="4" CreationDate="2018-07-15T13:09:23.077" Score="0" Body="Quantum foundations is the study of foundational questions related to Quantum mechanics and Quantum information theory. Some problems studied by researchers of quantum foundations are for instance the issue of the correct interpretation of quantum mechanics, the EPR paradox and the related area of quantum nonlocality and contextuality (Wikipedia). QUESTIONS RELATED TO INTERPRETATIONS OF QUANTUM THEORY SHOULD ALSO USE THIS TAG." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-15T13:09:23.077" LastActivityDate="2018-07-15T13:09:23.077" CommentCount="0" />
  <row Id="3753" PostTypeId="5" CreationDate="2018-07-15T13:15:39.963" Score="0" Body="" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-15T13:15:39.963" LastActivityDate="2018-07-15T13:15:39.963" CommentCount="0" />
  <row Id="3754" PostTypeId="4" CreationDate="2018-07-15T13:15:39.963" Score="0" Body="Use this tag for questions about mathematics relevant to quantum computing and/or quantum information theory. DO NOT use this tag for general mathematics questions." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-15T14:33:04.593" LastActivityDate="2018-07-15T14:33:04.593" CommentCount="0" />
  <row Id="3755" PostTypeId="5" CreationDate="2018-07-15T13:31:52.847" Score="0" Body="" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-15T13:31:52.847" LastActivityDate="2018-07-15T13:31:52.847" CommentCount="0" />
  <row Id="3756" PostTypeId="4" CreationDate="2018-07-15T13:31:52.847" Score="0" Body="For questions about matrix representations of quantum gates." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-15T13:31:52.847" LastActivityDate="2018-07-15T13:31:52.847" CommentCount="0" />
  <row Id="3757" PostTypeId="5" CreationDate="2018-07-15T13:36:59.720" Score="0" Body="" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-15T13:36:59.720" LastActivityDate="2018-07-15T13:36:59.720" CommentCount="0" />
  <row Id="3758" PostTypeId="4" CreationDate="2018-07-15T13:36:59.720" Score="0" Body="Quantum communication is a generalization of quantum cryptography. It refers to protocols and techniques for transmission of an unknown quantum state (of a quantum system) from one place to another." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-15T13:36:59.720" LastActivityDate="2018-07-15T13:36:59.720" CommentCount="0" />
  <row Id="3759" PostTypeId="5" CreationDate="2018-07-15T13:38:48.683" Score="0" Body="" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-15T13:38:48.683" LastActivityDate="2018-07-15T13:38:48.683" CommentCount="0" />
  <row Id="3760" PostTypeId="4" CreationDate="2018-07-15T13:38:48.683" Score="0" Body="A projection operator is one which when acts upon a quantum state (which is an element of a Hilbert space), &quot;projects&quot; it onto a subspace or onto another element of the same Hilbert space." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-15T13:44:25.753" LastActivityDate="2018-07-15T13:44:25.753" CommentCount="0" />
  <row Id="3761" PostTypeId="5" CreationDate="2018-07-15T13:46:19.157" Score="0" Body="" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-15T13:46:19.157" LastActivityDate="2018-07-15T13:46:19.157" CommentCount="0" />
  <row Id="3762" PostTypeId="4" CreationDate="2018-07-15T13:46:19.157" Score="0" Body="Quirk is an open-source drag-and-drop quantum circuit simulator for exploring and understanding small quantum circuits. It was developed by Craig Gidney." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-15T13:46:19.157" LastActivityDate="2018-07-15T13:46:19.157" CommentCount="0" />
  <row Id="3763" PostTypeId="5" CreationDate="2018-07-15T13:53:17.160" Score="0" Body="" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-15T13:53:17.160" LastActivityDate="2018-07-15T13:53:17.160" CommentCount="0" />
  <row Id="3764" PostTypeId="4" CreationDate="2018-07-15T13:53:17.160" Score="0" Body="Non-local games, which are cooperative games of incomplete information, include strategies that make use of entanglement, outperforming all possible classical strategies. Non-local games were introduced by Cleve et.al in 2004." OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-15T13:53:17.160" LastActivityDate="2018-07-15T13:53:17.160" CommentCount="0" />
  <row Id="3765" PostTypeId="1" CreationDate="2018-07-15T19:51:49.450" Score="5" ViewCount="128" Body="&lt;p&gt;As a beginner, for exercise purpose, I’ve studied this two quantum circuits. They are equivalent, and for 2 qubits it’s easy to write the unitary transformation matrix.&#xA;&lt;a href=&quot;https://i.stack.imgur.com/f9iYu.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/f9iYu.png&quot; alt=&quot;Cirquits and untary matrix&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Looking for another method I wrote what follows, but I’m not sure about notation and, particularly, the last passage.&#xA;So, I’m asking here if what I’ve written is admissible (maybe with some correction?).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/WRDBF.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/WRDBF.png&quot; alt=&quot;My solution&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are other methods?&lt;/p&gt;&#xA;" OwnerUserId="2886" LastEditorUserId="124" LastEditDate="2018-07-15T22:33:34.147" LastActivityDate="2018-07-17T15:02:52.037" Title="Showing the equivalence of two simple {NOT, CNOT} circuits" Tags="&lt;circuit-model&gt;" AnswerCount="3" CommentCount="0" FavoriteCount="1" />
  <row Id="3766" PostTypeId="2" ParentId="3765" CreationDate="2018-07-15T21:55:11.317" Score="2" Body="&lt;p&gt;You seem to have the basic idea. However, for a more formal way to approach the analysis, you might be interested in the following.$\def\ket#1{\lvert #1 \rangle}$&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;The effect of the 'NOT' gate $X$ on standard basis states can be presented in terms of an explicit change to the bit value inside the Dirac notation, &lt;em&gt;e.g.&lt;/em&gt;:&#xA;$$ X \,\ket t = \ket{t \oplus 1}$$&#xA;where $a \oplus b$ is the parity (&lt;em&gt;i.e.&lt;/em&gt;&amp;nbsp;the sum modulo 2) of a pair of bits $a,b \in \{0,1\}$.&lt;br&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Using the fact that $a \oplus b$ is the sum mod 2 of a pair of bits $a,b \in \{0,1\}$,we know that $\oplus$ is commutative and associative, so that in particular&#xA;$$ (a \oplus b) \oplus c = (a \oplus c) \oplus b.$$&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Using this, we may then describe your left-hand circuit as follows:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;\begin{align}&#xA;\ket{\psi_1} &amp;amp;= \ket{c} \otimes \ket{t} ;&#xA;\\[2ex]&#xA;\ket{\psi_2} &amp;amp;= X\ket{c} \otimes \ket{t}&#xA;\\&#xA;&amp;amp;= \ket{c {\,\oplus\;\!} 1} \otimes \ket{t} ;&#xA;\\[2ex]&#xA;\ket{\psi_3} &amp;amp;= \ket{c {\,\oplus\;\!} 1} \otimes \ket{(c {\,\oplus\;\!} 1) {\,\oplus\;\!} t}&#xA;\\&#xA;&amp;amp;= \ket{c {\,\oplus\;\!} 1} \otimes \ket{(c {\,\oplus\;\!} t) {\,\oplus\;\!} 1}&#xA;\\&#xA;&amp;amp;= X\ket{c} \otimes X\ket{c {\,\oplus\;\!} t} .&#xA;\end{align}$$&lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-07-15T22:31:55.257" LastActivityDate="2018-07-15T22:31:55.257" CommentCount="4" />
  <row Id="3767" PostTypeId="1" AcceptedAnswerId="3785" CreationDate="2018-07-16T00:39:56.460" Score="4" ViewCount="95" Body="&lt;p&gt;So far I have read a little bit about zx-calculus &amp;amp; &lt;a href=&quot;https://arxiv.org/abs/1702.00934&quot; rel=&quot;nofollow noreferrer&quot;&gt;y-calculus&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;From &lt;a href=&quot;https://link.springer.com/chapter/10.1007/978-3-642-36315-3_1&quot; rel=&quot;nofollow noreferrer&quot;&gt;Reversible Computation&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The zx-calculus is a graphical language for describing quantum systems. &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The zx-calculus is an equational theory, based on rewriting the diagrams&#xA;  which comprise its syntax. Re-writing can be automated by means of the &lt;a href=&quot;https://quantomatic.github.io/&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantomatic&lt;/a&gt; software.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;This method seems very interesting, however I am not able to find much introductory information on the subject. Any &lt;strong&gt;insight into the subject or additional resources&lt;/strong&gt; would be greatly appreciated.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Current Resources:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1705.11151&quot; rel=&quot;nofollow noreferrer&quot;&gt;A Complete Axiomatisation of the ZX-Calculus for Clifford+T Quantum Mechanics&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1804.05356&quot; rel=&quot;nofollow noreferrer&quot;&gt;ZX-Rules for 2-qubit Clifford+T Quantum Circuits&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1702.00934&quot; rel=&quot;nofollow noreferrer&quot;&gt;Y-Calculus: A Language for Real Matrices Derived from the ZX-Calculus&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://link.springer.com/chapter/10.1007%2F978-3-642-36315-3_1&quot; rel=&quot;nofollow noreferrer&quot;&gt;Tutorial: Graphical Calculus for Quantum Circuits&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1805.02175&quot; rel=&quot;nofollow noreferrer&quot;&gt;ZH: A Complete Graphical Calculus for Quantum Computations Involving Classical Non-linearity&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1111.6950&quot; rel=&quot;nofollow noreferrer&quot;&gt;Tensor networks and graphical calculus for open quantum system&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://quantomatic.github.io/papers.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Papers from Quantomatic&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://www.mscs.dal.ca/~selinger/papers/graphical.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;A survery of graphical languages for monoidal categories&lt;/a&gt; (PDF)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="26" LastEditDate="2018-07-16T15:49:25.447" LastActivityDate="2018-07-16T19:57:45.330" Title="Graphical Calculus for Quantum Circuits" Tags="&lt;resource-request&gt;&lt;mathematics&gt;" AnswerCount="2" CommentCount="2" />
  <row Id="3768" PostTypeId="2" ParentId="3767" CreationDate="2018-07-16T01:41:35.290" Score="2" Body="&lt;p&gt;You already put Selinger's survey, so here are a couple more links&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/0903.0340.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Baez and Stay&lt;/a&gt;. You could see other Baez blog posts as well.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://qchu.wordpress.com/2012/11/05/introduction-to-string-diagrams/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Qiaochu Yuan's blog&lt;/a&gt;. See later in that series as well.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Edit:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Baez and Stay is a survey article. It covers monoidal, braided, symmetric and dagger categories. For the example related to quantum computation focus on either Hilb or cobordism. The appropriate string diagrams for these are included along with the sections for those types of categories. It points the connections between logic and type theory as well, but you don't need those sections. However it would be helpful.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Qiaochu's blog post is more introductory and brief. It focuses solely on the vector space example as to avoid prerequisites besides linear algebra. The later posts in that series cover other adjectives to add on such as braided, symmetric or dagger.&lt;/p&gt;&#xA;" OwnerUserId="434" LastEditorUserId="434" LastEditDate="2018-07-16T18:35:10.813" LastActivityDate="2018-07-16T18:35:10.813" CommentCount="2" />
  <row Id="3769" PostTypeId="2" ParentId="3765" CreationDate="2018-07-16T04:39:17.180" Score="0" Body="&lt;p&gt;You can also use the definition of XOR in the following way:&#xA;$c\oplus t = c'.t + c.t'$ (where the primes mean not)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\implies (c\oplus t)' = (c'.t + c.t')'$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now using De Morgan's rule,&#xA;$(c'.t + c.t')' = (c+t').(c'+t) = c't'+ct$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Which can be seen as being the same as $c'\oplus t$&lt;/p&gt;&#xA;" OwnerUserId="4107" LastEditorUserId="26" LastEditDate="2018-07-17T15:02:52.037" LastActivityDate="2018-07-17T15:02:52.037" CommentCount="2" />
  <row Id="3770" PostTypeId="1" AcceptedAnswerId="3775" CreationDate="2018-07-16T04:55:38.013" Score="9" ViewCount="702" Body="&lt;p&gt;I was searching for examples of quantum circuits to exercise with Q# programming and I stumbled on this circuit:&#xA;&lt;a href=&quot;https://i.stack.imgur.com/eBhlJ.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/eBhlJ.png&quot; alt=&quot;Toffoli Gate as FANOUT&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt; &lt;strong&gt;From&lt;/strong&gt;: &lt;a href=&quot;https://warwick.ac.uk/fac/sci/physics/research/cfsa/people/pastmembers/charemzam/pastprojects/mcharemza_quant_circ.pdf&quot; rel=&quot;noreferrer&quot;&gt;Examples of Quantum Circuit Diagrams&#xA;- Michal Charemza&lt;/a&gt; &lt;/sup&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;During my introductory courses in quantum computation, we were taught that the cloning of a state is forbidden by the laws of QM, while in this case the first contol qubit is copied on the third, target, qubit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I quickly tried to simulate the circuit on Quirk, &lt;a href=&quot;https://algassert.com/quirk#circuit=%7B%22cols%22:[[%22X%22],[%22X%5Et%22],[%22Density%22,%22X%22,%22Density%22],[%22%E2%80%A2%22,%22%E2%80%A2%22,%22X%22],[%22Density%22,%22Density%22,%22Density%22]]%7D&quot; rel=&quot;noreferrer&quot;&gt;something like this&lt;/a&gt;, that sort of confirms the cloning of the state in output on the first qubit. Measuring the qubit before the Toffoli gate shows that is in fact no real cloning, but instead a change on the first control qubit, and an equal output on the first and third qubit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;By making simple math, it can be shown that the &quot;cloning&quot; happens only if the third qubit is in initial state 0, and that only if on the first qubit is not performed a &quot;spinning operation&quot; (as indicated on Quirk) on Y or X.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I tried writing a program in Q# that only confirmed which is aforesaid.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I struggle in understanding how the first qubit is changed by this operation, and how something similar to a cloning is possible.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thank you in advance!&lt;/p&gt;&#xA;" OwnerUserId="2601" LastEditorUserId="26" LastEditDate="2018-07-16T15:43:34.570" LastActivityDate="2018-07-18T16:14:36.003" Title="Toffoli gate as FANOUT" Tags="&lt;quantum-computer&gt;&lt;quantum-gate&gt;" AnswerCount="3" CommentCount="1" FavoriteCount="1" />
  <row Id="3771" PostTypeId="1" AcceptedAnswerId="3780" CreationDate="2018-07-16T05:23:44.857" Score="3" ViewCount="69" Body="&lt;p&gt;In &lt;a href=&quot;http://decodoku.blogspot.com/2016/07/quantum-computation-with-simplest-maths.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Computation with the simplest maths possible&lt;/a&gt; there is a section titled &quot;&lt;strong&gt;Doing maths with a controlled-half NOT&lt;/strong&gt;&quot; which covers a reversible-(N)AND circuit with controlled-half NOTs. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/6IFRG.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/6IFRG.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;What would the unitary matrix for a controlled-half NOT be?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;How could a &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2333/quantum-XNOR-gate-construction&quot;&gt;reversible-XNOR&lt;/a&gt; gate be constructed with controlled-half NOTs? &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;How would a half-adders, full adders &amp;amp; &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2346/quantum-ripple-carry-adder-construction&quot;&gt;ripple carry adders&lt;/a&gt; be constructed from controlled-half NOTs?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="26" LastEditDate="2018-07-16T15:41:36.913" LastActivityDate="2018-07-17T15:00:24.890" Title="Doing maths with controlled-half NOTs" Tags="&lt;quantum-gate&gt;&lt;gate-synthesis&gt;&lt;universal-gates&gt;&lt;controlled-gates&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="3772" PostTypeId="1" AcceptedAnswerId="3781" CreationDate="2018-07-16T05:40:10.547" Score="4" ViewCount="57" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;A topological quantum computer is a theoretical quantum computer that employs two-dimensional quasiparticles called anyons. -&lt;a href=&quot;https://en.wikipedia.org/wiki/Topological_quantum_computer&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wikipedia&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Are there other instances of topological quantum computing models that do not use anyons?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Are there alternative forms of anyons besides Fibonacci anyons?&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="26" LastEditDate="2018-07-16T15:38:42.670" LastActivityDate="2018-07-16T15:38:42.670" Title="Anyon alternatives in topological quantum computing" Tags="&lt;quantum-computing-models&gt;&lt;topological-quantum-computing&gt;&lt;anyons&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="3773" PostTypeId="1" CreationDate="2018-07-16T06:00:49.633" Score="6" ViewCount="73" Body="&lt;p&gt;Does something like &lt;a href=&quot;http://algassert.com/quirk&quot; rel=&quot;noreferrer&quot;&gt;Quirk&lt;/a&gt; exist for topological (eg. &lt;em&gt;braided&lt;/em&gt;) circuits? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Alternatively, any ideas on how @&lt;a href=&quot;https://quantumcomputing.stackexchange.com/users/119/craig-gidney&quot;&gt;CraigGidney&lt;/a&gt; is getting &lt;a href=&quot;http://algassert.com/post/1804&quot; rel=&quot;noreferrer&quot;&gt;these circuits&lt;/a&gt; (or something similar)?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/81SAl.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/81SAl.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="26" LastEditDate="2018-07-16T15:02:59.067" LastActivityDate="2018-07-23T17:05:19.117" Title="Topological Circuit Simulator" Tags="&lt;circuit-model&gt;&lt;topological-quantum-computing&gt;&lt;quirk-simulator&gt;" AnswerCount="1" CommentCount="3" />
  <row Id="3774" PostTypeId="2" ParentId="3770" CreationDate="2018-07-16T06:05:38.670" Score="4" Body="&lt;p&gt;Good question! The answer is that the &lt;a href=&quot;https://en.wikipedia.org/wiki/No-cloning_theorem&quot; rel=&quot;nofollow noreferrer&quot;&gt;no-cloning theorem&lt;/a&gt; states that you cannot clone an &lt;strong&gt;&lt;em&gt;arbitrary unknown state&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This circuit does not violate the no-cloning theorem, because let's look at what it does when the input is $\frac{1}{\sqrt{2}}(|0\rangle + |1\rangle)$. The output at the third register still has to be a $|0\rangle$ or a $|1\rangle$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Therefore it's impossible for this circuit to clone an &lt;strong&gt;&lt;em&gt;arbitrary&lt;/em&gt;&lt;/strong&gt; state $|\psi\rangle$, and one example of a state that it cannot clone is: $\frac{1}{\sqrt{2}}(|0\rangle + |1\rangle)$. &lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-07-16T08:11:09.563" LastActivityDate="2018-07-16T08:11:09.563" CommentCount="1" />
  <row Id="3775" PostTypeId="2" ParentId="3770" CreationDate="2018-07-16T06:07:32.493" Score="7" Body="&lt;p&gt;To simplify the question consider CNOT gate instead of Toffoli gate; CNOT is also fanout because&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{align}&#xA;|0\rangle|0\rangle \rightarrow |0\rangle|0\rangle\\&#xA;|1\rangle|0\rangle \rightarrow |1\rangle|1\rangle&#xA;\end{align}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;and it looks like cloning for any basis state $x\in\{0,1\}$&#xA;\begin{align}&#xA;|x\rangle|0\rangle \rightarrow |x\rangle|x\rangle&#xA;\end{align}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;but if you take a superposition $|\psi\rangle=\alpha|0\rangle + \beta|1\rangle$ then&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{align}&#xA;(\alpha|0\rangle+\beta|1\rangle)|0\rangle \rightarrow \alpha|0\rangle|0\rangle+ \beta|1\rangle|1\rangle&#xA;\end{align}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;so generally&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{align}&#xA;|\psi\rangle|0\rangle\not\rightarrow|\psi\rangle|\psi\rangle&#xA;\end{align}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;and fanout is not cloning.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As for the question of how the first qubit is changed - it is now &lt;em&gt;entangled&lt;/em&gt; with the second qubit.&lt;/p&gt;&#xA;" OwnerUserId="2105" LastEditorUserId="26" LastEditDate="2018-07-17T15:01:10.090" LastActivityDate="2018-07-17T15:01:10.090" CommentCount="1" />
  <row Id="3776" PostTypeId="2" ParentId="3772" CreationDate="2018-07-16T06:15:52.547" Score="0" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Are there other instances of topological QC that do not use anyons?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The use of anyons is part of the definition of topological QC. &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Are there alternative forms of anyons besides Fibonacci anyons?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There are Fibonacci anyons and Ising anyons. An excellent reference is &lt;a href=&quot;https://arxiv.org/pdf/0810.1955.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Non-Abelian anyons: when Ising meets Fibonacci&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-07-16T06:15:52.547" CommentCount="3" />
  <row Id="3777" PostTypeId="5" CreationDate="2018-07-16T06:26:22.250" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-07-16T06:26:22.250" LastActivityDate="2018-07-16T06:26:22.250" CommentCount="0" />
  <row Id="3778" PostTypeId="4" CreationDate="2018-07-16T06:26:22.250" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-07-16T06:26:22.250" LastActivityDate="2018-07-16T06:26:22.250" CommentCount="0" />
  <row Id="3779" PostTypeId="2" ParentId="3765" CreationDate="2018-07-16T08:01:35.910" Score="1" Body="&lt;p&gt;The way that I like to do the maths is by using linearity to break things down, and be a bit more explicit. We don't have to keep general functional forms so long as we consider the action of the circuits on a basis of states. When one is using it with regards to a controlled-not, the most natural basis to use is to ensure you have the computational basis on the control qubit. For example, I can track what happens on the first circuit if I input either $|0\rangle$ or $|1\rangle$ on the first qubit.&#xA;$$&#xA;|0\rangle|t\rangle\rightarrow |1\rangle|t\rangle\rightarrow|1\rangle(X|t\rangle)\qquad |1\rangle|t\rangle\rightarrow |0\rangle|t\rangle\rightarrow|0\rangle|t\rangle&#xA;$$&#xA;Meanwhile, for the second circuit,&#xA;$$&#xA;|0\rangle|t\rangle\rightarrow |0\rangle|t\rangle\rightarrow|1\rangle(X|t\rangle)\qquad |1\rangle|t\rangle\rightarrow |1\rangle(X|t\rangle)\rightarrow|0\rangle|t\rangle&#xA;$$&#xA;Both circuits give the same outputs for a complete basis of states, so they must be the same unitaries.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-07-16T10:08:22.453" LastActivityDate="2018-07-16T10:08:22.453" CommentCount="1" />
  <row Id="3780" PostTypeId="2" ParentId="3771" CreationDate="2018-07-16T08:17:25.230" Score="4" Body="&lt;p&gt;This is the gate that I would call controlled-square-root-of-not. Bit more of a mouthful, I know, but perhaps conveys more accurately what it's doing. The point is that it's a unitary $U$ such that $U^2$ is the controlled-not. There are probably a few ways of writing down such a thing, but, for example&#xA;$$&#xA;U=\left(\begin{array}{cccc} 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; \frac{e^{i\pi/4}}{\sqrt{2}} &amp;amp; \frac{e^{-i\pi/4}}{\sqrt{2}} \\ 0 &amp;amp; 0 &amp;amp; \frac{e^{-i\pi/4}}{\sqrt{2}} &amp;amp; \frac{e^{i\pi/4}}{\sqrt{2}}&#xA;\end{array}\right)&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There's a trivial answer to your other questions. Take the normal circuits for each of these things built out of (n)and gates, and substitute the reversible (n)and circuits in their place. Of course, there may be optimisations to improve things slightly...&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="26" LastEditDate="2018-07-17T15:00:24.890" LastActivityDate="2018-07-17T15:00:24.890" CommentCount="12" />
  <row Id="3781" PostTypeId="2" ParentId="3772" CreationDate="2018-07-16T08:43:01.127" Score="3" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Are there other instances of topological QC that do not use anyons?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;No, that's basically by definition. That said, there are different ways that one could use topological systems in order to achieve quantum computation. In the version you're talking about, you use these anyon pairs to define qubits, and braid them around each other to create quantum gates. Another option is more related to quantum memories: topological systems have a degenerate ground state that can be used to encode a qubit. But that qubit should be very robust against noise because it takes many many single-qubit errors (spanning the bulk of the system) to be misinterpreted as a logical operation. If you have many of these, you could use them as qubits in a quantum computer, but the challenge is actually getting them to do gates.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Are there alternative forms of anyons besides Fibonacci anyons?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There's a huge variety, it's just that Fibonacci anyons are a universal non-Abelian type of anyon that's comparatively easy to explain, but one does not have to be restricted to them if you can prove the right properties in some other system. The other type that are commonly discussed are Ising anyons.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Basically, every quantum system with localisable excitations has anyons, but their properties vary wildly. For example, if you look at Kitaev's Toric code, there are two types of anyon present. The particle-anti-particle pairs are basically joined together either by a string of $X$ operators, or a string of $Z$ operators. You move them around by applying $X$s or $Z$s as appropriate. When you braid them past each other, there's a single site where an $X$ and a $Z$ coincide. Since these two operators anti-commute, that corresponds to acquiring a -1 phase. Thus, the braiding effectively implements a logical $Z$. But that's all it implements; it can't change the type of excitation that the system is in (hence, we say it has Abelian anyons). That makes the computations you can do with them extremely limited. Even if you can find non-Abelian anyons, they may be of a limited form which is not universal for quantum computation (you might get an equivalent of the Clifford gates, for example).&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-07-16T08:43:01.127" CommentCount="1" />
  <row Id="3782" PostTypeId="1" AcceptedAnswerId="3784" CreationDate="2018-07-16T16:17:48.657" Score="9" ViewCount="429" Body="&lt;p&gt;I was trying to generate Greenberger-Horne-Zeilinger (GHZ) state for $N$ states using quantum computing, starting with $|000...000\rangle$ (N times) &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The proposed solution is to first apply Hadamard Transformation on the first qubit, and then start a loop of CNOT gates with the first qubit of all the others.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am unable to understand how I can perform CNOT($q_1,q_2$) if $q_1$ is a part of an entangled pair, like the Bell state $B_0$ which forms here after the Hadamard transformation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I know how to write the code for it, but algebraically why is this method correct and how is it done? Thanks.&lt;/p&gt;&#xA;" OwnerUserId="2951" LastEditorUserId="26" LastEditDate="2018-07-16T17:06:44.007" LastActivityDate="2018-07-16T19:13:35.597" Title="CNOT Gate on Entangled Qubits" Tags="&lt;quantum-gate&gt;&lt;quantum-entanglement&gt;&lt;qubit-state&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="2" />
  <row Id="3783" PostTypeId="2" ParentId="3782" CreationDate="2018-07-16T17:17:19.740" Score="5" Body="&lt;p&gt;$$&#xA;\psi_1 = |0 0 0 \rangle\\&#xA;\psi_2 = (H \otimes I \otimes I) \psi_1 = \frac{1}{\sqrt{2}} (|0 \rangle + |1 \rangle) \otimes |0 0 \rangle\\&#xA;= \frac{1}{\sqrt{2}} ( |0 0 0 \rangle + |1 0 0 \rangle)\\&#xA;\psi_3 = (\operatorname{CNOT}_{12} \otimes I) \psi_2 = \frac{1}{\sqrt{2}} (|0 0 0 \rangle + |1 1 0 \rangle)\\&#xA;\psi_4 = (\operatorname{CNOT}_{13} \otimes I_{2}) \psi_3 = \frac{1}{\sqrt{2}} (|0 0 0 \rangle + |1 1 1 \rangle)\\&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\operatorname{CNOT}_{ij}$ is itself an operator on $2$ qubits giving a $4\times 4$ unitary matrix. You can apply it to any state in $\mathbb{C}^2 \otimes \mathbb{C}^2$ not just those of the form $q_i \otimes q_j$. Just write the coefficients in the computational basis where you know what to do in terms of the $\operatorname{CNOT}_{ij}$ of classical reversible computing. Then just follow your linearity nose.&lt;/p&gt;&#xA;" OwnerUserId="434" LastEditorUserId="26" LastEditDate="2018-07-16T17:25:36.823" LastActivityDate="2018-07-16T17:25:36.823" CommentCount="0" />
  <row Id="3784" PostTypeId="2" ParentId="3782" CreationDate="2018-07-16T17:18:40.883" Score="3" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;I am unable to understand how I can perform CNOT($q_1,q_2$) if $q_1$&#xA;  is a part of an entangled pair, like the Bell state $B_0$ which forms&#xA;  here after the Hadamard transformation.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The key is to notice what happens to the &lt;strong&gt;computational basis states&lt;/strong&gt; (or, for that matter, any other &lt;em&gt;complete&lt;/em&gt; set of basis states) upon applying the relevant quantum gate(s). Doesn't matter whether the state is entangled or separable. This method &lt;em&gt;always&lt;/em&gt; works.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's consider the $2$-qubit Bell state (of two qubits $A$ and $B$):&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$|\Psi\rangle = \frac{1}{\sqrt{2}}(|00\rangle + |11\rangle)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$|\Psi\rangle$ is formed by an equal &lt;strong&gt;linear&lt;/strong&gt; superposition of the computational basis states $|00\rangle$ &amp;amp; $|11\rangle$ (which can be expressed as $|0\rangle_A\otimes|0\rangle_B$ and $|1\rangle_A\otimes|1\rangle_B$ respectively) and $|1\rangle_A\otimes |1\rangle_B$. We need not worry about the other two computational basis states: $|01\rangle$ and $|10\rangle$ as they are not part of the Bell state superposition $|\Psi\rangle$. A CNOT gate basically &lt;strong&gt;flips&lt;/strong&gt; (i.e. does either one of the two mappings $|0\rangle \mapsto |1\rangle$ or $|1\rangle\mapsto |0\rangle$) the state of the qubit $B$ &lt;strong&gt;in case&lt;/strong&gt; the qubit $A$ is in the state $|1\rangle$, or else it does nothing at all.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So basically CNOT will keep the computational basis state $|00\rangle$ as it is. However, it will convert the computational basis state $|11\rangle$ to $|10\rangle$. From the action of CNOT on $|00\rangle$ and $|11\rangle$, you can deduce the action of CNOT on the superposition state $|\Psi\rangle$ now: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\operatorname{CNOT}|\Psi\rangle = \frac{1}{\sqrt{2}}(|00\rangle + |10\rangle)$$&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You mention in the comments that you want one of the two qubits of the entangled state $|\Psi\rangle$ to act as &lt;strong&gt;control&lt;/strong&gt; (and the NOT operation will be applied on a different qubit, &lt;em&gt;say&lt;/em&gt; $C$, &lt;em&gt;depending upon the control&lt;/em&gt;). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In that case too, you can proceed in a similar way as above. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Write down the &lt;strong&gt;$3$-qubit combined state&lt;/strong&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$|\Psi\rangle\otimes |0\rangle_C = \frac{1}{\sqrt{2}}(|0\rangle_A\otimes |0\rangle_B + |1\rangle_A\otimes|1\rangle_B)\otimes |0\rangle_C$$ $$= \frac{1}{\sqrt{2}}(|0\rangle_A\otimes |0\rangle_B\otimes |0\rangle_C+ |1\rangle_A\otimes|1\rangle_B\otimes|0\rangle_C)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's say $B$ is your &lt;strong&gt;control&lt;/strong&gt; qubit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Once again we will simply check the action of the CNOT on the computational basis states (for a 3-qubit system) i.e. $|000\rangle$ &amp;amp; $|110\rangle$. In computational basis state $|000\rangle = |0\rangle_A\otimes|0\rangle_B|0\rangle_C$ notice that the state of the qubit $B$ is $|0\rangle$ and that of qubit $C$ is $|0\rangle$. Since qubit $B$ is in state $|0\rangle$, the state of qubit $C$ will &lt;strong&gt;not&lt;/strong&gt; be flipped. However, notice that in the computational basis state $|110\rangle = |1\rangle_A\otimes|1\rangle_B\otimes|0\rangle_C$ the qubit $B$ is in state $|1\rangle$ while qubit $C$ is in state $|0\rangle$. Since the qubit $B$ is in state $|1\rangle$, the state of the qubit $C$ will be flipped to $|1\rangle$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thus, you end up with the state:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\frac{1}{\sqrt{2}}(|0\rangle_A\otimes|0\rangle_B\otimes|0\rangle_C + |1\rangle_A\otimes|1\rangle_B\otimes|1\rangle_C)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is &lt;em&gt;the&lt;/em&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Greenberger%E2%80%93Horne%E2%80%93Zeilinger_state&quot; rel=&quot;nofollow noreferrer&quot;&gt;Greenberger–Horne–Zeilinger state&lt;/a&gt; for your $3$ qubits!&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-16T19:13:35.597" LastActivityDate="2018-07-16T19:13:35.597" CommentCount="7" />
  <row Id="3785" PostTypeId="2" ParentId="3767" CreationDate="2018-07-16T19:57:45.330" Score="3" Body="&lt;p&gt;The best possible reference at the moment is&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Coecke and Kissinger. &lt;a href=&quot;http://www.cambridge.org/gb/academic/subjects/physics/quantum-physics-quantum-information-and-quantum-computation/picturing-quantum-processes-first-course-quantum-theory-and-diagrammatic-reasoning?format=HB&amp;amp;isbn=9781107104228&quot; rel=&quot;nofollow noreferrer&quot;&gt;Picturing Quantum Processes: A First Course in Quantum Theory and Diagrammatic Reasoning.&lt;/a&gt; Cambridge University Press, 2017.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;It is written by one of the two inventors of the ZX calculus (Bob Coecke), and one of the people who has contributed the most to the development of Quantomatic (Aleks Kissinger), and so would be the definitive introductory reference.&lt;/p&gt;&#xA;" OwnerUserId="124" LastActivityDate="2018-07-16T19:57:45.330" CommentCount="0" />
  <row Id="3786" PostTypeId="1" CreationDate="2018-07-17T04:45:38.733" Score="4" ViewCount="80" Body="&lt;p&gt;I am experimenting with some Qiskit ACQUA AI algorithms which require the following import statement:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;from datasets import *&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;However, &lt;code&gt;import&lt;/code&gt; statement is throwing an error:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ModuleNotFoundError&#xA;Traceback (most recent call last) in&#xA;from datasets import * &#xA;ModuleNotFoundError: No module named 'datasets'&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am unable to determine the package that this import is from. Clearly, Qiskit ACQUA installation doesn't have to all required packages for the algorithm code to run. I asked the question at the IBM QE forum but the traffic on it is very low. I have not had the answer from anyone yet.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Any help would be most appreciated!&lt;/p&gt;&#xA;" OwnerUserId="4120" LastEditorUserId="4120" LastEditDate="2018-07-20T14:02:34.920" LastActivityDate="2018-07-20T14:02:34.920" Title="Quantum SVM Algorithm Error on import" Tags="&lt;quantum-algorithms&gt;&lt;qiskit&gt;&lt;artificial-intelligence&gt;" AnswerCount="0" CommentCount="2" />
  <row Id="3787" PostTypeId="2" ParentId="2724" CreationDate="2018-07-17T05:03:25.917" Score="2" Body="&lt;p&gt;Just sharing my own experience here: I honestly felt much better after reading an introductory book on quantum physics, &lt;a href=&quot;https://www.barnesandnoble.com/w/idiots-guides-phd-marc-humphrey-marc/1119618196?ean=9781615643172&amp;amp;st=PLA&amp;amp;sid=BNB_DRS_New%20Core%20Shopping%20Top%20Margin%20EANs_00000000&amp;amp;2sid=Google_&amp;amp;sourceId=PLGoP213156&amp;amp;gclid=CjwKCAjwhLHaBRAGEiwAHCgG3nFBE1dtjSAODP2lRyqz_-kapzpoEaYJYx4s854FMiLty099rwyMPBoC2sMQAvD_BwE&quot; rel=&quot;nofollow noreferrer&quot;&gt;Idiot's Guide&lt;/a&gt;. The book is written by three wonderful professors. They have a whole unit dedicating to Quantum Computing where they explain the fundamentals so nicely. Once you feel comfortable with that, poke around with &lt;a href=&quot;https://docs.microsoft.com/en-us/quantum/quantum-writeaquantumprogram?view=qsharp-preview&amp;amp;tabs=tabid-vs2017&quot; rel=&quot;nofollow noreferrer&quot;&gt;Microsoft Code&lt;/a&gt; and subscribe to the &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/experience&quot; rel=&quot;nofollow noreferrer&quot;&gt;IBM QuantumExpeirence&lt;/a&gt;. Installing &lt;a href=&quot;https://qiskit.org/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Qiskit&lt;/a&gt; and playing with the code examples was essential for me. If you coming from a functional programming background, you can also try &lt;a href=&quot;https://www.mathstat.dal.ca/~selinger/quipper/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quipper&lt;/a&gt;: A quantum programming language that is written in Haskell. The field is so young and those who claim to know very much, they basically know very little. So, don't be afraid of asking questions. There are no wrong ones.&lt;/p&gt;&#xA;" OwnerUserId="4120" LastActivityDate="2018-07-17T05:03:25.917" CommentCount="0" />
  <row Id="3788" PostTypeId="2" ParentId="2724" CreationDate="2018-07-17T11:26:27.500" Score="3" Body="&lt;p&gt;I find in &lt;a href=&quot;https://algassert.com/quirk&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quirk&lt;/a&gt; a very good tool to practice from basic concepts to more advanced subjects in the matter. It's pretty fast and intuitive, allowing to see in real time the effect of each modify applied to the circuit. The documentation I found is not so large, but, it's easy to understand. You can find an introduction to the tool &lt;a href=&quot;http://algassert.com/2016/05/22/quirk.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;.&#xA;On youtube you can find a lot of educational videos. I personally like a lot the TED talk of Leo Kouwenhoven (&lt;a href=&quot;https://www.youtube.com/watch?v=aUuaWVHhx-U&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;).&#xA;A &lt;a href=&quot;https://www.youtube.com/watch?v=g_IaVepNDT4&quot; rel=&quot;nofollow noreferrer&quot;&gt;similar video&lt;/a&gt; by Veritasium is a (qu)bit more detailed, while still very understandable. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;On the game side, James Wootton programmed a handful of &lt;a href=&quot;https://medium.com/@decodoku/the-history-of-games-for-quantum-computers-a1de98859b5a&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum computer games&lt;/a&gt;, in the sense that they are games designed for quantum computers.&lt;/p&gt;&#xA;" OwnerUserId="2601" LastActivityDate="2018-07-17T11:26:27.500" CommentCount="0" />
  <row Id="3789" PostTypeId="1" CreationDate="2018-07-17T14:46:03.970" Score="3" ViewCount="32" Body="&lt;p&gt;So, I wanted to learn about quantum computing.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What should I learn and where do I start?&lt;/p&gt;&#xA;" OwnerUserId="2316" LastEditorUserId="26" LastEditDate="2018-07-17T14:57:09.143" LastActivityDate="2018-07-17T14:57:09.143" Title="Are there sites that allow to learn about quantum computing?" Tags="&lt;quantum-algorithms&gt;" AnswerCount="0" CommentCount="2" ClosedDate="2018-07-17T15:03:17.183" />
  <row Id="3790" PostTypeId="1" CreationDate="2018-07-17T21:55:46.683" Score="6" ViewCount="143" Body="&lt;p&gt;CNOT gates have been realized for states living in 2-dimensional spaces (qubits).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What about higher-dimensional (qudit) states? Can CNOT gates be defined in such case? In particular, is this possible for three-dimensional states, for example, using &lt;a href=&quot;https://en.wikipedia.org/wiki/Orbital_angular_momentum_of_light&quot; rel=&quot;nofollow noreferrer&quot;&gt;orbital angular momentum&lt;/a&gt;?&lt;/p&gt;&#xA;" OwnerUserId="4131" LastEditorUserId="55" LastEditDate="2018-07-21T16:18:44.843" LastActivityDate="2018-07-21T17:49:03.253" Title="Is it possible to realize CNOT gate in 3 dimension?" Tags="&lt;quantum-computer&gt;&lt;quantum-gate&gt;" AnswerCount="2" CommentCount="11" FavoriteCount="1" />
  <row Id="3791" PostTypeId="2" ParentId="3790" CreationDate="2018-07-18T06:56:36.743" Score="2" Body="&lt;p&gt;A generalization of the $cX$ (called &quot;controlled $X$&quot; or &quot; controlled $\textrm{NOT}$&quot;)  gate is given as $c\tilde{X}$ in &lt;a href=&quot;https://arxiv.org/pdf/1304.4923.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;this paper&lt;/a&gt;. When the dimension of the Hilbert space is $d=2$, then $c\tilde{X}=cX=\textrm{CNOT}$, but $c\tilde{X}$ is also valid for $d&amp;gt;2$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then, in &lt;a href=&quot;https://arxiv.org/pdf/1702.07299.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;this paper&lt;/a&gt;, $d&amp;gt;2$ gates are interpreted in the context of OAMs.   &lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-07-18T09:20:41.687" LastActivityDate="2018-07-18T09:20:41.687" CommentCount="4" />
  <row Id="3792" PostTypeId="2" ParentId="3790" CreationDate="2018-07-18T07:15:51.933" Score="3" Body="&lt;p&gt;There are multiple questions implicit in this question.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;How do you define an equivalent of the controlled-not for qutrits?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There are probably multiple ways that the gate can be generalised, but &lt;a href=&quot;https://arxiv.org/abs/1304.4923&quot; rel=&quot;nofollow noreferrer&quot;&gt;this paper&lt;/a&gt; defines it as &#xA;$$&#xA;|x\rangle|y\rangle\mapsto|x\rangle|-x-y\text{ mod }3\rangle&#xA;$$&#xA;I'm not sure why they use the - sign, and am instead going to take the definition&#xA;$$&#xA;|x\rangle|y\rangle\mapsto|x\rangle|x+y\text{ mod }3\rangle&#xA;$$&#xA;That means that we can write the unitary matrix as&#xA;$$&#xA;\left(\begin{array}{ccccccccc}&#xA;1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0&#xA;\end{array}\right).&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Is it possible to realise this gate in 3 dimensions?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Sure, why not? &lt;a href=&quot;https://arxiv.org/abs/1105.5485&quot; rel=&quot;nofollow noreferrer&quot;&gt;This paper&lt;/a&gt; talks defines things slightly differently, but one could construct the gate I've specified using their formalism, and they also discuss some ideas for physical implementation. &lt;a href=&quot;https://journals.aps.org/pra/abstract/10.1103/PhysRevA.67.062313&quot; rel=&quot;nofollow noreferrer&quot;&gt;This paper&lt;/a&gt; may also be interesting.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Has this gate been realised?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Not to my knowledge, but I can't pretend to know everything that has every been achieved experimentally. I would point out, however, that &lt;a href=&quot;https://arxiv.org/abs/1702.07299&quot; rel=&quot;nofollow noreferrer&quot;&gt;this paper&lt;/a&gt; is only doing single-qudit gates, not two-qudit gates. Judging by the fact that that paper was only last year, I'd guess the two qudit generalisation hasn't been done yet in that particular physical realisation.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-07-18T07:15:51.933" CommentCount="1" />
  <row Id="3793" PostTypeId="1" CreationDate="2018-07-18T08:13:17.877" Score="5" ViewCount="61" Body="&lt;p&gt;The square-root of not and square-root of swap gates are often singled out for discussion of gates displaying important properties relating to quantum computers.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;How do I define arbitrary (non-integer) powers of the square-root of NOT or square-root of SWAP?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;How do I find their unitary matrices?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;How might I implement these gates?&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="26" LastEditDate="2018-07-18T14:49:52.797" LastActivityDate="2018-07-18T14:49:52.797" Title="Arbitrary powers of NOT and SWAP" Tags="&lt;quantum-gate&gt;&lt;circuit-model&gt;&lt;gate-synthesis&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="3794" PostTypeId="2" ParentId="3793" CreationDate="2018-07-18T08:13:17.877" Score="5" Body="&lt;p&gt;Let's start with some general theory. If you have a normal matrix $A$ (of which unitaries are a subset), you can define any function of that matrix $f(A)$. For example, $A^{1/2}$ or $A^{\pi}$. The most natural way to do this is via the spectral decomposition: if $\{\lambda_i\}$ are the eigenvalues of $A$ and $U$ is the matrix that diagonalises $A$:&#xA;$$&#xA;UAU^\dagger=\sum_i\lambda_i|i\rangle\langle i|:=D,&#xA;$$&#xA;i.e. $D$ is a diagonal matrix with entries corresponding to the eigenvalues. Then,&#xA;$$&#xA;f(A)=U^\dagger\sum_if(\lambda_i)|i\rangle\langle i| U.&#xA;$$&#xA;You can see why this works if you think about $\sqrt{A}=U^\dagger\sqrt{D} U$ (where $\sqrt{D}$ is just the same as $D$, but taking the square root on each of the diagonal entries), and we multiply it together:&#xA;$$&#xA;\sqrt{A}\cdot \sqrt{A}=U^\dagger\sqrt{D} UU^\dagger\sqrt{D} U=U^\dagger D U=A.&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In this way, we can define arbitrary power of $X$. Effectively, we have&#xA;$$&#xA;X^{q}=|+\rangle\langle +|+e^{i\pi q}|-\rangle\langle -|=\frac{1}{2}\left(\begin{array}{cc}&#xA;1+e^{i\pi q} &amp;amp; 1-e^{i\pi q} \\ 1-e^{i\pi q} &amp;amp; 1+ e^{i\pi q}&#xA;\end{array}\right)=e^{i\pi q/2}\left(\begin{array}{cc}&#xA;\cos\frac{\pi q}{2} &amp;amp; -i\sin\frac{\pi q}{2} \\ -i\sin\frac{\pi q}{2} &amp;amp; \cos \frac{\pi q}{2}&#xA;\end{array}\right)&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are several ways in which you might implement this gate. For example, as already mentioned &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/2609/1837&quot;&gt;here&lt;/a&gt;, you can think of it as a continuous time operator&#xA;$$&#xA;e^{i(\mathbb{I}-X)t}&#xA;$$&#xA;for any $t$ that you want ($t=\pi q/2$). Another way, if you have arbitrary phase gates available, is just the sequence Hadamard - phase - hadamard, as the hadamards convert a z-rotation into an x-rotation.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;As yet, I haven't mentioned the power of swap. Think about the swap gate. Clearly, two eigenvectors (of eigenvalue 1) are $|00\rangle$ and $|11\rangle$. These are unchanged by taking arbitrary powers. The bit that's affected is a $2\times 2$ subspace spanned by $\{|01\rangle,|10\rangle\}$. But when you look at just this subspace, the SWAP matrix is exactly the same as $X$.&#xA;So, knowing about $f(X)$ immediately tells us about $f(SWAP)$.&#xA;$$&#xA;SWAP^q=\left(\begin{array}{cccc}&#xA;1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; e^{i\pi q/2}\cos\frac{\pi q}{2} &amp;amp; -ie^{i\pi q/2}\sin\frac{\pi q}{2} &amp;amp; \ \\&#xA;0 &amp;amp; -ie^{i\pi q/2}\sin\frac{\pi q}{2} &amp;amp; e^{i\pi q/2}\cos \frac{\pi q}{2} &amp;amp; 0 \\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1&#xA;\end{array}\right)&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you want a continuous-time implementation, then one can use&#xA;$$&#xA;e^{it(\mathbb{I}-Z\otimes Z -X\otimes X-Y\otimes Y)/2},&#xA;$$&#xA;because this Hamiltonian, when restricted to the $2\times 2$ subspace is just $\mathbb{I}-X$, as we required before. As for a quantum circuit, that has been partially addressed &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2468/1837&quot;&gt;here&lt;/a&gt;. That answer effectively conveys how any $f(SWAP)$ can be converted into a controlled-$f(X)$ gate. One simply has to get the angle of rotation correct, and sufficient information is conveyed in that answer.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-07-18T08:13:17.877" CommentCount="4" />
  <row Id="3796" PostTypeId="2" ParentId="3770" CreationDate="2018-07-18T16:14:36.003" Score="0" Body="&lt;p&gt;The no cloning theorem says that there is no circuit which creates &lt;em&gt;independent&lt;/em&gt; copies of all quantum states. Mathematically, no cloning states that:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\forall C: \exists a,b: C \cdot \Big( (a|0\rangle + b|1\rangle)\otimes|0\rangle \Big) \neq (a|0\rangle + b|1\rangle) \otimes (a|0\rangle + b|1\rangle)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Fanout circuits don't violate this theorem. They don't make indepedent copies. They make &lt;em&gt;entangled&lt;/em&gt; copies. Mathematically, they do:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\text{FANOUT} \cdot \Big( (a|0\rangle + b|1\rangle) \otimes |0\rangle \Big) = a|00\rangle + b|11\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So everything is fine because $a|00\rangle + b|11\rangle$ is not the same thing as $(a|0\rangle + b|1\rangle) \otimes (a|0\rangle + b|1\rangle)$.&lt;/p&gt;&#xA;" OwnerUserId="119" LastActivityDate="2018-07-18T16:14:36.003" CommentCount="0" />
  <row Id="3798" PostTypeId="2" ParentId="2562" CreationDate="2018-07-19T09:42:33.180" Score="1" Body="&lt;p&gt;It is incorrect to use modulo arithmetic in this context. Instead finite field arithmetic should be applied. In $\textrm{GF}(4) = \{0, 1, x, x^2\}$ where $x^2 = x + 1$ and conjugation of $a$ is defined as $\bar{a} = a^2$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Addition, multiplication and conjugation tables are then as follows:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/68A2E.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/68A2E.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In this picture we have $0 \equiv 0$, $1 \equiv 1$, $2 \equiv x$, and $3 \equiv x^2$ such that $2 \times 2 = 3$ and so the apparent inconsistency does not occur.&lt;/p&gt;&#xA;" OwnerUserId="391" LastEditorUserId="391" LastEditDate="2018-07-19T11:21:45.217" LastActivityDate="2018-07-19T11:21:45.217" CommentCount="2" />
  <row Id="3799" PostTypeId="2" ParentId="2697" CreationDate="2018-07-19T11:46:36.680" Score="2" Body="&lt;p&gt;A couple years ago it was shown in &lt;a href=&quot;https://arxiv.org/pdf/1512.05903.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum algorithms and the finite element method&lt;/a&gt; by Montanaro and Pallister that the HHL algorithm could be applied to the Finite Element Method (FEM) which is a &lt;em&gt;&quot;technique for efficiently finding numerical approximations to the solutions of boundary value problems (BVPs) for partial differential equations, based on discretizing the parameter space via a finite mesh&quot;&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;They showed that within this context HHL could be used to achieve (perhaps at most) a polynomial speedup over the standard classical algorithm (the &quot;conjugate gradient method&quot;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;With respect to real-world use-cases, they state that &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;One example application is any dynamical problem involving $n$ bodies, which implies solving a PDE defined over a configuration space of dimension 2n. Also, there may be a significant advantage for problems in mathematical finance;&#xA;  for example, pricing multiasset options requires solving the Black-Scholes equation over a domain with dimension given by the number of assets&quot;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;This opens up a whole area of potential use-cases for HHL (assuming conditions on the sparsity of $A$ can be satisfied).&lt;/p&gt;&#xA;" OwnerUserId="391" LastActivityDate="2018-07-19T11:46:36.680" CommentCount="11" />
  <row Id="3800" PostTypeId="1" CreationDate="2018-07-19T14:34:57.293" Score="12" ViewCount="1406" Body="&lt;p&gt;For each IBM quantum chip, one can write a dictionary mapping each control qubit j to a list of its physically allowed targets, assuming j is the control of a CNOT. For example, &lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ibmqx4_c_to_tars = {&#xA;    0: [],&#xA;    1: [0],&#xA;    2: [0, 1, 4],&#xA;    3: [2, 4],&#xA;    4: []}  # 6 edges&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;for their ibmqx4 chip.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What would be that dict for Google's 72 qubit Bristlecone chip. You can write the dict as a comprehension. Same question for Rigetti's 19 qubit chip.&lt;/p&gt;&#xA;" OwnerUserId="1974" LastEditorUserId="1974" LastEditDate="2018-07-20T14:13:02.260" LastActivityDate="2018-07-20T21:22:40.170" Title="What are physically allowed CNOTs for Rigetti's 19 qubit chip and Google's 72 qubit BristleCone chip?" Tags="&lt;bristlecone&gt;&lt;rigetti&gt;&lt;cirq&gt;" AnswerCount="4" CommentCount="2" FavoriteCount="2" />
  <row Id="3802" PostTypeId="2" ParentId="3800" CreationDate="2018-07-19T14:54:24.550" Score="9" Body="&lt;p&gt;From the &lt;a href=&quot;https://ai.googleblog.com/2018/03/a-preview-of-bristlecone-googles-new.html&quot; rel=&quot;noreferrer&quot;&gt;original blog post&lt;/a&gt; presenting the Bristlecone quantum chip, here is the connectivity map of the chip:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/SsQsx.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/SsQsx.png&quot; alt=&quot;Bristlecone connectivity map&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Each cross represent a qubit, with nearest-neighbour connectivity. If you number the qubits from left to right, top to bottom (just like how you read english), starting by $0$ then the connectivity map would be given by:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;connectivity_map = {&#xA;    i : [i + offset&#xA;         for offset in (-6, -5, 5, 6) # values deduced by taking a qubit in the middle of&#xA;                                      # chip and computing the offsets between the choosen&#xA;                                      # qubit and it's 4 neighbours&#xA;         if ((0 &amp;lt;= i+offset &amp;lt; 72)             # the neighbour should be a valid qubit&#xA;             and ((i+offset) // 6 != i // 6)) # the neighbour should not be on the same line&#xA;    ]&#xA;    for i in range(72)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: the expression above is completely unverified. It seems to work for the first qubits, it seems logical to me, but it's up to you to check that the map is 100% correct.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Warning 2&lt;/strong&gt;: Google's blog post does not talk about the orientation of the connections between qubits. The connectivity map given above assumes that the connections are bilateral. &lt;/p&gt;&#xA;" OwnerUserId="1386" LastEditorUserId="1386" LastEditDate="2018-07-19T15:14:45.490" LastActivityDate="2018-07-19T15:14:45.490" CommentCount="0" />
  <row Id="3804" PostTypeId="2" ParentId="3800" CreationDate="2018-07-19T17:55:10.540" Score="11" Body="&lt;p&gt;Bristlecone's native operation is the CZ, not CNOTs. However, you can transform between the two with Hadamard gates so this is sort of a trivial difference.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Bristlecone can perform a CZ between any adjacent pair of qubits on a grid. You can see the grid by installing &lt;a href=&quot;https://github.com/quantumlib/cirq&quot; rel=&quot;noreferrer&quot;&gt;cirq&lt;/a&gt; and printing out the Bristlecone device:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ pip install cirq&#xA;$ python&#xA;&amp;gt;&amp;gt;&amp;gt; import cirq&#xA;&amp;gt;&amp;gt;&amp;gt; print(cirq.google.Bristlecone)&#xA;                                             (0, 5)────(0, 6)&#xA;                                             │         │&#xA;                                             │         │&#xA;                                    (1, 4)───(1, 5)────(1, 6)────(1, 7)&#xA;                                    │        │         │         │&#xA;                                    │        │         │         │&#xA;                           (2, 3)───(2, 4)───(2, 5)────(2, 6)────(2, 7)───(2, 8)&#xA;                           │        │        │         │         │        │&#xA;                           │        │        │         │         │        │&#xA;                  (3, 2)───(3, 3)───(3, 4)───(3, 5)────(3, 6)────(3, 7)───(3, 8)───(3, 9)&#xA;                  │        │        │        │         │         │        │        │&#xA;                  │        │        │        │         │         │        │        │&#xA;         (4, 1)───(4, 2)───(4, 3)───(4, 4)───(4, 5)────(4, 6)────(4, 7)───(4, 8)───(4, 9)───(4, 10)&#xA;         │        │        │        │        │         │         │        │        │        │&#xA;         │        │        │        │        │         │         │        │        │        │&#xA;(5, 0)───(5, 1)───(5, 2)───(5, 3)───(5, 4)───(5, 5)────(5, 6)────(5, 7)───(5, 8)───(5, 9)───(5, 10)───(5, 11)&#xA;         │        │        │        │        │         │         │        │        │        │&#xA;         │        │        │        │        │         │         │        │        │        │&#xA;         (6, 1)───(6, 2)───(6, 3)───(6, 4)───(6, 5)────(6, 6)────(6, 7)───(6, 8)───(6, 9)───(6, 10)&#xA;                  │        │        │        │         │         │        │        │&#xA;                  │        │        │        │         │         │        │        │&#xA;                  (7, 2)───(7, 3)───(7, 4)───(7, 5)────(7, 6)────(7, 7)───(7, 8)───(7, 9)&#xA;                           │        │        │         │         │        │&#xA;                           │        │        │         │         │        │&#xA;                           (8, 3)───(8, 4)───(8, 5)────(8, 6)────(8, 7)───(8, 8)&#xA;                                    │        │         │         │&#xA;                                    │        │         │         │&#xA;                                    (9, 4)───(9, 5)────(9, 6)────(9, 7)&#xA;                                             │         │&#xA;                                             │         │&#xA;                                             (10, 5)───(10, 6)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Here is how you can get a set containing the allowed CZ operations:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;qubits = cirq.google.Bristlecone.qubits&#xA;allowed = {cirq.CZ(a, b)&#xA;           for a in qubits&#xA;           for b in qubits&#xA;           if a.is_adjacent(b)}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;The set has 121 elements in it, and it's somewhat random whether you get CZ(x, y) or CZ(y, x) in the set, so I won't include a printout of the set here.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;An additional constraint to keep in mind is that you cannot perform two CZs next to each other at the same time. Cirq takes this into account when creating circuits targeted at Bristlecone. For example:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import cirq&#xA;device = cirq.google.Bristlecone&#xA;a, b, c, d, e = device.col(6)[:5]&#xA;circuit = cirq.Circuit.from_ops(&#xA;    cirq.CZ(a, b),&#xA;    cirq.CZ(c, d),&#xA;    cirq.CZ(a, b),&#xA;    cirq.CZ(d, e),&#xA;    device=device)&#xA;print(circuit)&#xA;# (0, 6): ───@───────@───&#xA;#            │       │&#xA;# (1, 6): ───@───────@───&#xA;# &#xA;# (2, 6): ───────@───────&#xA;#                │&#xA;# (3, 6): ───────@───@───&#xA;#                    │&#xA;# (4, 6): ───────────@───&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;The first two operations were staggered because they are adjacent CZs, but the second two weren't because they aren't.&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-07-19T18:14:40.170" LastActivityDate="2018-07-19T18:14:40.170" CommentCount="5" />
  <row Id="3806" PostTypeId="5" CreationDate="2018-07-19T18:22:36.097" Score="0" Body="&lt;p&gt;Cirq's github repository: &lt;a href=&quot;https://github.com/quantumlib/cirq&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://github.com/quantumlib/cirq&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-07-19T19:51:52.257" LastActivityDate="2018-07-19T19:51:52.257" CommentCount="0" />
  <row Id="3807" PostTypeId="4" CreationDate="2018-07-19T18:22:36.097" Score="0" Body="For questions about cirq, which is an open source python library for working with NISQ (Noisy Intermediate Scale Quantum) circuits." OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-07-19T19:51:41.327" LastActivityDate="2018-07-19T19:51:41.327" CommentCount="0" />
  <row Id="3808" PostTypeId="1" CreationDate="2018-07-19T18:38:05.353" Score="2" ViewCount="72" Body="&lt;p&gt;I am thinking as quantum computing is just a new word in tech, so let to explore it by building it or a prototype based on it so I am just wanted help in setting up and initial steps which should I keep in mind. please tell me about each implementation steps.&lt;/p&gt;&#xA;" OwnerUserId="2566" LastEditorUserId="2566" LastEditDate="2018-07-20T13:27:18.583" LastActivityDate="2018-07-20T13:27:18.583" Title="Is it possible to make our own quantum computer ? If yes, what will it take?" Tags="&lt;quantum-computer&gt;" AnswerCount="0" CommentCount="7" ClosedDate="2018-07-19T21:31:37.100" />
  <row Id="3809" PostTypeId="1" CreationDate="2018-07-19T19:03:33.407" Score="5" ViewCount="63" Body="&lt;p&gt;The QISKIT documentation doesn't explain what a TDG gate does and I can't find it anywhere else online. &lt;/p&gt;&#xA;" OwnerUserId="4150" LastEditorUserId="4164" LastEditDate="2018-07-23T10:26:42.090" LastActivityDate="2018-07-23T10:26:42.090" Title="What is the purpose of the TDG gate in QISKit?" Tags="&lt;qiskit&gt;&lt;ibm-q-experience&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="3810" PostTypeId="2" ParentId="3809" CreationDate="2018-07-19T19:16:57.557" Score="5" Body="&lt;p&gt;According to the &lt;a href=&quot;https://qiskit.org/documentation/_autodoc/qiskit._compositegate.html#qiskit._compositegate.CompositeGate.tdg&quot; rel=&quot;nofollow noreferrer&quot;&gt;QISKit documentation&lt;/a&gt;, &lt;code&gt;tdg(q)&lt;/code&gt; applies the &lt;code&gt;Tdg&lt;/code&gt; gate to a qubit. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$T$ is the basically the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_logic_gate#Phase_shift_(%7F&amp;#39;%22%60UNIQ--postMath-0000002D-QINU%60%22&amp;#39;%7F)_gates&quot; rel=&quot;nofollow noreferrer&quot;&gt;$\pi/8$ phase shift gate&lt;/a&gt; whose matrix representation considering standard (computational) basis is:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\left(\begin{matrix}1 &amp;amp; 0 \\ 0 &amp;amp; e^{i\pi/4}\end{matrix}\right)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;Tdg&lt;/code&gt; is simply the &lt;a href=&quot;https://en.wikipedia.org/wiki/Conjugate_transpose&quot; rel=&quot;nofollow noreferrer&quot;&gt;conjugate transpose&lt;/a&gt; of the matrix $T$ i.e. $T^{\dagger}$, which is:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\left(\begin{matrix}1 &amp;amp; 0 \\ 0 &amp;amp; e^{-i\pi/4}\end{matrix}\right)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thus, the $T$ gate would map the &lt;a href=&quot;https://en.wikipedia.org/wiki/Basis_(linear_algebra)&quot; rel=&quot;nofollow noreferrer&quot;&gt;basis vectors&lt;/a&gt; (of a qubit) $|0\rangle$ to $|0\rangle$ itself and $|1\rangle$ to $e^{i\pi/4}|1\rangle$, whereas $T^{\dagger}$ would map $|0\rangle$ to $|0\rangle$ itself and $|1\rangle$ to $e^{-i\pi/4}|1\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;P.S:&lt;/strong&gt; In case you're wondering what &lt;code&gt;dg&lt;/code&gt; means in &lt;code&gt;tdg&lt;/code&gt;, it is simply an abbreviation for &quot;dagger&quot; i.e. in the sense of $T^{\dagger}$ (pronounced as $T$ - dagger).&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-07-19T21:16:22.063" LastActivityDate="2018-07-19T21:16:22.063" CommentCount="0" />
  <row Id="3811" PostTypeId="5" CreationDate="2018-07-19T19:34:08.000" Score="0" Body="&lt;p&gt;Cirq's github repository: &lt;a href=&quot;https://github.com/quantumlib/cirq&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://github.com/quantumlib/cirq&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-07-19T21:32:06.307" LastActivityDate="2018-07-19T21:32:06.307" CommentCount="0" />
  <row Id="3812" PostTypeId="4" CreationDate="2018-07-19T19:34:08.000" Score="0" Body="Cirq is an open source python library for working with NISQ (Noisy Intermediate Scale Quantum) circuits." OwnerUserId="119" LastEditorUserId="23" LastEditDate="2018-07-19T21:33:31.280" LastActivityDate="2018-07-19T21:33:31.280" CommentCount="0" />
  <row Id="3813" PostTypeId="1" AcceptedAnswerId="3819" CreationDate="2018-07-19T21:21:46.463" Score="5" ViewCount="56" Body="&lt;p&gt;$\newcommand{\Q}{\mathbf{Q}}\newcommand{\S}{\mathbf{S}}\newcommand{\A}{{\mathcal A}}\newcommand{\H}{\mathcal H}$In the quantum amplitude amplification algorithm, as explained in Brassard et al. 2000 (&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0005055&quot; rel=&quot;nofollow noreferrer&quot;&gt;quant-ph/0005055&lt;/a&gt;), the unitary performing the amplification is defined as (using the notation found in pag 5 of the above paper):&#xA;$$\Q=-\A\S_0\A^{-1}\S_\chi,$$&#xA;where $\A$ is a unitary,&#xA;$\chi:\mathbb Z\to\{0,1\}$ is a Boolean function, and $\S_\chi$ and $\S_0$ are unitaries defined as&#xA;$$\S_\chi\equiv I-2\Pi_1,\quad \S_0\equiv I-|0\rangle\langle0|,$$&#xA;where $\Pi_i$ is the projector over the states $|x\rangle$ for which $\chi(x)=i$:&#xA;$$\Pi_i\equiv\Pi_{\chi(x)=i}\equiv\sum_{x:\,\chi(x)=i}|x\rangle\langle x|.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Given the state $|\Psi\rangle\equiv\A|0\rangle$, the authors define the states $|\Psi_i\rangle$, for $i=0,1$, as&#xA;$$|\Psi_i\rangle\equiv\Pi_i|\Psi\rangle=\Pi_i\A|0\rangle.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The first lemma in the paper, at the end of page 5, states that&#xA;\begin{align}&#xA;\Q|\Psi_1\rangle&amp;amp;=(1-2a)|\Psi_1\rangle-2a|\Psi_0\rangle, \\&#xA;\Q|\Psi_0\rangle&amp;amp;=2(1-a)|\Psi_1\rangle+(1-2a)|\Psi_0\rangle,&#xA;\end{align}&#xA;where $a=\langle\Psi_1|\Psi_1\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The action of $\Q$ over $|\Psi_i\rangle$ does not seem obvious. For example,&#xA;$$\Q|\Psi_0\rangle=-\A\S_0\A^{-1}\S_\chi|\Psi_0\rangle&#xA;=-\A\S_0\A^{-1}|\Psi_0\rangle,$$&#xA;but then already $\A^{-1}$ acts nontrivially on $|\Psi_0\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;How is $\Q|\Psi_i\rangle$ computed?&lt;/em&gt;&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-07-24T16:41:45.240" LastActivityDate="2018-07-24T16:41:45.240" Title="Computing of the action of the amplification operator $\mathbf Q$ over $|\Psi_i\rangle$ in the quantum amplitude amplification algorithm" Tags="&lt;quantum-algorithms&gt;&lt;amplitude-amplification&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="3814" PostTypeId="2" ParentId="2724" CreationDate="2018-07-19T22:32:17.517" Score="2" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Is there anything on software that gives a good introduction to the functions and uses a quantum computer will have?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I gave a talk on quantum computing from a computer science perspective &lt;a href=&quot;https://www.youtube.com/watch?v=F_Riqjdh2oM&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt; which has been well-received. I cover the function of basic quantum logic gates, and go over the simplest problem where a quantum computer outperforms classical methods (the Deutsch Oracle problem). High school students have reportedly found it understandable.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;As well as what language would be best to program one? Also, would there be a way to program a quantum computer through a classical computer?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Microsoft's &lt;a href=&quot;https://www.microsoft.com/en-us/quantum/development-kit&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Development Kit&lt;/a&gt; contains both a quantum language (Q#) and quantum computer simulator to run your quantum programs on your own classical computer.&lt;/p&gt;&#xA;" OwnerUserId="4153" LastActivityDate="2018-07-19T22:32:17.517" CommentCount="0" />
  <row Id="3815" PostTypeId="1" AcceptedAnswerId="3817" CreationDate="2018-07-19T23:07:15.527" Score="8" ViewCount="168" Body="&lt;p&gt;I've created a simple circuit in Q-Kit to understand conditional gates and outputted states on each step:&#xA;&lt;a href=&quot;https://i.stack.imgur.com/dIari.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/dIari.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;In the beginning there is clear 00 state, which is the input&lt;/li&gt;&#xA;&lt;li&gt;The first qubit is passed through the Hadamard gate, it gets into superposition, 00 and 10 become equally possible&lt;/li&gt;&#xA;&lt;li&gt;The first qubit CNOTs the second one, probability of 00 is unchanged, but 10 and 11 are swapped&lt;/li&gt;&#xA;&lt;li&gt;The first qubit passes Hadamard again and &lt;strong&gt;probability of 00 is splited between 00 and 10, and 11 between 01 and 11&lt;/strong&gt; as if first qubit stepped into superposition from a fixed state&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Shouldn't the result be equally distributed 00 and 01? The first qubit passes Hadamard twice, which should put it into superposition and back to initial 0. The CNOT gate does not affect controller qubit, so its existence shouldn't affect first qubit at all, but in fact it makes it act like it wasn't in superposition any more. &lt;strong&gt;Does usage of qubit as a controller collapse its superposition?&lt;/strong&gt;&lt;/p&gt;&#xA;" OwnerUserId="3068" LastEditorUserId="3068" LastEditDate="2018-07-20T09:29:00.617" LastActivityDate="2018-07-20T09:29:00.617" Title="Does conditional gate collapse controller's superposition?" Tags="&lt;quantum-gate&gt;&lt;superposition&gt;" AnswerCount="3" CommentCount="0" FavoriteCount="2" />
  <row Id="3816" PostTypeId="2" ParentId="1679" CreationDate="2018-07-20T00:15:05.593" Score="1" Body="&lt;p&gt;In addition to the security of the digital signatures used in cryptocurrencies, which, as mentioned, is susceptible to an attack with a quantum computer capable of executing Shor's algorithm, cryptocurrencies use other cryptographic primitives in the &quot;proof-of-work.&quot;  &lt;a href=&quot;https://arxiv.org/abs/1804.08118&quot; rel=&quot;nofollow noreferrer&quot;&gt;Or Sattath&lt;/a&gt; describes a weakness of Bitcoin's currently implemented proof-of-work.  Sattath proposes an easily-implementable countermeasure for this security flaw, but the &lt;em&gt;current implementation&lt;/em&gt; of Bitcoin has Sattath's weakness.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;In more detail, a cryptocurrency with a blockchain employing Nakamoto-style consensus requires miners who perform a proof-of-work, in order to determine the consensus ledger.  In Bitcoin, the proof-of-work entails finding a partial preimage of a particular hash function - that is, at height $n$, miner $i$ generating her merkle root $R_i$ representing the ledger, and finding a nonce $c$ such that a cryptographic hash $H(B_{n-1}\Vert c\Vert R_i)=B_n\le d$ for target $d$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As has been noted, such a proof-of-work is weakened by a quantum computer capable of executing Grover's algorithm - by running amplitude amplification on all states that hash to less than the target, a quadratic speedup may be achieved, and the nonce $c$ may be found more easily. A naive way to improve security, then, is to reduce the target $d$ polynomially - that is, make the difficulty be quadratically harder.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Further, a key requirement of such proofs-of-work is that they are &lt;strong&gt;progress-free&lt;/strong&gt;, meaning that after a miner has spent $t$ minutes working on finding a nonce $c$, then she would be no closer to finding the winning block than if she spent $t+1$ minutes.  The hope is that the race goes not the fastest, but to the ones with the most hash power.  This leads to a lack of correlation between the time separate miners find a block.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, Grover's algorithm is famously &lt;em&gt;not&lt;/em&gt; progress-free.  That is, each iteration of Grover's algorithm quadratically improves a miners' chance of finding the block.  Or Sattath noted that this will likely lead to miners stopping their work immediately upon receiving a mined block, and hopefully winning a fork.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Sattath states:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Suppose Alice devoted $2$ minutes of applying Grover’s algorithm, and now receives a new block, mined by Bob.  She could discard her computation, and start mining on top of Bob’s block, but that amounts to wasting $2$ minutes of computational resources.  Instead,  she could immediately stop Grover’s algorithm, and measure her quantum state. If she is lucky and her block is valid, and she also propagates her block to most other miners before Bob does, these other miners will mine on top of her block, and she, rather than Bob, will get the block reward.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Sattath supposes that if enough miners are Grover-capable, then all miners will be motivated to measure for their block whenever someone announces a nonce.  This leads to forks that destroy the security of the blockchain.  &lt;/p&gt;&#xA;" OwnerUserId="2927" LastEditorUserId="2927" LastEditDate="2018-07-20T02:01:48.350" LastActivityDate="2018-07-20T02:01:48.350" CommentCount="0" />
  <row Id="3817" PostTypeId="2" ParentId="3815" CreationDate="2018-07-20T00:17:28.373" Score="5" Body="&lt;p&gt;$$&#xA;\begin{eqnarray*}&#xA;\mid 0 0 \rangle &amp;amp;\to&amp;amp; \frac{1}{\sqrt{2}} \mid 0 0 \rangle + \frac{1}{\sqrt{2}} \mid 1 0 \rangle\\&#xA;&amp;amp;\to&amp;amp; \frac{1}{\sqrt{2}} \mid 0 0 \rangle + \frac{1}{\sqrt{2}} \mid 1 1 \rangle\\&#xA;&amp;amp;\to&amp;amp; \frac{1}{\sqrt{4}} \mid 0 0 \rangle + \frac{1}{\sqrt{4}} \mid 1 1 \rangle + \frac{1}{\sqrt{4}} \mid 1 0 \rangle + \frac{1}{\sqrt{4}} \mid 0 1 \rangle&#xA;\end{eqnarray*}&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If the second line was $(\frac{1}{\sqrt{2}} \mid 0 \rangle + \frac{1}{\sqrt{2}} \mid 1 \rangle) \otimes v$, then applying the $H$ again would take it to $\mid 0 \rangle \otimes v$, but it is not. They are entangled.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It seems like you're thinking the first qubit is unaffected by the CNOT, so the last two should commute.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;\begin{eqnarray*}&#xA;H_1 CNOT_{12} &amp;amp;=&amp;amp; \frac{1}{\sqrt{2}} \begin{pmatrix}&#xA;1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1\\&#xA;0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0\\&#xA;1 &amp;amp; 0 &amp;amp; 0 &amp;amp; -1\\&#xA;0 &amp;amp; 1 &amp;amp; -1 &amp;amp; 0&#xA;\end{pmatrix}\\&#xA;CNOT_{12} H_1 &amp;amp;=&amp;amp; \frac{1}{\sqrt{2}} \begin{pmatrix}&#xA;1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0\\&#xA;0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1\\&#xA;0 &amp;amp; 1 &amp;amp; 0 &amp;amp; -1\\&#xA;1 &amp;amp; 0 &amp;amp; -1 &amp;amp; 0&#xA;\end{pmatrix}\\&#xA;\end{eqnarray*}&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is in a superposition, the entire time. There was no collapse. It's a nonobvious noncommutation. If you had $Id \otimes U$, that would be something literally not affecting the first qubit and it would commute with $H_1$. But CNOT is not of that form.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can think of it this way at the beginning you have 2 qubits. After applying the first $H$ you still have 2 qubits. Then after the CNOT, they are entangled so you have 1 qudit with $d=4$ because they have been combined. Then the last $H$ leaves it with $d=4$. At each gate, you do a worst case scenario of the entanglement structure.&lt;/p&gt;&#xA;" OwnerUserId="434" LastActivityDate="2018-07-20T00:17:28.373" CommentCount="0" />
  <row Id="3818" PostTypeId="2" ParentId="3815" CreationDate="2018-07-20T00:18:01.037" Score="3" Body="&lt;p&gt;No, using a controlled gate doesn't measure the control.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In a sense, the idea that controlled gates would be implemented via measurement is exactly backwards. It's measurement that is implemented in terms of controlled gates, not vice versa. A measurement is just an interaction (i.e a controlled gate) between the computer and the environment that's intractable to undo.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As a simpler analogy, consider the Z gate. The Z gate applies a -1 phase factor to the $|1\rangle$ state of a qubit. It sends $a|0\rangle + b|1\rangle$ to $a|0\rangle - b |1\rangle$. One could describe this effect in a conditional way: &lt;em&gt;if&lt;/em&gt; the qubit is in the $|1\rangle$ state, &lt;em&gt;then&lt;/em&gt; the Z gate phases the qubit by -1. But the &quot;if&quot; in that description does not mean that we had to measure the qubit and then decide whether or not to apply the -1 phase factor, it's just a slightly-misleading description.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The same idea applies to the CNOT. Yes, you can describe it in an if-then way. But you can also describe it as &quot;apply a -1 phase factor to the $|1\rangle \otimes |-\rangle$ state&quot;. And the latter description makes it clear that measurement is not necessary.&lt;/p&gt;&#xA;" OwnerUserId="119" LastActivityDate="2018-07-20T00:18:01.037" CommentCount="0" />
  <row Id="3819" PostTypeId="2" ParentId="3813" CreationDate="2018-07-20T06:20:53.420" Score="2" Body="&lt;p&gt;The trick here is to not calculate $\mathcal{A}^{-1}|\Psi\rangle$ at all, because it's insufficiently defined! Instead, look at&#xA;$$&#xA;\mathcal{A}(\mathbb{I}-2|0\rangle\langle 0|)\mathcal{A}^{-1}=\mathbb{I}-2\mathcal{A}|0\rangle\langle 0|\mathcal{A}^{-1}&#xA;$$&#xA;by the fact that $\mathcal{A}$ is unitary. Now, by definition,&#xA;$$&#xA;\mathcal{A}|0\rangle=|\Psi_0\rangle+|\Psi_1\rangle&#xA;$$&#xA;Thus, we have&#xA;$$&#xA;\mathcal{A}(\mathbb{I}-|0\rangle\langle 0|)\mathcal{A}^{-1}=\mathbb{I}-2(|\Psi_0\rangle+|\Psi_1\rangle)(\langle\Psi_0|+\langle\Psi_1|).&#xA;$$&#xA;Now you can calculate the effect of this on any input state. Just remember that the states $|\Psi_0\rangle$ and $|\Psi_1\rangle$ are not normalised.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Hence,&#xA;\begin{align*}&#xA;Q|\Psi_0\rangle&amp;amp;=-\left(\mathbb{I}-2(|\Psi_0\rangle+|\Psi_1\rangle)(\langle\Psi_0|+\langle\Psi_1|)\right)|\Psi_0\rangle  \\&#xA;&amp;amp;=-\left(|\Psi_0\rangle-2(|\Psi_0\rangle+|\Psi_1\rangle)(1-a)\right) \\&#xA;&amp;amp;=2(1-a)|\Psi_1\rangle+(1-2a)|\Psi_0\rangle&#xA;\end{align*}&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-07-20T06:20:53.420" CommentCount="0" />
  <row Id="3820" PostTypeId="2" ParentId="3815" CreationDate="2018-07-20T08:47:37.207" Score="0" Body="&lt;blockquote&gt;&#xA;  &lt;ol&gt;&#xA;  &lt;li&gt;In the beginning there is clear 00 state, which is the input&lt;/li&gt;&#xA;  &lt;li&gt;The first qubit is passed through the Hadamard gate, it gets into superposition, 00 and 10 become equally possible&lt;/li&gt;&#xA;  &lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Correct.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;ol start=&quot;3&quot;&gt;&#xA;  &lt;li&gt;The first qubit CNOTs the second one, probability of 00 is unchanged, but 10 and 11 are swapped&lt;/li&gt;&#xA;  &lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;To be precise, 10 becomes 11.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;ol start=&quot;4&quot;&gt;&#xA;  &lt;li&gt;The first qubit passes Hadamard again and &lt;strong&gt;probability of 01 is splited between 01 and 11, and 11 between 01 and 11&lt;/strong&gt; as if first qubit stepped into superposition from a fixed state&lt;/li&gt;&#xA;  &lt;/ol&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Incorrect. There is no &lt;strong&gt;01&lt;/strong&gt; here, only &lt;strong&gt;00&lt;/strong&gt; and &lt;strong&gt;11&lt;/strong&gt;, and after applying Hadamard to the first qubit you have superposition of 4 states: &lt;strong&gt;00&lt;/strong&gt;, &lt;strong&gt;10&lt;/strong&gt;, &lt;strong&gt;11&lt;/strong&gt; and &lt;strong&gt;01&lt;/strong&gt;,&#xA;$$\frac{1}{\sqrt{2}}(|00\rangle+|11\rangle)\rightarrow\frac{1}{2}(|00\rangle+|10\rangle+|01\rangle-|11\rangle)$$&lt;/p&gt;&#xA;" OwnerUserId="2105" LastEditorUserId="2105" LastEditDate="2018-07-20T09:08:02.227" LastActivityDate="2018-07-20T09:08:02.227" CommentCount="0" />
  <row Id="3821" PostTypeId="1" AcceptedAnswerId="3829" CreationDate="2018-07-20T09:52:34.450" Score="6" ViewCount="147" Body="&lt;p&gt;I am looking for some good software to simulate quantum computing, visually if possible.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I know about quirk (&lt;a href=&quot;http://algassert.com/quirk&quot; rel=&quot;noreferrer&quot;&gt;http://algassert.com/quirk&lt;/a&gt;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;and IBM Q Experience (&lt;a href=&quot;https://quantumexperience.ng.bluemix.net&quot; rel=&quot;noreferrer&quot;&gt;https://quantumexperience.ng.bluemix.net&lt;/a&gt;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I just saw this question ( &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/3815/does-conditional-gate-collapse-controllers-superposition&quot;&gt;Does conditional gate collapse controller&amp;#39;s superposition?&lt;/a&gt; ) and the asker uses something that looks really neat : &lt;a href=&quot;https://i.stack.imgur.com/dIari.png&quot; rel=&quot;noreferrer&quot;&gt;https://i.stack.imgur.com/dIari.png&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Does someone knows what this is?&#xA;And does someone knos other good software like these?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thank you!!&lt;/p&gt;&#xA;" OwnerUserId="4160" LastEditorUserId="4160" LastEditDate="2018-07-20T12:22:47.127" LastActivityDate="2018-07-24T06:37:45.890" Title="What are some good quantum computing simulator and visualiser?" Tags="&lt;simulation&gt;" AnswerCount="2" CommentCount="2" FavoriteCount="2" ClosedDate="2018-07-24T13:56:57.603" />
  <row Id="3823" PostTypeId="1" AcceptedAnswerId="3824" CreationDate="2018-07-20T12:05:30.820" Score="6" ViewCount="321" Body="&lt;p&gt;Following from &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/3743/error-simulation-of-quantum-algorithm-for-linear-systems-of-equations-for-4&quot;&gt;this question&lt;/a&gt;, I tried to look at the cited &lt;a href=&quot;https://arxiv.org/abs/1110.2232v2&quot; rel=&quot;noreferrer&quot;&gt;article&lt;/a&gt; in order to simulate and solve that same problem... without success. Mainly, I still fail to understand how the authors managed to simulate the hamiltonian evolution through the circuit shown at the bottom of Fig.4. Even exponentiating classically the matrix I do not get values of the gates shown in the Quirk circuit that @Blue linked along his question.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I tried to look at the &lt;a href=&quot;https://arxiv.org/pdf/1009.5625.pdf&quot; rel=&quot;noreferrer&quot;&gt;paper&lt;/a&gt; in which the Group Leader Optimizaion algorithm is explained, but I still have troubles understanding how do they assign the rotation angles to the different gates.&lt;/p&gt;&#xA;" OwnerUserId="2648" LastEditorUserId="1386" LastEditDate="2018-07-20T12:20:54.867" LastActivityDate="2018-07-20T13:27:48.913" Title="Practical implementation of Hamiltonian Evolution" Tags="&lt;quantum-algorithms&gt;&lt;quantum-gate&gt;&lt;hhl-algorithm&gt;&lt;hamiltonian-simulation&gt;" AnswerCount="1" CommentCount="4" />
  <row Id="3824" PostTypeId="2" ParentId="3823" CreationDate="2018-07-20T13:19:40.570" Score="4" Body="&lt;p&gt;I don't know why/how the authors of that paper do what they do. However, here's how I'd go about it for this special case (and it is a very special case):&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can write the Hamiltonian as a Pauli decomposition&#xA;$$&#xA;A=15\mathbb{I}\otimes\mathbb{I}+9Z\otimes X+5X\otimes Z-3Y\otimes Y.&#xA;$$&#xA;Now, it is interesting to note that every one of these terms commutes. So, that means that&#xA;$$&#xA;e^{iA\theta}=e^{15i\theta}e^{9i\theta Z\otimes X}e^{5i\theta X\otimes Z}e^{-3i\theta Y\otimes Y}.&#xA;$$&#xA;You could work out how to simulate each of these steps individually, but let me make one further observation first: these commuting terms are the stabilizers of the 2-qubit cluster state. That may or may not mean anything to you, but it tells me that a smart thing to do is apply a controlled-phase gate.&#xA;$$&#xA;CP\cdot A\cdot CP=15\mathbb{I}\otimes\mathbb{I}+9\mathbb{I}\otimes X+5X\otimes \mathbb{I}-3X\otimes X.&#xA;$$&#xA;(You may want to check the sign of the last term. I didn't compute it carefully.)&#xA;So, if we start and end our sequence with controlled-phase gates, then 2 of the terms are easy to get right: we rotate the first qubit about the $x$ axis by an angle $5\theta$, and the second qubit about the $x$ axis by an angle $9\theta$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The only thing we are left to get right is the $X\otimes X$ rotation. If you think about the structure of $e^{-3i\theta X\otimes X}$, this is like an $x$ rotation on the basis states $\{|00\rangle,|11\rangle\}$, and another one on $\{|01\rangle,|10\rangle\}$. A controlled-not converts these bases into the single-qubit bases controlled off the target qubit. But since both implement the same controlled-rotation but controlled off opposite values, we can just remove the control. Thus, the overall circuit is:&#xA;&lt;a href=&quot;https://i.stack.imgur.com/YKwjo.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/YKwjo.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&#xA;This simplifies slightly by combining the two controlled-gates at the end:&#xA;&lt;a href=&quot;https://i.stack.imgur.com/f0g1A.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/f0g1A.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&#xA;Note that I have not included the global phase term here because that's not the sensible way to do it. When you make controlled-($e^{iA\theta}$), you apply the &quot;global phase&quot; as a $z$ rotation on the control qubit.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-07-20T13:27:48.913" LastActivityDate="2018-07-20T13:27:48.913" CommentCount="0" />
  <row Id="3826" PostTypeId="2" ParentId="3800" CreationDate="2018-07-20T16:27:30.640" Score="2" Body="&lt;p&gt;The current version of PyQuil provides an &quot;ISA&quot; object that houses the information that you want about Rigetti's quantun processors, but it isn't formatted as you request.  I'm a poor Python programmer, so you'll have to excuse my non-Pythonic-ness—but here's a snippet that will take a &lt;code&gt;device_name&lt;/code&gt; and reformat the pyQuil ISA into one of your dictionaries:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import pyquil.api as p&#xA;&#xA;device_name = '19Q-Acorn'&#xA;&#xA;isa = p.get_devices(as_dict=True)[device_name].isa&#xA;d = {}&#xA;for qubit in isa.qubits:&#xA;    l = []&#xA;    for edge in isa.edges:&#xA;        if qubit.id is edge.targets[0]:&#xA;            l += [edge.targets[1]]&#xA;        if qubit.id is edge.targets[1]:&#xA;            l += [edge.targets[0]]&#xA;    if not qubit.dead:&#xA;        d[qubit.id] = l&#xA;&#xA;print(d)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;As in Google's case, the native two-qubit gate typically available on a Rigetti quantum processor is a &lt;code&gt;CZ&lt;/code&gt;, which (1) is bidirectional(†) in the sense that &lt;code&gt;CZ q0 q1&lt;/code&gt; is the same as &lt;code&gt;CZ q1 q0&lt;/code&gt; and (2) is easily converted into either of your preferred &lt;code&gt;CNOT&lt;/code&gt;s by sandwiching the target with Hadamard gates.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;† - The physical implementation of a &lt;code&gt;CZ&lt;/code&gt; gate in a superconducting architecture &lt;em&gt;is&lt;/em&gt; handed, which is why you often see architectural descriptions include &lt;code&gt;CZ q0 q1&lt;/code&gt; but not &lt;code&gt;CZ q1 q0&lt;/code&gt;.  It's a shorthand for which qubit is participating in which half of the physical interaction, even if the result (ignoring noise effects) is the same with either ordering.&lt;/p&gt;&#xA;" OwnerUserId="1796" LastActivityDate="2018-07-20T16:27:30.640" CommentCount="0" />
  <row Id="3827" PostTypeId="2" ParentId="3800" CreationDate="2018-07-20T18:14:51.780" Score="0" Body="&lt;p&gt;I found the following picture for the Rigetti 19 qubit chip (Acorn).&#xA;&lt;a href=&quot;https://i.stack.imgur.com/69omU.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/69omU.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It also appears that qubit 3 in that picture malfunctioned. Therefore the connectivity dictionary that I was looking for would be&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;rigetti20_c_to_tars = {&#xA;    0: [5, 6],&#xA;    1: [6, 7],&#xA;    2: [7, 8],&#xA;    3: [],  # 3: [8, 9],&#xA;    4: [9],&#xA;    5: [0, 10],&#xA;    6: [0, 1, 11],&#xA;    7: [1, 2, 12],&#xA;    8: [2, 13],  # 8: [2, 3, 13],&#xA;    9: [4, 14],  # 9: [3, 4, 14],&#xA;    10: [5, 15, 16],&#xA;    11: [6, 16, 17],&#xA;    12: [7, 17, 18],&#xA;    13: [8, 18, 19],&#xA;    14: [9, 19],&#xA;    15: [10],&#xA;    16: [10, 11],&#xA;    17: [11, 12],&#xA;    18: [12, 13],&#xA;    19: [13, 14]}  # 42 edges&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="1974" LastActivityDate="2018-07-20T18:14:51.780" CommentCount="0" />
  <row Id="3828" PostTypeId="1" CreationDate="2018-07-20T18:28:00.140" Score="7" ViewCount="74" Body="&lt;p&gt;By &quot;faulty&quot;, I mean that you can have errors on the ancilla qubits, you can have faulty syndrome extraction, etc. &lt;/p&gt;&#xA;" OwnerUserId="108" LastEditorUserId="26" LastEditDate="2018-07-20T18:35:38.447" LastActivityDate="2018-07-23T15:11:32.863" Title="What are reliable references on analytical and/or numerical studies of threshold theorems under faulty quantum error correction?" Tags="&lt;quantum-error-correction&gt;&lt;resource-request&gt;" AnswerCount="2" CommentCount="2" FavoriteCount="1" />
  <row Id="3829" PostTypeId="2" ParentId="3821" CreationDate="2018-07-20T19:20:11.920" Score="3" Body="&lt;p&gt;I will tell you what my software Qubiter (&lt;a href=&quot;https://github.com/artiste-qb-net/qubiter&quot; rel=&quot;nofollow noreferrer&quot;&gt;GitHub page&lt;/a&gt;) does. Others like IBM (QISKit &lt;a href=&quot;https://github.com/Qiskit/qiskit.org&quot; rel=&quot;nofollow noreferrer&quot;&gt;GitHub page&lt;/a&gt;, &lt;a href=&quot;https://qiskit.org/&quot; rel=&quot;nofollow noreferrer&quot;&gt;website&lt;/a&gt; and &lt;a href=&quot;https://qiskit.org/documentation/&quot; rel=&quot;nofollow noreferrer&quot;&gt;documentation&lt;/a&gt;), Google (Cirq &lt;a href=&quot;https://github.com/quantumlib/Cirq&quot; rel=&quot;nofollow noreferrer&quot;&gt;GitHub page&lt;/a&gt; and &lt;a href=&quot;https://cirq.readthedocs.io/en/latest/index.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;documentation&lt;/a&gt;), Rigetti (PyQuil &lt;a href=&quot;https://github.com/rigetticomputing/pyQuil&quot; rel=&quot;nofollow noreferrer&quot;&gt;GitHub page&lt;/a&gt; and &lt;a href=&quot;https://pyquil.readthedocs.io/en/latest/&quot; rel=&quot;nofollow noreferrer&quot;&gt;documentation&lt;/a&gt;) and Microsoft (Q# &lt;a href=&quot;https://github.com/Microsoft/Quantum&quot; rel=&quot;nofollow noreferrer&quot;&gt;GitHub page&lt;/a&gt; and &lt;a href=&quot;https://docs.microsoft.com/en-us/quantum/?view=qsharp-preview&quot; rel=&quot;nofollow noreferrer&quot;&gt;documentation&lt;/a&gt;) can describe what their own software does to help visualize the circuit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Qubiter automatically creates 2 files for the quantum circuit, a Qubiter qasm file and an ASCII picture file. This makes debugging easier (Qubiter can also draw fancy LaTex picture of circuit but that is slower so only optional) The ascii file and qasm file correspond line by line, so line 5 in each gives 2 representations, ascii and qasm, of the same gate. Note that it is common to draw pictures of quantum circuits with time pointing from left to right, but Qubiter draws them with time pointing downwards.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, for Teleportation, this is gif of the Qubiter qasm file:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/mEcwG.gif&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/mEcwG.gif&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;and this is a gif of the Qubiter ascii file:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/Xse46.gif&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/Xse46.gif&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The PRINT ALL statements print to screen the state vector of the qc at the time at which they appear.&lt;/p&gt;&#xA;" OwnerUserId="1974" LastEditorUserId="1386" LastEditDate="2018-07-24T06:37:45.890" LastActivityDate="2018-07-24T06:37:45.890" CommentCount="0" />
  <row Id="3830" PostTypeId="1" AcceptedAnswerId="3840" CreationDate="2018-07-21T15:57:50.173" Score="4" ViewCount="54" Body="&lt;p&gt;Reading about quantum topological error correction I’ve found some information, but I don’t have already clear the link with the topological concept (trivial and not trivial paths, how they are related with the error).&#xA;Can I have explanations or some link where conceptual meaning is explained?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thanks.&lt;/p&gt;&#xA;" OwnerUserId="2886" LastEditorUserId="2645" LastEditDate="2018-07-23T10:26:36.400" LastActivityDate="2018-07-23T10:26:36.400" Title="topological error correction concepts" Tags="&lt;quantum-error-correction&gt;&lt;resource-request&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="2" />
  <row Id="3832" PostTypeId="1" AcceptedAnswerId="3850" CreationDate="2018-07-21T19:20:13.640" Score="6" ViewCount="112" Body="&lt;p&gt;I found the following proof of BQP belonging to PP (the original document is &lt;a href=&quot;https://cs.uwaterloo.ca/~watrous/LectureNotes/CPSC519.Winter2006/22.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;). There is a part of the proof that I have trouble understanding. First, the structure is given below.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;We try to simulate a polynomial-time generated quantum circuit&#xA;  (which encodes our problem) using a PP machine. We start with a&#xA;  universal set of gates. &lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;We have a Hadamard gate and a Toffoli gate. We also include a $i$-phase shift gate ($|0 \rangle$&#xA;  $\rightarrow |0 \rangle, |1 \rangle \rightarrow i|1 \rangle$). However,&#xA;  we simulate the action of this gate by considering an additional qubit&#xA;  and performing the following transformations:&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;$$|00 \rangle → |00 \rangle $$ $$|01 \rangle → |01 \rangle $$ &#xA;  $$|10\rangle→ |11 \rangle $$ $$|11 \rangle  →  −|10 \rangle $$&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;The first qubit is viewed as the original qubit and the additional&#xA;  qubit acts as the &quot;real/imaginary part&quot;.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;There is a register $B \leftarrow 0$ to store the phase. A register $Z$&#xA;  $\leftarrow 0^n$ stores the initial state of the machine. We simulate&#xA;  the circuit as follows:&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;$\bullet$ If the gate is a Toffoli gate, simply modify $Z$&#xA;  accordingly.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;$\bullet$ If the gate is a Hadamard gate, flip a coin to determine the&#xA;  new state of the corresponding bit of $Z$. If the induced&#xA;  transformation was $1 \rightarrow 1$, toggle the sign bit.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;$\bullet$ If the gate is the two-qubit gate we used to replace the&#xA;  $i$-phase shift gate, modify $Z$ appropriately and toggle the sign bit&#xA;  if the transformation induced was $11 \rightarrow 10$.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;The steps above are repeated a second time, using variables $B'$ and&#xA;  $Z'$ in place of $B$ and $Z$. Finally, the following operations are&#xA;  performed:&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;$\bullet$ If $Z = Z'$ and the first bit of $Z$ and $Z'$ is a $0$, then&#xA;  output $B ⊕ B'$.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;$\bullet$ If $Z = Z'$ and the first bit of $Z$ and $Z'$ is a $1$, then&#xA;  output $\bar B ⊕ B'$.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;$\bullet$ If $Z \neq Z'$, then “give up”. This means: flip a fair coin&#xA;  and output $0$ or $1$ accordingly.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The claim is that the algorithm above simulates a BQP circuit on a PP machine faithfully as the probability the algorithm outputs $1$ minus the probability that the algorithm outputs $0$ is proportional to $\langle 1 | Q_x |1 \rangle - \langle 0 | Q_x |0 \rangle$ (where $Q_x$ is the quantum circuit for a given encoding $x$ from a polynomial-time generated uniform family of quantum circuits). I do not understand why the terms are proportional.&lt;/p&gt;&#xA;" OwnerUserId="1351" LastEditorUserId="1351" LastEditDate="2018-07-23T09:12:14.700" LastActivityDate="2018-07-23T12:51:34.690" Title="Query regarding BQP belonging to PP" Tags="&lt;complexity-theory&gt;" AnswerCount="1" CommentCount="2" />
  <row Id="3833" PostTypeId="2" ParentId="2724" CreationDate="2018-07-22T00:08:00.650" Score="2" Body="&lt;p&gt;I have not read it yet, however I don't imagine there is a better &lt;em&gt;introduction&lt;/em&gt; than &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/1492671185&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Computing for Babies&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&quot;https://i.stack.imgur.com/a3STU.jpg&quot; alt=&quot;quantum computing for babies&quot;&gt;&lt;/p&gt;&#xA;" OwnerUserId="2645" LastActivityDate="2018-07-22T00:08:00.650" CommentCount="0" />
  <row Id="3834" PostTypeId="2" ParentId="3828" CreationDate="2018-07-22T05:45:12.537" Score="2" Body="&lt;p&gt;This is the paper I found really convincing once I’d worked through it:&#xA;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0504218&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/quant-ph/0504218&lt;/a&gt;&#xA;This was really the start of rigorous threshold proofs, and is the starting point for a number of subsequent improvements.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-07-22T05:45:12.537" CommentCount="0" />
  <row Id="3835" PostTypeId="1" AcceptedAnswerId="3839" CreationDate="2018-07-22T09:24:26.393" Score="6" ViewCount="106" Body="&lt;p&gt;Qubit and qumode are different forms of quantum computation. But most existing quantum computers/chips seems to be of discrete variables. I heard that a group chose qubit for a quantum optical frequency comb experiment relating to quantum computing because the environment noise of continuous variable is much higher. Is this a reason for preferring qubit to qumode at present (if people do prefer it)?&lt;/p&gt;&#xA;" OwnerUserId="4178" LastEditorUserId="2293" LastEditDate="2018-07-22T21:33:40.003" LastActivityDate="2018-07-23T10:29:22.793" Title="Are qubits preferred over qumode, and if so, why?" Tags="&lt;qubit&gt;&lt;continuous-variable&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="3836" PostTypeId="2" ParentId="2505" CreationDate="2018-07-22T16:27:48.500" Score="0" Body="&lt;p&gt;The other answers were (almost?*) correct, and pointed me in the right direction for computing any probability for a measurement(especially the notion that I was measuring in the wrong basis), but I missed the definition. &lt;br&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Assuming you are in state $|\psi\rangle$, and you want to know the probability of measuring outcome $|\phi\rangle$:&lt;br&gt;&#xA;$P=|\langle\psi|\phi\rangle|^2$ (&lt;a href=&quot;https://ocw.tudelft.nl/course-lectures/0-3-1-measuring-qubits-standard-basis/&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://ocw.tudelft.nl/course-lectures/0-3-1-measuring-qubits-standard-basis/&lt;/a&gt; @1:48)&lt;br&gt;&#xA;where $\langle\psi|$ is the complex conjugate transpose of the $|\psi\rangle$&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;More, concrete, if we are in $T |+\rangle$ ($\equiv{1\over\sqrt 2} \begin{bmatrix}1\\e^{i\pi/4}\end{bmatrix}$), and want to know the probability of measuring $|+\rangle$ ($\equiv{1\over\sqrt 2}\begin{bmatrix} 1 \\ 1 \end{bmatrix})$, we calculate:&lt;br&gt;&#xA;$P=|{1\over\sqrt 2} \begin{bmatrix}1 &amp;amp; e^{-i\pi/4}\end{bmatrix}{1\over\sqrt 2}\begin{bmatrix} 1 \\ 1 \end{bmatrix}|^2$&lt;br&gt;&#xA;$P={1\over4}|1+e^{-i\pi/4}|^2 \approx 0.853553$ (or use Euler's formula for the exact outcome)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;P.S. I hope I took the right complex conjugate. &lt;br&gt;&#xA;* I also have the $\psi$ and $\phi$ the other way around compared to DaftWullie his/her answer. &lt;/p&gt;&#xA;" OwnerUserId="2794" LastActivityDate="2018-07-22T16:27:48.500" CommentCount="2" />
  <row Id="3837" PostTypeId="1" CreationDate="2018-07-22T17:20:36.160" Score="7" ViewCount="79" Body="&lt;p&gt;A lot of people claim that quantum provides exponential speedup whereas classical computers scale linearly. I have seen examples (such as Shor's algorithm and Simon's) that I believe, but the layman's explanation appears to boil down to &quot;quantum registers with n qubits are able to hold $2^n$ values.&quot; To me, this sounds a lot like having a SIMD (Single Instruction Multiple Data) CPU where I can load two times $2^n$ variables, and &lt;br&gt;&#xA;a) get the correct outcomes, and only these outcomes&lt;br&gt;&#xA;b) trace back which answer is to which questions&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When trying to do this in quantum computing, I think this is definitely not the case. Let me try to evaluate this with an example: &lt;br&gt;&#xA;Say I have two 2-qubit registers , and I want to add two sets of values (2+1 and 1+2):&lt;br&gt;&#xA;$a|10\rangle + b|01\rangle$&lt;br&gt;&#xA;$a|01\rangle + b|10\rangle$&lt;br&gt;&#xA;where a denotes values in register a, and b denotes values in register b. Aka a and b are not scalars&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we now look at the cubits, we see that all are once 0, and once 1. This implies a superposition of all qubits in our input. If we now were to do an addition on the two registers that both hold 2 qubits in superposition, and repeat this experiment sufficient enough times to create a probability distribution, I believe we would end up with a probability distribution for all outcomes as follows:&lt;br&gt;&#xA;$P(0) = 1/16 $&lt;br&gt;&#xA;$P(1) = 2/16 $&lt;br&gt;&#xA;$P(2) = 3/16 $&lt;br&gt;&#xA;$P(3) = 4/16 $&lt;br&gt;&#xA;$P(4) = 3/16 $&lt;br&gt;&#xA;$P(5) = 2/16 $&lt;br&gt;&#xA;$P(6) = 1/16 $&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we look at what we wanted to calculate, 2+1 and 1+2, we see that both our answers (two times the answer 3) are indeed present in the set of outcomes. However, &lt;br&gt;&#xA;a) there are a lot of other answers &lt;br&gt;&#xA;b) we can not trace which answer corresponds to 2+1, and which to 1+2&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;So my questions&lt;/strong&gt;:&lt;br&gt;&#xA;a) Is it correct that for the addition of two sets of randomly chosen variables, we are not guaranteed to see exponential scaling (unless we want to add all values 0 to 2^n with themselves)&lt;br&gt;&#xA;b) Is it correct that, when doing simple classical addition, we loose track of the mapping from input to output&lt;br&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And as a bonus, does the following hold:&lt;br&gt;&#xA;When performing the computation as above, the usability would be the same (or worse, as the mapping from input to output is lost) as a lookup table with the same number of input values, as when we have two registers in superposition, we will always receive the same output distribution&lt;/p&gt;&#xA;" OwnerUserId="2794" LastEditorUserId="26" LastEditDate="2018-07-22T20:27:37.677" LastActivityDate="2018-07-23T14:42:20.023" Title="Does &quot;quantum registers with $n$ qubits are able to hold $2^n$ values and therefore scale exponentially&quot; actually hold that straightforwardly?" Tags="&lt;quantum-algorithms&gt;" AnswerCount="2" CommentCount="3" FavoriteCount="2" />
  <row Id="3838" PostTypeId="2" ParentId="3837" CreationDate="2018-07-23T02:54:44.127" Score="0" Body="&lt;p&gt;I'm going to answer in two parts:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Regarding your example with addition, a quantum adder has been discussed in the question &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1654/how-do-i-add-11-using-a-quantum-computer/1656#1656&quot;&gt;How do I add 1+1 using a quantum computer&lt;/a&gt;. They're a bit involved and I'm not sure if I exactly follow your line of thinking for your questions following your example, but hopefully that link explains a bit about how a quantum computer would handle addition.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;With regards to your more general question about quantum speedups, the important thing isn't that quantum computers can hold up to $2^n$ values in $n$ qubits, as that is also true in a classical computer. The important thing is that they can hold all these $2^n$ values &lt;em&gt;at once&lt;/em&gt;. A lot of quantum algorithms start by taking a register of $n$ qubits all in state $|0\rangle$ and applying a Hadamard transform to all bits. This leads to the register being in the state &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$|\psi\rangle = \displaystyle\sum_{i=0}^{2^n-1}|i\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Which can be fed into an algorithm and have it work on each piece simultaneously. If you look at &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/proxy/tutorial/full-user-guide/004-Quantum_Algorithms/070-Grover&amp;#39;s_Algorithm.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;this explanation of Grover's Algorithm&lt;/a&gt; you can see this at work. By plugging in this uniformly distributed $|\psi\rangle$ into a circuit which picks out a specific element, one can isolate that element without having to cycle through each of the possible $2^n$ values for $|i\rangle$ individually. Although Grover's algorithm isn't an exponential speedup, the same sort of structure holds for more complex algorithms as well.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Hopefully that helps!&lt;/p&gt;&#xA;" OwnerUserId="3056" LastEditorUserId="3056" LastEditDate="2018-07-23T03:03:52.507" LastActivityDate="2018-07-23T03:03:52.507" CommentCount="0" />
  <row Id="3839" PostTypeId="2" ParentId="3835" CreationDate="2018-07-23T03:14:02.150" Score="3" Body="&lt;p&gt;Both models have their potential advantages and disadvantages. The CV model doesn't require energy intensive cooling systems. CV will also work better for continuous-valued problems. Nevertheless, since the model uses photons it brings various challenges to the table as well. Since both models (especially CV)  aren't developed, your question may not be the right one to ask right now. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you're interested, I know that Xanadu is developing the CV model. They have some papers on CV algorithms and QML out right now. &lt;/p&gt;&#xA;" OwnerUserId="4181" LastEditorUserId="2293" LastEditDate="2018-07-23T10:29:22.793" LastActivityDate="2018-07-23T10:29:22.793" CommentCount="1" />
  <row Id="3840" PostTypeId="2" ParentId="3830" CreationDate="2018-07-23T03:21:19.590" Score="4" Body="&lt;p&gt;This explanation of &lt;a href=&quot;https://arxiv.org/abs/1208.0928&quot; rel=&quot;nofollow noreferrer&quot;&gt;Surface Codes&lt;/a&gt; has a lot of detail and starts from the basics. It should hopefully help out, as well as looking at some of the initial Toric Code papers by Alexei Kitaev.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My understanding of the term (hopefully someone more knowledgeable can chime in if I'm incorrect!) is that it's because the errors needed to create a logical error have to be non-local, and can be deviated. IE if you take the Toric code which exists on a torus, a logical operation is a loop of errors around the torus, which cannot be smoothly modified into a local error since the topology of the space prevents it.&lt;/p&gt;&#xA;" OwnerUserId="3056" LastEditorUserId="409" LastEditDate="2018-07-23T09:41:14.860" LastActivityDate="2018-07-23T09:41:14.860" CommentCount="0" />
  <row Id="3841" PostTypeId="1" CreationDate="2018-07-23T04:01:33.140" Score="4" ViewCount="130" Body="&lt;p&gt;I'm just learning about quantum computer but some of it has been available for people to research &amp;amp; practice so I'd like to study it myself. The only kind of quantum computing I found so far is IBM cloud service and Q# quantum simulator but the sources and examples are limited, and I only found a bunch of display emoji &amp;amp; a card-guessing mini game in quantum programming. Are there any main sources like github but for quantum computing programming? &lt;/p&gt;&#xA;" OwnerUserId="4182" LastEditorUserId="2293" LastEditDate="2018-07-23T10:31:42.830" LastActivityDate="2018-07-23T11:41:46.320" Title="Is there something like GitHub for Quantum Programming?" Tags="&lt;ibm-q-experience&gt;&lt;q#&gt;" AnswerCount="3" CommentCount="1" FavoriteCount="2" />
  <row Id="3842" PostTypeId="2" ParentId="3841" CreationDate="2018-07-23T04:09:59.037" Score="0" Body="&lt;p&gt;Are you looking for algorithms to look through, or programs for an actual quantum computer?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If the former the &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/tutorial?sectionId=full-user-guide&amp;amp;page=introduction&quot; rel=&quot;nofollow noreferrer&quot;&gt;IBM Q Experience&lt;/a&gt; user guide has good explanations of some of them, and other questions you can find on this Stack Exchange can get you to more algorithms.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you are looking for programs to be run on a quantum computer like IBM's cloud offerings, I'm not sure if there is a github specific to is, but looking into the &lt;a href=&quot;https://github.com/Qiskit/qiskit-tutorial&quot; rel=&quot;nofollow noreferrer&quot;&gt;Qiskit&lt;/a&gt; github would be a good place to start!&lt;/p&gt;&#xA;" OwnerUserId="3056" LastActivityDate="2018-07-23T04:09:59.037" CommentCount="2" />
  <row Id="3843" PostTypeId="2" ParentId="3841" CreationDate="2018-07-23T05:46:33.787" Score="4" Body="&lt;p&gt;For Q#, the largest GitHub repository of algorithms written in Q# is the official &lt;a href=&quot;https://github.com/Microsoft/Quantum/&quot; rel=&quot;nofollow noreferrer&quot;&gt;libraries and samples repo&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you want to start studying Q# by writing small quantum computing programs, there is &lt;a href=&quot;https://github.com/Microsoft/QuantumKatas&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Katas repo&lt;/a&gt;, it has less code and the code is simpler but it aims specifically to teach the basics.&lt;/p&gt;&#xA;" OwnerUserId="2879" LastActivityDate="2018-07-23T05:46:33.787" CommentCount="2" />
  <row Id="3844" PostTypeId="1" CreationDate="2018-07-23T07:13:07.000" Score="5" ViewCount="54" Body="&lt;p&gt;Say I have a quantum register containing 1 qubit. A qubit can hold either 0, 1 or both 0 and 1. In Dirac, one would write &lt;br&gt;&#xA;0: $|0\rangle=\begin{bmatrix}1\\0\end{bmatrix}$ &lt;br&gt;&lt;br&gt;&#xA;1: $|1\rangle=\begin{bmatrix}0\\1\end{bmatrix}$ &lt;br&gt;&lt;br&gt;&#xA;0 and 1: $|+\rangle={1\over\sqrt 2}\begin{bmatrix}1\\1\end{bmatrix}$ &lt;br&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we were to extend our register to 2 qubits: &lt;br&gt;&#xA;0: $|00\rangle = |0\rangle \otimes |0\rangle = \begin{bmatrix}1\\0\end{bmatrix} \otimes \begin{bmatrix}1\\0\end{bmatrix} = \begin{bmatrix}1\\0\\0\\0\end{bmatrix}$ &lt;br&gt;&lt;br&gt;&#xA;1: $|01\rangle = |0\rangle \otimes |1\rangle = \begin{bmatrix}1\\0\end{bmatrix} \otimes \begin{bmatrix}0\\1\end{bmatrix} = \begin{bmatrix}0\\1\\0\\0\end{bmatrix}$ &lt;br&gt;&lt;br&gt;&#xA;0 and 1: $|0+\rangle = |0\rangle \otimes |+\rangle = \begin{bmatrix}1\\0\end{bmatrix} \otimes {1\over\sqrt 2}\begin{bmatrix}1\\1\end{bmatrix} = {1\over\sqrt 2}\begin{bmatrix}1\\1\\0\\0\end{bmatrix}$ &lt;br&gt;&lt;br&gt;&#xA;2: $|10\rangle = |1\rangle \otimes |0\rangle = \begin{bmatrix}0\\1\end{bmatrix} \otimes \begin{bmatrix}1\\0\end{bmatrix} = \begin{bmatrix}0\\0\\1\\0\end{bmatrix}$ &lt;br&gt;&lt;br&gt;&#xA;3: $|11\rangle = |1\rangle \otimes |1\rangle = \begin{bmatrix}0\\1\end{bmatrix} \otimes \begin{bmatrix}0\\1\end{bmatrix} = \begin{bmatrix}0\\0\\0\\1\end{bmatrix}$ &lt;br&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now if I would want to load the decimal values 1 and 2 in the quantum register, I have two ways of reasoning, of which one appears to be flawed: &lt;br&gt;&#xA;a)&lt;br&gt;&#xA;This is in line with the reasoning above for 1 qubit, section &quot;0 and 1&quot;: &lt;br&gt;&#xA;I want to add values $|01\rangle$ and $|10\rangle$. My first qubit is a 0 for the decimal value 1, and my first qubit is a 1 for the decimal value 2. This means my first qubit is both 0 and 1, and therefor $|+\rangle$. My second qubit is a 1 for decimal value 1, and a zero for decimal value 2, which also implies $|+\rangle$. Hence, I need to load &lt;br&gt;&#xA;$|++\rangle = &#xA;|+\rangle \otimes |+\rangle = &#xA;{1\over\sqrt 2}\begin{bmatrix}1\\1\end{bmatrix} \otimes {1\over\sqrt 2}\begin{bmatrix}1\\1\end{bmatrix} =&#xA;{1\over\sqrt 4}\begin{bmatrix}1\\1\\1\\1\end{bmatrix}$ &lt;br&gt;&#xA;Which provides me with 1 and 2, but also 0 and 3. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;b) &lt;br&gt;&#xA;$c ( |01\rangle + |10\rangle) = c( \begin{bmatrix}0\\1\\0\\0\end{bmatrix} + \begin{bmatrix}0\\0\\1\\0\end{bmatrix}) = c \begin{bmatrix}0\\1\\1\\0\end{bmatrix}$, where $c$ is likely ${1\over\sqrt 2}$&lt;br&gt;&#xA;Which provides me with 1 and 2 and only 1 and 2, and works out in mathematics, but fails in my current common sense. &lt;br&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;My questions:&lt;/strong&gt; Even though I see with math that b) holds and a) fails, can someone explain to me why this fails? Specifically, why is it that both individual qubits appear to be both 0 and 1, hence in superposition, but they are able to distinguish that as a total, only the decimal values 1 and 2 are present, and not 0,1,2 and 3 (which you would expect from 2 qubits in superposition).&lt;/p&gt;&#xA;" OwnerUserId="2794" LastActivityDate="2018-07-23T09:56:25.213" Title="Can a qubit register hold any subset of values, or only specific subsets?" Tags="&lt;quantum-algorithms&gt;" AnswerCount="1" CommentCount="1" FavoriteCount="1" />
  <row Id="3845" PostTypeId="2" ParentId="3837" CreationDate="2018-07-23T07:40:57.883" Score="4" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;Does “quantum registers with n&#xA;  qubits are able to hold $2^n$&#xA;  values and therefore scale exponentially” actually hold that straightforwardly?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;No, it doesn't. That's the popularised explanation of where quantum computers get their speed-up, but it's far more nuanced than that.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To illustrate this, imagine you have a function $f:x\in\{0,1\}^n\mapsto y\in\{0,1\}^m$. Sure, in quantum you can produce the state&#xA;$$&#xA;|\Psi\rangle=\frac{1}{\sqrt{2^n}}\sum_{x\in\{0,1\}^n}|x\rangle|f(x)\rangle&#xA;$$&#xA;so, in some sense,the function $f$ has been evaluated at every $x$. But what answers can you get? What you certainly cannot read out is every different value of $f(x)$: when you measure (assuming projective measurements) you get a maximum of 1 bit of information for every measurement, $n+m$ bits. But there are $2^n$ inputs, each with $m$ bits to learn, so you need to be able to determine $m2^n$. This is not really any better than doing things classically (in a sense, it's a bit worse because a single measurement will pick an $x$ at random, but classically you'd normally only get the $m$ bits of information from the final outcome).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The real power of quantum computation comes from doing something clever with that state $|\Psi\rangle$. This usually relies on some special properties that you know about $f(x)$, such as &quot;it has a global property which is parametrised by $k$. Find $k$.&quot;. For example, in the Deutsch-Jozsa algorithm, the structure is that either all $f(x)$ are the same, or there's a perfect 50:50 split between answers (Here, $k$ is one bit of information). That sort of comparison between different function evaluations in a classical domain obviously needs lots of different function evaluations, whereas in the quantum domain, sometimes one can perform the right measurement that compares different parts of the superposition and gives you the right information out. &lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-07-23T14:42:20.023" LastActivityDate="2018-07-23T14:42:20.023" CommentCount="0" />
  <row Id="3846" PostTypeId="1" AcceptedAnswerId="3849" CreationDate="2018-07-23T09:39:31.433" Score="5" ViewCount="275" Body="&lt;p&gt;As far I understand, qubits in cirq are labelled by their positions on chip. For example&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;print( cirq.google.Foxtail.qubits )&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;yields&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;frozenset({GridQubit(0, 1), GridQubit(1, 9), GridQubit(0, 2), ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;I would like to get a simpler version of the above, namely a simple array of tuples for the positions of all qubits&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[ (0,1), (0,2), (0,3), ..., (1,1), (1,2), (1,3), ... ]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;What is the easiest way to obtain this for a given known device in cirq?&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-07-23T12:16:52.547" Title="List of qubit locations with cirq" Tags="&lt;quantum-programming&gt;&lt;cirq&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="3847" PostTypeId="2" ParentId="3844" CreationDate="2018-07-23T09:56:25.213" Score="2" Body="&lt;p&gt;What you're discovering here is the phenomenon of &lt;em&gt;entanglement&lt;/em&gt;: (Pure) States that cannot be constructed using the tensor product of states of smaller systems. Entanglement typically contains some sort of collective property that cannot be accessed by just acting on one qubit (here, measurement outcomes are always anti-correlated)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Mathematically, a pure single-qubit system can be described by any normalised vector in $\mathbb{C}^2$, i.e. $\left(\begin{array}{c} \alpha \\ \beta \end{array}\right)$ provided $|\alpha|^2+|\beta|^2=1$. Talking about &quot;0 and 1&quot; is already problematic. Clearly you're thinking about &quot;an equal superposition of 0 and 1&quot;. Now, for two qubits, we can have any normalised state in $\mathbb{C}^4$, which clearly has many more possibilities than the tensor products of two single-qubit states (just count the number of parameters). So, sure, you can ask for &quot;an equally weighted superposition of 01 and 10&quot;, and you'll get exactly what you had in (b): $(|01\rangle+|10\rangle)/\sqrt{2}$. If you try and create a normalised state with equal amplitudes for those two components using a state $|\psi\rangle\otimes|\phi\rangle$, you will necessarily have $|00\rangle$ and $|11\rangle$ components a well, so the state you've specified will be a superposition of all 4 possible basis states, not just the 2 that you want.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's also take it from the other perspective: let's say I've made $|+\rangle\otimes|+\rangle$. Now let's say that I measure in the computational basis and get the 0 answer. What's my state now? $|0\rangle\otimes|+\rangle$. If I measure the second qubit, I have a 50% change of getting the 0 answer. With a string 00 as my outcome, that certainly does not fulfil your requirement of being a bit 01 or 10.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Beyond that, I'm not quite sure what your question is asking. &quot;Why&quot; is probably either something incredibly deep (that probably nobody understands) or it's &quot;because the maths says so&quot;. You should probably bear in mind that quantum mechanics is a theory. It's a theory that starts from some postulates, which automatically imply a whole bunch of mathematics. Why we pick those postulates is either an issue of philosophy &quot;why is the world the way it is?&quot; or a very practical &quot;we did some experiments, and this seems to fit&quot;.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-07-23T09:56:25.213" CommentCount="0" />
  <row Id="3848" PostTypeId="2" ParentId="3841" CreationDate="2018-07-23T11:41:46.320" Score="2" Body="&lt;p&gt;There is no GitHub like service dedicated to quantum programming. It is all on standard GitHub.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Most useful examples are on the repositories for the quantum SDKs (IBM's &lt;a href=&quot;https://github.com/Qiskit&quot; rel=&quot;nofollow noreferrer&quot;&gt;QISKit&lt;/a&gt;, &lt;a href=&quot;https://github.com/rigetticomputing&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rigetti's Forest&lt;/a&gt;, Microsoft's &lt;a href=&quot;https://github.com/Microsoft/Quantum&quot; rel=&quot;nofollow noreferrer&quot;&gt;Q#&lt;/a&gt;, Google's &lt;a href=&quot;https://github.com/quantumlib/Cirq&quot; rel=&quot;nofollow noreferrer&quot;&gt;Circ&lt;/a&gt;, and &lt;a href=&quot;https://github.com/projectq-framework&quot; rel=&quot;nofollow noreferrer&quot;&gt;ProjectQ&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For QISKit, the tutorial has quite a large number of examples. Beyond the simple 'Hello World' example, most resources are found in the &lt;a href=&quot;https://github.com/Qiskit/qiskit-tutorial/tree/master/reference&quot; rel=&quot;nofollow noreferrer&quot;&gt;reference&lt;/a&gt; folder.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You'll also find things scattered around on the pages of single GitHub users. To find these, you could try looking at who has forked the SDKs or participated in quantum hackathons.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-07-23T11:41:46.320" CommentCount="0" />
  <row Id="3849" PostTypeId="2" ParentId="3846" CreationDate="2018-07-23T12:08:08.727" Score="7" Body="&lt;p&gt;&lt;code&gt;GridQubit&lt;/code&gt; has comparison methods defined, so &lt;code&gt;sorted&lt;/code&gt; will give you a list of the qubits in row-major order:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; sorted(cirq.google.Foxtail.qubits)&#xA;[GridQubit(0, 0), GridQubit(0, 1), [...] GridQubit(1, 9), GridQubit(1, 10)]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Once you have that, you're one list comprehension away:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; [(q.row, q.col) for q in sorted(cirq.google.Foxtail.qubits)]&#xA;[(0, 0), (0, 1), [...] (1, 9), (1, 10)]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Because tuples also have a default ordering, it doesn't matter whether you sort before or after the conversion:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; sorted((q.row, q.col) for q in cirq.google.Foxtail.qubits)&#xA;[(0, 0), (0, 1), [...] (1, 9), (1, 10)]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-07-23T12:16:52.547" LastActivityDate="2018-07-23T12:16:52.547" CommentCount="0" />
  <row Id="3850" PostTypeId="2" ParentId="3832" CreationDate="2018-07-23T12:51:34.690" Score="4" Body="&lt;p&gt;Two quick comments before explaining this:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;The notes don't actually contain a proof of the claim made about the simulation; the intention was only to give a basic idea of how the simulation works. It is therefore not at all surprising that the mathematical justification is not clear, because the notes didn't even try to explain it. (It was the last lecture of the course and there just wasn't time to go over it in detail.)&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;The notation is a little bit unusual here: we're interpreting $Q_x$ as the one-qubit mixed state output by the circuit corresponding to $x$, so $\langle 1 | Q_x | 1 \rangle$ is the probability that $Q_x$ outputs 1 and $\langle 0 | Q_x | 0 \rangle$ is the probability that $Q_x$ outputs 0. The point is that we want the probability that our algorithm outputs 1 minus the probability it outputs 0 to be proportional to the probability the circuit outputs 1 minus the probability it outputs zero.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Moving on to the actual question, let us suppose that $x$ is fixed so that we can just talk about a single quantum circuit $Q$ that acts on $n$ qubits and has $t$ gates of the type described in the question: Hadamard gates, Toffoli gates, and these two-qubit gates that mimic phase shift gates. (You can ignore these if you want, so long as you accept that Toffoli and Hadamard gates are universal for quantum computation. The point is that we do not want to deal with non-real numbers.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, consider a sequence of binary strings $(y_0,\ldots,y_t)$, where each of these strings has length $n$ and there are $t+1$ strings in total. We can think of such a sequence as a possible &lt;em&gt;computation path&lt;/em&gt; through the circuit, where $y_0$ represents a classical state of $n$ qubits at time 0, $y_1$ represents a classical state of $n$ qubits at time 1, and so on. Let us call such a path &lt;em&gt;valid&lt;/em&gt; if $y_0 = 0^n$ and, for every choice of $k\in\{1,\ldots,t\}$, the $k$-th gate of $Q$ takes $|y_{k-1}\rangle$ to $|y_k\rangle$ with a nonzero amplitude. (Given our limited choice of gates, this nonzero amplitude will always be $\pm 1$ or $\pm 1/\sqrt{2}$.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Associated with any such path $P = (y_0,\ldots,y_t)$ is an amplitude $\alpha(P)$. Given the gates we are considering, the amplitude $\alpha(P)$ for each valid path $P$ will always take the form&#xA;$$&#xA;\alpha(P) = \frac{s(P)}{2^{m/2}}&#xA;$$&#xA;where $s(P)\in\{-1,+1\}$ and $m$ is the total number of Hadamard gates in the circuit. The probability that the circuit outputs a string $z\in\{0,1\}^n$ is equal to&#xA;$$&#xA;\left(\sum_P \alpha(P)\right)^2&#xA;= \frac{1}{2^m} \sum_P \sum_Q s(P) s(Q),&#xA;$$&#xA;where in these sums $P$ and $Q$ range only over the valid paths that end at $z$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now consider the probabilistic algorithm. We can again consider paths of the same form as before: $P = (y_0,\ldots,y_t)$. This time, think of these strings as the sequences of states of the register $Z$. The probability associated with each valid path $P$ will be $2^m$, and the bit $B$ will always track the sign of the corresponding amplitude, so that after running through all of the gates you will have $B = 0$ if $s(P) = +1$ and $B = 1$ if $s(P) = -1$. The same reasoning is applied, independently, to $Z'$ and $B'$ for the second run through the process.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, for a particular choice of a final string $z\in\{0,1\}^n$, consider the situation in which both paths $P$ and $P'$ end in $z$, and look at the binary value $B\oplus B'$. This value is 0 if $B$ and $B'$ are equal, which is the same as saying $s(P)s(Q) = +1$, and 1 if $B$ and $B'$ are different, which is the same as saying $s(P)s(Q) = -1$. Therefore, if the final string contained in $Z$ and $Z'$ is $z$, then the probability that the algorithm outputs 0 minus the probability that it outputs 1 is&#xA;$$&#xA;\frac{1}{2^{2m}} \sum_P \sum_Q s(P) s(Q),&#xA;$$&#xA;where again we're restricting the sums to valid paths $P$ and $Q$ that end at $z$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If the final strings of $Z$ and $Z'$ are different, the algorithm just outputs a random bit, so the probability of outputting 0 minus the probability it outputs 1 is zero, so there's effectively no contribution to the bias of the output in this case.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Finally, consider the probabilities as we range over all possible final strings $z$. For those strings beginning with 0, which represent the quantum circuit outputting 0, the expression above is the probability that the algorithm outputs 0 minus the probability it outputs 1. For choices of $z$ beginning with 1, which corresponds to the quantum circuit outputting 1, the algorithm flips the output ($1\oplus B \oplus B'$ would have been a better way to write it than $\overline{B}\oplus B'$). Summing everything up, the probability that the algorithm outputs 1 minus the probability it outputs 0 is exactly $2^{-m}$ times the probability that the quantum circuit outputs 1 minus the probability if outputs zero.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This argument is based on the original proof of $\text{BQP}\subseteq\text{PP}$ found in this paper:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Adleman, DeMarrais, and Huang. Quantum Computability. SIAM Journal on Computing 26(5):&#xA;  1524-1540, 1997.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="1764" LastActivityDate="2018-07-23T12:51:34.690" CommentCount="0" />
  <row Id="3851" PostTypeId="2" ParentId="3828" CreationDate="2018-07-23T15:11:32.863" Score="1" Body="&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1804.01127.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;This paper&lt;/a&gt; by one of my group mates includes faulty prep on ancilla qubits and other errors in an analysis of Bacon Shor. I'm not sure what you mean by faulty error extraction (measurement errors?) but it has an explanation of the error model.&lt;/p&gt;&#xA;" OwnerUserId="3056" LastActivityDate="2018-07-23T15:11:32.863" CommentCount="2" />
  <row Id="3852" PostTypeId="1" CreationDate="2018-07-23T16:16:38.993" Score="3" ViewCount="134" Body="&lt;p&gt;Are there schematics and/or diagrams out there to build a very basic quantum system? &lt;/p&gt;&#xA;" OwnerUserId="4164" LastEditorUserId="4164" LastEditDate="2018-07-23T16:54:50.123" LastActivityDate="2018-07-26T20:49:54.707" Title="Is it possible to purchase quantum computing hardware?" Tags="&lt;quantum-computer&gt;" AnswerCount="3" CommentCount="4" FavoriteCount="1" ClosedDate="2018-07-27T18:41:54.830" />
  <row Id="3853" PostTypeId="2" ParentId="1474" CreationDate="2018-07-23T16:54:14.100" Score="1" Body="&lt;p&gt;Unfortunately, the list on Quantiki is pretty old and not well maintained. Even listing all quantum programming languages in a single reply to this question isn't sustainable since the quantum landscape is constantly evolving. For example, Google has just released &lt;a href=&quot;https://github.com/quantumlib/Cirq&quot; rel=&quot;nofollow noreferrer&quot;&gt;Cirq&lt;/a&gt;, a new quantum programming framework for Noisy Intermediate Scale Quantum (NISQ) computers which isn't featured in any of the above replies since it was announced only a couple of days ago.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To address this problem and as a response to &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1918/does-a-complete-list-of-open-quantum-software-projects-exist/1923#1923&quot;&gt;another question&lt;/a&gt; on QC StackExchange I started a &lt;a href=&quot;https://github.com/markf94/os_quantum_software&quot; rel=&quot;nofollow noreferrer&quot;&gt;curated list of open-source software projects on GitHub&lt;/a&gt; which also includes a comprehensive overview of actively developed quantum programming languages and frameworks. The list is actively maintained by the community and we constantly add new projects.&lt;/p&gt;&#xA;" OwnerUserId="1234" LastActivityDate="2018-07-23T16:54:14.100" CommentCount="2" />
  <row Id="3854" PostTypeId="2" ParentId="3821" CreationDate="2018-07-23T17:02:06.530" Score="1" Body="&lt;p&gt;Additional to the projects you mentioned in your question, the following projects come to my mind:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Toronto-based quantum computing startup Xanadu has recently released a great &lt;a href=&quot;https://strawberryfields.ai/&quot; rel=&quot;nofollow noreferrer&quot;&gt;visual &amp;amp; interactive quantum simulator&lt;/a&gt; on the web.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And there is &lt;a href=&quot;https://github.com/jacobmarks/QTop&quot; rel=&quot;nofollow noreferrer&quot;&gt;QTop&lt;/a&gt; which is a great tool for the simulation and visualization of topological quantum computers.&lt;/p&gt;&#xA;" OwnerUserId="1234" LastActivityDate="2018-07-23T17:02:06.530" CommentCount="0" />
  <row Id="3855" PostTypeId="2" ParentId="3773" CreationDate="2018-07-23T17:05:19.117" Score="3" Body="&lt;p&gt;There is &lt;a href=&quot;https://github.com/jacobmarks/QTop&quot; rel=&quot;nofollow noreferrer&quot;&gt;QTop&lt;/a&gt; which is an open-source project that can simulate but also visualize topological quantum codes.&lt;/p&gt;&#xA;" OwnerUserId="1234" LastActivityDate="2018-07-23T17:05:19.117" CommentCount="0" />
  <row Id="3856" PostTypeId="2" ParentId="3852" CreationDate="2018-07-23T17:07:35.003" Score="0" Body="&lt;p&gt;Considering that they are currently experiments in different labs, with the &lt;a href=&quot;https://thenextweb.com/artificial-intelligence/2018/03/06/google-reclaims-quantum-computer-crown-with-72-qubit-processor/&quot; rel=&quot;nofollow noreferrer&quot;&gt;record&lt;/a&gt; of around 72 qubit, they are yet very far from a product which can be sold.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, you can choose from a &lt;a href=&quot;https://quantiki.org/wiki/list-qc-simulators&quot; rel=&quot;nofollow noreferrer&quot;&gt;long list&lt;/a&gt; of different emulators/simulators.&lt;/p&gt;&#xA;" OwnerUserId="27" LastActivityDate="2018-07-23T17:07:35.003" CommentCount="0" />
  <row Id="3857" PostTypeId="2" ParentId="3852" CreationDate="2018-07-23T17:40:18.530" Score="2" Body="&lt;p&gt;The only commercially available quantum machines are from a  company called &lt;a href=&quot;https://www.dwavesys.com/home&quot; rel=&quot;nofollow noreferrer&quot;&gt;D-Wave&lt;/a&gt; however there is debate on exactly how &quot;quantum&quot; their machines are.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;True quantum computers in the way most of the community looks at them are not available for physical purchase, although IBM's &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx&quot; rel=&quot;nofollow noreferrer&quot;&gt;Q Experience&lt;/a&gt; allows you to use their quantum computing resources through the cloud.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In terms of trying to DIY a quantum computer we are a long way from such a goal being viable.&lt;/p&gt;&#xA;" OwnerUserId="3056" LastActivityDate="2018-07-23T17:40:18.530" CommentCount="2" />
  <row Id="3859" PostTypeId="1" CreationDate="2018-07-24T00:11:30.247" Score="5" ViewCount="26" Body="&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1203.4740&quot; rel=&quot;noreferrer&quot;&gt;Aaronson and Christiano&lt;/a&gt; call public-key or private-key quantum mini-schemes $\mathcal M$ &lt;strong&gt;secret-based&lt;/strong&gt; if a mint works by &lt;em&gt;first&lt;/em&gt; uniformly generating a secret random classical strings $r$, and &lt;em&gt;then&lt;/em&gt; generating a banknote $\$:=(s_r,\rho_r)$, where $s_r$ is a (classical) serial number corresponding to the quantum state $\rho_r$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;They state: &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Intuitively, in a secret-based scheme, the bank can generate many identical banknotes $s$ by simply reusing $r$, while in a non-secret-based scheme, &lt;strong&gt;not even the bank&lt;/strong&gt; might be able to generate two identical banknotes. （emphasis in original).&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;In characterizing a putative distributed quantum currency based on Aaronson and Christiano's secret-based scheme, &lt;a href=&quot;https://arxiv.org/abs/1604.01383&quot; rel=&quot;noreferrer&quot;&gt;Jogenfors&lt;/a&gt; describes a &quot;reuse attack.&quot;  For example he colorfully envisions someone, say Alice, who has minted and distributed a coin $\$_r$, and learns that the coin is in possession of a political rival Bob; she uses her secret knowledge of $r$ to mint and distribute a large number of identical coins $\$_r$, thus devaluing the coins in Bob's possession.  Jogenfors describes a novel approach to prevent this attack, for example as discussed &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1323/quantum-bitcoin-subdivision?rq=1&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;However, would the above attack even work with a non-secret-based scheme?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;If not even Alice can produce copies of her own coins that she's minted, then she has no way devaluing any others that have been distributed.&lt;/p&gt;&#xA;" OwnerUserId="2927" LastActivityDate="2018-07-24T00:11:30.247" Title="Are non-secret-based quantum money mini-schemes susceptable to Jogenfors' &quot;reuse attack?&quot;" Tags="&lt;quantum-algorithms&gt;&lt;cryptography&gt;&lt;cryptocurrency&gt;" AnswerCount="0" CommentCount="0" FavoriteCount="1" />
  <row Id="3860" PostTypeId="1" AcceptedAnswerId="3862" CreationDate="2018-07-24T14:48:21.823" Score="4" ViewCount="129" Body="&lt;p&gt;I want to simulate an arbitrary isolated quantum circuit acting on $n$ qubits (i.e. a pure state of $n$ qubits).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As I know RAM is the bottleneck for quantum simulators, you can consider a &quot;normal&quot; computer to have between $4$ and $8$ Gio of RAM, all the other components are considered sufficiently powerful to not be the bottleneck.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;With this definition of a &quot;normal&quot; computer, &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;What is the maximum value of $n$ (the number of qubits) for which an arbitrary quantum circuit is simulable in a reasonable time ($&amp;lt;1\text{h}$) with a normal computer and freely accessible simulators?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="1386" LastEditorUserId="4164" LastEditDate="2018-07-24T16:10:28.817" LastActivityDate="2018-07-26T18:56:39.947" Title="How many qubits are simulable with a normal computer and freely accessible simulators?" Tags="&lt;qubit&gt;&lt;simulation&gt;" AnswerCount="2" CommentCount="6" FavoriteCount="1" />
  <row Id="3861" PostTypeId="1" CreationDate="2018-07-24T15:30:19.280" Score="5" ViewCount="74" Body="&lt;p&gt;Given an arbitrary $n$-qudit state vector $|\psi\rangle =\sum_i c_i| i \rangle \in \mathbb{C}_d^n$ for some orthonormal basis $\{|i\rangle\}$, what is the most efficient way one can:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Verify whether the state is a stabilizer state (i.e. can be defined by $n \leq m \leq 2n$ stabilizer generators, with equality for $d=2$), and if so,&lt;/li&gt;&#xA;&lt;li&gt;Find the state's stabilizer generators (in the form of some tensor product of local Pauli matrices).&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;" OwnerUserId="391" LastEditorUserId="391" LastEditDate="2018-07-25T22:32:31.570" LastActivityDate="2018-07-25T22:32:31.570" Title="Stabilizer state verification and specification from state vector" Tags="&lt;quantum-state&gt;&lt;stabilizer-state&gt;" AnswerCount="1" CommentCount="17" />
  <row Id="3862" PostTypeId="2" ParentId="3860" CreationDate="2018-07-24T16:10:11.297" Score="4" Body="&lt;p&gt;This answer doesn't directly answer the question (I have little experience of &lt;em&gt;real&lt;/em&gt; simulators with practical overheads etc.), but here's a theoretical upper bound.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's assume that you need to store the whole state vector of $k$ qubits in memory. There are $2^n$ elements that are complex numbers. A complex number requires 2 real numbers, and a real number occupies &lt;a href=&quot;https://code.tutsplus.com/tutorials/understand-how-much-memory-your-python-objects-use--cms-25609&quot; rel=&quot;nofollow noreferrer&quot;&gt;24 bytes in python&lt;/a&gt;. Let's say we want to cram this into $4\times 10^9$ bytes of RAM (probably leaving a few over for your operating system etc.) Hence,&#xA;$$&#xA;48\times 2^n\leq 4\times 10^9&#xA;$$&#xA;Rearrange for $n$ and you have $n\leq26$ qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that applying gates in a quantum circuit is relatively inexpensive memory-wise. See the &quot;Efficiency Improvements&quot; section in &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1970/1837&quot;&gt;this answer&lt;/a&gt;. From that strategy, one should be able to estimate the time it takes to apply a single one- or two-qubit gate to an $n$-qubit system, and hence how many gates you might expect to fit within some times limit (an hour is very modest, but would certainly serve for illustrative purposes).&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-07-25T09:20:33.797" LastActivityDate="2018-07-25T09:20:33.797" CommentCount="8" />
  <row Id="3863" PostTypeId="1" CreationDate="2018-07-24T17:42:17.647" Score="6" ViewCount="98" Body="&lt;p&gt;As part of a variational algorithm, I would like to construct a quantum circuit (ideally with &lt;a href=&quot;https://github.com/rigetticomputing/pyquil/&quot; rel=&quot;nofollow noreferrer&quot;&gt;pyQuil&lt;/a&gt;) that simulates a Hamiltonian of the form:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$H = 0.3 \cdot Z_3Z_4 + 0.12\cdot Z_1Z_3 + [...] + &#xA;- 11.03 \cdot Z_3 - 10.92 \cdot Z_4 + \mathbf{0.12i \cdot Z_1 Y_5 X_4}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When it comes to the last term, the problem is that pyQuil throws the following error:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;TypeError: PauliTerm coefficient must be real&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I started diving into the literature and it seems like a non-trivial problem. I came across &lt;a href=&quot;https://arxiv.org/pdf/1701.05182.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;this paper on universal quantum Hamiltonians&lt;/a&gt; where complex-to-real encodings as well as local encodings are discussed. However, it is still not clear to me how one would practically implement something like this. Can anyone give me some practical advice how to solve this problem?&lt;/p&gt;&#xA;" OwnerUserId="1234" LastEditorUserId="26" LastEditDate="2018-08-02T15:42:03.270" LastActivityDate="2018-08-03T06:47:58.537" Title="Hamiltonian simulation with complex coefficients" Tags="&lt;hamiltonian-simulation&gt;&lt;quantum-simulation&gt;" AnswerCount="2" CommentCount="8" />
  <row Id="3865" PostTypeId="1" CreationDate="2018-07-24T19:21:03.107" Score="5" ViewCount="56" Body="&lt;p&gt;According to &lt;a href=&quot;https://arxiv.org/abs/1703.05342&quot; rel=&quot;nofollow noreferrer&quot;&gt;J. Gough&lt;/a&gt;, one of the bottlenecks in the current development of large-scale quantum computing may be the lack of our ability to simulate large scale quantum system, which is a NP-hard problem and also requires exponential memory with classical hardware if I understand correctly.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I'm currently developing a certain powerful discrete approximate algorithm. In principle, it can, for example, find an approximate solution for a given quantum Ising model efficiently or optimize the configuration of quantum gates to minimize the error a la &lt;a href=&quot;https://arxiv.org/abs/1512.00674&quot; rel=&quot;nofollow noreferrer&quot;&gt;U. Las Heras et. al.&lt;/a&gt; by replacing its GA with mine.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1) Can we reduce digital/analog quantum simulation to a NP-hard discrete optimization problem (like solving Ising model), so that it can be approximately solved by a classical algorithm using classical device?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2) What are some other crucial bottlenecks? Do they need discrete optimization? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Edit: I guess one of other bottlenecks is quantum error correction, which was already mentioned above. &lt;/p&gt;&#xA;" OwnerUserId="4193" LastEditorUserId="4193" LastEditDate="2018-07-25T16:09:20.883" LastActivityDate="2018-07-25T16:09:20.883" Title="Application of classical approximate optimization algorithm to bottlenecks of quantum computing" Tags="&lt;simulation&gt;&lt;optimization&gt;" AnswerCount="0" CommentCount="2" FavoriteCount="1" />
  <row Id="3866" PostTypeId="5" CreationDate="2018-07-24T22:35:28.237" Score="0" Body="" OwnerUserId="-1" LastEditorUserId="-1" LastEditDate="2018-07-24T22:35:28.237" LastActivityDate="2018-07-24T22:35:28.237" CommentCount="0" />
  <row Id="3867" PostTypeId="4" CreationDate="2018-07-24T22:35:28.237" Score="0" Body="Stabilizer states are quantum states that can be efficiently represented by some set of Pauli operators of which the state is a +1 eigenstate. Stabilizer states are used commonly in many areas of quantum computation, such as error correction, teleportation and state verification." OwnerUserId="391" LastEditorUserId="391" LastEditDate="2018-07-26T15:59:14.607" LastActivityDate="2018-07-26T15:59:14.607" CommentCount="0" />
  <row Id="3868" PostTypeId="2" ParentId="3861" CreationDate="2018-07-25T10:49:17.817" Score="1" Body="&lt;p&gt;Here's a necessary condition that might help recognise potential stabilizer states. I'll state it for qubits as that's what I'm used to thinking about, but I suspect it  can be generalised:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;all the non-zero amplitudes of a stabilizer state must have the same magnitude.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;To see this, let's assume that the state $|\psi\rangle$ is an $n$-qubit stabilizer state with linearly independent stabilizers $\Lambda=\{K_i\}_{i=1}^n$. In other words, $K_i|\psi\rangle=|\psi\rangle$, $K_i=K_i^\dagger$ and $[K_i,K_j]=0$. Let $x,y\in\{0,1\}^n$ be such that $\langle x|\psi\rangle\neq 0$ and $\langle y|\psi\rangle\neq 0$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now consider&#xA;$$&#xA;|\psi\rangle\langle \psi|x\rangle=\left(\frac{1}{2^n}\prod_{K\in\Lambda}(\mathbb{I}+K)\right)|x\rangle&#xA;$$&#xA;If we multiply out the terms, there are all the different possible products of subsets of stabilizers, each turning $|x\rangle$ into a (possibly different) basis state. Hence, there is at least one subset $S\subseteq\Lambda$ such that $\left(\prod_{K\in S}K\right)|x\rangle=|y\rangle$ up to a global phase.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Finally, what is the amplitude we're after?&#xA;$$&#xA;\langle x|\psi\rangle=\langle x|\left(\prod_{K\in S}K\right)|\psi\rangle=\langle y|\psi\rangle&#xA;$$&#xA;up to a global phase.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Presumably this could put you on a route towards a better-than-brute-force algorithm for determining the stabilizers (I haven't done this myself, hence some vagueness in the statement). If you have a binary string of each of the non-zero basis elements, and the corresponding phase, you know a lot about the group generated by $\Lambda$. A bit of linear algebra should allow you to extract the generators. I would guess that there's even an argument a bit like the one in &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2141/1837&quot;&gt;Simon's algorithm&lt;/a&gt; that says you don't need more than $O(n)$ of those basis elements in order to extract the group generators. I'm not sure if this will give you all the information, or just the information about bit-flips. You may also need a Hadamard-rotated version of the state in order to determine the phase flips in the stabilizers.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-07-25T10:49:17.817" CommentCount="3" />
  <row Id="3869" PostTypeId="1" CreationDate="2018-07-26T05:44:24.210" Score="2" ViewCount="36" Body="&lt;p&gt;I am very interested in this field right now, due to the quantum advantage &#xA;and would like some helpful nudges in the right direction i.e. where should I start from.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;P.S: I have some background in software engineering and subpar knowledge in math and physics.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thanks in advance&lt;/p&gt;&#xA;" OwnerUserId="4207" LastEditorUserId="26" LastEditDate="2018-07-26T15:34:35.507" LastActivityDate="2018-07-26T15:34:35.507" Title="Any tips on where to start learning quantum computing?" Tags="&lt;resource-request&gt;" AnswerCount="0" CommentCount="2" ClosedDate="2018-07-26T07:34:48.663" />
  <row Id="3870" PostTypeId="2" ParentId="3863" CreationDate="2018-07-26T09:31:54.917" Score="1" Body="&lt;p&gt;This simple MATLAB/Octave code shows that $i0.12Z_1Y_2X_3$ is not Hermitian:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;z=[1 0 ; 0 -1];&#xA;x=[0 1;  1  0];&#xA;y=[0 -1i; 1i 0];&#xA;&#xA;z1 = kron(z,eye(4));&#xA;y2 = kron(kron(eye(2),y),eye(2));&#xA;x3 = kron(eye(4),x);&#xA;&#xA;H=0.12*1i*z1*y2*x3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;The output is H:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    0     0    0 0.12    0    0     0     0&#xA;    0     0 0.12    0    0    0     0     0&#xA;    0 -0.12    0    0    0    0     0     0&#xA;-0.12     0    0    0    0    0     0     0&#xA;    0     0    0    0    0    0     0 -0.12&#xA;    0     0    0    0    0    0 -0.12     0&#xA;    0     0    0    0    0 0.12     0     0&#xA;    0     0    0    0 0.12    0     0     0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Since it's a real matrix, Hermitian means symmetric, but this is not symmetric and therefore not Hermitian. The top-right triangle isn't equal to the bottom-right triangle. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;However the top-right triangle is the &lt;strong&gt;&lt;em&gt;negative&lt;/em&gt;&lt;/strong&gt; of the bottom-right triangle, so it is anti-Hermitian.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So doing AHussain's suggestion of adding the conjugate transpose, results in 0. Just run this command:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;H + H'&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;and you will get an 8x8 matrix of 0's.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So when you make your Hamiltonian Hermitian by adding the conjugate transpose, you get 0 for this term, and &lt;strong&gt;&lt;em&gt;therefore you do not need to have any imaginary coefficients&lt;/em&gt;&lt;/strong&gt;. &lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-07-26T09:31:54.917" CommentCount="5" />
  <row Id="3871" PostTypeId="1" CreationDate="2018-07-26T16:12:40.003" Score="6" ViewCount="75" Body="&lt;p&gt;Among available qubit technologies for universal quantum computing these 3 come up as promising. NV centers and Majorana qubits also underway but relatively new. &#xA;I find superconducting qubits and Trapped Ion qubits very hard to scale. Also T1(decoherence) and T2 (dephasing) for superconducting qubits is very less (us).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Being a non-physicist, I am not able to exactly locate good sources to convince myself why is one technology preferred over the other? I would really appreciate if you can direct me to relavant literature available on this topic.&lt;/p&gt;&#xA;" OwnerUserId="2391" LastActivityDate="2018-07-29T05:04:20.453" Title="What are the pros/cons of Trapped Ion Qubits, Superconducting Qubits and Si Spin Qubits?" Tags="&lt;quantum-computer&gt;&lt;qubit&gt;&lt;quantum-decoherence&gt;&lt;superconducting-quantum-computing&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="3872" PostTypeId="1" AcceptedAnswerId="3876" CreationDate="2018-07-26T16:25:26.450" Score="6" ViewCount="87" Body="&lt;p&gt;I understand that right now Qubits are physical entities in a Quantum Computer and I am playing around on the IBM Quantum Computer as well as the Q# language and dipping my toes into the Quantum world for the first time.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I have read a lot of the Alice and Bob style scenarios where it often mentions transporting a Qubit from Alice to Bob. I am inferring that as physically transporting it but I haven't found a discussion on what this looks like from a computing sense. As in how it could be theoretically achieved to &quot;package&quot; a Qubit, or even a representation of a Qubit (state or values) for transportation via a Classical or Quantum channel? I am assuming the only way this is possible is via entanglement and teleportation. Is it possible for non-entangled, ordinary Qubits, to be represented in some format and transferred logically between two points, whereby the receiving point can decode and interpret the information contained within. That receiving point could be a computer service in a Classical computer architecture or another Quantum machine.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I ask this in the sense of Classical Computing, where we can encode bits onto a chip but logically represent a bit (or series of bits) in numerous formats and transfer them for manipulation. As a software engineer that's where my thought process is coming from. This might not be a practical thing to want to do in Quantum but in theory, is it something that could be achieved? Any guidance would be welcome.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;EDIT: &#xA;Thank you for the really comprehensive answers, it has filled in a lot of gaps and I did not realise the strong link between photons &amp;amp; fiber which brings a potential bridge in theory. I'm working my way through the basic hello world applications and was trying to mentally bridge my software knowledge of Classical into this world at a basic transfer and representation level.  I'm trying to build some small apps that bridge both worlds and my mental block right now is representing the characteristics of a Qubit in traditional programming notations. Have you any thoughts on what would need to be modelled to create a logical representation of a Qubit? What I am getting at is something similar to a specification that would allow a programmer represent a type (like a String e.g. &lt;a href=&quot;https://en.wikipedia.org/wiki/String_(computer_science)&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://en.wikipedia.org/wiki/String_(computer_science)&lt;/a&gt;). In the Quantum programming languages the Qubit is it's own type, drilling down a level can the characteristics be captured in a very basic manner so that potentially they could be represented in something like a vector array to capture key characteristics e.g. &#xA;state (notwithstanding the difficulty of superposition!), spin etc.&lt;/p&gt;&#xA;" OwnerUserId="4210" LastEditorUserId="4210" LastEditDate="2018-07-27T07:10:40.987" LastActivityDate="2018-07-27T07:10:40.987" Title="The process for transferring Qubits between locations" Tags="&lt;qubit&gt;&lt;classical-computing&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="3873" PostTypeId="1" CreationDate="2018-07-26T17:18:05.183" Score="5" ViewCount="68" Body="&lt;p&gt;If I understand correctly, there must exist unitary operations that can be approximated to a distance $\epsilon$ only by an exponential number of quantum gates and no less.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, by the Solovay-Kitaev theorem, any arbitrary unitary operation in $n$ qubits, with $n$ fixed, can be approximated to a distance of $\epsilon$ using poly(log(1/$\epsilon$)) universal gates.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Don't these two statements appear contradictory? What am I missing?&lt;/p&gt;&#xA;" OwnerUserId="1351" LastEditorUserId="55" LastEditDate="2018-07-27T11:20:33.250" LastActivityDate="2018-07-27T11:20:33.250" Title="Number of gates required to approximate arbitrary unitaries" Tags="&lt;quantum-gate&gt;&lt;solovay-kitaev-algorithm&gt;" AnswerCount="0" CommentCount="5" />
  <row Id="3874" PostTypeId="2" ParentId="3872" CreationDate="2018-07-26T17:48:59.103" Score="2" Body="&lt;p&gt;It’s worth stating from the start that “Alice and Bob” scenarios are very different from quantum computation scenarios. The Alice and Bob scenarios are very much that there are two distantly separated locations between which it is impossible to directly perform quantum gates. Meanwhile in the quantum computing architectures you’re talking about, two-qubit gates are readily available. Even if you can’t directly interact a pair of qubits, a bunch of swap gates are enough to move the qubits next to each other, and back again.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You also want to be careful with your classical software engineer interpretation, because classically it’s very easy to move things about, and make multiple copies. In quantum, you can’t make copies of your data.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, how do you move a qubit? Entanglement and teleportation aren’t really an answer. They might help give you error-correction enhanced protocols, but the basic question is still how you share the entangled state to achieve the teleportation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Probably the best way is to transfer the quantum information from one physical carrier, such as the qubits in a quantum computer, to a different one. We’d usually think about photons in this context - they’re really good at travelling long distances without interacting too much. In the same way that classical data can transfer via an optical fibre, it’s not too wild to imagine sending photons in superpositions through an optical fibre. You ‘just’ have to convert the photon at either end into the different storage/manipulation type of qubit. The technology certainly exists to do this, but I don’t know how reliably it happens.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-07-26T17:48:59.103" CommentCount="1" />
  <row Id="3875" PostTypeId="2" ParentId="3860" CreationDate="2018-07-26T18:56:39.947" Score="-1" Body="&lt;p&gt;Along with depending on time constraints, as Craig mentioned, you also need to specify how accurate/what gates you want the simulation to have. CHP (CNOT, Phase, Hadamard) simulations can do incredibly large circuits with large numbers of qubits incredible quickly, however they only allow a certain restricted gate set, so some gates, such as T gates, must be approximated.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Other simulations exist (such as quantumsim and others) which store full density matrices, and as a result are much more significantly limited in the number of qubits they work with seeing as they must store a $2^n \times 2^n$ matrix.&lt;/p&gt;&#xA;" OwnerUserId="3056" LastActivityDate="2018-07-26T18:56:39.947" CommentCount="0" />
  <row Id="3876" PostTypeId="2" ParentId="3872" CreationDate="2018-07-26T20:35:09.357" Score="10" Body="&lt;p&gt;You are totally right in your assumption about transporting qubits from Alice to Bob implies something physical. Usually problems/situations that have this setup of a transmission between two parties are called &lt;em&gt;quantum communications&lt;/em&gt;. These problems/situations sometimes disambiguate by calling their qubits &quot;flying qubits&quot; which are almost always photons. Single photons are also quantum systems that can be prepared in useful qubit states, they can be operated on with gates (but not all kinds of gates and not as easily as some other physical implementations of qubits), and can be measured just like any other qubit system. Alice and Bob would literally share these photos by either an optical fiber they are connected by or through free space (which could be literally to a satellite in space).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Photons are great for this application because we already use them for a large portion of our classical communication networks. &quot;Fiber&quot; internet or photonic networks send classical information in optical fiber with strong pulsed lasers. So if you wanted to have both a classical channel and a quantum communication channel you could do both with the same fiber (hard for some technical reasons but totally possible).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are also may other physical systems that you cab make qubits out of for quantum computing (super conductors, ion traps, etc.). You are correct in that to connect different groups of these qubits one would not pick the chip up and move it, but instead they often create a(n) photon(s) that are entangled with the original system or have some information they want to share with the second system and then send the photon over.  &lt;/p&gt;&#xA;" OwnerUserId="4211" LastActivityDate="2018-07-26T20:35:09.357" CommentCount="2" />
  <row Id="3877" PostTypeId="2" ParentId="3852" CreationDate="2018-07-26T20:49:54.707" Score="5" Body="&lt;p&gt;I think this kind of depends on what you are looking for. You asked about building a basic quantum system which you can totally do*. Just grab a good laser, single photon detectors, beam splitters and wave plates, and some attenuating filters. If you can get the laser down to a trickle of single photons you can do some fun quantum key distribution demos, and operations on single qubits (possibly on pairs if you have the right components). Now, that's obviously no computer, but since computers are built out of qubits its a start.&#xA;Also as @peterh mentioned, there is lots of simulators that you can use if you want to work with more qubits now, and example being &lt;a href=&quot;https://en.wikipedia.org/wiki/Q_Sharp&quot; rel=&quot;noreferrer&quot;&gt;Q#&lt;/a&gt; that actually can estimate the number of qubits you would need to run your algorithm on a real quantum computer.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;This is still gonna be a couple thousand dollars or more, but not nearly as much as a D-Wave :) Here is a &quot;demo&quot; system from an overpriced lab equipment store: &lt;a href=&quot;https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=9869&quot; rel=&quot;noreferrer&quot;&gt;https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=9869&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="4211" LastActivityDate="2018-07-26T20:49:54.707" CommentCount="1" />
  <row Id="3878" PostTypeId="2" ParentId="3871" CreationDate="2018-07-26T23:24:23.610" Score="5" Body="&lt;p&gt;It think the (very) short answer is that there is not a preferred platform yet. This is why there are very active research communities around each of these technologies. Often if someone says otherwise they are probably working on one of the platforms :)&lt;/p&gt;&#xA;" OwnerUserId="4211" LastActivityDate="2018-07-26T23:24:23.610" CommentCount="0" />
  <row Id="3879" PostTypeId="1" AcceptedAnswerId="3911" CreationDate="2018-07-27T08:51:36.893" Score="10" ViewCount="76" Body="&lt;p&gt;In @DaftWullie's answer to &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/3823/practical-implementation-of-hamiltonian-evolution&quot;&gt;this question&lt;/a&gt; he showed how to represent in terms of quantum gates the matrix used as example in &lt;a href=&quot;https://arxiv.org/pdf/1110.2232v2.pdf&quot; rel=&quot;noreferrer&quot;&gt;this article&lt;/a&gt;. However, I believe it to be unlikely to have such well structured matrices in real life examples, therefore I was trying to look at other methods to simulate an Hamiltonian.&#xA; I have found in several articles a reference to &lt;a href=&quot;https://arxiv.org/pdf/quant-ph/0301023.pdf&quot; rel=&quot;noreferrer&quot;&gt;this one&lt;/a&gt; by Aharonov and Ta-Shma in which, among other things they state that it is possible to have some advantage in simulating &lt;em&gt;sparse&lt;/em&gt; hamiltonians. After reading the article, however, I haven't understood how the simulation of sparse hamiltonians could be performed. The problem is usually presented as one of graph coloring, however also looking at the &lt;a href=&quot;https://www.cs.umd.edu/~amchilds/talks/ibm13.pdf&quot; rel=&quot;noreferrer&quot;&gt;presentation&lt;/a&gt; that @Nelimee suggested to read to study matrix exponentiation, this all falls down the silmulation through product formula.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To make an example, let's take a random matrix like:   &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;A = \left[\begin{matrix}&#xA;2 &amp;amp;  0  &amp;amp; 0 &amp;amp; 0\\&#xA;8  &amp;amp;  5 &amp;amp; 0 &amp;amp; 6\\&#xA;0 &amp;amp; 0 &amp;amp; 7 &amp;amp; 0\\&#xA;0 &amp;amp; 5 &amp;amp; 3 &amp;amp; 4&#xA;\end{matrix}\right];&#xA;$$&#xA; this is not hermitian, but using the suggestion from Harrow,Hassidim and Lloyd we can construct an hermitian matrix starting from it:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;C = \left[ \begin{matrix}&#xA;0 &amp;amp; A\\&#xA;A^{\dagger} &amp;amp; 0&#xA;\end{matrix} \right]&#xA; =  \left[\begin{matrix}&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 2 &amp;amp;  0  &amp;amp; 0 &amp;amp; 0\\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 8  &amp;amp;  5 &amp;amp; 0 &amp;amp; 6\\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 7 &amp;amp; 0\\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 5 &amp;amp; 3 &amp;amp; 4\\&#xA;2 &amp;amp; 8 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0\\&#xA;0 &amp;amp; 5 &amp;amp; 0 &amp;amp; 5 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0\\&#xA;0 &amp;amp; 0 &amp;amp; 7 &amp;amp; 3 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 6 &amp;amp; 0 &amp;amp; 4 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\  &#xA;\end{matrix}\right].&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now that I have an 8x8, 2-sparse hermitian matrix:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Can I simulate its evolution in other ways than the product formula method?&lt;/li&gt;&#xA;&lt;li&gt;Even if I use the product formula, how do I exploit the fact that it is sparse? Is it just because there are less non-zero entries and therefore it should be easier to find the product of basic gates?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="2648" LastActivityDate="2018-07-31T13:45:32.017" Title="Advantage of simulating sparse Hamiltonians" Tags="&lt;quantum-algorithms&gt;&lt;matrix-representation&gt;&lt;hamiltonian-simulation&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="2" />
  <row Id="3880" PostTypeId="1" AcceptedAnswerId="3881" CreationDate="2018-07-27T09:09:01.500" Score="5" ViewCount="564" Body="&lt;p&gt;As far as I have seen, when it comes to solving linear systems of equations it is assumed to have a matrix with a number of rows and columns equal to a power of two, but what if it is not the case? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If for instance I have the equation $Ax=b$ where &lt;em&gt;A&lt;/em&gt; is a 4x4 matrix and &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt; 4x1 vectors, I expect to find the solution in terms of amplitudes of the 4 basis states considered for the problem. What if instead of 4 there is 5? &#xA;My idea would be to choose an Hilbert space of smallest dimension that it includes 5 i.e. 8, and then make it so that 3 basis states will have amplitude 0. Is it correct to reason in this way, or am i making problems for nothing? &lt;/p&gt;&#xA;" OwnerUserId="2648" LastActivityDate="2018-07-27T09:37:37.563" Title="Solving linear systems represented by NxN matrices with N not power of 2" Tags="&lt;qubit-state&gt;&lt;quantum-state&gt;&lt;hhl-algorithm&gt;&lt;matrix-representation&gt;" AnswerCount="1" CommentCount="1" />
  <row Id="3881" PostTypeId="2" ParentId="3880" CreationDate="2018-07-27T09:37:37.563" Score="6" Body="&lt;p&gt;This is indeed a correct way to solve linear systems with dimension not equal to a power of 2. Solve the smallest possible system of dimension 2$^n$ that contains the system you want to solve, and pad the matrices and vectors with zeros to make it the right size. This is because the vector $|b\rangle$ in the HHL algorithm, is a quantum state, which means if we have $n$ qubits, its dimension is naturally 2$^n$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, this procedure is not the &lt;strong&gt;&lt;em&gt;only&lt;/em&gt;&lt;/strong&gt; way to solve systems with dimension not equal to a power of 2. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Remember you do not have to work with qubits but can also work with other qudits such as qutrits (3-level systems). Then your $|b\rangle$ will have dimension 3$^n$, so you can do for example a 9x9 system without resorting to solving a 16x16 problem involving 4 qubits. The question then becomes whether or not your hardware can more easily perform the algorithm for the case where $|b\rangle$ is represented by 4 qubits, or for the case where it is 2 qutrits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For a 5x5 matrix, you can use for $|b\rangle$ a &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2100/do-any-specific-types-of-qudits-other-than-qubits-and-qutrits-have-a-name&quot;&gt;qupit&lt;/a&gt; with $p=5$. Or you can use 3 qubits and work with an 8x8 matrix. Since there's not likely to be a lot of quantum computing hardware around with &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2100/do-any-specific-types-of-qudits-other-than-qubits-and-qutrits-have-a-name&quot;&gt;qupits&lt;/a&gt;, it may be easier to do what you suggest, which is to just use more qubits.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-07-27T09:37:37.563" CommentCount="2" />
  <row Id="3883" PostTypeId="2" ParentId="1880" CreationDate="2018-07-27T16:59:58.823" Score="4" Body="&lt;p&gt;I have worked with NVs in nanodiamonds a little bit, and you are totally right, surface characteristics have a huge influence on how far we can push them. There are definitely multiple groups working on the chemistry/material science that are working to clean up the surfaces as much as possible. I had a colleague, Carlo Bradac who worked with our chemistry dept to passivate/manipulate the surface properties of nanodiamonds for us and they were way better than what we could commercially buy from anywhere. I think he has a &lt;a href=&quot;https://www.lucigem.com.au/our-products/&quot; rel=&quot;nofollow noreferrer&quot;&gt;startup&lt;/a&gt; now where you can order samples of nanodiamonds (and other structures) with certain properties. If I recall correctly, they did things like hot acid baths and centrifuging to do this, but as there is a startup I am not sure it is published. A place to start may be:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://doi.org/10.1016/j.diamond.2018.01.022&quot; rel=&quot;nofollow noreferrer&quot;&gt;Influence of surface composition on the colloidal stability of ultra-small detonation nanodiamonds in biological media&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="4211" LastEditorUserId="26" LastEditDate="2018-07-27T17:24:48.173" LastActivityDate="2018-07-27T17:24:48.173" CommentCount="0" />
  <row Id="3885" PostTypeId="1" AcceptedAnswerId="3886" CreationDate="2018-07-28T05:57:26.723" Score="6" ViewCount="102" Body="&lt;p&gt;Also, why is Microsoft placing such an emphasis on topological qubits when most other companies seem to be focusing on other qubit technologies?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I know topological qubits could handle noise far better than other systems, so they are appealing, but they are also new and seemingly only theoretical so far.&lt;/p&gt;&#xA;" OwnerUserId="1287" LastActivityDate="2018-07-29T00:52:41.400" Title="Are there any other companies besides Microsoft pursuing topological QC?" Tags="&lt;topological-quantum-computing&gt;&lt;quantum-technologies&gt;" AnswerCount="1" CommentCount="1" FavoriteCount="1" />
  <row Id="3886" PostTypeId="2" ParentId="3885" CreationDate="2018-07-28T06:36:04.373" Score="4" Body="&lt;p&gt;Microsoft is the only company that is trying to build a topological quantum computer. You mention that topological qubits handle noise far better than other systems, but they are also theoretical. That's the reason Microsoft is applying a topological approach. It's high-risk, high-reward. If Microsoft manages to realize a topological qubit, scaling up a computer made of topological qubits will be easier than competing approaches because a topological quantum computer would use less resources to perform quantum error correction compared to other implementations.&lt;/p&gt;&#xA;" OwnerUserId="362" LastActivityDate="2018-07-28T06:36:04.373" CommentCount="0" />
  <row Id="3887" PostTypeId="1" AcceptedAnswerId="3889" CreationDate="2018-07-28T09:05:06.463" Score="4" ViewCount="148" Body="&lt;p&gt;I need to use the following matrix gate in a quantum circuit:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\text{Sign Flip}=\left[\begin{matrix}0 &amp;amp; -1 \\ -1 &amp;amp; 0\end{matrix}\right]$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\text{Sign Flip}$ can be decomposed as (in terms of Pauli-$X$,$Y$,$Z$):&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\begin{bmatrix} 0 &amp;amp; -1\\ -1 &amp;amp; 0\end{bmatrix} = \begin{bmatrix} 0 &amp;amp; 1\\ 1 &amp;amp; 0\end{bmatrix} \begin{bmatrix} 0 &amp;amp; -i\\ i &amp;amp; 0\end{bmatrix} \begin{bmatrix} 1 &amp;amp; 0\\ 0 &amp;amp; -1\end{bmatrix} \begin{bmatrix} 0 &amp;amp; -i\\ i &amp;amp; 0\end{bmatrix} \begin{bmatrix} 1 &amp;amp; 0\\ 0 &amp;amp; -1\end{bmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is there any standard shorthand notation for the $\text{Sign Flip}$ gate? I don't really want to replace one simple custom gate by $5$ quantum gates in my circuit.&lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-07-28T14:59:11.647" Title="Shorthand notation for the sign flip gate" Tags="&lt;quantum-gate&gt;" AnswerCount="2" CommentCount="3" />
  <row Id="3888" PostTypeId="2" ParentId="3887" CreationDate="2018-07-28T10:09:41.470" Score="1" Body="&lt;p&gt;With the IBM Q Experience you can implement that transformation with what they call the U3 gate, which takes three input arguments and looks like this:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;U3(\theta,\phi,\lambda) = \begin{bmatrix}&#xA;\cos(\theta/2) &amp;amp; -e^{i\lambda}\sin(\theta/2) \\&#xA;e^{i\phi}\sin(\theta/2) &amp;amp; e^{i\lambda+i\phi}\cos(\theta/2) &#xA;\end{bmatrix}.&#xA;$$&#xA;So in this case you could just write $U3(\pi,\pi,0)$.&lt;/p&gt;&#xA;" OwnerUserId="4223" LastActivityDate="2018-07-28T10:09:41.470" CommentCount="3" />
  <row Id="3889" PostTypeId="2" ParentId="3887" CreationDate="2018-07-28T10:46:53.723" Score="5" Body="&lt;p&gt;A unitary $U$ and $e^{i\phi}U$, which differs from it by a phase, act &lt;em&gt;exact identically&lt;/em&gt; on any quantum state.  Thus, they should really be considered the &quot;same&quot; unitary in terms of their action.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can therefore use $X$ instead of your unitary, which is $-X$. This will have exactly the identical action in any circuit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(Why is this? There are different ways to see this: Either since $|\psi\rangle$ and $e^{i\phi}|\psi\rangle$ describe the same quantum state, or by working with density operators on which $U$ acts as $\rho\mapsto U\rho U^\dagger$, such that phases cancel.  Also, note that this is not true for &lt;em&gt;controlled&lt;/em&gt;-unitaries -- but this is an entirely different question.)&lt;/p&gt;&#xA;" OwnerUserId="491" LastEditorUserId="491" LastEditDate="2018-07-28T14:59:11.647" LastActivityDate="2018-07-28T14:59:11.647" CommentCount="0" />
  <row Id="3890" PostTypeId="1" CreationDate="2018-07-28T12:37:39.413" Score="7" ViewCount="116" Body="&lt;p&gt;I am going through &lt;a href=&quot;https://www.youtube.com/watch?v=F_Riqjdh2oM&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt; video of Quantum Computing for Computer Scientists. I am not able to understand the entanglement state of qubits. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is entanglement just an operation, or is it a state which can be stored. If it's a state which is stored then how can we send two qubits far apart? &#xA;But if it is just an operation then isn't the operation somehow affected the probability from 50% to 100% to superimposed states of qubits. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Also, what if the operation has 50% chance of assigning the probability. So when measuring multiple times we tend to get 50% probability of qubits collapsing to one of the states.&lt;/p&gt;&#xA;" OwnerUserId="4226" LastEditorUserId="2293" LastEditDate="2018-07-29T17:07:52.640" LastActivityDate="2018-08-24T13:13:18.707" Title="Is entanglement an operation or a stored state for qubits?" Tags="&lt;quantum-entanglement&gt;" AnswerCount="3" CommentCount="0" />
  <row Id="3891" PostTypeId="2" ParentId="3890" CreationDate="2018-07-28T16:52:28.500" Score="6" Body="&lt;p&gt;It’s a property of the state that is stored. But it’s not a physical change that relates to a force: it is not that you entangle qubits, and that means that they are physically joined. The two physical qubits remain as independent physical entities that can move around separately, just with a joint state. (At least, not usually. In things like covalent bonds, that’s exactly what’s happening!)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Incidentally, try not to talk too much about “probability” as it can be very misleading in a quantum scenario, especially when you start talking about entanglement. Talk about probability amplitudes where possible, and keep probabilities for being associated with the outcomes of measurements. Otherwise the differences between entanglement and classical correlation will be impossible to distinguish.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-08-24T13:13:18.707" LastActivityDate="2018-08-24T13:13:18.707" CommentCount="4" />
  <row Id="3893" PostTypeId="1" AcceptedAnswerId="3895" CreationDate="2018-07-29T00:53:45.717" Score="5" ViewCount="93" Body="&lt;p&gt;I'm stuck while trying to understand the Hadamard Gate in a more linear algebra understanding. (I understand the algebraic way). This is because I want to program a simulation of a quantum computer. To apply a gate you multiply each &lt;em&gt;ket&lt;/em&gt; by the unitary matrix.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, the Hadamard gate maps the state $\alpha |0\rangle + \beta|1\rangle$ to $\frac{\alpha}{\sqrt{2}}\begin{bmatrix}1\\1\\\end{bmatrix}+\frac{\beta}{\sqrt{2}}\begin{bmatrix}1\\-1\\\end{bmatrix}$ right?&#xA;But the outputs are not basis vectors. I know this is hard to understand but how do I &lt;em&gt;make&lt;/em&gt; it back to the basis vector form so I can write it in ket form. I know you can do it algebraically but how to in linear algebra?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So put it in the form:&#xA;$$\alpha\begin{bmatrix}1\\0\\\end{bmatrix}+\beta\begin{bmatrix}0\\1\\\end{bmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you understand what I mean, can you explain it in a general matrix form?&lt;/p&gt;&#xA;" OwnerUserId="4232" LastEditorUserId="2293" LastEditDate="2018-07-29T17:09:52.237" LastActivityDate="2018-08-04T17:02:55.107" Title="How do you represent the output of a quantum gate in terms of its basis vectors?" Tags="&lt;quantum-computer&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="3895" PostTypeId="2" ParentId="3893" CreationDate="2018-07-29T04:02:25.290" Score="5" Body="&lt;p&gt;In linear algebra representation:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The state of the qubit is $\alpha|0\rangle + \beta|1\rangle = \begin{bmatrix}\alpha \\ \beta \end{bmatrix}$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Hadamard matrix is $\frac{1}{\sqrt{2}}\begin{bmatrix}1 &amp;amp; 1 \\ 1 &amp;amp; -1 \end{bmatrix}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The state after applying a Hadamard gate can be calculated by multiplying the column vector representing the state by the matrix representing the operator:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\frac{1}{\sqrt{2}}\begin{bmatrix}1 &amp;amp; 1 \\ 1 &amp;amp; -1 \end{bmatrix} \cdot \begin{bmatrix}\alpha \\ \beta \end{bmatrix} = \frac{1}{\sqrt{2}} \begin{bmatrix}\alpha + \beta \\ \alpha - \beta \end{bmatrix}$ = $\frac{1}{\sqrt{2}}(\alpha + \beta)|0\rangle + \frac{1}{\sqrt{2}}(\alpha - \beta)|1\rangle$&lt;/p&gt;&#xA;" OwnerUserId="2879" LastEditorUserId="3056" LastEditDate="2018-07-29T06:29:47.110" LastActivityDate="2018-07-29T06:29:47.110" CommentCount="1" />
  <row Id="3896" PostTypeId="2" ParentId="3890" CreationDate="2018-07-29T04:47:13.080" Score="0" Body="&lt;p&gt;To add on to what @DaftWullie said, in my mind it might make more sense to think of entanglement as a property of a multi-qubit state, instead of as a state itself. There is no special &quot;Entangled&quot; state, it's just that some states are entangled and some are not.&lt;/p&gt;&#xA;" OwnerUserId="3056" LastActivityDate="2018-07-29T04:47:13.080" CommentCount="0" />
  <row Id="3897" PostTypeId="2" ParentId="3871" CreationDate="2018-07-29T05:04:20.453" Score="2" Body="&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1702.01852&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;strong&gt;Here's&lt;/strong&gt;&lt;/a&gt; a paper comparing Trapped Ion and Superconducting (the main competitors right now) from the group at UMD which compares their trapped ion system with IBM's transmon (superconducting) system. If you want to look at a more algorithm-focused line of thought.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you are looking for a more general summary of the strengths and weaknesses &lt;a href=&quot;https://arxiv.org/pdf/1804.10648.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;strong&gt;this&lt;/strong&gt;&lt;/a&gt; paper seems to discuss all major options, and then &lt;a href=&quot;https://arxiv.org/abs/cond-mat/0411174&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;strong&gt;this&lt;/strong&gt;&lt;/a&gt; one focuses on Superconducting qubits in particular.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Hope that helps!&lt;/p&gt;&#xA;" OwnerUserId="3056" LastActivityDate="2018-07-29T05:04:20.453" CommentCount="1" />
  <row Id="3898" PostTypeId="1" AcceptedAnswerId="3966" CreationDate="2018-07-29T08:21:47.577" Score="7" ViewCount="95" Body="&lt;p&gt;I recently came to know about this interesting topic of &quot;&lt;strong&gt;communication complexity&lt;/strong&gt;&quot;. In simple words, Wikipedia defines it as:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;In theoretical computer science, &lt;strong&gt;communication complexity&lt;/strong&gt; studies the&#xA;  &lt;strong&gt;amount of communication&lt;/strong&gt; required to solve a problem when the input to&#xA;  the problem is distributed among two or more parties. It was&#xA;  introduced by Andrew Yao in 1979, who investigated the following&#xA;  problem involving two separated parties, traditionally called Alice&#xA;  and Bob. Alice receives an n-bit string $x$ and Bob another $n$-bit&#xA;  string $y$, and the goal is for one of them (say Bob) to compute a&#xA;  certain function $f(x,y)$ with the least amount of communication&#xA;  between them. Of course, they can always succeed by having Alice send&#xA;  her whole n-bit string to Bob, who then computes the function $f$, but&#xA;  the idea here is to find clever ways of calculating $f$ with fewer than&#xA;  n bits of communication. Note that in communication complexity, we are&#xA;  not concerned with the amount of computation performed by Alice or&#xA;  Bob, or the size of the memory used.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Now, I was going through the first couple of pages of this paper: &quot;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0101005&quot; rel=&quot;noreferrer&quot;&gt;Quantum Communication Complexity (A Survey) - Brassard&lt;/a&gt;&quot;. Apparently, it seems that if the non-communicating parties are previously entangled then more bits of information may be communicated than in the classical case. The paper looks nice, and so I'll read further. However, are there any other important papers or texts which are &quot;must-reads&quot; when learning about &quot;quantum communication complexity&quot;? (I'm mostly interested in the theoretical/algorithmic side)&lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-08-07T14:55:01.860" Title="Resources for Quantum Communication Complexity" Tags="&lt;quantum-algorithms&gt;&lt;resource-request&gt;&lt;communication-complexity&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="3899" PostTypeId="1" AcceptedAnswerId="3900" CreationDate="2018-07-29T21:25:54.600" Score="5" ViewCount="84" Body="&lt;p&gt;Under the influence of a time-independent Hamiltonian $H$, a state $|\psi\rangle$ will evolve after a time $t$ to the final state $|\psi(t)\rangle=e^{-iH t}|\psi\rangle$, while in the most general case of a time-dependent Hamiltonian $H(t)$, the final state can be formally written as&#xA;$$|\psi(t)\rangle=T\exp\left(-i\int_{t_0}^{t}dt\,H(t)\right) |\psi\rangle.$$&#xA;What are the preferred &lt;em&gt;numerical&lt;/em&gt; methods to compute $|\psi(t)\rangle$, given $H$, $t$ and $|\psi\rangle$?&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-07-30T15:50:29.357" LastActivityDate="2018-07-30T15:50:29.357" Title="What are the preferred numerical methods to simulate the evolution of a state through a time-dependent Hamiltonian?" Tags="&lt;simulation&gt;&lt;quantum-dynamics&gt;" AnswerCount="1" CommentCount="12" FavoriteCount="1" />
  <row Id="3900" PostTypeId="2" ParentId="3899" CreationDate="2018-07-30T08:42:45.407" Score="6" Body="&lt;p&gt;It depends on the Hamiltonian. There are three particular questions whose answers might influence your choice of strategy:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Does the Hamiltonian have any particular structure or symmetry?&lt;/li&gt;&#xA;&lt;li&gt;How quickly does the Hamiltonian change in time?&lt;/li&gt;&#xA;&lt;li&gt;What do you know about the initial state in relation to the initial Hamiltonian?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Obviously, if the Hamiltonian has any particular structure or symmetry, you should start by taking advantage of it. For example, if your Hamiltonian $H$ satisfies $$\left[H,\sum_{i=1}^NZ_i\right]=0,$$&#xA;then you can split $H$ into a series of subspaces $H=\bigoplus_{i=0}^NH_i$, whose evolutions you can handle separately. This is particularly good if your initial state turns out to be supported on a small number of those subspaces. Another particularly trivial case is of $[H(t),H(s)]=0$ for all $s$ and $t$. In that case, you would start by decomposing the initial state in terms of the eigenvectors.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If your Hamiltonian is changing slowly in time, and your initial state only has support on a small number of eigenstates, it might be worthwhile investigating whether an &lt;a href=&quot;https://en.wikipedia.org/wiki/Adiabatic_theorem&quot; rel=&quot;noreferrer&quot;&gt;adiabatic evolution&lt;/a&gt; is occurring. In that case, it may be &quot;just&quot; a case of finding the final Hamiltonian and some of its eigenstates.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If it's changing at a reasonable speed, but your initial state still has support only on a small number of the low-energy eigenvectors, then you might use matrix-product states (especially if your Hamiltonian has a one-dimensional structure).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If your Hamiltonian is changing very quickly in time, then the default option of Trotterising the Hamiltonian can work quite badly, with errors building quickly. There are improved techniques that work in these sorts of situations, but I've never seen them applied in the discrete setting of qubits (that said, I've never looked). Things like the &lt;a href=&quot;https://en.wikipedia.org/wiki/Arnoldi_iteration&quot; rel=&quot;noreferrer&quot;&gt;explicit Arnoldi method&lt;/a&gt;, or explicit Fatunla method. You may find some useful details &lt;a href=&quot;https://arxiv.org/abs/1401.6318&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The default method, which will always work (if you take a small enough $\delta t$) is to split the Hamiltonian evolution into lots of little time steps $\delta t$ and just evaluate&#xA;$$&#xA;\ldots e^{-iH(5\delta t/2)\delta t}e^{-iH(3\delta t/2)\delta t}e^{-iH(\delta t/2)\delta t}|\psi\rangle.&#xA;$$&#xA;This can be improved by using &lt;a href=&quot;https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods&quot; rel=&quot;noreferrer&quot;&gt;Runge-Kutta type techniques&lt;/a&gt;. You can also vary the size of the time step depending on how quickly the Hamiltonian is changing at a particular instant. Some of the quantum techniques for simulation may also be interesting. There have been &lt;a href=&quot;https://arxiv.org/abs/1805.00582&quot; rel=&quot;noreferrer&quot;&gt;recent advancements&lt;/a&gt; that massively improve the accuracy of those simulations by moving away from the standard Trotterisation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There's probably plenty more that could be said, but I guess that's enough to get you started.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-07-30T11:07:53.497" LastActivityDate="2018-07-30T11:07:53.497" CommentCount="0" />
  <row Id="3901" PostTypeId="1" CreationDate="2018-07-30T15:07:51.117" Score="3" ViewCount="101" Body="&lt;p&gt;I have run this program -&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# Import the QISKit SDK&#xA;from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister&#xA;from qiskit import execute, register&#xA;&#xA;# Set your API Token.&#xA;# You can get it from https://quantumexperience.ng.bluemix.net/qx/account,&#xA;# looking for &quot;Personal Access Token&quot; section.&#xA;QX_TOKEN = &quot;....&quot;&#xA;QX_URL = &quot;https://quantumexperience.ng.bluemix.net/api&quot;&#xA;&#xA;# Authenticate with the IBM Q API in order to use online devices.&#xA;# You need the API Token and the QX URL.&#xA;register(QX_TOKEN, QX_URL)&#xA;&#xA;# Create a Quantum Register with 2 qubits.&#xA;q = QuantumRegister(2)&#xA;# Create a Classical Register with 2 bits.&#xA;c = ClassicalRegister(2)&#xA;# Create a Quantum Circuit&#xA;qc = QuantumCircuit(q, c)&#xA;&#xA;# Add a H gate on qubit 0, putting this qubit in superposition.&#xA;qc.h(q[0])&#xA;# Add a CX (CNOT) gate on control qubit 0 and target qubit 1, putting&#xA;# the qubits in a Bell state.&#xA;qc.cx(q[0], q[1])&#xA;# Add a Measure gate to see the state.&#xA;qc.measure(q, c)&#xA;&#xA;# Compile and run the Quantum Program on a real device backend&#xA;job_exp = execute(qc, 'ibmqx4', shots=1024, max_credits=10)&#xA;result = job_exp.result()&#xA;&#xA;# Show the results&#xA;print(result)&#xA;print(result.get_data())&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Output - &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;COMPLETED {'time': 19.799431085586548, 'counts': {'00': 445, '01': 62,&#xA;  '10': 67, '11': 450}, 'date': '2018-07-30T14:56:23.330Z'}&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;But when I was running this, it was no  very fast. Is this due to queuing on the machine?&lt;/p&gt;&#xA;" OwnerUserId="4216" LastEditorUserId="4211" LastEditDate="2018-08-07T03:45:19.633" LastActivityDate="2018-08-07T03:45:19.633" Title="Comparing run times on IBM Quantum Experience" Tags="&lt;qiskit&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="3902" PostTypeId="1" AcceptedAnswerId="3905" CreationDate="2018-07-31T01:55:06.047" Score="2" ViewCount="135" Body="&lt;p&gt;A bit is a binary digit, typically 0 or 1.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Until a value is assigned (or a measurement is made) a bit is in a superposition of the entangled binary pair, is it not?&lt;/p&gt;&#xA;" OwnerUserId="2645" LastActivityDate="2018-07-31T11:21:53.087" Title="Are classical bits quantum?" Tags="&lt;qubit&gt;" AnswerCount="4" CommentCount="1" />
  <row Id="3903" PostTypeId="2" ParentId="3902" CreationDate="2018-07-31T02:00:07.277" Score="-2" Body="&lt;p&gt;A bit is effectively&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$|\psi\rangle = \alpha|0\rangle + \beta|1\rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;where either $\alpha = 1, \beta = 0$ (the bit = 0) or $\alpha = 0, \beta = 1$ (the bit = 1).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, yes, in the sense I think you mean, a classical bit can be represented with the quantum notation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Remember for quantum mechanics to be a legitimate theory, it must describe all the phenomenons and behaviors that classical mechanics explains, which it does. Similar is true in this case.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that if you ever refer to a classical bit as quantum, you will probably confuse the heck out of everybody, which is why the distinction is made. Also different gates can apply, etc.&lt;/p&gt;&#xA;" OwnerUserId="91" LastActivityDate="2018-07-31T02:00:07.277" CommentCount="6" />
  <row Id="3904" PostTypeId="2" ParentId="3902" CreationDate="2018-07-31T03:44:54.973" Score="1" Body="&lt;p&gt;You are correct that if you set $\alpha=0$ or $\alpha=1$, then the information gain upon measurement will be none. There is no way to be surprised. You do need a some nontrivial $p$ for be the prior distribution, to get information gain. If you say the state is $\sqrt{p} \mid 0 \rangle + \sqrt{1-p} \mid 1 \rangle$ instead, then when you measure it in the computational basis you can have some surprise/information. Presumably let $p=\frac{1}{2}$ because you want a full bit, not less. One might play fast and loose between &quot;less than or equal to 1 bit&quot; vs &quot;1 bit&quot; because of implicit assumptions about the probability distribution.&lt;/p&gt;&#xA;" OwnerUserId="434" LastActivityDate="2018-07-31T03:44:54.973" CommentCount="0" />
  <row Id="3905" PostTypeId="2" ParentId="3902" CreationDate="2018-07-31T05:26:29.143" Score="4" Body="&lt;p&gt;A bit, either 0 or 1, can certainly be thought of as a special case of being a qubit. However, that is not to say that anything capable of computing with classical bits is capable of computing with quantum bits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you have a bit, and don’t know if it’s a 0 or a 1, then how do you describe its state? You have to use Bayesian priors. If you have no idea which it is, you assign the two options equal probabilities. And it really is probabilities here. So it’s 50:50 being in 0 or 1. You can’t describe this as a pure quantum state, but you can use a density matrix:&#xA;$$\rho=(|0\rangle\langle 0|+|1\rangle\langle 1|)/2.$$&#xA;This formalism also means that if you later learn something about what the bit value might be (perhaps as a result of reading other bits in a computation), you can update those probabilities using conditional probabilities and Bayes’ rule. Note that this also means it’s a subjective description of the state: it reflects your personal knowledge of the state of the bit, while somebody else, who perhaps prepared the bit, already knows what value it has. This is perhaps one way to see why it should be different from the pure state that you proposed, which should be an objective description that everyone would agree on (in that there is no uncertainty in the state; the only uncertainty is induced by the action of the measurement).&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="55" LastEditDate="2018-07-31T10:24:16.400" LastActivityDate="2018-07-31T10:24:16.400" CommentCount="0" />
  <row Id="3906" PostTypeId="2" ParentId="3901" CreationDate="2018-07-31T06:37:38.227" Score="1" Body="&lt;p&gt;The time given in the results is the execution time on the backend. In your example, your quantum circuit took nearly 20 seconds to execute 1024 times (which seems huge for such a short circuit).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Before these nearly 20 seconds of execution, it is likely that your job had to wait for a few seconds (maybe up to several hours) in the backend queue, where all the jobs submitted but not executed are kept.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What you can do to estimate the waiting time is to ask to the backend how many jobs there are in queue, but you can't estimate precisely the time your job will need to wait in the queue as you don't know the content of the other jobs before you.&lt;/p&gt;&#xA;" OwnerUserId="1386" LastActivityDate="2018-07-31T06:37:38.227" CommentCount="0" />
  <row Id="3907" PostTypeId="2" ParentId="3902" CreationDate="2018-07-31T10:38:50.667" Score="2" Body="&lt;p&gt;No, &lt;em&gt;superposition is not the same as uncertainty about an outcome&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you throw a coin, the state of the coin is &lt;em&gt;not&lt;/em&gt; $|0\rangle+|1\rangle$ before landing.&#xA;If you really want to use the formalism of quantum mechanics to describe the uncertainty about the outcome, you have to describe it as a &lt;em&gt;mixture&lt;/em&gt; of the two possible outcomes, that is, something like $|0\rangle\!\langle0|+|1\rangle\!\langle1|$.&#xA;As also discussed in &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1476/55&quot;&gt;this other answer&lt;/a&gt;, coherent superpositions and mixtures are two entirely different beasts.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In particular, saying that the state of a coin (classical bit) is $|0\rangle+|1\rangle$ before the measurement implies the possibility of performing coherent operations on it, which is wrong: it is not possible, even in principle, to do something like measuring the state of the coin in the $|+\rangle$ basis.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In other words, the crucial difference is that even if you do not know in what state a &lt;em&gt;bit&lt;/em&gt; is, it is still the case that the bit &lt;em&gt;is&lt;/em&gt; in some definite state (which means no interferences), you just don't which one.&#xA;On the other hand, the &quot;uncertainty&quot; associated with a qubit &lt;em&gt;does not&lt;/em&gt; mean that there is something that we do not know about the state: the qubit can be fully characterised, and yet lead to uncertainty in (some) measurement outcomes.&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-07-31T11:21:53.087" LastActivityDate="2018-07-31T11:21:53.087" CommentCount="0" />
  <row Id="3908" PostTypeId="1" AcceptedAnswerId="3909" CreationDate="2018-07-31T12:05:29.067" Score="6" ViewCount="315" Body="&lt;p&gt;I wish to have a &quot;reset&quot; gate. This gate would have an effect to bring a qubit to the $\mid0\rangle$ state.&lt;br&gt;&#xA;Clearly, such a gate is not unitary (and so I'm unable to find any reliable implementation in terms of universal gates).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now for my particular needs, I need this ability to reset a qubit or a quantum register to that state so users can always start from $\mid0\rangle$.  I'm making a small programming language that transpiles to QASM, and when a function is exited, I want all local (quantum) variables (qubits) reset to $\mid0\rangle$ so they can be reused.  QASM reset instruction does not work on the real processor.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I think that something to this effect may be achieved with quantum phase estimation but I'm wondering if there is another way.&lt;/p&gt;&#xA;" OwnerUserId="2417" LastEditorUserId="26" LastEditDate="2018-08-01T15:19:56.343" LastActivityDate="2018-08-01T15:19:56.343" Title="Possibility of a &quot;reset&quot; quantum gate" Tags="&lt;quantum-gate&gt;&lt;quantum-programming&gt;" AnswerCount="2" CommentCount="4" FavoriteCount="3" />
  <row Id="3909" PostTypeId="2" ParentId="3908" CreationDate="2018-07-31T12:21:31.100" Score="4" Body="&lt;p&gt;One way is simply to measure the qubit in the standard, $Z$, basis. If you get the answer 0, then you've got the state you want. Otherwise, you apply a bit-flip to it.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Indeed, if you want to implement a non-unitary operation, you need some sort of measurement operation somewhere, whether that's a direct measurement, or the implementation of a CP map or POVM (but for these options, you need to introduce ancillas of a fixed state, which rather negates the point). Or you could use noise in the system, but you are unlikely to have sufficient control of it - it's noise after all! Of course, none of these options just reset a single qubit; anything that qubit is entangled with is also affected, but that's kind of in the definition of &quot;reset&quot; in the quantum context.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The only other option is to uncompute, but this is not a generic option because, generically you have to uncompute the entire computation to reset even a single qubit, and that resets everything. Except it doesn't work perfectly because of errors. You would be better starting a new computation. There are specific scenarios where an ancilla qubit is used and it can be uncomputed, but this is typically built into the algorithm because the uncomputation step is important for getting rid of some unwanted entanglement that would otherwise appear.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-08-01T07:11:42.033" LastActivityDate="2018-08-01T07:11:42.033" CommentCount="3" />
  <row Id="3910" PostTypeId="2" ParentId="3908" CreationDate="2018-07-31T12:23:14.650" Score="3" Body="&lt;p&gt;I do not think that you can achieve this with a single gate, but the cool thing of quantum gates and unitary transformations is that they are reversible, therefore, when implementing a function in your quantum circuit, all you need to do is 'uncompute' it just by reversing the gates that you used.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;http://algassert.com/quirk#circuit=%7B%22cols%22:[[%22%E2%80%A2%22,%22X%22],[%22X%22],[%22%E2%80%A2%22,%22X%22,%22%E2%80%A2%22],[1,%22H%22],[%22H%22,%22%E2%80%A2%22],[%22H%22,%22H%22],[%22Sample3%22],[%22H%22,%22H%22],[%22H%22,%22%E2%80%A2%22],[1,%22H%22],[%22%E2%80%A2%22,%22X%22,%22%E2%80%A2%22],[%22X%22],[%22%E2%80%A2%22,%22X%22]]%7D&quot; rel=&quot;nofollow noreferrer&quot;&gt;Here&lt;/a&gt; i made a random circuit and reversed it; you can see that you are back to the state $\vert 0\rangle$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This would mean that you have to &quot;reset&quot; in a specific way for each function, though.&lt;/p&gt;&#xA;" OwnerUserId="2648" LastActivityDate="2018-07-31T12:23:14.650" CommentCount="4" />
  <row Id="3911" PostTypeId="2" ParentId="3879" CreationDate="2018-07-31T13:19:55.917" Score="5" Body="&lt;p&gt;The insight that suggests that sparse matrices are useful goes along the lines of: for any $H$, we can decompose it in terms of a set of $H_i$ whose individual components all commute (making diagonalisation straightforward),&#xA;$$&#xA;H=\sum_{i=1}^mH_i.&#xA;$$&#xA;If the matrix is sparse, then you shouldn't need too many distinct $H_i$. Then you can simulate the Hamiltonian evolution&#xA;$$&#xA;e^{-iHt}=\prod_{j=1}^Ne^{-iH_m\delta t}e^{-iH_{m-1}\delta t}\ldots e^{-iH_{1}\delta t},&#xA;$$&#xA;where $t=N\delta t$. For example, in your case, you can have&#xA;$$&#xA;H_1=\frac14 X\otimes(18\mathbb{I}-6Z\otimes Z-4Z\otimes\mathbb{I}) \\&#xA;H_2=\frac14(X\otimes(11\mathbb{I}+5Z)\otimes X+Y\otimes(11\mathbb{I}+5Z)\otimes Y)\\&#xA;H_3=\frac14(11X\otimes X-Y\otimes Y)\otimes(\mathbb{I}-Z)&#xA;$$&#xA;(the 3 terms corresponding to the fact that it's a 3-sparse Hamiltonian). I believe there's a strategy here: you go through all the non-zero matrix elements of your Hamiltonian and group them so that if I write their coordinates as $(i,j)$ (and I always include their complex conjugate pair), I continue adding other elements to my set $(k,l)$ provided neither $k$ nor $l$ equal $i$ or $j$.. This would mean for an $m$-sparse Hamiltonian, you have $m$ different $H_i$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The problem is this doesn't necessarily work this straightforwardly in practice. For one thing, there's still exponentially many matrix elements that you have to go through, but that's always going to be the case with the way you're setting it up.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The way that people get around this is they set up an oracle. One possible oracle is essentially a function $f(j,l)$ which returns the position and value of the $l^{th}$ non-zero entry on the $j^{th}$ row. This can be built into a full on quantum algorithm. There are a few papers on this topic (none of which I've completely understood yet). For example, &lt;a href=&quot;https://arxiv.org/abs/1202.5822&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/abs/1501.01715&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;. Let me try to give a crude description of the way they work.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The first step is to decompose the Hamiltonian as a set of unitaries, multiplied by positive scale factors $\alpha_i$:&#xA;$$&#xA;H=\sum_i\alpha_iU_i&#xA;$$&#xA;For simplicity, let's assume $H=U_1+\alpha U_2$. It might be assumed that you're given this decomposition. One then defines an operation (constructed out of controlled-$U_1$ and controlled-$U_2$) that implements $V=|0\rangle\langle 0|\otimes U_1+|1\rangle\langle 1|\otimes U_2$. If we input a particular state $|0\rangle+\sqrt{\alpha}|1\rangle$ (up to normalisation) on the control qubit, apply $V$, then measure the control qubit, post-selecting on it being in the state $|0\rangle+\sqrt{\alpha}|1\rangle$, then if the post-selection succeeds, we have implemented $U_1+\alpha U_2$, which happens with a probability at least $(1-\alpha)^2/(1+\alpha)^2$. You can do exactly the same with multiple terms, and indeed with exponentials of Hamiltonians (think about the series expansion), although in practice some better series expansions are used based on Bessel functions.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-07-31T13:45:32.017" LastActivityDate="2018-07-31T13:45:32.017" CommentCount="3" />
  <row Id="3912" PostTypeId="2" ParentId="3901" CreationDate="2018-08-01T00:13:41.880" Score="3" Body="&lt;p&gt;The time that you see in the &lt;code&gt;result&lt;/code&gt; data structure is recorded by the device itself, so it is the running time of your experiment. It &lt;em&gt;does not&lt;/em&gt; include the time spent processing your circuit in Qiskit, or the time spent by your job in the queue.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;That being said, here is a rough breakdown of this time (ballpark durations):&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1) Loading the experiment into the instruments that create the pulses (~ 15s)&lt;/li&gt;&#xA;&lt;li&gt;2) 1024 repetitions (shots) of running calibration pulses &amp;amp; your circuit (~ 5s)&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;a) Reset qubits (relaxation) + calibration: ~ 4ms&lt;/li&gt;&#xA;&lt;li&gt;b) Reset qubits (relaxation) + your circuit: ~ 1ms&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Which adds up to the total experiment time you are seeing.&lt;/p&gt;&#xA;" OwnerUserId="2503" LastActivityDate="2018-08-01T00:13:41.880" CommentCount="0" />
  <row Id="3913" PostTypeId="1" CreationDate="2018-08-01T06:10:46.050" Score="-1" ViewCount="132" Body="&lt;p&gt;Yacht design is hull, resistance, wave making, near-field far-field wake, side pressure, velocity prediction program, stability and simple computational fluid dynamics, sail design etc.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are hundreds of equations to optimize to find a good yacht.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is this a question which DWave can answer and give me hundreds of designs at the end quickly?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I read DWave gives too many answers. My boat designs will be optimized for one speed and free curves and they will be very beautiful.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I want to get a good computation in short time.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What do you think, what would be the time taken to do this using a DWave machine?&lt;/p&gt;&#xA;" OwnerUserId="4250" LastEditorUserId="26" LastEditDate="2018-08-01T15:15:09.990" LastActivityDate="2018-08-03T11:24:58.807" Title="Can D-Wave optimize yacht design with all possible formulas and CFD and give me thousands of designs?" Tags="&lt;d-wave&gt;" AnswerCount="1" CommentCount="1" ClosedDate="2018-08-04T09:04:30.880" />
  <row Id="3914" PostTypeId="2" ParentId="1869" CreationDate="2018-08-01T10:09:15.733" Score="1" Body="&lt;p&gt;The problem here is that $U_f$ as you've defined it is not unitary. To see this, note that  the overlaps between states are preserved under the action of a unitary: $\langle\psi|\phi\rangle=\langle\psi|U^\dagger U|\phi\rangle$, while for a constant function $f$ you have $U_f|x\rangle=U_f|x'\rangle$ even if $x\neq x'$ (thereby changing the overlap from 0 to 1).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The way that you set this up as a unitary is with some additional qubits. If $f:x\mapsto y$ where $x\in\{0,1\}^n$ and $y\in\{0,1\}^m$, then you define $U_f|x\rangle|y\rangle=|x\rangle|y\oplus f(x)\rangle$. This is definitely unitary because&#xA;$$&#xA;U_fU_f|x\rangle|y\rangle=|x\rangle|y\oplus f(x)\oplus f(x)\rangle=|x\rangle|y\rangle,&#xA;$$&#xA;so $U_f$ is its own inverse.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Of course, you could define a quantum operation that always sets everything to 0. It's basically a measurement (in the $Z$ basis) followed by a compensating action depending on the measurement outcome. But then you can't use linearity as you did in your analysis, because you have to follow through the different measurement outcomes separately.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-08-01T10:09:15.733" CommentCount="0" />
  <row Id="3915" PostTypeId="2" ParentId="3913" CreationDate="2018-08-01T13:07:32.303" Score="5" Body="&lt;p&gt;So I do not know much about yacht design but having played a little bit with a D-Wave machine I would suggest to see if you can model your problem as a Quadratic unconstrained binary optimization.&#xA;See &lt;a href=&quot;https://en.wikipedia.org/wiki/Quadratic_unconstrained_binary_optimization&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://en.wikipedia.org/wiki/Quadratic_unconstrained_binary_optimization&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;That is your variables must be binary and a D-Wave machine will try to find a minimum to your QUBO. It will return many answers in a sense that it tries multiple times to find it but the goal is to find one minimum or sample near it with this minimization objective. If you ask for 1000 tries, it may give you a 100 different solutions but some with more frequencies.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now about the time to do it, it will depend on how the problem can fit in the hardware. You have to take into account the number of variables and their connectivity (which variables share a coefficient in the QUBO) and finally see if it fits with the number of qubits and their connectivity on D-Wave.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Say you can fit it, it will give you answers quickly. Depending on numbers of runs you ask and time parameters for each run you pass, it will be a matter of seconds.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example of a QUBO, here is a the simplest one :&#xA;x0 + x1 -2*x1*x0 &lt;/p&gt;&#xA;&#xA;&lt;p&gt;x1 and x0 are my binary variables (0 or 1 values).&#xA;Here two solutions : (0,0) and (1,1).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To solve this on the machine, you generally pass a file/dictionary/table that looks like this and represent your QUBO problem:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;0 0 1 (coefficient of x0 with himself) &lt;br&gt;&#xA;1 1 1 (coefficient of x1 with himself) &lt;br&gt;&#xA;0 1 -2 (coefficient between x0 and x1) &lt;br&gt;&lt;/p&gt;&#xA;" OwnerUserId="4127" LastEditorUserId="4127" LastEditDate="2018-08-03T11:24:58.807" LastActivityDate="2018-08-03T11:24:58.807" CommentCount="14" />
  <row Id="3917" PostTypeId="2" ParentId="2717" CreationDate="2018-08-01T22:27:52.640" Score="2" Body="&lt;h2&gt;Background&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Often, in quantum optics, the &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Heisenberg_picture&quot; rel=&quot;nofollow noreferrer&quot;&gt;Heisenberg picture&lt;/a&gt;&lt;/em&gt; is used, where instead of considering equations of motion of states, equations of motions of operators are looked at instead. When considering creation/annihilation operators, this is often considerably easier as the matrices that determine the evolution (assuming it can be written in terms of matrices) are, for one, finite.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Heisenberg equations of motions are calculated using $$\frac{dA}{dt} = \frac i\hbar \left[H, A\right] + \frac{\partial A}{\partial t},$$ for an operator $A$ evolving under a Hamiltonian $H$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here, the operator $a_j \left(a_j^\dagger\right)$ is the annihilation (creation) operator for spatial mode $j$. For a single mode, this allows for an effective Hamiltonian (acting on the operators) to be written as $$i\frac{d}{dt}\begin{pmatrix}a \\ a^\dagger\end{pmatrix} = H_{\text{eff}}\begin{pmatrix}a \\ a^\dagger\end{pmatrix}.$$ This naturally extends to writing their transformation as $$\begin{pmatrix}b \\ b^\dagger\end{pmatrix} = M\begin{pmatrix}a \\ a^\dagger\end{pmatrix}$$ for input modes $a \left(a^\dagger\right)$ and output modes $b \left(b^\dagger\right)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When it exists, this transformation matrix $M$ can be calculated using $U^\dagger A_jU = \sum_{k}M_{jk}A_k$ for unitary evolution $U$. For the Unitaries in the question, this gives:&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Transformations&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Displacement&lt;/strong&gt;&#xA;$$D_j\left(\alpha\right):\begin{pmatrix}b_j\\b_j^\dagger\\I\end{pmatrix} = \begin{pmatrix}1 &amp;amp;&amp;amp; 0 &amp;amp;&amp;amp; \alpha\\0&amp;amp;&amp;amp;1&amp;amp;&amp;amp;\alpha^*\\0&amp;amp;&amp;amp;0&amp;amp;&amp;amp;1\end{pmatrix} \begin{pmatrix}a_j\\a_j^\dagger\\I\end{pmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Rotation&lt;/strong&gt;&#xA;$$R_j\left(\phi\right):\begin{pmatrix}b_j\\b_j^\dagger\end{pmatrix} = \begin{pmatrix}e^{-i\phi} &amp;amp;&amp;amp; 0\\0&amp;amp;&amp;amp;e^{i\phi}\end{pmatrix} \begin{pmatrix}a_j\\a_j^\dagger\end{pmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Squeezing&lt;/strong&gt;&#xA;$$S_j\left(\xi=re^{i\theta}\right):\begin{pmatrix}b_j\\b_j^\dagger\end{pmatrix} = \begin{pmatrix}\cosh r &amp;amp;&amp;amp; -e^{i\theta}\sinh r\\-e^{-i\theta}\sinh r&amp;amp;&amp;amp;\cosh r\end{pmatrix} \begin{pmatrix}a_j\\a_j^\dagger\end{pmatrix}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Beamsplitter&lt;/strong&gt;&#xA;$$B_{jk}\left(\zeta = te^{i\varphi}\right):\begin{pmatrix}b_j\\b_k\\b_j^\dagger\\b_k^\dagger\end{pmatrix} = \begin{pmatrix}t &amp;amp;&amp;amp; re^{-i\varphi}&amp;amp;&amp;amp;0&amp;amp;&amp;amp; 0\\re^{i\varphi}&amp;amp;&amp;amp;t&amp;amp;&amp;amp;0&amp;amp;&amp;amp;0\\0&amp;amp;&amp;amp;0&amp;amp;&amp;amp;t&amp;amp;&amp;amp;re^{i\varphi}\\0&amp;amp;&amp;amp;0&amp;amp;&amp;amp;re^{-i\varphi}&amp;amp;&amp;amp;t\end{pmatrix} \begin{pmatrix}a_j\\a_k\\a_j^\dagger\\a_k^\dagger\end{pmatrix},$$ where $r=\cos\left|\zeta\right|$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Cubic Phase&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Unfortunately, this is too nonlinear to write in the above way in matrix form. As $x = \frac{1}{\sqrt 2}\left(a+a^\dagger\right)$, even to first order, $V^\dagger a^\dagger V$ will include terms such as $\left[a^3, a^\dagger\right] = 3a^2$, which cannot be written in terms of $\alpha a^\dagger+\beta a+\gamma$.&lt;/p&gt;&#xA;" OwnerUserId="23" LastActivityDate="2018-08-01T22:27:52.640" CommentCount="8" />
  <row Id="3918" PostTypeId="1" AcceptedAnswerId="3924" CreationDate="2018-08-01T22:36:07.587" Score="4" ViewCount="245" Body="&lt;p&gt;It seems that a coin flip &lt;em&gt;game&lt;/em&gt; is a decent metaphor for a 2-level system. Until 1 of the 2 players picks heads or tails, even if the coin has already been flipped, the &lt;em&gt;win/loss&lt;/em&gt; wave form has not yet collapsed.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Would rock paper scissors be a good metaphor for qutrits? Where the number of players corresponds w/ the number of qutrits (eg. $3^n$ possible states).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Would a standard pack of 52 cards be a good metaphor for a 52-level quantum system (the &lt;em&gt;game&lt;/em&gt; being guessing correctly a card selected from the deck at random)?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Particularly interested in game based metaphors because of the easy correlation to combinitorial game theory &amp;amp; computation complexity.&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-08-01T23:24:53.523" LastActivityDate="2018-08-07T15:22:47.230" Title="Good metaphors for n-level quantum systems" Tags="&lt;complexity-theory&gt;" AnswerCount="6" CommentCount="0" FavoriteCount="1" />
  <row Id="3919" PostTypeId="2" ParentId="3918" CreationDate="2018-08-01T23:15:26.043" Score="1" Body="&lt;p&gt;Rock paper scissors seems a good one. &#xA;Now for the cards pack, I would not see the collapse metaphor here. While a player has not shown his cards, the cards are already set even if you do not see them. But I guess it is a point of view.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Maybe just pick a MMORPG with 52 monsters appearing randomly.&lt;/p&gt;&#xA;" OwnerUserId="4127" LastActivityDate="2018-08-01T23:15:26.043" CommentCount="2" />
  <row Id="3920" PostTypeId="1" AcceptedAnswerId="3921" CreationDate="2018-08-02T02:11:17.597" Score="7" ViewCount="108" Body="&lt;p&gt;I'm a computer science major who's really keen on physics and quantum mechanics. I have started learning about Q# and D-Wave, but I just wanted to know if it's possible to test quantum mechanical theories using quantum computers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If so, then what all different things should I look into? For example, Q# allows us about 30 qubits for free developing. What kind of simulations can I do with that many qubits?&lt;/p&gt;&#xA;" OwnerUserId="4259" LastEditorUserId="91" LastEditDate="2018-08-02T02:15:58.100" LastActivityDate="2018-08-02T18:48:20.270" Title="Can we perform quantum mechanical simulations using a quantum computer?" Tags="&lt;simulation&gt;&lt;q#&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="3921" PostTypeId="2" ParentId="3920" CreationDate="2018-08-02T02:20:19.763" Score="3" Body="&lt;p&gt;What do you mean by &quot;Quantum Mechanical Simulations&quot; ?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One of the primary motivations in the early history of quantum computing was a statement from Richard Feynman that a quantum computer would be able to effectively simulate quantum systems. To that end, a lot of the nearest term quantum programs people are trying to run (and have run) are simulations of ground states of atoms and molecules. These are very classically resource intensive, but &lt;a href=&quot;https://www.ibm.com/blogs/research/2017/09/quantum-molecule/&quot; rel=&quot;nofollow noreferrer&quot;&gt;IBM has done this to good success&lt;/a&gt; on smaller highly symmetric molecules using their current quantum computers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;On the other hand, if you are wondering if we can test Quantum Mechanics as a theory using a Quantum Computer things like &lt;a href=&quot;https://en.wikipedia.org/wiki/Bell%27s_theorem&quot; rel=&quot;nofollow noreferrer&quot;&gt;Bell's Inequalities&lt;/a&gt; can be tested. This is a proof that a system is Quantum Mechanical, as there is an inequality which can only be broken if using entanglement. The article linked has a good explanation, and goes into some of the experimental verifications which have already been done, but such a test is one of the ways to ensure that a given Black Box Computer is quantum is nature.&lt;/p&gt;&#xA;" OwnerUserId="3056" LastActivityDate="2018-08-02T02:20:19.763" CommentCount="5" />
  <row Id="3922" PostTypeId="2" ParentId="3918" CreationDate="2018-08-02T02:22:23.290" Score="1" Body="&lt;p&gt;A rolling n-sided die would be a good analogy that follows the coin example very closely. Until the die settles you can think of it as having not &quot;collapsed&quot;, and die can come in whatever side number desired (at least in your mind, if you're trying to make a physical example that might be difficult.)&lt;/p&gt;&#xA;" OwnerUserId="3056" LastActivityDate="2018-08-02T02:22:23.290" CommentCount="1" />
  <row Id="3923" PostTypeId="2" ParentId="3918" CreationDate="2018-08-02T04:31:34.117" Score="6" Body="&lt;p&gt;There is always a difference between a quantum system and a classical metaphor. If a system is a qubit in a pure state, then there always exists a measurement basis (or alternatively a proper unitary gate for the standard measurement basis) such that the measurement outcome is 100% predictable, and a measurement basis with measurement outcome 50%-50%. You can't demonstrate this feature using a classical metaphor - in classical physics random is random and deterministic is deterministic.&lt;/p&gt;&#xA;" OwnerUserId="2105" LastActivityDate="2018-08-02T04:31:34.117" CommentCount="0" />
  <row Id="3924" PostTypeId="2" ParentId="3918" CreationDate="2018-08-02T15:57:14.133" Score="4" Body="&lt;p&gt;Your metaphor can be chosen as $N-1$ identical coins, such that the outcome state vector corresponds to the sum of the heads. Thus we wind up in the state $|k\rangle$ when we have $k$ heads and $N-1-k$ tails. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In this approach you can actually associate your metaphor with a classical phase space, as a generalization of the association of a qubit with the Bloch sphere whose generator can be thought in the coin case as the direction of the normal to the coin's face.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the multiple coin case, we have $N-1$ such directions. But since in our Hilbert space we don't mind the order of the coins only their summed result, in the classical phase space we should not distinguish states in which the direction of the normal to the coins faces switch.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What I just described to you in words is actually the &lt;em&gt;Majorana representation&lt;/em&gt; (some call it the Majorana star representation), which is based on the isomorphism of the symmetrized tensor product of $N-1$ spheres to the complex projective space $CP^{N-1}$.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\otimes_{\mathrm{sym}} ^{N-1}  S^2 \cong CP^{N-1}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The geometric quantization of this complex projective space is the $N-$ level system. There is some renewed interest in this representation, partially motivated by holonomic quantum computation, please see for example &lt;a href=&quot;https://arxiv.org/abs/1406.6821v4&quot; rel=&quot;nofollow noreferrer&quot;&gt;Liu and Fu&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, the outcome of the coin flipping in the case of a single qubit can be described as a measurement of the angular momentum component of the coin in the $z$ direction $j_z$. It is not hard to see that the corresponding operator in the multiple coin flip is the sum of the individual angular momenta:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$J_z = \sum_1^{N-1} j^{(i)}_z$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(The above equation is just standard shorthand used by physicists since the operators act on different components in the tensor product Hilbert space). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;(In the $N\times N$ matrix representation, this operator can be chosen as: $J_z = \mathrm{diag}[N-1, N-3, .,.,., -N+1]$).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This representation of the $N-$ qubit system has a further analogy. As in the case of a single coin or qubit, the distribution function of the operator $j_z$ is Bernoullian  for any state (density matrix) in which the system is prepared; the distribution function of $J_z$ in the multiple coin case is Binomial, for any choice of the density matrix of the system.  Thus in both cases this observable returns the classical distribution function.&lt;/p&gt;&#xA;" OwnerUserId="4263" LastActivityDate="2018-08-02T15:57:14.133" CommentCount="0" />
  <row Id="3925" PostTypeId="2" ParentId="3920" CreationDate="2018-08-02T18:48:20.270" Score="5" Body="&lt;p&gt;A separate note on using simulators for this (as opposed to using an actual quantum computer).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Simulators, like the one that ships with Q#, are built to simulate quantum mechanical theories as we understand them now. This means that any experiment you run on a simulator will behave exactly as the theory says (well, unless the simulator has a bug in the code), but it doesn't mean that this experiment confirms the theory - it only means that it's a good simulation/illustration of the theory.&lt;/p&gt;&#xA;" OwnerUserId="2879" LastActivityDate="2018-08-02T18:48:20.270" CommentCount="2" />
  <row Id="3927" PostTypeId="2" ParentId="3918" CreationDate="2018-08-02T20:40:00.683" Score="2" Body="&lt;p&gt;A coin is an extremely bad and highly misleading analogy for a qubit.  You shouldn't use it by any means.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Yet, if you want an equally bad and misleading analogy for a qu-$d$-it, you should use something which is random and has $d$ possible outcome.  For $d=3$, this might be rock-paper-scissors.  On the other hand, a deck of cards with $52$ cards can have $52!$ possibilities, so it is an equally bad analogy for a qu-$(52!)$-it.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;It has been suggested to add an explanation why I think this is a horrible analogy.  The key point is that it pretends that quantum mechanics is merely classical randomness -- something which can be easily understood with our classical intuition, and thereby implying that all that talking about quantum mechanics being special is just talking.  Indeed, the coin analogy already fails for a single qubit, when one performs measurements in more than one basis.  This is for instance explained in DaftWullie's answer. Now one could argue that his answer also provides a way to model this with coins, but (1) these are coins which are rigged in a very weird way, and (2) it is still incomplete -- I just need to toss in measurement in yet another basis to make the whole description break down, and to yield an even more complex pattern of rigged coins (even worse, those coins would not get tossed after looking at another coins as in DW's answer, but they would get tossed in a &lt;em&gt;biased&lt;/em&gt; way depending on which measurement I did).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Of course, since quantum theory is a theory about measurements -- which have classical inputs, i.e. measurement settings, and classical outputs, i.e. measurement outcomes -- we can always model this with classical objects which follow some odd distribution. However, the point is exactly that this distribution cannot be modeled by coins any more in any even remotely reasonable way (even more so once we consider two spatially separated qubits).  &lt;/p&gt;&#xA;" OwnerUserId="491" LastEditorUserId="491" LastEditDate="2018-08-07T15:22:47.230" LastActivityDate="2018-08-07T15:22:47.230" CommentCount="6" />
  <row Id="3928" PostTypeId="2" ParentId="3863" CreationDate="2018-08-03T06:42:29.437" Score="3" Body="&lt;p&gt;A conventional Hamiltonian is Hermitian. Hence, if it contains a non-Hermitian term, it must either also contain its Hermitian conjuagte as another term, or have 0 weight. In this particular case, since $Z\otimes X\otimes Y$ is Hermitian itself, the coefficient would have to be 0. So, if you're talking about conventional Hamiltonians, you've probably made a mistake in your calculation. Note that if the Hermitian conjugate of the term is not present, you cannot simply fix things by adding it in; it will give you a completely different result.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;On the other hand, you might be wanting to implement a &lt;em&gt;non-Hermitian&lt;/em&gt; Hamiltonian. These things do exist, often for the description of noise processes, but are not nearly so widespread. You need to explicitly include the &quot;non-Hermitian&quot; terminology, otherwise everyone will just think that what you're doing is wrong because it's not Hermitian, and a Hamiltonian should be Hermitian. I'm not overly familiar with what capabilities the various simulators provide, but I'd be surprised if they have non-Hermiticity built in.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, you can simulate it, at the cost of non-deterministic implementation. There will be more sophisticated methods than this (see the links in &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/3911/1837&quot;&gt;this answer&lt;/a&gt;), but let me describe a particularly simply one: I'm going to assume there's only one non-Hermitian component, which is $i\times$(a tensor product of Paulis). I'll call this tensor product of Paulis $K$. The rest of the Hamiltonian is $H$. You want to create the evolution&#xA;$$&#xA;e^{-iHt+Kt}&#xA;$$ &#xA;We start by Trotterising the evolution,&#xA;$$&#xA;e^{-iHt+Kt}= \prod_{i=1}^Ne^{-iH\delta t+K\delta t}&#xA;$$&#xA;where $N\delta t=t$. Now we work on simulating an individual term $e^{-iH\delta t+K\delta t}\approx e^{-iH\delta t}e^{K\delta t}$ (which becomes more accurate at large $N$). You already know how to deal with the Hermitian part so, focus on $$e^{K\delta t}=\cosh(\delta t)\mathbb{I}+\sinh(\delta t)K.$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We introduce an ancilla qubit in the state $|\psi\rangle=\alpha|0\rangle+\beta|1\rangle$, and we use this as the control qubit in a controlled-$K$ gate. Then we measure the ancilla in the $\{|\psi\rangle,|\psi^\perp\rangle\}$ basis (where $\langle\psi|\psi^\perp\rangle=0$). If the outcome is $|\psi\rangle$, then on the target qubits we have implemented the operation $|\alpha|^2\mathbb{I}+|\beta|^2K$, up to normalisation. So, if you fix $(1-|\alpha|^2)/|\alpha|^2=\tanh(\delta t)$, you have perfectly implemented that operation. If the measurement fails, then it's up to you whether you want to try to recover (this may well not be possible) or start again.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-08-03T06:47:58.537" LastActivityDate="2018-08-03T06:47:58.537" CommentCount="0" />
  <row Id="3929" PostTypeId="1" AcceptedAnswerId="3931" CreationDate="2018-08-03T15:06:12.370" Score="5" ViewCount="379" Body="&lt;p&gt;I’m trying to calculate the probability amplitudes for this circuit:&#xA;&lt;img src=&quot;https://i.stack.imgur.com/O92sm.png&quot; alt=&quot;Quantum Circuit&quot;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My Octave code is:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sys = kron([1; 0], [1;0], [1;0])&#xA;h = 1/sqrt(2) * [1 1; 1 -1];&#xA;c = [1 0 0 0; 0 1 0 0; 0 0 0 1; 0 0 1 0];&#xA;op1 = kron(h, eye(2), eye(2));&#xA;op2 = kron(c, eye(2));&#xA;op3 = kron(eye(2), c);&#xA;op4 = kron(h, eye(2), eye(2));&#xA;op4*op3*op2*op1 * sys&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;The output is: &lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;ans =&#xA;0.50000&#xA;0.00000&#xA;0.00000&#xA;0.50000&#xA;0.50000&#xA;0.00000&#xA;0.00000&#xA;-0.50000&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;This differs from the results the quantum circuit simulator gives me, where have I gone wrong?&lt;/p&gt;&#xA;" OwnerUserId="4275" LastActivityDate="2018-08-04T05:09:38.047" Title="Incorrectly Calculating Probability Amplitudes for 3-qbit Circuit" Tags="&lt;quantum-gate&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="3930" PostTypeId="2" ParentId="3929" CreationDate="2018-08-03T15:41:07.603" Score="3" Body="&lt;p&gt;The output you've stated there appears to be correct. The Hadamard produces&#xA;$$&#xA;|000\rangle\mapsto\frac{1}{\sqrt{2}}(|000\rangle+|100\rangle).&#xA;$$&#xA;Then, the two controlled-nots give&#xA;$$&#xA;\mapsto\frac{1}{\sqrt{2}}(|000\rangle+|111\rangle).&#xA;$$&#xA;The final Hadamard then yields&#xA;$$&#xA;\mapsto\frac{1}{2}((|0\rangle+|1\rangle)|00\rangle+(|0\rangle-1|\rangle)|11\rangle).&#xA;$$&#xA;This is the same as $\frac12(|000\rangle+|011\rangle+|100\rangle-|111\rangle)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The problem is presumably with the quantum simulator, or your interpretation of it, but since you don’t specify what simulator you’re using, it’s difficult to know...&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-08-04T05:09:38.047" LastActivityDate="2018-08-04T05:09:38.047" CommentCount="0" />
  <row Id="3931" PostTypeId="2" ParentId="3929" CreationDate="2018-08-03T16:31:43.117" Score="5" Body="&lt;p&gt;You're getting the same output as Quirk, just with a different bit ordering convention for the kets.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quirk considers the top qubit to be the &quot;least significant&quot; qubit (i.e. if you count 000, 001, 010, ... then it refers to the rightmost bit). So if you apply a Hadamard gate to the top qubit of a three-qubit circuit in Quirk you get the state |000&gt; + |001&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In your code you are using the opposite convention, and putting the H as the first argument to kron instead of the last argument, so you would get |000&gt; + |100&gt; instead.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To get comparable results you just need to vertically mirror the Quirk circuit, e.g. by throwing in a swap gate:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;http://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22H%22%5D%2C%5B%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22H%22%5D%2C%5B%22Swap%22%2C1%2C%22Swap%22%5D%5D%7D&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/wE82H.png&quot; alt=&quot;reversed circuit&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="119" LastActivityDate="2018-08-03T16:31:43.117" CommentCount="2" />
  <row Id="3932" PostTypeId="1" CreationDate="2018-08-03T22:03:59.450" Score="10" ViewCount="113" Body="&lt;p&gt;Officials in Rubik's cube tournaments have used two different ways of scrambling a cube.  Presently, they break a cube apart and reassemble the cubies in a random order $\pi\in G$ of the Rubik's cube group $G$.  Previously, they would apply a random sequence $g$ of Singmaster moves $\langle U,D, F, B, L, R\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, the length $t$ of the word $g$ - the number of random moves needed in order to fully scramble the cube such that each of the $\Vert G\Vert=43,252,003,274,489,856,000$ permutations is roughly equally likely to occur - is presently unknown, but &lt;a href=&quot;https://www.popsci.com/science/article/2010-08/gods-number-revealed-20-moves-will-solve-any-rubiks-cube-position&quot; rel=&quot;nofollow noreferrer&quot;&gt;must be at least&lt;/a&gt; $20$.  This length $t$ can be called the &lt;a href=&quot;https://en.wikipedia.org/wiki/Markov_chain_mixing_time&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;em&gt;mixing time&lt;/em&gt;&lt;/a&gt; of a random walk on the Cayley graph of the Rubik's cube group generated by the Singmaster moves $\langle U,D, F, B, L, R\rangle$.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Would a quantum computer have any advantages to determining the mixing time $t$ of the Rubik's cube group?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I think we can have some clever sequence of Hadamard moves to create a register $\vert A \rangle$ as a uniform superposition over all $\Vert G\Vert$ such configurations; thus applying any sequence of Singmaster moves to $\vert A \rangle$ doesn't change $\vert A \rangle$.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we have a guess $t'$ as to what the mixing time $t$ is, we can also create another register $\vert B \rangle$ as a uniform superposition of all Singmaster words of length $t'$, and conditionally apply each such word to a solved state $\vert A'\rangle$, to hopefully get a state $\vert B\rangle \vert A\rangle$ such that, if we measure $\vert A \rangle$, each of the $\Vert G \Vert$ configurations are equally likely to be measured.  If $t'\lt t$, then we won't have walked along the Cayley graph of $G$ for long enough, and if we were to measure $\vert A \rangle$, configurations that are &quot;closer&quot; to the solved state would be more likely. Some clever Fourier-like transform on $\vert B \rangle$ might be able to measure how uniformly distributed $\vert A \rangle$ is.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To me this feels like something a quantum computer may be good at.  For example, if $\vert A \rangle$ hasn't been uniformly mixed by all of the words in $\vert B\rangle$, then some configurations are more likely than others, e.g. $\vert A \rangle$ is more &quot;constant&quot;; whereas if $\vert A \rangle$ &lt;em&gt;has&lt;/em&gt; been fully mixed by all of the walks, then $\vert A \rangle$ is more &quot;balanced&quot;.  But my inuition about both quantum algorithms and Markov chains is not strong enough to get very far.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;EDIT&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Contrast this question with the quantum knot verification problem.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the quantum knot verification, a merchant is given a quantum coin as a state $\vert K \rangle$ of all knots that have a particular invariant.  In order to verify the quantum coin, she applies a Markov chain $M$ to transition $\vert K \rangle$ to &lt;em&gt;itself&lt;/em&gt; (if it's a valid coin.)  She must apply this Markov chain and measure the result at least $t$ times, but otherwise she has no way to construct $\vert K \rangle$ on her own (lest she could forge the coin.)  So if she's given a valid coin, she's given a state that she &lt;em&gt;can't produce on her own&lt;/em&gt;, along with a Markov chain as a matrix $M$, and she presumably knows the mixing time $t$; she's required to test that $\vert K \rangle$ is valid.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the present question, it's probably pretty &lt;em&gt;easy&lt;/em&gt; to generate $\vert RC \rangle$ of all Rubik's cube permutations.  The quantum circuit corresponding to the Markov chain, call it $S$, of Singmaster moves, is also probably pretty easy to build.  However, the mixing time $t$ is unknown, and is the one thing to be determined.&lt;/p&gt;&#xA;" OwnerUserId="2927" LastEditorUserId="2927" LastEditDate="2018-08-06T22:50:21.120" LastActivityDate="2018-08-09T00:04:54.733" Title="Can a quantum computer easily determine the mixing time of the Rubik's cube group?" Tags="&lt;quantum-algorithms&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="3933" PostTypeId="1" CreationDate="2018-08-03T23:01:21.147" Score="12" ViewCount="119" Body="&lt;p&gt;The quantum effects of the FMO complex (photosynthetic light harvesting complex found in green sulfur bacteria) have been well studied as well as the quantum effects in other photosynthetic systems. One of the most common hypotheses for explaining these phenomenon (focusing on FMO complex) is Environment-Assisted Quantum Transport (ENAQT) originally described by &lt;a href=&quot;https://arxiv.org/abs/0807.0929&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rebentrost et al.&lt;/a&gt;. This mechanism describes how certain quantum networks can &quot;use&quot; decoherence and environment effects to improve the efficiency of quantum transport. Note that the quantum effectss arise from the transport of &lt;em&gt;excitons&lt;/em&gt; from one pigment (chlorophyll) in the complex to another. (There is a &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1854/quantum-simulation-of-environment-assisted-quantum-walks-in-photosynthetic-energ&quot;&gt;question&lt;/a&gt; that discusses the quantum effects of the FMO complex in a little more detail).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Given that this mechanism allows for quantum effects to take place at room temperatures without the negative effects of decoherence, &lt;strong&gt;are their any applications for quantum computing?&lt;/strong&gt; There are some examples of artificial systems that utilize ENAQT and related quantum effects. However, they present biomimetic solar cells as a potential application and do not focus on the applications in quantum computing.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Originally, it was &lt;a href=&quot;https://www.nature.com/articles/nature05678&quot; rel=&quot;nofollow noreferrer&quot;&gt;hypothesized&lt;/a&gt; that the FMO complex performs a Grover's search algorithm, however, from what I understand, it has now since been showed that this is not true.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There have been a couple studies that use chromophores and substrates not found in biology (will add references later). However, I would like to focus on &lt;strong&gt;systems that use a biological substrate.&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Even for biological substrates there are a couple examples of &lt;em&gt;engineered&lt;/em&gt; systems that use ENAQT. For example, a &lt;a href=&quot;https://www.nature.com/articles/nmat4448#methods&quot; rel=&quot;nofollow noreferrer&quot;&gt;virus-based system&lt;/a&gt; was developed using genetic engineering. A &lt;a href=&quot;https://www.nature.com/articles/nmat5033&quot; rel=&quot;nofollow noreferrer&quot;&gt;DNA-based excitonic circuit&lt;/a&gt; was also developed. However, most of these examples present photovoltaics as a main example and not quantum computing.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1311.4688&quot; rel=&quot;nofollow noreferrer&quot;&gt;Vattay and Kauffman&lt;/a&gt; was (AFAIK) the first to study the quantum effects as quantum biological computing, and proposed a method of engineering a system similar to the FMO complex for quantum computing.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;How could we use this mechanism to build new types of computers? In&#xA;  the light harvesting case the task of the system is to transport the&#xA;  exciton the fastest possible way to the reaction center whose position&#xA;  is known. In a computational task we usually would like to find the&#xA;  minimum of some complex function $f_n$. For the simplicity let this&#xA;  function have only discrete values from 0 to K. If we are able to map&#xA;  the values of this function to the electrostatic site energies of the&#xA;  chromophores $H_{nn} = \epsilon_0 f_n$ and we deploy reaction centers&#xA;  near to them trapping the excitons with some rate $κ$ and can access&#xA;  the current at each reaction center it will be proportional with the&#xA;  probability to find the exciton on the chromophore $j_n ∼ κ\rho_{nn}$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;How can the quantum effects of the FMO complex be used on a biological substrate for quantum computing? Given that the quantum effects occur due to the transport of excitons on network structures, could ENAQT provide more efficient implementations of network-based algorithms (ex: shortest path, traveling salesman, etc.)?&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;P.S. I will add more relevant references if needed. Also, feel free to add relevant references as well.&lt;/p&gt;&#xA;" OwnerUserId="141" LastEditorUserId="141" LastEditDate="2018-08-28T02:00:40.313" LastActivityDate="2018-08-28T02:00:40.313" Title="Does the quantum coherence in the FMO complex have any significance to quantum computing (on a biological substrate)?" Tags="&lt;quantum-computer&gt;&lt;quantum-decoherence&gt;&lt;biocomputing&gt;&lt;quantum-biology&gt;" AnswerCount="1" CommentCount="10" FavoriteCount="3" />
  <row Id="3934" PostTypeId="2" ParentId="3918" CreationDate="2018-08-04T05:42:00.680" Score="2" Body="&lt;p&gt;A coin is not a great analogy for a quantum system. A (slightly) better one is a box that contains 3 coins. There are 3 windows, labelled x, y and z. The box is rigged so that you can only open one window at a time. When you open a window, you can see the heads/tails state of the corresponding coin, but the other two coins get flipped, and you can’t see what happens to them (unless you open another window, but then you know nothing anymore about the window you just had open because that coin has been flipped again).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I’m not sure that this attempt at an analogy scales very well to larger dimensional systems, because you probably can’t, in general, describe the algebra of the system using a set of mutually anti-commuting observables, so your rules for how the different coins flip would have to be more complicated. The qudit analogy has $d^2-1$ coins. For example, 2 qubits have 15 coins, each corresponds to a tensor product of 2 Paulis. You can open sets of windows that correspond to commuting observables. The other coins get flipped upon opening, but there are some consistency conditions that some outcomes of coin flips are entirely determined by the outcomes of other coin flips. It becomes messy very quickly...&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h1&gt;Further explanation (expanding some of the Mathematics)&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Any density matrix of a qudit is described by a $d\times d$ matrix. You can pick any basis of matrices that you like to decompose that (Hermitian) matrix. You'll need $d^2$ of them, but one of those terms is always $\mathbb{I}/d$, which I don't need to count. For example, a basis for the qubit are the Pauli matrices $X$, $Y$ and $Z$ (and $\mathbb{I}$). If you correspond each of these basis elements to measurement operators, because there are 2 distinct eigenvalues, you get two measurement outcomes (like head/tails on a coin). If two operators commute, you can simultaneously know the two measurement outcomes. If the two observables anti-commute, the corresponds to maximal uncertainty between the two observables. In other words, you measure one observable (say $Z$), and the other observables ($X$ and $Y$, because both anticommute with $Z$) are complete uncertain, i.e. the coins are flipped.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For qubits, all 3 observables pair-wise anticommute: $\{X,Y\}=\{Y,Z\}=\{X,Z\}=0$, so whichever measurement you choose, the other two observables reset.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, for two qubits, the relationships are not nearly so simple. You have all possible terms&#xA;$$&#xA;\mathbb{I}\otimes X \qquad \mathbb{I}\otimes Y \qquad \mathbb{I}\otimes Z \\&#xA;X\otimes \mathbb{I} \qquad Y\otimes \mathbb{I} \qquad Z\otimes \mathbb{I} \\&#xA;X\otimes X \qquad X\otimes Y \qquad X\otimes Z \\&#xA;Y\otimes X \qquad Y\otimes Y \qquad Y\otimes Z \\&#xA;Z\otimes X \qquad Z\otimes Y \qquad Z\otimes Z&#xA;$$&#xA;You can see that not all of these pair-wise anticommute, because $\mathbb{I}\otimes Z$ and $Z\otimes \mathbb{I}$ commute, for example. So, we could simultaneously measure the set of observables $\mathbb{I}\otimes Z$, $Z\otimes \mathbb{I}$ and $Z\otimes Z$, but all other observables are completely uncertain. Overall, you'd have 15 coins and there are sets of 3 windows that you can open simultaneously, and all other coins are flipped at that instant.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you want to describe the same thing for qutrits, it gets more messy because you can use a basis where everything gives 2 answers, but there's not a perfect division into whether operators commute or anticommute, so you get partial connections between coins which are messier to give a classical equivalent of.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-08-05T08:01:23.260" LastActivityDate="2018-08-05T08:01:23.260" CommentCount="1" />
  <row Id="3935" PostTypeId="1" AcceptedAnswerId="3941" CreationDate="2018-08-04T11:05:54.010" Score="3" ViewCount="94" Body="&lt;p&gt;Having n qubits, I want to have the unitary described a controlled operation.&#xA;Say for example you get as input a unitary, an index for a controlled qubit and another for a target.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;How would you code this unitary operation?&lt;/p&gt;&#xA;" OwnerUserId="4127" LastEditorUserId="26" LastEditDate="2018-08-04T17:32:35.320" LastActivityDate="2018-08-06T07:21:48.817" Title="How do we code the matrix for a controlled operation knowing the control qubit, the target qubit and the $2\times 2$ unitary?" Tags="&lt;quantum-gate&gt;&lt;quantum-simulation&gt;" AnswerCount="2" CommentCount="4" />
  <row Id="3936" PostTypeId="1" AcceptedAnswerId="3938" CreationDate="2018-08-04T11:46:11.020" Score="6" ViewCount="111" Body="&lt;p&gt;Say I have a string representing the operations of a quantum circuit.&#xA;I want to have the unitary operator representing it.&#xA;Is there a tool for doing so in Python or else?&lt;/p&gt;&#xA;" OwnerUserId="4127" LastEditorUserId="26" LastEditDate="2018-08-04T17:33:06.190" LastActivityDate="2018-08-07T21:19:42.303" Title="Is there a tool that can give you the unitary representing a quantum circuit from just a string?" Tags="&lt;quantum-gate&gt;&lt;quantum-simulation&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="3937" PostTypeId="2" ParentId="3936" CreationDate="2018-08-04T13:48:54.587" Score="1" Body="&lt;p&gt;Normally, quantum simulators ask you to specify a starting state, for example,  all qubits initially in state $|0\rangle$, and then they give you the final state after that initial state evolves through all of the SEO (sequence of elementary operations). This is performed in my software Qubiter by the class SEO_simulator.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, a well designed simulator package should also multiply the SEO and give you the unitary matrix it represents. This is done in &lt;a href=&quot;https://github.com/artiste-qb-net/qubiter&quot; rel=&quot;nofollow noreferrer&quot;&gt;Qubiter&lt;/a&gt; by the class &lt;code&gt;SEO_MatrixProduct&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I have described the features of Qubiter in some of my other answers; it is my own code.&lt;/p&gt;&#xA;" OwnerUserId="1974" LastEditorUserId="91" LastEditDate="2018-08-07T21:19:42.303" LastActivityDate="2018-08-07T21:19:42.303" CommentCount="0" />
  <row Id="3938" PostTypeId="2" ParentId="3936" CreationDate="2018-08-04T13:52:58.263" Score="4" Body="&lt;p&gt;You can use Python with Qiskit. Say your string representation is written using OpenQASM syntax.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;qasm = &quot;&quot;&quot;&#xA;OPENQASM 2.0;&#xA;include &quot;qelib1.inc&quot;;&#xA;qreg q[2];&#xA;h q[0];&#xA;t q[1];&#xA;cx q[0], q[1];&#xA;&quot;&quot;&quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;You can build a circuit out of this and simulate it on a unitary simulator:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import qiskit as qk&#xA;import numpy as np&#xA;circuit = qk.load_qasm_string(qasm)&#xA;result = qk.execute(circuit, 'local_unitary_simulator').result()&#xA;print(np.round(result.get_unitary(), 1))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Yields:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[[ 0.7+0.j   0.7-0.j   0. +0.j   0. +0.j ]&#xA;[ 0. +0.j   0. +0.j   0.5+0.5j -0.5-0.5j]&#xA;[ 0. +0.j   0. +0.j   0.5+0.5j  0.5+0.5j]&#xA;[ 0.7+0.j  -0.7+0.j   0. +0.j   0. +0.j ]]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="2503" LastActivityDate="2018-08-04T13:52:58.263" CommentCount="0" />
  <row Id="3939" PostTypeId="2" ParentId="3935" CreationDate="2018-08-04T14:59:22.240" Score="3" Body="&lt;p&gt;I would solve it like that: suppose you have CNOT gate; it's unitary matrix can be written as a sum of tensor products&#xA;$$&#xA;\begin{pmatrix}1 &amp;amp; 0 \\&#xA;0 &amp;amp; 0&#xA;\end{pmatrix}\otimes&#xA;\begin{pmatrix}1 &amp;amp; 0 \\&#xA;0 &amp;amp; 1&#xA;\end{pmatrix}+&#xA;\begin{pmatrix}0 &amp;amp; 0 \\&#xA;0 &amp;amp; 1&#xA;\end{pmatrix}\otimes&#xA;\begin{pmatrix}0 &amp;amp; 1 \\&#xA;1 &amp;amp; 0&#xA;\end{pmatrix}&#xA;$$&#xA;(this is another way to say: if first qubit is 0, the second qubit is unchanged; if first qubit is 1, the second qubit is swapped).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now if we have more qubits, we need to insert additional identity matrices&#xA;$$&#xA;\begin{pmatrix}1 &amp;amp; 0 \\&#xA;0 &amp;amp; 1&#xA;\end{pmatrix}&#xA;$$&#xA;into the tensor products from the left, from the right, or into the middle, depending on the indexes of control and target CNOT qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;PS: I also assumed that the index of control qubit is less than the index of target qubit; if this is not the case swap the terms in the tensor products in the first equation.&lt;/p&gt;&#xA;" OwnerUserId="2105" LastEditorUserId="2105" LastEditDate="2018-08-05T03:31:29.770" LastActivityDate="2018-08-05T03:31:29.770" CommentCount="0" />
  <row Id="3940" PostTypeId="2" ParentId="3893" CreationDate="2018-08-04T17:02:55.107" Score="2" Body="&lt;p&gt;I think you are misunderstanding what a basis vector is. $|0\rangle$ and $|1\rangle$ are basis vectors and these are referred to a rectilinear basis vectors and $\frac{|0\rangle+|1\rangle}{\sqrt{2}} = |+\rangle$ and $\frac{|0\rangle-|1\rangle}{\sqrt{2}} = |-\rangle$ are basis vectors too and these are referred to as diagonal basis vectors. The hadamard transform takes a vector from one basis representation to another. If you take a dot product between the diagonal basis vectors i.e $\langle+|-\rangle$ you will realize that they are orthonormal. It is entirely possible for a Hilbert space and more generally a vector space to have multiple sets of basis vectors.&lt;/p&gt;&#xA;" OwnerUserId="422" LastActivityDate="2018-08-04T17:02:55.107" CommentCount="0" />
  <row Id="3941" PostTypeId="2" ParentId="3935" CreationDate="2018-08-05T05:14:03.127" Score="2" Body="&lt;p&gt;Here’s some pseudo code, where &lt;code&gt;id(n)&lt;/code&gt; creates an $2^n\times 2^n$ identity matrix, and &lt;code&gt;tensor(A,B,...)&lt;/code&gt; returns $A\otimes B\otimes\ldots$.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&#xA;def cU(ctrl,targ,U,size):&#xA;    '''implement controlled-U with:&#xA;          control qubit ctrl,&#xA;          target qubit targ,&#xA;          within a set of size qubits'''&#xA;#check input ranges&#xA;    assert 1&amp;#60;=ctrl&amp;#60;=size&#xA;    assert 1&amp;#60;=targ&amp;#60;=size&#xA;    assert ctrl&amp;#60;&amp;#62;targ&#xA;    assert ctrl,targ,size &amp;#8714; &amp;#8484;&#xA;#ensure U is a 2x2 unitary&#xA;    assert U&amp;#8714;&amp;#8450;&lt;sup&gt;2x2&lt;/sup&gt;&#xA;    assert U.U&lt;sup&gt;&amp;dagger;&lt;/sup&gt;=id(2)&#xA;#the actual code&#xA;    if ctrl&amp;#60;targ:&#xA;        return id(size)+tensor(id(ctrl-1),id(1)-Z,id(targ-1-ctrl),U-id(1),id(size-targ))/2&#xA;    else:&#xA;        return id(size)+tensor(id(targ-1),U-id(1),id(ctrl-1-targ),id(1)-Z,id(size-ctrl))/2&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;However, remember that usually you're trying to calculate the action of a unitary on some state vector. It will be far more memory efficient to calculate that application directly, rather than first calculating the unitary matrix and applying it to the state vector.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To understand where this formula came from, think about the two-qubit version, where the first qubit is the control qubit. You'd normally write the unitary as&#xA;$$&#xA;|0\rangle\langle 0|\otimes\mathbb{I}+|1\rangle\langle 1|\otimes U.&#xA;$$&#xA;Let's rewrite this as&#xA;$$&#xA;(\mathbb{I}-|1\rangle\langle 1|)\otimes\mathbb{I}+|1\rangle\langle 1|\otimes U=\mathbb{I}\otimes\mathbb{I}+|1\rangle\langle 1|\otimes (U-\mathbb{I}).&#xA;$$&#xA;It can be easier to write things in terms of Pauli matrices, so&#xA;$$&#xA;|1\rangle\langle 1|=(\mathbb{I}-Z)/2.&#xA;$$&#xA;To get the same unitary on a different number of qubits, you just need to pad with identity matrices everywhere.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-08-06T07:21:48.817" LastActivityDate="2018-08-06T07:21:48.817" CommentCount="4" />
  <row Id="3942" PostTypeId="2" ParentId="2414" CreationDate="2018-08-05T10:40:39.633" Score="3" Body="&lt;p&gt;To start off, I would really suggest you to read this review on &quot;&lt;a href=&quot;https://arxiv.org/pdf/quant-ph/0410100.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum information with continuous variables(cv)&lt;/a&gt;&quot;. It covers most of your questions with cv architecture. Since it is a very big review, I will try to address your questions with what I can remember from reading that paper and glancing over it again now.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For discrete variables(dv), as you have mentioned, Knill and Laflamme have pioneered the LOQC. But this approach was translated to cvs shortly after the proposal for realization of cv teleportation by Braunstein &lt;em&gt;et al.&lt;/em&gt; They showed that &lt;a href=&quot;https://www-users.cs.york.ac.uk/schmuel/papers/Aetal98.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;cv quantum error correction codes can be implemented using only linear optics and resources of squeezed light&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now coming to the universality of this type of quantum computer, they have also shown in the paper that a universal quantum computer for the amplitudes of the electromagnetic field might be constructed using linear optics, squeezers and at least one further non-linear optical element such as the Kerr effect(pg.48~50). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I will try to summarize their proof verbally as simple as I can. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;1) It is true that, for universal qcs, logical operations can only affect few variables in the form of qubit logic gates and by stacking those gates, it can effect any unitary transformation over a finite number of those variables to any desired degree of precision.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2) The argument is that since an arbitrary unitary transformation over even a single cv requires an infinite number of parameters to define, it typically cannot be approximated by any finite number of quantum operations.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;3) This problem is tackled by showing that a notion of universal quantum computation over cvs for various subclasses of transformations, such as Hamiltonians (which are polynomial functions of the operators corresponding to the cvs). A set of continuous quantum operations will be termed universal for a particular set of transformations if one can, by a finite number of applications of the operations, approach arbitrarily closely to any transformation in the set.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;4) The result is a very lengthy mathematical proof of constructing quadratic Hamiltonians for EM fields.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So to answer your question, even though, as you mentioned, the squeezing of light adds external noise to qc, I believe that it can be used for error correcting the same noise. Along with that, the claim of quantum speedup arrives from the fact that to generate all unitary transformations given by an arbitrary polynomial Hermitian Hamiltonian (as is necessary to perform universal cv quantum computation), one must include a gate described by a Hamiltonian other than an inhomogeneous quadratic in the canonical operators. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;These nonlinear transformations can be used in cv algorithms and may provide a significant speedup over any classical process.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So to conclude, yes cv quantum computation looks optimistic because most of it is theoretical at this point. There are only a few experimental confirmations of the cv architecture like &quot;squeezed-state EPR entanglement&quot;, &quot;coherent state quantum teleportation&quot; etc. But the recent experiments in &quot;quantum key distribution&quot; and &quot;quantum memory effect&quot; shows that continuous variable quantum computers have the potential to be as effective as their discrete counterparts if not more for some tasks. &lt;/p&gt;&#xA;" OwnerUserId="419" LastActivityDate="2018-08-05T10:40:39.633" CommentCount="5" />
  <row Id="3943" PostTypeId="1" AcceptedAnswerId="3944" CreationDate="2018-08-05T17:41:03.960" Score="5" ViewCount="118" Body="&lt;p&gt;I've been reading through &quot;Quantum Computing: A Gentle Introduction&quot;, and I've been struggling with this particular problem. How would you create the circuit diagram, and what kind of reasoning would lead you to it?&lt;/p&gt;&#xA;" OwnerUserId="4287" LastActivityDate="2018-08-07T21:25:08.393" Title="How do you implement the Toffoli gate using only single-qubit and CNOT gates?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-computer&gt;&lt;quantum-gate&gt;" AnswerCount="2" CommentCount="1" FavoriteCount="1" />
  <row Id="3944" PostTypeId="2" ParentId="3943" CreationDate="2018-08-05T18:10:40.613" Score="6" Body="&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/DgKJu.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/DgKJu.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;is the decomposition (I took this from google images, originally on &lt;a href=&quot;https://www.semanticscholar.org/paper/On-the-CNOT-cost-of-TOFFOLI-gates-Shende-Markov/860a047de8a2fe56ab1f9fc0391da54495191266&quot; rel=&quot;noreferrer&quot;&gt;this website.&lt;/a&gt;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In order to understand how to decompose it, we can look at it's base structure. The idea is that we combine gates that cancel out, but put CNOT gates in between such that if the specific NOT is executed, the gates don't cancel. This is how generic controlled-U gates are implemented for arbitrary U. as explained in Quantum Computation and Quantum Information by Nielsen and Chuang.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For a simpler example, imagine you have a gate U and you want to make a controlled-U from it, with just one control. To do so you find single qubit gates A, B, C such that CBA = I, but CXBXA = U. By putting a CNOT where every X gate must be applied, you have created a control-U gate. Similar logic applies in the CC-U case, except you need EDCBA  = EXDCXBA = EDXCBXA = I up to a phase, and EXDXCXBXA = U. Where the first and third X corresponds to a CNOT from one control, and the second and fourth are from the other. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Essentially the intuition for this structure is that you want the have the bottom line cancel out if either control is zero, and to be your desired unitary if they both apply the not gates.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For additional reading check out pages 181-183 in Nielsen and Chuang. [EDIT: &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/proxy/tutorial/full-user-guide/004-Quantum_Algorithms/061-Basic_Circuit_Identities_and_Larger_Circuits.html&quot; rel=&quot;noreferrer&quot;&gt;The link @Norbert Schuch posted&lt;/a&gt; also contains the same info, and you don't need to track down a textbook.]&lt;/p&gt;&#xA;" OwnerUserId="3056" LastEditorUserId="3056" LastEditDate="2018-08-05T21:32:22.463" LastActivityDate="2018-08-05T21:32:22.463" CommentCount="0" />
  <row Id="3946" PostTypeId="2" ParentId="3898" CreationDate="2018-08-06T03:28:26.163" Score="3" Body="&lt;p&gt;One recent breakthrough which is not covered in that survey is &lt;em&gt;cheat sheets&lt;/em&gt;. See, &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;em&gt;Separations in communication complexity using cheat sheets and information complexity&lt;/em&gt;;&#xA;  Anurag Anshu, Aleksandrs Belovs, Shalev Ben-David, Mika Göös, Rahul Jain, Robin Kothari, Troy Lee, and Miklos Santha;&#xA;  &lt;a href=&quot;https://arxiv.org/abs/1605.01142&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv:1605.01142 [quant-ph]&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;It might be a good idea to first familiarize yourself with the cheat sheet framework.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;em&gt;Separations in query complexity using cheat sheets&lt;/em&gt;;&#xA;  Scott Aaronson, Shalev Ben-David, Robin Kothari;&#xA;  &lt;a href=&quot;https://arxiv.org/abs/1511.01937v1&quot; rel=&quot;nofollow noreferrer&quot;&gt;arXiv:1511.01937 [quant-ph]&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Personally, I like thinking about query complexity as a whole instead of specializing in communication complexity. A lot of theorems in traditional query complexity can be &lt;em&gt;lifted&lt;/em&gt; into communication complexity, and indeed that is what they do in the above paper.&lt;/p&gt;&#xA;" OwnerUserId="1813" LastActivityDate="2018-08-06T03:28:26.163" CommentCount="0" />
  <row Id="3947" PostTypeId="1" AcceptedAnswerId="3949" CreationDate="2018-08-06T06:15:11.103" Score="5" ViewCount="368" Body="&lt;p&gt;When I look at most circuits (admittedly small sample as I'm a beginner), the Hadamard gate is used a lot to prepare a superposition from say the $\mid0\rangle$ state.&lt;br&gt;&#xA;But upon a little reflection, we can prepare a superposition using a $\dfrac{\pi}{2}$ rotation about the X axis.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I do know that a successive application of the Hadamard gate yields the initial state back (for any state).&lt;br&gt;&#xA;If we have one of $\mid0\rangle$ or $\mid1\rangle$, we can recover them using a succession of said rotation followed by a NOT gate (Pauli-X).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So why is the Hadamard gate preferred to create superpositions when it uses more gates (rotation about Z then rotation about X then rotation about Z again)?&lt;br&gt;&#xA;If it is because the Hadamard gate allows recovery of any initial state, why is that property so important? (Even when not actually used when I look at the examples I see.)&lt;/p&gt;&#xA;" OwnerUserId="2417" LastEditorUserId="2417" LastEditDate="2018-08-06T20:51:50.263" LastActivityDate="2018-08-07T08:00:47.517" Title="Advantange of Hadamard gate over rotation about the X axis for creating superpositions" Tags="&lt;quantum-gate&gt;&lt;superposition&gt;" AnswerCount="3" CommentCount="3" FavoriteCount="2" />
  <row Id="3948" PostTypeId="2" ParentId="3947" CreationDate="2018-08-06T07:00:23.630" Score="3" Body="&lt;p&gt;Any Hermitian quantum gate $U$ is &quot;self-recovering&quot;. This is because $U$ is unitary, and&#xA;$$UU^{\dagger}=U^{\dagger}U=I$$&#xA;If $U$ is also Hermitian, then $U=U^{\dagger}$ and&#xA;$$UU=I$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Hadamard gate prepares $\frac{1}{\sqrt{2}}(|0\rangle + |1\rangle)$ superposition from $|0\rangle$ state. If you need this superposition, you use Hadamard. If you need a different superposition, $\alpha|0\rangle + \beta|1\rangle$ with some $\alpha$ and $\beta$, you need a different gate or a sequence of gates; Hadamard gate has no advantage here.&lt;/p&gt;&#xA;" OwnerUserId="2105" LastEditorUserId="2105" LastEditDate="2018-08-06T09:50:35.523" LastActivityDate="2018-08-06T09:50:35.523" CommentCount="7" />
  <row Id="3949" PostTypeId="2" ParentId="3947" CreationDate="2018-08-06T07:09:30.973" Score="4" Body="&lt;p&gt;It's mostly about simplicity and adopted convention. In the end, this is basically the same question as &quot;why should I pick a universal set of gates A rather than a universal set B?&quot; (see &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/1581/1837&quot;&gt;here&lt;/a&gt;). Experimentalists would pick the universal set they have available. Theorists just pick something that they like to work with, and eventually a convention is adopted. But it doesn't matter which convention they adopt because any universal set is easily converted into any other universal set, and it is (or should be) understood that the quantum circuits describing algorithms are not what you actually want to run on a quantum computer: you need to recompile them for the available gate set and optimise based on the available architecture (and this process is unique to each architecture).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You could use operations such as $\sqrt{X}$, but they are a little bit more fiddly because of all the imaginary numbers that appear. Or there's $\sqrt{Y}$ which gives an even more direct comparison to $H$, avoiding imaginary numbers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One of the main purposes of $H$ in a quantum circuit is to prepare uniform superpositions: $H|0\rangle=(|0\rangle+|1\rangle)/\sqrt{2}$. But $\sqrt{Y}$ also does this: $\sqrt{Y}|1\rangle=(|0\rangle+|1\rangle)/\sqrt{2}$. When you start combining multiple Hadamards on unknown input states (i.e. the Hadamard transform), it has a particularly convenient structure&#xA;$$&#xA;H^{\otimes n}=\frac{1}{\sqrt{2^n}}\sum_{x,y\in\{0,1\}^n}(-1)^{x\cdot y}|x\rangle\langle y|.&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Hadamard gives you some very nice inter-relations (reflecting basis changes between pairs of mutually unbiased bases),&#xA;$$&#xA;HZH=X\qquad HXH=Z \qquad HYH=-Y.&#xA;$$&#xA;It also enables relations between controlled-not and controlled phase, and between controlled-not in two different directions (swapping control and target). There are similar relations for $\sqrt{Y}$:&#xA;$$&#xA;\sqrt{Y}Z\sqrt{Y}^\dagger=YZ=iX \qquad \sqrt{Y}X\sqrt{Y}^\dagger=YX=-iZ\qquad \sqrt{Y}Y\sqrt{Y}^\dagger=Y&#xA;$$&#xA;Part of this looking (slightly) nicer is because, as stated in the question, $H^2=\mathbb{I}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One way that many courses introduce the basic idea of quantum computation, and interference, is to use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mach%E2%80%93Zehnder_interferometer&quot; rel=&quot;nofollow noreferrer&quot;&gt;Mach-Zehnder interferometer&lt;/a&gt;. This consists of two beam splitters which, mathematically, should be described by $\sqrt{X}$ (or $\sqrt{Y}$ would do). Indeed, this is important for a first demonstration because of course these operations are &quot;square root of not&quot;, which you can prove is logically impossible classically. However, once that initial introduction is over, theorists will often substitute the beam splitter operation for Hadamard, just because it makes everything slightly easier.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-08-07T08:00:47.517" LastActivityDate="2018-08-07T08:00:47.517" CommentCount="15" />
  <row Id="3950" PostTypeId="2" ParentId="3932" CreationDate="2018-08-06T07:40:02.150" Score="5" Body="&lt;p&gt;It's an interesting question which is better than most &quot;is there a quantum algorithm for x?&quot; questions. I don't know of an existing quantum algorithm. Let me describe what I think would be a typical first attempt, and why that fails. At the end I'll describe a couple of things that might lead to some improvements.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;First Attempt at an Algorithm&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Let's say I want to test a particular mixing time $t$. I'm going to create one register, $RC$ to contains sufficient workspace to hold any of the possible configurations of the Rubik's cube. The initial state of this is a product state that corresponds to the starting state of the cube.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then I'm going to make $t$ ancilla registers, $A_1$ to $A_t$. Each of these is the same size as the number of possible Singmaster moves, and is prepared as a uniform superposition across all possible basis elements. Then for each $i=1,\ldots t$, we apply a controlled-unitary from $A_i$ to $RC$ where the register $A_i$ specifies which Singmaster move is applied on $RC$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;After all this, if we just look at $RC$, it should be in the maximally mixed state if the mixing has happened as desired. The problem is how to test whether or not this output is the maximally mixed state. There are useful techniques such as &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0203016&quot; rel=&quot;noreferrer&quot;&gt;this one&lt;/a&gt;, but what accuracy do we require (i.e. how many repetitions?). We'll need about $|A|^t$ to be sure, I think.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In fact, this way of doing things is just as bad as doing it classically: you could replace the initial state of each of the $A_i$ with $\mathbb{I}/2^{|A_i|}$ and it wouldn't change the outcome. But this really is just like making a random choice each time and running many times, checking for the correct output distribution.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Possible Improvements&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Running as I described, the output density matrix $\rho$ (on $RC$) must be diagonal. That means that the uniform superposition $|u\rangle$ over all basis states is an eigenstate if and only if the system is maximally mixed. I would if one could combine this observation with some sort of amplitude amplification to get a mild speed-up. Note that $\rho^k|u\rangle$ builds up a difference very rapidly from $|u\rangle$ if the state is not an eigenvector.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Aside from that, you probably need to do something smarter with the ancilla registers. There is some hope that this might be possible because there's quite a lot of group structure built in to the Rubik's cube. One thing that you might try is to see whether you can replace all $t$ ancilla registers with a single register, apply Hadmard gates on every qubit of the register in between each round of controlled-unitaries. It might be that all this does is give you an efficiency saving in terms of the number of qubits compared to my original suggestion. It might not even do that.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Whether either of those work directly, I don't know. Still, I think the key principles are to find some useful group structure, and find a way that amplitude amplification can be applied.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You might find it useful to read up about &lt;a href=&quot;https://arxiv.org/abs/1208.0692&quot; rel=&quot;noreferrer&quot;&gt;unitary designs&lt;/a&gt;. This is certainly a distinct problem from what we're talking about here, but some of the technical tools might be useful. Roughly speaking, the idea is that a set of unitaries $\{U\}$ is a $t$-design if random application of these unitaries lets one simulate a truly random unitary (drawn from the Haar measure) on output functions $f$ which, when expanded using a Taylor series, are accurate up to degree $t$. The approximate connection here is that if you take the unitaries representing a sequence of $t$ Singmaster moves as $\{U\}$, it would be sufficient if this set were a 2-design (if you get $\text{Tr}(\rho^2)$ correct, you're done).&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-08-06T08:17:32.567" LastActivityDate="2018-08-06T08:17:32.567" CommentCount="4" />
  <row Id="3951" PostTypeId="2" ParentId="3943" CreationDate="2018-08-06T15:14:13.653" Score="3" Body="&lt;p&gt;You also have this one with V the square root of NOT gate:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/fKlkb.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/fKlkb.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you have as control qubits :&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(0,0) : do nothing;&#xA;(0,1) : apply V and its conjugate which is identity;&#xA;(1,0) : same but inversed;&#xA;(1,1) : apply V twice which correspond to your NOT gate.&lt;/p&gt;&#xA;" OwnerUserId="4127" LastActivityDate="2018-08-06T15:14:13.653" CommentCount="0" />
  <row Id="3952" PostTypeId="2" ParentId="3947" CreationDate="2018-08-06T17:09:16.600" Score="3" Body="&lt;p&gt;I think the major advantages of the Hadamard gate are &quot;usability&quot; stuff, as opposed to fundamental mathematical stuff. It's just easier to remember and simpler to apply.&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;The Hadamard gate's marix is real and symmetric. Makes it easy to remember.&lt;/li&gt;&#xA;&lt;li&gt;Hadamard is its own inverse. Makes it easy to optimize in circuits. Any two Hs that meet cancel out; whereas $\sqrt{X}$ tends to meet $\sqrt{X}$ as often as $\sqrt{X}^{-1}$ leaving behind $X$ operations.&lt;/li&gt;&#xA;&lt;li&gt;Hadamard's effect on operators is easy to remember: swap X for Z. Whereas for $\sqrt{X}$ style operations you need to remember a right hand rule. If you pass a hadamard over a CZ, it turns into a CNOT. If you pass a $\sqrt{Y}$ over a CZ, whether you get a CNOT or a CNOT+Z depends on whether you went left-to-right or right-to-left.&lt;/li&gt;&#xA;&lt;li&gt;In the surface code you need twist defects or distilled states to do $\sqrt{X}$ gates. Hadamard operations need neither (though the twists are more efficient...).&lt;/li&gt;&#xA;&lt;li&gt;The Hadamard is unique. There are two values $M$ such that $M^2 = X$, and so you need an agreed upon convention for which one $\sqrt{X}$ is.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;PS: it would be better to compare a Hadamard to a 90 degree rotation about the &lt;em&gt;Y&lt;/em&gt; axis, not the X axis, because the Hadamard operation is equivalent $\sqrt{Y}$ up to Pauli operations ($H \propto Z \cdot \sqrt{Y}$).&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-08-06T19:26:37.547" LastActivityDate="2018-08-06T19:26:37.547" CommentCount="0" />
  <row Id="3953" PostTypeId="1" AcceptedAnswerId="3958" CreationDate="2018-08-06T19:13:32.477" Score="0" ViewCount="57" Body="&lt;p&gt;What Hilbert space of dimension greater than 4.3e19 would be most convenient for working with the &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/3932/can-a-quantum-computer-easily-determine-the-mixing-time-of-the-rubiks-cube-grou&quot;&gt;Rubik's Cube&lt;/a&gt; verse one qudit?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The cardinality of the &lt;a href=&quot;https://wikipedia.org/wiki/Rubik%27s_Cube_group&quot; rel=&quot;nofollow noreferrer&quot;&gt;Rubik's Cube group&lt;/a&gt; is given by:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/cae85de130092535db33b0b2ae7b7ff8cc8f24a3&quot; alt=&quot;enter image description here&quot;&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Examples&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;66 Qubits yields ~7.378697629484e19 states (almost more than double the number of states needed)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;42 Qutrits yields ~1.094189891315e20 states (more than double the needed states)&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-08-07T07:46:30.800" LastActivityDate="2018-08-07T07:46:30.800" Title="Hilbert space to accurately represent Rubik's Cube" Tags="&lt;qudit&gt;&lt;many-body-systems&gt;" AnswerCount="1" CommentCount="3" />
  <row Id="3954" PostTypeId="1" CreationDate="2018-08-06T21:00:43.807" Score="6" ViewCount="39" Body="&lt;p&gt;Are there any books, courses, tutorials, etc. for studying quantum biology?&#xA;Preferably they provide some introduction/primer on the relevant quantum aspects of the quantum biological systems being described.&lt;/p&gt;&#xA;" OwnerUserId="141" LastEditorUserId="141" LastEditDate="2018-08-07T02:50:13.890" LastActivityDate="2018-08-07T02:50:13.890" Title="Resources for quantum biology" Tags="&lt;resource-request&gt;&lt;quantum-biology&gt;" AnswerCount="0" CommentCount="5" FavoriteCount="1" />
  <row Id="3955" PostTypeId="1" CreationDate="2018-08-07T01:59:38.123" Score="7" ViewCount="198" Body="&lt;p&gt;What's the simplest algorithm (like &lt;a href=&quot;https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm&quot; rel=&quot;noreferrer&quot;&gt;Deutsch's algorithm&lt;/a&gt; and &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/175/how-is-the-oracle-in-grovers-search-algorithm-implemented&quot;&gt;Grover's Algorithm&lt;/a&gt;) for intuitively demonstrating quantum speed-up? And can this algorithm be explained intuitively? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Ideally this would be also illustrate clear how quantum interference is being utilized, and why it is not possible or useful using just &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2595/if-quantum-speed-up-is-due-to-the-wave-like-nature-of-quantum-mechanics-why-not&quot;&gt;interference of classical waves&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="2660" LastActivityDate="2018-08-11T11:17:23.557" Title="Simplest algorithm for intuitively demonstrating quantum speed-up?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-computer&gt;&lt;quantum-information&gt;&lt;classical-computing&gt;&lt;quantum-computing-models&gt;" AnswerCount="3" CommentCount="3" FavoriteCount="2" />
  <row Id="3956" PostTypeId="2" ParentId="3955" CreationDate="2018-08-07T03:02:51.983" Score="0" Body="&lt;p&gt;There is nice example in the &lt;a href=&quot;https://www.youtube.com/watch?time_continue=1&amp;amp;v=F_Riqjdh2oM&quot; rel=&quot;nofollow noreferrer&quot;&gt;Microsoft lecture&lt;/a&gt;. Suppose you have a classical black box with 1 input and 1 output. How many queries you need to determine whether the output is constant or variable? Evidently you need 2 queries; first you input 0, second you input 1; if both outputs are identical you have constant, otherwise variable. It turns out that after you convert the classical black box into a quantum black box you can build a circuit that needs only a single query (the lecture explains how to do it).&lt;/p&gt;&#xA;" OwnerUserId="2105" LastActivityDate="2018-08-07T03:02:51.983" CommentCount="3" />
  <row Id="3957" PostTypeId="1" AcceptedAnswerId="3964" CreationDate="2018-08-07T05:35:22.910" Score="7" ViewCount="78" Body="&lt;p&gt;I want to decompose a Toffoli gate into CNOTs and arbitrary single-qubit gates. I want to minimize the number of CNOTs. I have a locality constraint: because the Toffoli is occurring in a linear array, the two controls are not adjacent to each other (so no CNOTs directly between the controls).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What is the minimum number of CNOTs required to perform this task? What is an example of a circuit which achieves this minimum?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To be specific, this is the layout I have in mind:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1 ---@---&#xA;     |&#xA;2 ---X---&#xA;     |&#xA;3 ---@---&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Each control is adjacent to the target, but the controls are not adjacent to each other.&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-08-07T07:48:13.793" LastActivityDate="2018-08-07T22:37:12.013" Title="Minimum number of CNOTs for Toffoli with non-adjacent controls" Tags="&lt;optimization&gt;&lt;circuit-construction&gt;" AnswerCount="2" CommentCount="1" FavoriteCount="0" />
  <row Id="3958" PostTypeId="2" ParentId="3953" CreationDate="2018-08-07T06:36:29.573" Score="2" Body="&lt;p&gt;This question does not need to be phrased as a quantum question. One can equally ask what classical register can be used to store a string that uniquely identifies each different configuration of the Rubik’s Cube. This is already implicitly answered in the question: you need 27 bits, 14 trits....&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, this is labouring under the assumption that you can easily pick and choose your information carrier, and combine together arbitrary sets with different dimensions, and easily talk about the logic operations on them and how they all interact. This is clearly not how it works in classical: your computer only processes bits (and if you want different dimensional systems, the software can handle the conversion: see, for example, the MixedRadix function in Mathematica), and the same will be true of quantum. A particular experiment will focus on one type of information carrier, and will be able to manipulate a certain number of levels. You might be able to repeat that many times, but you won’t be combining qubits, qutrits etc. So you’ll probably be using qubits, and you just need to find the smallest Hilbert space that’s larger than the required dimension. Again, as indicated by the question, that’s 66 qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Perhaps the concern is that 66 seems like a lot of qubits and we need to make that number as small as possible. Remember that computations will require error correction, which means increasing the number of qubits by several orders of magnitude. One extra qubit doesn’t matter so much on the scale of things.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-08-07T06:36:29.573" CommentCount="7" />
  <row Id="3959" PostTypeId="1" AcceptedAnswerId="4000" CreationDate="2018-08-07T06:46:53.363" Score="9" ViewCount="181" Body="&lt;p&gt;&lt;a href=&quot;https://www.cube20.org/&quot; rel=&quot;noreferrer&quot;&gt;God's number&lt;/a&gt; is the worst case of &lt;a href=&quot;https://wikipedia.org/wiki/God%27s_algorithm&quot; rel=&quot;noreferrer&quot;&gt;God's algorithm&lt;/a&gt; which is&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;a notion originating in discussions of ways to solve the Rubik's Cube puzzle, but which can also be applied to other combinatorial puzzles and mathematical games. It refers to any algorithm which produces a solution having the fewest possible moves, the idea being that an omniscient being would know an optimal step from any given configuration.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Calculating God's number to be 20 took &quot;35 CPU-years of idle (classical) computer time.&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What kind of speed up could be achieved with a quantum approach? &lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-08-08T16:04:06.457" LastActivityDate="2018-08-15T00:14:27.147" Title="Quantum Algorithm for God's Number" Tags="&lt;quantum-algorithms&gt;&lt;quantum-speedup&gt;&lt;complexity-theory&gt;&lt;quantum-walks&gt;" AnswerCount="1" CommentCount="5" FavoriteCount="1" />
  <row Id="3960" PostTypeId="1" CreationDate="2018-08-07T07:03:38.357" Score="6" ViewCount="103" Body="&lt;p&gt;I see somewhere that this happens:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/w8X0P.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/w8X0P.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But I wonder if this is just identity. &lt;/p&gt;&#xA;" OwnerUserId="4292" LastEditorUserId="26" LastEditDate="2018-08-12T06:13:33.223" LastActivityDate="2018-08-12T07:10:09.783" Title="Just want to confirm: Do two CNOT gates cancel each other?" Tags="&lt;quantum-gate&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="3961" PostTypeId="2" ParentId="3960" CreationDate="2018-08-07T07:08:37.837" Score="4" Body="&lt;p&gt;Yes, it is. If the bottom qubit is 0, neither gate does anything to the top qubit. If the bottom qubit is 1, both gates apply $X$. But since $X^2=\mathbb{I}$, the net effect is that nothing happens. Hence, overall, nothing happens.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Another way to see this is to look at the unitary matrix of controlled-not.&#xA;$$&#xA;\left(\begin{array}{cccc}&#xA;1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\&#xA;0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0&#xA;\end{array}\right)&#xA;$$ It’s reasonably easy to see that the eigenvalues are 1,1,1,-1 (evidently, $|00\rangle$ and $|01\rangle$ are +1 eigenvectors, leaving behind a $2\times 2$ matrix like Pauli $X$, which we know has $\pm 1$ eigenvalues), so the square obviously has eigenvalues 1,1,1,1 and the only 4x4 unitary matrix with all ones eigenvalues is the identity matrix.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Equally, direct calculation:&#xA;$$&#xA;\left(\begin{array}{cccc}&#xA;1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\&#xA;0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0&#xA;\end{array}\right)\cdot \left(\begin{array}{cccc}&#xA;1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\&#xA;0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0&#xA;\end{array}\right)=\left(\begin{array}{cccc}&#xA;1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1&#xA;\end{array}\right)&#xA;$$&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-08-07T07:34:19.090" LastActivityDate="2018-08-07T07:34:19.090" CommentCount="0" />
  <row Id="3963" PostTypeId="2" ParentId="3957" CreationDate="2018-08-07T10:04:00.900" Score="3" Body="&lt;p&gt;I believe I've got it down to 9 controlled-not gates:&#xA;&lt;a href=&quot;https://i.stack.imgur.com/J4wb7.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/J4wb7.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What I did was I used a set of three cNots in the place of Swap to move the two controls next to each other to achieve the last part of the standard Toffoli circuit (see &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/3943/1837&quot;&gt;here&lt;/a&gt;). This used 12 cNots.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, the final $T$ and $H$ gates on the target qubit I propagated through one of these swaps. This let me cancel two controlled-Nots.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then, in the final SWAP, I chose the first of the controlled-nots to be controlled from the middle qubit. I replaced it with a controlled-phase and two Hadamards. The leading Hadamard cancelled. The controlled-phase gate commutes with the preceding controlled gates controlled off the middle qubit, and phase gates on the middle qubit and bottom qubits. These operations bring that controlled phase up to a controlled-not from the first inserted swap. Hence, we can combine these two gates as a controlled-$iY$, controlled off the bottom qubit. But this can be written as a single cNot with some $S$ gates.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I've made no attempt at an optimality proof, but I'm already pretty pleased to have got it this small.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-08-07T10:04:00.900" CommentCount="0" />
  <row Id="3964" PostTypeId="2" ParentId="3957" CreationDate="2018-08-07T10:49:12.143" Score="3" Body="&lt;p&gt;Here is the best construction I've found. It uses 8 CNOTs.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/tkwsh.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/tkwsh.png&quot; alt=&quot;8-cnot construction&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I verified this circuit &lt;a href=&quot;http://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22QFT3%22%5D%2C%5B%22inputA3%22%2C1%2C1%2C%22%2B%3DA3%22%5D%2C%5B%22%E2%80%A6%22%5D%2C%5B1%2C%22H%22%5D%2C%5B%22Z%5E%C2%BC%22%2C%22Z%5E%C2%BC%22%2C%22Z%5E%C2%BC%22%5D%2C%5B%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C%22Z%5E%C2%BC%22%5D%2C%5B%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C%22Z%5E-%C2%BC%22%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C%22H%22%5D%2C%5B%22%E2%80%A6%22%5D%2C%5B%22%E2%80%A2%22%2C%22X%22%2C%22%E2%80%A2%22%5D%2C%5B%22inputA3%22%2C1%2C1%2C%22-%3DA3%22%5D%2C%5B%22QFT%E2%80%A03%22%5D%5D%7D&quot; rel=&quot;nofollow noreferrer&quot;&gt;in Quirk using the channel-state duality and a known-good inverse&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The target is the middle qubit. None of the CNOTs go directly from top to bottom or bottom to top. You can switch which qubit is the the target by simply switching which line the Hadamards are on.&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-08-07T22:37:12.013" LastActivityDate="2018-08-07T22:37:12.013" CommentCount="9" />
  <row Id="3965" PostTypeId="1" CreationDate="2018-08-07T12:44:33.587" Score="7" ViewCount="219" Body="&lt;p&gt;I found an algorithm that can compute the distance of two quantum states. It is based on a subroutine known as swap test (a fidelity estimator or inner product of two state, btw I don't understand what fidelity mean).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is about inner product. How can I calculate the inner product of two quantum registers which contains different number of qubits?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The description of the algorithm is found in &lt;a href=&quot;https://arxiv.org/abs/1804.10068&quot; rel=&quot;noreferrer&quot;&gt;this paper&lt;/a&gt;. Based on the 3rd step that appear on the image, I want to prove it by giving an example.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let:&#xA;$|a| = 5$, $|b| = 5 $, and $ Z = 50 $&#xA;$$|a\rangle = \frac{3}{5}|0\rangle + \frac{4}{5}|1\rangle$$  $$|b\rangle = \frac{4}{5}|0\rangle + \frac{3}{5}|1\rangle&#xA;$$&#xA;All we want is the fidelity of the following two states $|\psi\rangle$ and $|\phi\rangle$ and to calculate the distance between $|a\rangle$ and $|b\rangle$is given as:&#xA;$ {|a-b|}^2 = 2Z|\langle\phi|\psi\rangle|^2$&#xA;so &#xA;$$|\psi\rangle = \frac{3}{5\sqrt{2}}|00\rangle + \frac{4}{5\sqrt{2}}|01\rangle+ + \frac{4}{5\sqrt{2}}|10\rangle +  + \frac{3}{5\sqrt{2}}|11\rangle$$&#xA;$$|\phi\rangle = \frac{5}{\sqrt{50}} (|0\rangle + |1\rangle) $$&#xA;then how to compute &#xA;$$\langle\phi|\psi\rangle = ??$$&lt;/p&gt;&#xA;" OwnerUserId="4206" LastEditorUserId="4206" LastEditDate="2018-08-08T08:36:39.263" LastActivityDate="2018-08-28T14:36:33.403" Title="Inner product of a quantum states" Tags="&lt;quantum-algorithms&gt;&lt;quantum-speedup&gt;" AnswerCount="2" CommentCount="6" FavoriteCount="1" />
  <row Id="3966" PostTypeId="2" ParentId="3898" CreationDate="2018-08-07T14:01:12.820" Score="3" Body="&lt;p&gt;For a review of the subject, see this paper: &quot;Non-locality and Communication Complexity&quot; &#xA;&lt;a href=&quot;https://arxiv.org/abs/0907.3584&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/0907.3584&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="4294" LastEditorUserId="4294" LastEditDate="2018-08-07T14:55:01.860" LastActivityDate="2018-08-07T14:55:01.860" CommentCount="0" />
  <row Id="3967" PostTypeId="1" AcceptedAnswerId="3970" CreationDate="2018-08-07T14:09:08.053" Score="3" ViewCount="56" Body="&lt;p&gt;Has any work been done on quantum systems which use a combination of types of qunits (eg. using qubits &amp;amp; qutrits simultaneously)?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If work has been done, what kind of work has been done? (eg. in quantum information in general? in quantum computing? in physical implementations?)&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-08-07T15:15:03.323" LastActivityDate="2018-08-07T15:38:49.117" Title="Combining Different Qunits" Tags="&lt;resource-request&gt;&lt;qudit&gt;&lt;many-body-systems&gt;" AnswerCount="2" CommentCount="2" />
  <row Id="3968" PostTypeId="2" ParentId="3967" CreationDate="2018-08-07T14:38:09.767" Score="3" Body="&lt;p&gt;Yes. Just to give one example, &lt;a href=&quot;https://www.quantiki.org/wiki/ppt-separability-criterion&quot; rel=&quot;nofollow noreferrer&quot;&gt;the PPT criterion&lt;/a&gt; is necessary and sufficient to decide whether a state is separable for qubit-qubit and qubit-qutrit systems, but not beyond.&lt;/p&gt;&#xA;" OwnerUserId="491" LastActivityDate="2018-08-07T14:38:09.767" CommentCount="0" />
  <row Id="3969" PostTypeId="2" ParentId="3965" CreationDate="2018-08-07T14:54:43.367" Score="3" Body="&lt;p&gt;I guess you're looking at equations (130) and (131)? So, here, you have $|\psi\rangle=(|0\rangle|a\rangle+|1\rangle|b\rangle)/\sqrt{2}$ and $|\phi\rangle=|a| |0\rangle+|b| |1\rangle$. When it says to calculate $\langle\phi|\psi\rangle$, what it really means is&#xA;$$&#xA;(\langle\phi|\otimes\mathbb{I})|\psi\rangle,&#xA;$$&#xA;padding everything with identity matrices to make them all the same size.&#xA;Thus, the calculation becomes&#xA;$$&#xA;\frac{1}{\sqrt{2Z}}\left(\begin{array}{cccc} |a| &amp;amp; 0 &amp;amp; |b| &amp;amp; 0 \\ 0 &amp;amp; |a| &amp;amp; 0 &amp;amp; |b| \end{array}\right)\cdot\left(\begin{array}{c}  a_0 \\ a_1 \\ b_0 \\ b_1 \end{array}\right),&#xA;$$&#xA;where $a_0$ and $a_1$ are the elements of your vector $|a\rangle$. If you work this through, you'll get&#xA;$$&#xA;\frac{1}{\sqrt{2Z}}(|a| |a\rangle+|b| |b\rangle).&#xA;$$&#xA;I have no idea where the negative sign has come from in equation (133).&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-08-13T06:27:46.470" LastActivityDate="2018-08-13T06:27:46.470" CommentCount="2" />
  <row Id="3970" PostTypeId="2" ParentId="3967" CreationDate="2018-08-07T15:00:44.653" Score="4" Body="&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_walk&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum walks&lt;/a&gt; are a simple case of quantum dynamics that involves a qubit (named &lt;em&gt;coin&lt;/em&gt; in this context) interacting with a high-dimensional qudit (named &lt;em&gt;walker&lt;/em&gt; in this context).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Almost anything in quantum optics can be thought of as &quot;&lt;em&gt;combining different qunits&lt;/em&gt;&quot; as well: a photon in a superposition of many spatial modes (high-dimensional qudit), together with its polarization degree of freedom (qubit) fits the bill.&#xA;You can replace &quot;spatial modes&quot; with something like &quot;orbital angular momentum modes&quot; or &quot;frequency modes&quot; or &quot;time modes&quot; and you have the same.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Many quantum algorithms also inherently deal with this scenario: Grover's algorithm and the phase estimation algorithm come to mind (of course, the high-dimensional qudit in those algorithms can be replaced by a number of qubits, but that depends on the context).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Countless other examples could be found, but it would not be very meaningful without specifying the context a bit more.&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-08-07T15:38:49.117" LastActivityDate="2018-08-07T15:38:49.117" CommentCount="2" />
  <row Id="3971" PostTypeId="1" CreationDate="2018-08-07T20:39:31.180" Score="9" ViewCount="132" Body="&lt;p&gt;Sligthly related to &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1367/programming-quantum-computers-for-non-physics-majors&quot;&gt;this question&lt;/a&gt;, but not the same.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Traditional computer science requires no physics knowledge for a computer scientist to be able to research and make progress in the field. Of course, you do need to know about the underlying physical layer when your research is related to that, but in many cases you can ignore it (e.g. when designing an algorithm). Even when architectural details are important (e.g. cache layout), oftentimes it is not necessary to know all the details about them, or how they're implemented at the physical level.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Has quantum computing reached this level of &quot;maturity&quot;? Can you design a quantum algorithm, or do actual research in the field, as a computer scientist that doesn't know anything about quantum physics? In other words, can you &quot;learn&quot; quantum computing ignoring the physical side, and is it worth it (in terms of scientific career)?&lt;/p&gt;&#xA;" OwnerUserId="4296" LastActivityDate="2018-08-08T01:26:56.760" Title="Is quantum computing mature enough for a computer scientist with no physics background?" Tags="&lt;quantum-computer&gt;&lt;resource-request&gt;" AnswerCount="3" CommentCount="0" />
  <row Id="3972" PostTypeId="2" ParentId="3971" CreationDate="2018-08-07T20:52:49.967" Score="3" Body="&lt;p&gt;It has pretty much always been like that.  You can study the book by Nielsen &amp;amp; Chuang without knowing about physics. There is the &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0207118&quot; rel=&quot;nofollow noreferrer&quot;&gt;introduction by Mermin&lt;/a&gt; aimed at computer scientists. There are probably lots of other resources (I'm pretty sure e.g. that Aaronson's book -- based on a &lt;a href=&quot;https://www.scottaaronson.com/democritus/&quot; rel=&quot;nofollow noreferrer&quot;&gt;CS lecture&lt;/a&gt; -- is perfectly suited for people without a physics background.) Overall, the physics formalism needed to understand quantum information and computation is pretty low-key, as compared to other fields of (quantum) physics. (This doesn't mean though that studying the phenomena in quantum information and computation is low-key.)&lt;/p&gt;&#xA;" OwnerUserId="491" LastEditorUserId="491" LastEditDate="2018-08-07T20:57:59.113" LastActivityDate="2018-08-07T20:57:59.113" CommentCount="0" />
  <row Id="3973" PostTypeId="2" ParentId="3971" CreationDate="2018-08-07T22:18:20.997" Score="4" Body="&lt;p&gt;As I can relate in my experience, I will say yes. One can indeed design algorithms without physics knowledge. For me it is so far Maths concepts. &#xA;I remember once I watched a course about quantum computing from Scott Aaronson and he quoted : &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Quantum computing is really &quot;easy&quot; when you take the physics out of it.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;However, if you are going to work on applications in physics or chemistry, it will always be useful to have a background of what you are going to work on.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The field is open to many backgrounds (Maths, Physics, Computer Science...).&#xA;I think it is just a challenge sometimes communicating between different backgrounds but it is not impossible. Indeed, I would say it is constructive and it can be beneficial to collaborate together. But one can always relate to his preferred interpretation/concepts.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As a career, it is again according to your point of view. I think there is much work to be done in this field so do not worry about it. Do it if you feel you like it. Plus working in this field does not mean you have to restrain yourself. You will still have to work with classical algorithms and you will need coding skills.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you are interested in learning it from a computer scientist point of view,&#xA;there is this book that may be helpful:&#xA;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/0521879965&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://www.amazon.com/Quantum-Computing-Computer-Scientists-Yanofsky/dp/0521879965&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Good luck on your quantum trip !&lt;/p&gt;&#xA;" OwnerUserId="4127" LastActivityDate="2018-08-07T22:18:20.997" CommentCount="0" />
  <row Id="3974" PostTypeId="1" AcceptedAnswerId="3975" CreationDate="2018-08-07T22:28:33.967" Score="8" ViewCount="65" Body="&lt;p&gt;Recently I've been wondering how high NISQ machines will be able to &quot;count&quot;. What I mean by that is, given the most optimized increment circuit you can make, how many times can you physically apply that circuit to qubits in a secret initial state before there's a more than 50% chance that the output is the wrong value.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To that end, I need a good increment circuit that would actually run on a NISQ machine! E.g. this means respecting locality constrains, and costing the circuit based on how many 2-qubit operations are performed (since those are the noisiest). For simplicity, I will say that the gate set is &quot;any single qubit operation + local CNOTs on a grid&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It seems clear to me that a NISQ machine should be able to apply a 3-qubit incrementer at least 8 times (so it wraps back to 0 and loses count), but I think wrapping a 4-qubit counter is much more challenging. Thus this question's focus on that size specifically.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A 4-qubit incrementer is a circuit which effects the state permutation $|k\rangle \rightarrow |k + 1\pmod{16}\rangle$. The value $k$ must be stored as a 2s complement binary integer in four qubits. If the value is under superposition, it must still be coherent after applying the incrementer (i.e. no entangling with other qubits except as temporary workspace). You may place the qubits wherever you want on the grid.&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-08-09T01:58:43.330" LastActivityDate="2018-08-09T01:58:43.330" Title="Minimum number of CNOTs for a 4-qubit increment on a planar grid" Tags="&lt;optimization&gt;&lt;nisq&gt;" AnswerCount="1" CommentCount="6" FavoriteCount="1" />
  <row Id="3975" PostTypeId="2" ParentId="3974" CreationDate="2018-08-07T22:28:33.967" Score="3" Body="&lt;p&gt;Here is the best circuit I've found. It uses 14 CNOTs.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that this circuit is not using a linear layout! It is placed on the grid like this:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;0-A-1&#xA;  |&#xA;  3&#xA;  |&#xA;  2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Where 'A' is an ancilla initialized in the |0&gt; state and '0','1','2','3' are the qubits making up the register (with '0' being the least significant bit).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/TwZjJ.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/TwZjJ.png&quot; alt=&quot;14 CNOT 4-qubit increment&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I verified this circuit &lt;a href=&quot;http://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B%22QFT4%22%5D%2C%5B%22inputA4%22%2C1%2C1%2C1%2C%22%2B%3DA4%22%5D%2C%5B1%2C1%2C%22%3C%3C7%22%5D%2C%5B1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B1%2C1%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C%22H%22%2C%22H%22%5D%2C%5B1%2C1%2C%22Z%5E%C2%BC%22%2C%22Z%5E%C2%BC%22%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C1%2C%22Z%5E-%C2%BC%22%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C%22H%22%2C%22H%22%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C%22Z%5E%C2%BC%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C%22X%22%2C%22%E2%80%A2%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B1%2C%22X%22%2C%22%E2%80%A2%22%5D%2C%5B%22X%22%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C%22%3E%3E7%22%5D%2C%5B1%2C1%2C%22Swap%22%2C%22Swap%22%5D%2C%5B%22dec4%22%5D%2C%5B1%2C1%2C%22Swap%22%2C%22Swap%22%5D%2C%5B%22inputA4%22%2C1%2C1%2C1%2C%22-%3DA4%22%5D%2C%5B%22QFT%E2%80%A04%22%5D%5D%7D&quot; rel=&quot;nofollow noreferrer&quot;&gt;in Quirk using the channel-state duality and a known-good inverse&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If one had access to the sqrt-of-CNOT operation, the number of 2-qubit operations could be brought down to 13 by merging two CNOTs and three Ts in the bottom area into a controlled-S.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If CNOTs had an error rate of 0.5%, and all other sources of error were negligible, you could apply this circuit nearly ten times before reaching a 50% failure rate. Implying a plausible NISQ machine could &quot;almost count to ten&quot;.&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-08-07T22:48:25.963" LastActivityDate="2018-08-07T22:48:25.963" CommentCount="0" />
  <row Id="3977" PostTypeId="5" CreationDate="2018-08-08T01:14:29.983" Score="0" Body="&lt;p&gt;&lt;strong&gt;N&lt;/strong&gt;oisy &lt;strong&gt;I&lt;/strong&gt;ntermediate &lt;strong&gt;S&lt;/strong&gt;cale &lt;strong&gt;Q&lt;/strong&gt;uantum (NISQ) computers have enough qubits to see non-classically-simulable behavior, but not enough for error correction. NISQ algorithms often revolve around sampling very short circuits many times and using classical feedback to choose which circuit to sample next. The cost bottlenecks for NISQ computation are things that introduce noise into the results (e.g. circuit depth and two-qubit gates). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;See John Preskill's 2018 paper &lt;a href=&quot;https://arxiv.org/abs/1801.00862&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;Quantum Computing in the NISQ era and beyond&quot;&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-08-08T07:22:07.553" LastActivityDate="2018-08-08T07:22:07.553" CommentCount="0" />
  <row Id="3978" PostTypeId="4" CreationDate="2018-08-08T01:14:29.983" Score="0" Body="For questions related to Noisy Intermediate Scale Quantum (NISQ) computing. NISQ computers cannot be classically simulated in a reasonable time but are not advanced enough to also be error corrected." OwnerUserId="119" LastEditorUserId="23" LastEditDate="2018-08-08T20:24:56.083" LastActivityDate="2018-08-08T20:24:56.083" CommentCount="0" />
  <row Id="3979" PostTypeId="2" ParentId="3971" CreationDate="2018-08-08T01:26:56.760" Score="12" Body="&lt;p&gt;Speaking as a computer scientist without any physics background making contributions to quantum computing: yes, computer scientists without any physics background can make contributions to quantum computing. Though I think it was always that way; it has nothing to do with the field being &quot;mature&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you understand the postulates of quantum mechanics (operations are unitary matrices, states are unit vectors, measurement is a projection), and know how to apply those in the context of a computation, you can create quantum algorithms. The fact that these concepts were originally derived from physics is historically interesting, but not really relevant when optimizing a quantum circuit. As a concrete example: quantum physics is very heavy on calculus, but quantum computation isn't.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quantum physics does become relevant if you are trying to design algorithms for simulating quantum systems. And some of the concepts you would learn in a quantum physics course should also appear in a quantum computation course. But overall &lt;a href=&quot;https://www.scottaaronson.com/democritus/lec9.html&quot; rel=&quot;noreferrer&quot;&gt;I agree with Scott Aaronson&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;[My] way to teach quantum mechanics [...] starts directly from the conceptual core -- namely, a certain generalization of probability theory to allow minus signs. Once you know what the theory is actually about, you can then sprinkle in physics to taste [...]&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;[quantum mechanics is] not a physical theory in the same sense as electromagnetism or general relativity. [...] Basically, quantum mechanics is the operating system that other physical theories run on as application software [...]&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;[...] [quantum mechanics is] about information and probabilities and observables, and how they relate to each other.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="119" LastActivityDate="2018-08-08T01:26:56.760" CommentCount="0" />
  <row Id="3980" PostTypeId="1" AcceptedAnswerId="4019" CreationDate="2018-08-08T01:55:53.730" Score="8" ViewCount="160" Body="&lt;p&gt;I was looking into applications of Quantum Computing for machine learning and encountered the following pre-print from 2003. &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0309070&quot; rel=&quot;noreferrer&quot;&gt;Quantum Convolution and Correlation Algorithms are Physically Impossible&lt;/a&gt;.  The article doesn't appear to have been published in any journals, but it has been cited a few dozen times.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The article author makes the case that it is impossible to compute discrete convolution over quantum states.  Intuitively this seems incorrect to me, since I know we can perform quantum matrix multiplication, and I know that discrete convolution can be framed simply as multiplication with a Toeplitz (or circulant) matrix.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The crux of his argument seems to be that there is no realizable composition of unitary operators for the elementwise (Hadamard) product of two vectors.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Where is my disconnect?  Is there any reason we cannot in general construct a Toeplitz matrix for discrete convolution in a quantum computer?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Or is the article simply incorrect?  I have worked through the contradiction that the author presents in his proof of Lemma 14, and it seems to make sense to me.&lt;/p&gt;&#xA;" OwnerUserId="4298" LastActivityDate="2018-08-15T00:45:41.517" Title="Quantum Algorithms for Convolution" Tags="&lt;quantum-algorithms&gt;&lt;quantum-fourier-transform&gt;" AnswerCount="2" CommentCount="2" />
  <row Id="3981" PostTypeId="2" ParentId="3980" CreationDate="2018-08-08T07:09:48.563" Score="3" Body="&lt;p&gt;I am highly suspicious of the result. If you look at Theorem 16, it claims that there is no operation that achieves the map&#xA;$$&#xA;\sum_{ij}\alpha_i\beta_j|ij\rangle\mapsto \sum_i\alpha_i\beta_i|i\rangle&#xA;$$&#xA;up to normalisation. However, consider the measurement operator&#xA;$$&#xA;P=\sum_{i}|i\rangle\langle ii|.&#xA;$$&#xA;This clearly implements the desired map (for that particular measurement outcome). Moreover, its implementation is quite straightforward. There is a unitary (effectively, a generalised controlled-not) that can map&#xA;$$&#xA;|ii\rangle\mapsto|i0\rangle,&#xA;$$&#xA;so that you then measure the second spin and post-select on getting the 0 result. This would seem to invalidate the proof of the paper.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-08-08T07:09:48.563" CommentCount="7" />
  <row Id="3982" PostTypeId="1" AcceptedAnswerId="3983" CreationDate="2018-08-08T08:06:14.847" Score="7" ViewCount="224" Body="&lt;p&gt;In a &lt;a href=&quot;https://qiskit.slack.com/archives/C7SJ0PJ5A/p1526979601000340&quot; rel=&quot;noreferrer&quot;&gt;discussion with Jay Gambetta&lt;/a&gt; on the QISKit Slack channel, Jay told me that &quot;T2 is the time that $\vert 0 \rangle + \vert 1 \rangle$ goes to $\vert 0 \rangle \langle 0 \vert + \vert 1 \rangle \langle 1 \vert$&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is: what is the difference between those two states?&lt;/p&gt;&#xA;" OwnerUserId="1386" LastActivityDate="2018-08-09T01:24:58.500" Title="What is the difference between $\vert 0 \rangle + \vert 1 \rangle$ and $\vert 0 \rangle \langle 0 \vert + \vert 1 \rangle \langle 1 \vert$?" Tags="&lt;quantum-state&gt;&lt;quantum-decoherence&gt;" AnswerCount="3" CommentCount="2" FavoriteCount="1" />
  <row Id="3983" PostTypeId="2" ParentId="3982" CreationDate="2018-08-08T08:18:03.707" Score="7" Body="&lt;p&gt;In short: &quot;coherence&quot;! It's the crucial difference between quantum and classical. $\rho=|0\rangle\langle 0|+|1\rangle\langle 1|$ is just a statistical mixture, and behaves like a classical coin - any measurement that you perform on it gives a 50:50 split between the two possible outcomes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;By contrast, $|+\rangle=(|0\rangle+|1\rangle)/\sqrt{2}$ is a very different beast. When you look at them both as density matrices, you can see the difference:&#xA;$$&#xA;\rho=\frac{1}{2}\left(\begin{array}{cc} 1 &amp;amp; 0 \\ 0 &amp;amp; 1 \end{array}\right)\qquad |+\rangle\langle +|=\frac{1}{2}\left(\begin{array}{cc} 1 &amp;amp; 1 \\ 1 &amp;amp; 1 \end{array}\right)&#xA;$$&#xA;Sure, if you measure $|+\rangle$ in the Z-basis, you get 50:50 outcomes, just like you did with $\rho$, but measurement in other bases gives different outcomes. Most importantly, if you measure in the $X$ basis, you get a definite measurement result, a 100:0 split.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Put another way, if I perform a Hadamard gate on the two states:&#xA;$$&#xA;H\rho H=\rho\qquad H|+\rangle\langle +|H=|0\rangle\langle 0|.&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One of the crucial ways that we use the $|+\rangle$ state is in the first step of quantum algorithms: you prepare one register in $|+\rangle^{\otimes n}$. If, instead, you prepared it in $\rho^{\otimes n}$, this would be equivalent to classical sampling of the function evaluation in the next step. There would be no phase kick-back, and no quantum speed-up.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Exercise for the Reader:&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Imagine a qubit starts in the state $\rho_0=|+\rangle\langle +|$ and experiences the noise map&#xA;$$&#xA;\rho_{n+1}=\mathcal{E}(\rho_n)=(1-p)\rho_n+p Z\rho_n Z&#xA;$$&#xA;where $0&amp;lt;p&amp;lt;1$ quantifies the probability of a phase error in a particular time step. Calculate $\rho_n$. Show that:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$\rho_n-\rho_{n+1}\neq 0$&lt;/li&gt;&#xA;&lt;li&gt;the fixed point of the map is $(|0\rangle\langle 0|+|1\rangle\langle 1|)/2$&lt;/li&gt;&#xA;&lt;li&gt;as $n\rightarrow\infty$, $\rho_n$ tends to this fixed point.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-08-08T08:44:13.277" LastActivityDate="2018-08-08T08:44:13.277" CommentCount="0" />
  <row Id="3984" PostTypeId="2" ParentId="3982" CreationDate="2018-08-08T09:10:18.220" Score="5" Body="&lt;p&gt;There are multiple ways to mathematically express the state of a quantum system. One is to write it as a linear combination of basis states, as either a vector or a matrix, as you have here. This is useful in many cases, but it also seems to be confusing to newcomers, since things like $\vert 0 \rangle + \vert 1 \rangle$, $\vert 0 \rangle \langle 0 \vert + \vert 1 \rangle \langle 1 \vert$ and other states all just look like a $50/50$ mix of $\vert 0 \rangle$ and $\vert 1 \rangle$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So let's look at another way of representing states: using expectation values for a set of observables. For a single qubit we can use the Pauli matrices:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$\rho = \frac{1}{2} \left( \mathbb{1} + \sum_{\alpha \in \{x,y,z\}} \, \langle \sigma_\alpha \rangle \,\,\sigma_\alpha \right)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here $\langle \sigma_z \rangle$ is a quantity that takes the value $+1$ if a $|0\rangle$/$|1\rangle$ measurement is certain to give the outcome $|0\rangle$, and takes the value $-1$ if the measurement would certainly give the outcome $|1\rangle$. Otherwise we'll find $1 &amp;gt; \langle \sigma_z \rangle &amp;gt; -1$, with the value depending on the probabilities. For example, the value is $\langle \sigma_z \rangle = 0$ for a $50/50$ mix.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The quantity $\langle \sigma_x \rangle$ is the same but for a $|+\rangle$/$|-\rangle$ measurement (this is equivalent to doing a Hadamard immediately before a $|0\rangle$/$|1\rangle$ measurement). Similarly for $\langle \sigma_y \rangle$, but no-one ever cares much about poor $\sigma_y$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;With this method, the state $\vert 0 \rangle + \vert 1 \rangle$ (once normalized) is&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ \rho = \frac{1}{2} \left( \mathbb{1} + \sigma_x \right) $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This has $\langle \sigma_z \rangle = \langle \sigma_y \rangle =0$. So for these two types of measurement, we'd get the outcomes with $50/50$ probabilities. But $\langle \sigma_x \rangle =1$, showing that the outcome for this type of measurement is certain.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For $\vert 0 \rangle \langle 0 \vert + \vert 1 \rangle \langle 1 \vert$ (once normalized) we get&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ \rho = \frac{1}{2} \mathbb{1} $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\langle \sigma_\alpha \rangle = 0$ for $x$, $y$ and $z$. All three of these measurements give random results. In fact, so will any kind of measurement.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This way of representing states is explored in IBM's &lt;a href=&quot;http://helloquantum.mybluemix.net/&quot; rel=&quot;noreferrer&quot;&gt;Hello Quantum&lt;/a&gt; project, which might be of some additional help (note: I also helped make this).&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-08-08T09:10:18.220" CommentCount="0" />
  <row Id="3985" PostTypeId="1" CreationDate="2018-08-08T11:06:24.460" Score="9" ViewCount="166" Body="&lt;p&gt;A metric called the &quot;quantum volume&quot; has been proposed to somehow compare the utility of different quantum computing hardware. Roughly speaking, it measures their worth by the square of the maximum depth of quantum computations it permits but limits its value to the square of the qubits involved. This limit is justified by wanting to forestall &quot;gaming&quot; of the system by optimizing towards few qubits. One reference is &lt;a href=&quot;https://arxiv.org/abs/1710.01022&quot; rel=&quot;noreferrer&quot;&gt;https://arxiv.org/abs/1710.01022&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am concerned that this measure, as good as it may be for noisy near-term quantum computing devices, hides the actual quality advances for more advanced quantum computers (those with high quantum gate fidelity). The question is: Is this concern justified?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The argument behind my concern is the assumption that potential killer applications for quantum computers, for example quantum chemical calculations, will require computations with a gate depth much larger than the (potentially modest) number of qubits required. In this case, the &quot;quantum volume&quot; would be limited to the square of the number of qubits, regardless of whether one quantum computer (with particularly high fidelity) permits an essentially unlimited depth or whether it only allows the bare minimum gate depth to achieve the limitation of the &quot;quantum volume&quot; to the square of the number of qubits. One aspect of my question is: Is this argument correct?&lt;/p&gt;&#xA;" OwnerUserId="1039" LastEditorUserId="491" LastEditDate="2018-08-08T17:19:34.943" LastActivityDate="2018-08-11T06:52:07.897" Title="Is the &quot;Quantum Volume&quot; a fair metric for future, elaborate, high value quantum computations?" Tags="&lt;quantum-computer&gt;&lt;architecture&gt;&lt;quantum-volume&gt;" AnswerCount="2" CommentCount="1" FavoriteCount="1" />
  <row Id="3986" PostTypeId="1" CreationDate="2018-08-08T14:10:53.663" Score="5" ViewCount="38" Body="&lt;p&gt;I have been reading about a family of quantum error correction codes called Quantum Turbo Codes, which are the quantum analog of the well-known classical Turbo codes. This codes were introduced in &lt;a href=&quot;https://arxiv.org/pdf/0712.2888.pdf&quot; rel=&quot;noreferrer&quot;&gt;quantum serial turbo codes&lt;/a&gt; and the entanglement-assisted version of those was presented in &lt;a href=&quot;https://arxiv.org/pdf/1010.1256.pdf&quot; rel=&quot;noreferrer&quot;&gt;entanglement-assisted quantum turbo codes&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In such papers, the decoding algorithm presented for  is a modification of the classical belief propagation algorithms that are used for obtaining the most probable codeword received based on the channel information and the syndromes read from the information received. The difference in the quantum paradigm is that the belief propagation algorithm here is used to detect the most probable error that happened in the channel and so the recovery operation can be applied to the received quantum states. This modified algorithm is purely classical, and so it would be executed in a classical computer before feeding the decoded information back to the quantum computer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The fact that it is a classical algorithm presents some problems, such as the fact that if the belief propagation takes more time than the decoherence time of the qubits, then the recovery would be unsuccesfull as more errors would have happened before correction is applied.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;That's why I wonder if there are quantum versions of the belief propagation algorithms that use the parallel nature of quantum computers to obtain substantial speedups in the decoding process. I am seeking for reference respect to this topic, or to know if there are research groups concerned about this kind of problem.&lt;/p&gt;&#xA;" OwnerUserId="2371" LastActivityDate="2018-08-08T14:10:53.663" Title="Quantum Belief Propagation decoding" Tags="&lt;quantum-error-correction&gt;&lt;resource-request&gt;&lt;quantum-decoherence&gt;" AnswerCount="0" CommentCount="2" FavoriteCount="1" />
  <row Id="3987" PostTypeId="2" ParentId="3932" CreationDate="2018-08-09T00:04:54.733" Score="3" Body="&lt;p&gt;&lt;strong&gt;(CW to avoid reps from self-answer)&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There &lt;em&gt;might&lt;/em&gt; be an interactive way for two parties to narrow in on the value of $t$, following up on @DaftWullie's answer and @Steven Sagona's comments.  My formalism is poor, but I hope the idea gets through...&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For example, call  the two parties Alice and Bob.  The parties have to cooperate, and behave honestly according to the protocol.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Alice&lt;/strong&gt; knows how to prepare two states, $\vert A_0 \rangle$ and $\vert A_1 \rangle$.  Here, $\vert A_0\rangle$ is the uniform superposition over all Rubik's cube combinations, and $\vert A_1\rangle$ is some other monkey state with the same number of qubits (such as the state corresponding to a solved Rubik's cube, or a uniform superposition over some large subgroup of $G$).   &lt;strong&gt;Bob&lt;/strong&gt; knows how to apply a matrix $M$ to a quantum state, where $M$ corresponds to single step of all of the Singmaster moves (with ancillas where appropriate.) &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Alice and Bob want to show that the mixing time $t$ of the Rubik's cube group under Singmaster moves is at most $r$.  Alice and Bob repeat the following $s$ times. &lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Alice flips a coin $i\in\{0,1\}$, and provides $\vert A_i \rangle$ to Bob&lt;/li&gt;&#xA;&lt;li&gt;Bob repeats $r$ times to apply $M$ to $\vert A_i \rangle$, and measures the projector each time.&lt;/li&gt;&#xA;&lt;li&gt;If the projector is $1$ for each of the $r$ iterations, then Bob says that $i=0$. If the projector is not $1$ for at least one of the $r$ iterations, then Bob says that Alice's $i=1$. &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;If $i=0$, then each of Bob's $r$ iterations in step 2 does not change $\vert A_0\rangle$ - because by definition $\vert A_0 \rangle$ is an eigenstate of Bob's matrix, and Bob's matrix just permutes the states among themselves. If $i=1$, then the monkey state $\vert A_1 \rangle$ is &lt;em&gt;not&lt;/em&gt; an eigenstate of Bob's projector, and the chance that a $1$ will not be measured grows quickly with $r$.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thus, if Bob has accurately predicted $i$ for $s$ iterations, the probability of success grows exponentially with $s$, and Bob's $r$ is large enough to distinguish a valid Rubik's cube state from a monkey state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I don't know how far apart $\vert A_1\rangle$ has to be from $\vert A_0\rangle$.  I also don't know if interaction can be removed.&lt;/p&gt;&#xA;" OwnerUserId="2927" LastActivityDate="2018-08-09T00:04:54.733" CommentCount="0" CommunityOwnedDate="2018-08-09T00:04:54.733" />
  <row Id="3988" PostTypeId="2" ParentId="3982" CreationDate="2018-08-09T01:24:58.500" Score="1" Body="&lt;p&gt;This question is (in my opinion) the most important question to ask when trying to understand the mathematics of &quot;quantum superposition.&quot; Quantum superposition is the essence of how quantum computations are made.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;If I have a coin, and I flip it 50% of the times I'll get heads and 50% of the time I can get tails: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;P(Heads) = 50%&lt;/p&gt;&#xA;&#xA;&lt;p&gt;P(Tails) = 50%&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But if I make a quantum coin and write it in our fancy ket notation:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$|\psi\rangle = \frac{1}{\sqrt{2}}(|H\rangle + |T\rangle)$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I can see that this fancy notation gives me the same results as my coin flip!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;P(H) = $| \langle H |\psi\rangle |^2 = \frac{1}{2}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;P(T) = $| \langle T |\psi\rangle |^2 = \frac{1}{2}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So what's even the point? We say there's something special about quantum events, but the math is just the same as flipping coins?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What we need to do is investigate a little deeper to see how a coin is different from a quantum coin:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the case where we simply check if our quantum coin is heads-or-tails, we don't see how its different from a normal coin. Instead we're going to do a different procedure (with an silly analogy for intuition): Without checking if our coin is heads-or-tails, we insert our quantum coin through a special slot machine. This special slot machine (meant for cheaters) has a trick: if we insert the coin in one orientation (Heads-side pointing to the left) it gives luckier odds than when its inserted in the other orientation (heads-side pointing to the right).  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This means that if we flip a coin and (without looking) insert it into the machine, our odds look like this:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ \text{P(win)} = \frac{1}{2}(P(\text{win|lucky-odds}) + \frac{1}{2}(P(\text{win|unlucky-odds})   $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Half the time we get the lucky odds and half the time we get unlucky odds. (And everyone who plays this slot that doesn't know the trick will get this average between the two odds!)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But what about the quantum coin?  The quantum coin will not measure what was measured above. Let's work out the mathematical shapes of quantum mechanics, and define winning the slot machine is as a quantum mechanical operator:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$P(\text{win|lucky-odds}) = |\langle W|H \rangle|^2$  and $P(\text{win|unlucky-odds}) = |\langle W|T \rangle|^2$ &lt;/p&gt;&#xA;&#xA;&lt;p&gt;But now if I insert the Heads-to-the-left orientation into the slot machine, I get the probability of winning with the lucky odds (same as before), and if the same if the heads-to-the-right orientation. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The difference now is that when I apply my fancy ket state from before $| \psi \rangle = |H\rangle + |T\rangle$, I am now working with a quantum state, so now to find the probabilties I have to square &lt;strong&gt;everything&lt;/strong&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{align}&#xA;P(Win) &amp;amp;= |\langle W|\psi\rangle|^2 \\&#xA;&amp;amp;= \frac{1}{2}|\langle W | (|H\rangle+|V\rangle)|^2 \\&#xA;&amp;amp;= \frac{1}{2}|\langle W|H\rangle + \langle W|T\rangle|^2 \\&#xA;&amp;amp;= \frac{1}{2}|\langle W|H\rangle|^2 + |\langle W|T\rangle|^2 \\&#xA;&amp;amp;   + \langle T|W\rangle \langle W|H\rangle + \langle H|W\rangle \langle W|T\rangle &#xA;\end{align}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So now putting the &quot;normal coin&quot; together with our &quot;quantum coin&quot;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{align}&#xA;P_{normal}(Win) &amp;amp;= \frac{1}{2}(P(\text{win|lucky-odds}) + \frac{1}{2}(P(\text{win|unlucky-odds}) \\&#xA;P_{quantum}(Win) &amp;amp;= \frac{1}{2}(P(\text{win|lucky-odds}) + \frac{1}{2}(P(\text{win|unlucky-odds}) \\&#xA;&amp;amp;   + \langle T|W\rangle \langle W|H\rangle + \langle H|W\rangle \langle W|T\rangle   &#xA;\end{align}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We see that we have &lt;em&gt;extra&lt;/em&gt; terms that are in the quantum case!  These &quot;interference terms&quot; are the terms that are fundamental to what a quantum superposition is! &lt;/p&gt;&#xA;&#xA;&lt;p&gt;These &quot;interference terms&quot; change depending on the sign of the quantum superposition. So consider the case when $|\psi\rangle = |H\rangle  - |T\rangle $ instead of $ |H\rangle  + |T\rangle $ :&lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{align}&#xA;P_{normal}(Win) &amp;amp;= \frac{1}{2}(P(\text{win|lucky-odds}) + \frac{1}{2}(P(\text{win|unlucky-odds}) \\&#xA;P_{quantum}(Win) &amp;amp;= \frac{1}{2}(P(\text{win|lucky-odds}) + \frac{1}{2}(P(\text{win|unlucky-odds}) \\&#xA;&amp;amp;   - \langle T|W\rangle \langle W|H\rangle - \langle H|W\rangle \langle W|T\rangle   &#xA;\end{align}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The sign actually carries through, and this affects the &lt;em&gt;probabilities&lt;/em&gt; to win our slot machine. These weird interference terms are the essence of quantum mechanics, and while the notation of bras and kets are convenient, it's often easy to get lost in the mathematical shapes and not realize the essence or intuition of what's going on!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So finally, to answer your question, what is the difference between $ |H\rangle  + |T\rangle $ and $ |H\rangle \langle H |  + |T\rangle \langle T| $?  The difference is that $ |H\rangle  + |T\rangle $ is a &lt;strong&gt;quantum coin&lt;/strong&gt; that has these extra terms shown above.   The state:   $ |H\rangle \langle H |  + |T\rangle \langle T| $ is a &lt;strong&gt;normal coin&lt;/strong&gt; without any properties of quantum superposition. It has the porbabilities of $P_{normal}$. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In normal unitary quantum mechanics typically taught in undergraduate classes, it's actually not possible to construct a state that acts like a normal coin without quantum superposition! To get this &quot;normal coin&quot; you actually need to add extra rules to quantum mechanics (called working in the &quot;density matrix&quot; framework). &lt;/p&gt;&#xA;" OwnerUserId="2660" LastActivityDate="2018-08-09T01:24:58.500" CommentCount="0" />
  <row Id="3989" PostTypeId="1" CreationDate="2018-08-09T09:34:48.640" Score="6" ViewCount="62" Body="&lt;p&gt;As I understand so far, in some algorithms such as Simon's algorithm, swap-test algorithm or quantum k-means algorithm, we repetitively perform a measurement yielding a classical result. Consequently, this pushes us to run the whole algorithm again and again (starting from initialization of the system).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question is:&#xA;&lt;em&gt;do we lose the complexity as the number of repetitions of the algorithm increases?&lt;/em&gt;&lt;/p&gt;&#xA;" OwnerUserId="4206" LastEditorUserId="55" LastEditDate="2018-08-09T12:09:07.783" LastActivityDate="2018-08-09T12:09:07.783" Title="Does the need of many quantum algorithms to be repeated several times impair the efficiency gains?" Tags="&lt;quantum-algorithms&gt;&lt;measurement&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="3990" PostTypeId="2" ParentId="3989" CreationDate="2018-08-09T09:44:36.850" Score="5" Body="&lt;p&gt;You probably want to look at old posts about Simon's algorithm, such as the rather complete explanation I gave &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1718/1837&quot;&gt;here&lt;/a&gt;, or talking more specifically about the number of times the algorithm has to be &lt;a href=&quot;https://quantumcomputing.stackexchange.com/q/2223/1837&quot;&gt;repeated&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Yes, you have to repeat the algorithm several times to get different pieces of classical data, which you then process classically to get your final answer. But this is taken into account in the complexity. Indeed, that is often one of the most significant bits of the analysis: what's the average run-time to get the answer? It is this that you compare to the classical run-time.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-08-09T09:44:36.850" CommentCount="0" />
  <row Id="3992" PostTypeId="2" ParentId="3985" CreationDate="2018-08-09T16:53:35.283" Score="5" Body="&lt;p&gt;As a start, you might want to look at &lt;a href=&quot;https://arxiv.org/abs/1605.03590&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/1605.03590&lt;/a&gt;, which lays out conservative (i.e., high) qubit and gate requirements for a meaningful quantum chemistry calculation under some pretty reasonable assumptions. The estimates there are on the order of $10^{15}$ total logical gates (not gate depth) over roughly 100 logical qubits, which means that the gate depth must be on the order of $10^{13}$ or higher (I'm looking at the nested counts).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So at the logical level, you're correct: you don't need $10^{13}$ qubits &lt;em&gt;and&lt;/em&gt; $10^{13}$ gate depth to run nitrogenase. The two metrics, qubit count and gate depth, are not really equivalent: to run a real problem, I need on the order of a hundred qubits, but ten quadrillion gate depth.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;That's not the whole picture, though. It's on the order of a hundred &lt;em&gt;logical&lt;/em&gt; qubits, and &lt;em&gt;logical&lt;/em&gt; gate depth of 10^13. Quantum error correction is essentially all about trading physical qubit count to get better logical gate depth. As you can see in table II in the paper, the logical-to-physical ratio ranges from 17,000/1 to 300/1 as the physical qubits get better (i.e., as the &lt;em&gt;physical&lt;/em&gt; gate depth increases). Again from table II, a &lt;em&gt;physical&lt;/em&gt; gate depth of $10^3$ leads to needing $10^9$ physical qubits, while a physical gate depth of $10^9$ only requires $10^6$ physical qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &quot;quantum volume&quot; measurement still doesn't seem quite right to me at this scale, though. I think a measurement more on the order of the product of the physical gate depth and the square of the physical qubit count is more accurate; for the three cases in table II, which represent equally powerful (in some sense) quantum computers, this value is roughly constant across the three columns. It also matches the rule of thumb that the number of qubits in a distance $d$ QEC code scales as $d^2$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The one thing this leaves out is that the computer with $10^9$ physical gate depth will run your chemistry simulation much faster than the computer with $10^3$ physical gate depth because the computational and wall-clock overhead of QEC will be much lower. You could come up with a more complicated formula to take this into account, if you like.&lt;/p&gt;&#xA;" OwnerUserId="4265" LastEditorUserId="1978" LastEditDate="2018-08-09T17:24:12.823" LastActivityDate="2018-08-09T17:24:12.823" CommentCount="2" />
  <row Id="3993" PostTypeId="2" ParentId="3965" CreationDate="2018-08-09T21:49:51.040" Score="1" Body="&lt;p&gt;Actually, there should be a minus.&#xA;There is a mistake in the paper. &#xA;Wittek uses a minus in his (expensive) book [&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/0128100400&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://www.amazon.com/Quantum-Machine-Learning-Computing-Mining/dp/0128100400/ref=sr_1_3?ie=UTF8&amp;amp;qid=1533850923&amp;amp;sr=8-3&amp;amp;keywords=quantum+machine+learning]&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Indeed say :&#xA;$$ |\psi\rangle =  \frac{1}{\sqrt{2}} (|0,a\rangle + |1,b\rangle) $$&#xA;$$ |\phi\rangle =  \frac{1}{\sqrt{Z}} (|a||0\rangle - |b||1\rangle) $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Then :&#xA;$$ \langle \phi |\psi\rangle = \frac{1}{\sqrt{2Z}} (|a|\langle 0| - |b|\langle 1|) (|0,a\rangle + |1,b\rangle) $$&#xA;$$ = \frac{1}{\sqrt{2Z}}( |a|\langle 0|0\rangle|a\rangle - |b|\langle 1|0 \rangle|a\rangle + |a|\langle 0|1 \rangle|b\rangle - |b|\langle 1| 1 \rangle |b\rangle )$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ = \frac{1}{\sqrt{2Z}}  (|a| |a\rangle - 0 + 0 - |b| |b\rangle) = \frac{1}{\sqrt{2Z}}  (|a| |a\rangle  - |b| |b\rangle) $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now for the part of the question where you ask how to swap quantum registers of different numbers of qubits, the answer is you don't really do that.&#xA;In your example, you have the $ |\phi\rangle $ as a single-qubit state  and $ |\psi\rangle $ as a 2-qubit state. Let $ q_0,q_1,q_2 $ being the qubits representing them respectively.&#xA;At the beginning, we have &#xA;$$ q_0 \otimes q_1 \otimes q_2 $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the control qubit was 1, I think what you would like is swap them so that conditioning on the control qubit we have &#xA;$$ q_1 \otimes q_2 \otimes q_0 $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So your solution would be to control-swap $ q_0 $ with $ q_2 $ then swap $ q_2 $ with $ q_1 $.   &lt;/p&gt;&#xA;" OwnerUserId="4127" LastEditorUserId="4127" LastEditDate="2018-08-28T14:36:33.403" LastActivityDate="2018-08-28T14:36:33.403" CommentCount="3" />
  <row Id="3994" PostTypeId="1" AcceptedAnswerId="3998" CreationDate="2018-08-10T02:24:31.147" Score="6" ViewCount="147" Body="&lt;p&gt;Unlike Google's Bristlecone or IBM's Qbit computer, do simulators like Q# or Alibaba really use quantum mechanics anywhere in their physical chips? Are they just defining properties using a classical computer and trying to achieve quantum simulations ?&lt;/p&gt;&#xA;" OwnerUserId="4259" LastActivityDate="2018-08-10T15:42:45.200" Title="Are quantum simulators like Microsoft Q# actually using quantum mechanics in their chips?" Tags="&lt;quantum-computer&gt;&lt;quantum-simulation&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="3996" PostTypeId="2" ParentId="3955" CreationDate="2018-08-10T06:18:36.437" Score="1" Body="&lt;p&gt;The difficulty with the question is the word &lt;em&gt;intuitive&lt;/em&gt;. Intuition basically reflects our understanding of the world around us, which is described by classical physics. Quantum mechanics is exactly the regime where our intuition breaks down because it functions very differently from the world of our everyday experience. As Terry Pratchett said :&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;It’s very hard to talk quantum using a language originally designed to&#xA;  tell other monkeys where the ripe fruit is.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;It is exactly that difference that we're using to get the computational speed-up.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There is a sequence of standard algorithms that most quantum computing texts progress through: Deutsch's algorithm, &lt;a href=&quot;https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;Deutsch-Jozsa&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Simon%27s_problem&quot; rel=&quot;nofollow noreferrer&quot;&gt;Simon's&lt;/a&gt;/Bernstein-Vazirani. These are chosen because they are the easiest to understand. They all have broadly the same structure, but increasing complexity, with a corresponding gain in computational speed (with Simon's and Bernstein-Vazirani giving exponential speed-up). You will not understand them intuitively. You have to do the maths. I think the closest that you will come is through the following explanation of Deutsch's algorithm:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Imagine a one-bit function $f(x)$. Either $f(0)=f(1)$, or it does not. Your task is to determine which. Obviously, in the classical world, you have to evaluate $f(0)$ and $f(1)$; two function calls. In the quantum world, crudely speaking, you can look at both values simultaneously, and perform a one-qubit measurement (which will give you one bit of information), but you can choose that measurement so that the one bit is a global property of the function, in this case $f(0)\oplus f(1)$. The same is broadly true of the other algorithms I mentioned: there is information, due to the structure of the problem, hidden in the collective properties of the function evaluations, and it is those collective properties that you are trying to determine.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-08-10T06:18:36.437" CommentCount="2" />
  <row Id="3997" PostTypeId="2" ParentId="3994" CreationDate="2018-08-10T06:57:43.423" Score="6" Body="&lt;p&gt;Quantum simulators don't rely on quantum-mechanical effects in the physical chips; instead they simulate certain aspects of quantum state and operations on it using only classical compute.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Universal simulators simulate full quantum state of the system, performing linear algebra transformations on it. They support universal set of quantum operations, but the memory required grows exponentially with the number of qubits simulated, thus the system size is limited to 30-40 qubits (depending on the hardware and the simulator).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Specialized simulators can focus on simulating certain aspects of larger systems at the cost of supporting a smaller set of operations. For example, CHP simulator (described in &lt;a href=&quot;https://www.scottaaronson.com/papers/chp6.pdf&quot; rel=&quot;noreferrer&quot;&gt;this paper&lt;/a&gt;) evolves only the stabilizer information in a matrix tableau instead of the full quantum state, and the required memory growth is quadratic in the number of qubits. The set of gates supported is limited to CNOT, Hadamard and phase gates, but it is sufficient to study quantum error correction protocols.&lt;/p&gt;&#xA;" OwnerUserId="2879" LastEditorUserId="2879" LastEditDate="2018-08-10T15:42:45.200" LastActivityDate="2018-08-10T15:42:45.200" CommentCount="0" />
  <row Id="3998" PostTypeId="2" ParentId="3994" CreationDate="2018-08-10T08:25:03.820" Score="7" Body="&lt;p&gt;There is a distinction between what you use to write a program (the SDK), and what you use to run it (the backend).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The SDK can be either a graphical interface, like the &lt;a href=&quot;https://quantumexperience.ng.bluemix.net/qx/editor&quot; rel=&quot;noreferrer&quot;&gt;IBM Q Experience&lt;/a&gt; or the &lt;a href=&quot;http://quantumcomputer.ac.cn/index.html&quot; rel=&quot;noreferrer&quot;&gt;CAS-Alibaba Quantum Computing Laboratory&lt;/a&gt;. It could also be a way of writing programs, like Q#, QISKit, Forest, Circ, ProjectQ, etc.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The backend can either be a simulator that runs on a standard computer, or an actual quantum device.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Simulators use our knowledge of quantum theory to construct the simulation program, but no actual quantum computing happens. It is just the standard chips of your own computer, or of a supercomputer they let you use, running standard classical programs.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This approach is something we can do for small quantum programs, but the runtime will become unfeasibly long for large ones. So if you notice that your job takes longer and longer to run as you add more qubits, you know that it is being classically simulated rather than run on a real device.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The only actual quantum devices that can be used are those by IBM, Rigetti and Alibaba. To write programs for these you can use the Q Experience, QISKit or ProjectQ for the IBM devices, Rigetti's Forest for their devices, or the Alibaba graphical interface for their device.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Microsoft are making hardware, and they hope that it will one day be used as a backend in Q#. But they have not yet gotten a single qubit, so we might have to wait a while. Until then it will be only simulators that can be used (or other companies hardware).&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-08-10T08:25:03.820" CommentCount="2" />
  <row Id="3999" PostTypeId="2" ParentId="3955" CreationDate="2018-08-10T12:44:20.247" Score="3" Body="&lt;p&gt;I would like to suggest that period finding (a subroutine, if you like, of the famous Shor algorithm) demonstrates a very intuitive, exponential speed-up: It should be intuitively clear that something on the order of (the square root of the uncertainty $\Delta p$) of the period $p$ of function evaluations is required classically to find an unknown period $p$ of a function that is guaranteed to be periodic in its integer input value. I've deliberately placed the paranthesis such that their content will be intuitive to people who have deeply ingrained the birthday paradox yet, for demonstrating a superpolynomial speedup, it is sufficient to intuitively understand that it is somewhere near $\Delta p$, the correct answer $\sqrt{\Delta p}$, or some polynomial thereof and not something like the number of digits of $p$, $O(\log p)$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The quantum algorithm for period finding, as employed by Shor's algorithm, simply takes the quantum Fourier transform of the periodic function applied to the equal superposition of all states. Naturally, only integer multiples of the period can then have a non-zero probability amplitude, so doing this (typically) twice will allow you to quickly extract the common factor as greatest common denominator. But a quantum Fourier transform is trivially implementable by $O(log p)$ controlled rotations (one per each input bit).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The biggest intuitive speedup obviously occurs if you make the function evaluation very costly: The quantum algorithm only requires a constant (single) evaluation! But even otherwise you get a gain as you have an algorithm that runs, assuming function evaluations are constant time, in $O(\log p)$ rather than in $O(\sqrt{\Delta p})$ which, if you have no idea of the correct period $p$ is essentially $O(\sqrt{p})$.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastEditorUserId="1039" LastEditDate="2018-08-11T11:17:23.557" LastActivityDate="2018-08-11T11:17:23.557" CommentCount="0" />
  <row Id="4000" PostTypeId="2" ParentId="3959" CreationDate="2018-08-11T01:39:58.223" Score="4" Body="&lt;p&gt;We can think of the Rubik's cube &lt;a href=&quot;https://en.wikipedia.org/wiki/Cayley_graph&quot; rel=&quot;nofollow noreferrer&quot;&gt;Cayley graph&lt;/a&gt; $\Gamma=(V,E)$ with each (colored) edge $E$ being one of the Singmaster moves $\langle U,U^{2},U^{3}=U^{-1},D,D^{2},D^{3},\cdots\rangle$ and each vertex $V$ being one of the $43252003274489856000\approx 4.3e{19}$ different configurations of the $3\times 3\times 3$ cubes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &lt;a href=&quot;http://mathworld.wolfram.com/GraphDiameter.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;diameter&lt;/a&gt; of a graph is the longest shortest path in the graph.  Classical algorithm for determining the diameter is polynomial in $\vert V \vert$; see, e.g., &lt;a href=&quot;https://cs.stackexchange.com/questions/194/the-time-complexity-of-finding-the-diameter-of-a-graph&quot;&gt;this answer&lt;/a&gt; from a sister site.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As mentioned above, God's number is (related to) this diameter; to know the longest shortest path between to vertices for a Cayley graph on a group, it suffices to know how many steps away from the solved state one is.  We know, thanks to Rokicki, Kociemba, Davidson, and Dethridge among others, that God's number is $20$.  The algorithms they executed was polynomial in $\vert V\vert$, e.g. polynomial in $4.3e{19}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Heiligman's quantum algorithm for graph diameter, mentioned in the comments, achieves a Grover speedup over Djikstra's algorithms, with &quot;a total quantum cost of $O(|V|^{9/4})$.&quot;  However, I believe Heiligman encodes the graph much as a classical algorithm would; e.g. with $O(|V|)$ qubits.  Clearly if $|V|=4.3e{19}$ then this would not help.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Instead,&lt;/em&gt; another way to encode a Rubik's cube, as hinted in the other questions, is of course to prepare a uniform superposition over all $4.3e{19}$ states.  This only takes $\log 4.3e{19}$ qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quantum algorithms are good at talking about &quot;eigenvalues&quot; and &quot;eigenvectors&quot; and &quot;eigenstates.&quot;  Applying all Singmaster moves to a uniform superposition of all $4.3e{19}$ states does not change the state; i.e. the uniform superposition is an eigenstate of the Markov chain on the Cayley graph.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are relations between the &lt;em&gt;diameter&lt;/em&gt; of a graph and the &lt;em&gt;eigenvalues/eigenvectors&lt;/em&gt; of the corresponding adjacency/Laplacian matrix, especially the spectral gap, the distance between the two largest eigenvalues ($\lambda_1-\lambda_2$).  A quick Google search of &quot;diameter eigenvalue&quot; produces &lt;a href=&quot;https://link.springer.com/article/10.1007/BF01789463&quot; rel=&quot;nofollow noreferrer&quot;&gt;this&lt;/a&gt;; I recommend exploring similar Google searches.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Spectral gaps are &lt;strong&gt;exactly&lt;/strong&gt; what limits the &lt;a href=&quot;https://en.wikipedia.org/wiki/Adiabatic_quantum_computation&quot; rel=&quot;nofollow noreferrer&quot;&gt;adiabatic algorithm&lt;/a&gt;.  Thus, perhaps by knowing how fast an adiabatic algorithm needs to run to evolve from the uniform superpositon to the solved state for various subgroups/subspaces of the Rubik's cube group, one could estimate the spectral gap, and use this to bound God's number.  But I'm quickly out of my league here and I doubt any sense of accuracy is achievable.&lt;/p&gt;&#xA;" OwnerUserId="2927" LastEditorUserId="2927" LastEditDate="2018-08-11T02:02:00.363" LastActivityDate="2018-08-11T02:02:00.363" CommentCount="4" />
  <row Id="4001" PostTypeId="2" ParentId="3985" CreationDate="2018-08-11T06:52:07.897" Score="5" Body="&lt;p&gt;Quantum volume is likely only useful as a metric for small noisy computers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It’s impossible to invent any single-number metric that’s ideal for all tasks. Even with classical computers, metrics such as Dhrystone or Windows Performance Index are at best suggestive at predicting performance on real-world tasks. Conversely, giving more than one number can potentially be much more informative. Within the quantum volume framework, I suggest when characterizing a QPU to give quantum volume as the “executive summary” but also quote for a range of different qubit numbers $N$ the model circuit depths $d(N)$. Comparing the $d(N)$ to the needed depth and qubits will be predictive, at least to the extent that the killer apps resemble the model circuit sequences of parallel random $SU(4)$ on random pairs of qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The quantum volume is about correctly implementing the model circuits, thus measuring it involves simulating those circuits to compare the output of the QPU against the ideal results.  Simulation is practical only for relatively few qubits or low depth, so it is only possible to measure the quantum volume for small/noisy devices (without additional assumptions). Fortunately, when width/depth reaches the limit of simulation (very roughly around $N\simeq d\simeq 50$), this is when the noise must necessarily be low enough that we could begin to use such a device to implement logical qubits. Defining appropriate metrics for logical qubits is an open question. The emphasis switches from “Can this algorithm run at all?” to “How long will this algorithm take?” and metrics will surely be very different, involving the logical gate time.&lt;/p&gt;&#xA;" OwnerUserId="4322" LastActivityDate="2018-08-11T06:52:07.897" CommentCount="0" />
  <row Id="4002" PostTypeId="1" AcceptedAnswerId="4004" CreationDate="2018-08-11T07:51:42.133" Score="7" ViewCount="55" Body="&lt;p&gt;In many sources (like on Page 30 &lt;a href=&quot;https://arxiv.org/abs/1802.08227&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;), I found that the complexity of the original Harrow Hassidim Lloyd is stated as $\mathcal{O}(\log (N) s^2 \kappa^2/\epsilon)$ where $s$ is said to be the &quot;matrix sparsity&quot;. What is a precise definition of the term &quot;matrix sparsity&quot;? I couldn't find it stated anywhere. &lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-08-11T12:23:59.963" Title="What exacty is &quot;matrix sparsity&quot; $s$?" Tags="&lt;quantum-algorithms&gt;&lt;hhl-algorithm&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="4003" PostTypeId="2" ParentId="4002" CreationDate="2018-08-11T08:12:58.147" Score="2" Body="&lt;p&gt;I believe the way they use it is as&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The maximum number of non-zero elements in any row.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Although that’s different to the way Wikipedia defines sparsity, which is essentially the average:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;the total number of non-zero elements divided by the number of elements.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-08-11T08:12:58.147" CommentCount="0" />
  <row Id="4004" PostTypeId="2" ParentId="4002" CreationDate="2018-08-11T12:09:08.463" Score="7" Body="&lt;p&gt;You have the definitions in your paper &lt;a href=&quot;https://arxiv.org/abs/1802.08227&quot; rel=&quot;noreferrer&quot;&gt;you link&lt;/a&gt; page 12.&#xA;Simply said, it is a matrix with many 0s.&lt;br&gt;&#xA;As an example take N = 16, and the polynomial function is just a simple function like 1.5*X,&#xA;then your matrix has at most 1.5*log(16,2)=6 non-zero entries per row.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/XQGw9.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/XQGw9.png&quot; alt=&quot;Definitions of sparsity&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you prefer a visual, you have it &lt;a href=&quot;https://www.cs.umd.edu/~amchilds/talks/nsf15.pdf&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/rbRcz.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/rbRcz.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="4127" LastEditorUserId="4127" LastEditDate="2018-08-11T12:23:59.963" LastActivityDate="2018-08-11T12:23:59.963" CommentCount="0" />
  <row Id="4005" PostTypeId="1" CreationDate="2018-08-11T15:03:39.597" Score="7" ViewCount="69" Body="&lt;p&gt;Many people have suggested using &quot;Random Circuit Sampling&quot; to demonstrate quantum supremacy. But what is the precise definition of the &quot;Random Circuit Sampling&quot; problem? I've seen statements like &quot;the task&#xA;is to take a random (efficient) quantum circuit of a specific form and generate samples from its output distribution&quot;. But it is not clear to me what the terms &quot;random (efficient) quantum circuit&quot; mean precisely. Also, do we know anything about the classical computational complexity of this problem?&lt;/p&gt;&#xA;" OwnerUserId="4324" LastActivityDate="2018-08-11T22:16:48.567" Title="What exactly is &quot;Random Circuit Sampling&quot;?" Tags="&lt;quantum-speedup&gt;&lt;quantum-supremacy&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="4006" PostTypeId="2" ParentId="4005" CreationDate="2018-08-11T22:10:07.680" Score="5" Body="&lt;p&gt;There are a continuous set of possible states for $n$ qubits, each of which can be expressed as a superposition of the $2^n$ basis states.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Mostly of these states are highly entangled, and would require highly complex circuits to create (assuming the standard gate set of single qubit rotations and two or three qubit entangling gates).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;These circuits would have to be implemented very cleanly to be able to reach these states. Noise causes decoherence, which essentially drives your qubits to an unentangled state (like all qubits $|0\rangle$ due to relaxation, or the maximally mixed state due to constantly rotated relaxation and dephasing).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The set of unentangled states is just a tiny corner of the total set of all possible states, but it is a corner that is hard to leave for long. So implementing circuits capable of fully exploring the $n$ qubit Hilbert space will be very hard. But taking advantage of the full Hilbert space is what quantum computing is all about. So we have to show that we can overcome this hurdle.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One way to see how well we do this is to focus on just randomly producing $n$ qubit states. These should be picked uniformly from all possible states, and not be biased towards the tiny set of states that it is easy for us to produce or write down. This can be done by running a random circuits of sufficient circuit depth. The number of gates for this thought to be efficient (i.e. polynomial in $n$), though I'm not sure if this is proven or is just a widely held conjecture.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The randomness of the process ensures that there are no nice properties that could be exploited by a classical simulation. So the task of simulating arbitrary random circuits will require a full simulation of the $n$ qubits, the required classical resources for which scale exponentially with $n$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The details of how exactly to go about creating the random circuit, and what to look for in the results to declare success, depend on the proposal (such as Google's). It is also not yet clear how many qubits are needed before current supercomputers cannot reproduce the result.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-08-11T22:16:48.567" LastActivityDate="2018-08-11T22:16:48.567" CommentCount="0" />
  <row Id="4007" PostTypeId="1" CreationDate="2018-08-12T02:25:30.650" Score="5" ViewCount="67" Body="&lt;p&gt;Is there a method to calculate prime factorization in Q# of Visual Studio of Microsoft Quantum Development Kit?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the python language, it is the &lt;code&gt;sympy.factorint&lt;/code&gt; method.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Or else Q# sample program there?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is like &lt;a href=&quot;https://en.wikipedia.org/wiki/Shor%27s_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;Shor's algorithm&lt;/a&gt; calling Q# from C#.&lt;/p&gt;&#xA;" OwnerUserId="4308" LastEditorUserId="23" LastEditDate="2018-08-13T20:18:06.307" LastActivityDate="2018-08-13T20:18:06.307" Title="Q# factorization Method Program" Tags="&lt;quantum-computer&gt;&lt;q#&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="4008" PostTypeId="2" ParentId="4007" CreationDate="2018-08-12T05:49:49.290" Score="4" Body="&lt;p&gt;&lt;a href=&quot;https://github.com/Microsoft/Quantum/tree/master/Samples/IntegerFactorization&quot; rel=&quot;nofollow noreferrer&quot;&gt;Integer factorization sample&lt;/a&gt; in the official Quantum Development Kit samples repository implements Shor's algorithm in Q# and shows how to call it from C#.&lt;/p&gt;&#xA;" OwnerUserId="2879" LastActivityDate="2018-08-12T05:49:49.290" CommentCount="0" />
  <row Id="4009" PostTypeId="2" ParentId="3960" CreationDate="2018-08-12T07:10:09.783" Score="3" Body="&lt;p&gt;Any Hermitian gate is &quot;self-canceling&quot;. Proof: since any gate $U$ is unitary&#xA;$$&#xA;UU^{\dagger}=U^{\dagger}U=I&#xA;$$&#xA;If $U$ is also Hermitian, $U=U^{\dagger}$ and&#xA;$$UU=I$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;CNOT gate&#xA;$$&#xA;\left(\begin{array}{cccc}&#xA;1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\&#xA;0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\&#xA;0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0&#xA;\end{array}\right)&#xA;$$&#xA;is Hermitian by inspection.&lt;/p&gt;&#xA;" OwnerUserId="2105" LastActivityDate="2018-08-12T07:10:09.783" CommentCount="0" />
  <row Id="4010" PostTypeId="1" CreationDate="2018-08-12T20:34:45.397" Score="7" ViewCount="43" Body="&lt;p&gt;Quoting from &lt;a href=&quot;https://earltcampbell.com/research/magic-states/&quot; rel=&quot;noreferrer&quot;&gt;this blog post by Earl T. Campbell&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Magic states are a special ingredient, or resource, that allows quantum computers to run faster than traditional computers.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;One interesting example that is mentioned in that blog post is that, in the case of a single qubit, any state apart from the eigenstates of the Pauli matrices is &lt;em&gt;magic&lt;/em&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;How are these &lt;em&gt;magic states&lt;/em&gt; more generally defined? Is it really just &lt;em&gt;any state that is not a stabilizer state&lt;/em&gt;, or is it something else?&lt;/p&gt;&#xA;" OwnerUserId="55" LastActivityDate="2018-08-13T06:25:12.287" Title="How are magic states defined in the context of quantum computation?" Tags="&lt;quantum-speedup&gt;&lt;fault-tolerance&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="4011" PostTypeId="2" ParentId="4010" CreationDate="2018-08-13T05:16:07.630" Score="2" Body="&lt;p&gt;It is any state that, if you have an unlimited supply of them, can be used to give you universal quantum computation when used in conjunction with perfect Clifford operations.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The standard example is that if you can produce the state $(|0\rangle+e^{i\pi/4}|1\rangle)/\sqrt{2}$, then you can combine this with Clifford operations in order to apply a $T$ gate (see Fig. 10.25 in Nielsen and Chuang), and we know that $T$+Clifford is universal.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To be clear, in the one qubit case that is being discussed, I assume the accurate statement is that any &lt;em&gt;pure&lt;/em&gt; state that is not an eigenstate of a Pauli operator is magic. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The real interest is in mixed states - how noisy can a particular magic state be before it isn’t magic any more. The theory being that Clifford operations are often comparatively easy in a fault-tolerant scenario (they can be applied transversally), and it is creating the one non-Clifford gate that’s hard. The more noise it can tolerate, the easier it will be to make.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I believe that I’ve seen results proving that there are some non-Clifford mixed states which are not magic, but I don’t remember the reference off the top of my head. Earl’s papers are the ones you want to read on this topic.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-08-13T06:25:12.287" LastActivityDate="2018-08-13T06:25:12.287" CommentCount="0" />
  <row Id="4012" PostTypeId="1" AcceptedAnswerId="4013" CreationDate="2018-08-13T14:27:24.667" Score="4" ViewCount="43" Body="&lt;p&gt;For example, one have measured some states like $|0\rangle$ in the computational basis for many times and got the approximate probability of getting 0 and 1 ($P(0)$ and $P(1)$). Then how does he calculate the off-diagonal elements of the density of the initial quantum state?&#xA;The system is open and with noise.&lt;/p&gt;&#xA;" OwnerUserId="4178" LastActivityDate="2018-08-13T14:41:14.227" Title="How to calculate the off-diagonal elements of a density matrix using the measurement result?" Tags="&lt;measurement&gt;&lt;density-matrix&gt;" AnswerCount="1" CommentCount="1" />
  <row Id="4013" PostTypeId="2" ParentId="4012" CreationDate="2018-08-13T14:41:14.227" Score="5" Body="&lt;p&gt;With the given measurements, you cannot: there is no observable difference between many different states such as $|\pm\rangle=(|0\rangle\pm|1\rangle)/\sqrt{2}$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In order to determine what the state is completely, you need more measurements. If you're using projective measurements, you need two more. These would typically be projections onto the bases&#xA;$$&#xA;|\pm\rangle \qquad\text{and}\qquad  (|0\rangle\pm i|1\rangle)/\sqrt{2}&#xA;$$&#xA;However, if you are willing to use POVMs, you can define a single measurement, comprising four measurement operators that does the job. One way to visualise these is in the Bloch-sphere: you need a set of axes that provides a basis in the three dimensional space. Three vectors cannot do this because they satisfy a completeness relation which constrains them to be in a plane. The most effective way to do this is to inscribe a regular tetrahedron inside the Bloch sphere and take the 4 corners as measurement bases.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-08-13T14:41:14.227" CommentCount="0" />
  <row Id="4014" PostTypeId="1" CreationDate="2018-08-14T02:04:32.497" Score="5" ViewCount="69" Body="&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Boson_sampling&quot; rel=&quot;nofollow noreferrer&quot;&gt;Boson Sampling&lt;/a&gt;, sometimes stylized as BosonSampling, is an attractive candidate problem to establish quantum supremacy; the engineering problems appear more surmountable than those associated with a Turing-complete quantum computer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, Boson Sampling has a downside, in that the output of a photonic quantum computer capable of executing Boson Sampling with only a handful ($\le 100$ or so) of qubits may not even be able to be clasically simulated.  This is, of course, unlike $\mathsf{NP}$ problems such as factoring, the engineering aspects of which are significantly harder.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Thus, we may establish the results of Boson Sampling on $100$ or so photons, but in order to verify the results, we need to calculate the permanent of a $100\times100$ matrix.  This is famously computationally hard to verify.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Maybe a supercomputer powerful enough to calculate the permanent can do the trick.  But then everyone would have to believe &lt;em&gt;both&lt;/em&gt; the supercomputer's results &lt;em&gt;and&lt;/em&gt; the Boson Sampling results.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Is there anything about Boson Sampling that can be easily verified?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I've had a flight of fancy to maybe put the resources of a cryptocurrency mining network to use to calculate such a permanent, and relying on some $\mathsf{\#P}$ / $\mathsf{IP}$ tricks for public verification, but I haven't gotten very far.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;EDIT&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I like @gIS's answer.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Compare Boson Sampling with Appel and Franken's computer-assisted proof of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Four_color_theorem&quot; rel=&quot;nofollow noreferrer&quot;&gt;Four Color Theorem&lt;/a&gt;.  The original proof of the 4CT was allegedly controversial, precisely because the proof was too long to be publicly verified by a human reader.  We've moved so far from the '70's with our trust of computers, wherein I think now most people accept the proof of the 4CT without much controversy. But thinking about how to make things like a proof of the 4CT human-verifiable may lead to interesting ideas like the &lt;a href=&quot;https://en.wikipedia.org/wiki/PCP_theorem&quot; rel=&quot;nofollow noreferrer&quot;&gt;$\mathsf{PCP}$ theorem&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="2927" LastEditorUserId="2927" LastEditDate="2018-08-14T16:19:23.097" LastActivityDate="2018-08-24T11:20:15.910" Title="What about BosonSampling can be publicly verified?" Tags="&lt;photonics&gt;&lt;boson-sampling&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="4015" PostTypeId="5" CreationDate="2018-08-14T12:03:40.867" Score="0" Body="&lt;p&gt;Use for questions about money whose security is based on aspects of the No-Cloning Theorem.  For example, questions regarding Wiesner's scheme from the 1970's, or more recent public-key schemes from the early 2010's, or other questions about distributed ledgers and quantum money from the late 2010's.&lt;/p&gt;&#xA;" OwnerUserId="2927" LastEditorUserId="2927" LastEditDate="2018-08-14T14:38:11.537" LastActivityDate="2018-08-14T14:38:11.537" CommentCount="0" />
  <row Id="4016" PostTypeId="4" CreationDate="2018-08-14T12:03:40.867" Score="0" Body="Use for questions about money whose security is based on aspects of the No-Cloning Theorem." OwnerUserId="2927" LastEditorUserId="2927" LastEditDate="2018-08-14T14:38:21.777" LastActivityDate="2018-08-14T14:38:21.777" CommentCount="0" />
  <row Id="4017" PostTypeId="1" CreationDate="2018-08-14T12:37:15.387" Score="4" ViewCount="60" Body="&lt;p&gt;I was wondering if there was some code available for Hamiltonian simulation for sparse matrix. And also if they exist, they correspond to a divide and conquer approach or a Quantum walk approach?&lt;/p&gt;&#xA;" OwnerUserId="4127" LastActivityDate="2018-08-14T12:59:53.410" Title="Is there a Hamiltonian simulation technique implemented somewhere?" Tags="&lt;quantum-algorithms&gt;&lt;hamiltonian-simulation&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="4018" PostTypeId="2" ParentId="4017" CreationDate="2018-08-14T12:59:53.410" Score="2" Body="&lt;p&gt;&lt;a href=&quot;https://www.tandfonline.com/doi/abs/10.1080/00268976.2012.668289&quot; rel=&quot;nofollow noreferrer&quot;&gt;In this article&lt;/a&gt; the authors stated that they used this &lt;a href=&quot;https://docs.lib.purdue.edu/cgi/viewcontent.cgi?referer=https://www.google.com/&amp;amp;httpsredir=1&amp;amp;article=1762&amp;amp;context=nanopub&quot; rel=&quot;nofollow noreferrer&quot;&gt;Group Leader's algorithm&lt;/a&gt; in order to obtain the circuit implementing the hamiltonian simulation used as a subroutine in an instance of &lt;em&gt;HHL&lt;/em&gt; algorithm. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Unfortunately though, I did not understand quite well how they actually managed to find the circuit with that method.&lt;/p&gt;&#xA;" OwnerUserId="2648" LastActivityDate="2018-08-14T12:59:53.410" CommentCount="1" />
  <row Id="4019" PostTypeId="2" ParentId="3980" CreationDate="2018-08-14T13:48:35.050" Score="3" Body="&lt;p&gt;You can actually perform convolution on a quantum computer (and exponentially faster for that matter), if your input signals have a certain structure. But for general inputs, this seems challenging and maybe even physically impossible, which is what the paper seems to argue.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Consider how you would compute the convolution of two discrete signals $f$ and $g$ classically. You can take the Fourier transform of both signals, do a point-wise multiplication of the resulting vectors, and then do an inverse Fourier transform:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;\mathscr{F}^{-1} (\mathscr{F}(f) . \mathscr{F}(g))&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that Fourier transform is a very cheap operation on a quantum computer. So this seems great. The problem is that the point-wise multiplication of two vectors is not so easy. Let's see what factors determine that.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Suppose we are lucky and the Fourier spectrum of $f$ turns out to be flat:&#xA;$$&#xA;F = \mathscr{F}(f) = \frac{1}{N}\sum_{i=0}^{N-1}{|i\rangle} = \sum_{i=1}^{N-1}F(i)&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In that case, your quantum computer can do a diagonal matrix operation that gives you the point-wise multiplication:&#xA;$$&#xA;\mathscr{F}(f) . \mathscr{F}(g) = F.G = &#xA;\left(\begin{array}{cccc}&#xA;F(0) &amp;amp;      &amp;amp;  &amp;amp;  \\&#xA;     &amp;amp; F(1) &amp;amp;  &amp;amp;  \\&#xA;     &amp;amp;      &amp;amp; . &amp;amp; \\&#xA;     &amp;amp;      &amp;amp;  &amp;amp; F(N-1)&#xA;\end{array}\right) &#xA;\left(\begin{array}{c}&#xA;G(0) \\&#xA;G(1) \\&#xA;. \\&#xA;G(N-1)&#xA;\end{array}\right)&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, quantum algorithms that find the point-wise multiplication of two vectors may be physically impossible in the general case. This is because this operation is non-unitary in general. As a simple example, suppose that the Fourier transform of $f$ is a spiky function, with zeros in most places:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;F = \mathscr{F}(f) = \frac{1}{2}(|0\rangle + |2\rangle + |5\rangle + |7\rangle)&#xA;$$&#xA;The point-wise multiplication of this state with another state is non-reversible (because of the zeros), and thus not unitary.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There has been prior work to discover functions that result in a flat or near-flat Fourier spectrum, and are thus easy to convolute:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/0811.3208&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/0811.3208&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0211140&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/quant-ph/0211140&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="2503" LastEditorUserId="2503" LastEditDate="2018-08-14T16:43:51.840" LastActivityDate="2018-08-14T16:43:51.840" CommentCount="0" />
  <row Id="4020" PostTypeId="2" ParentId="4014" CreationDate="2018-08-14T14:53:24.837" Score="4" Body="&lt;h1&gt;About the need of boson sampling verification&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;First of all, let me point out that it is not a strict necessity to &lt;em&gt;verify&lt;/em&gt; the output of a boson sampler. By this, I don't mean to say that it is not useful or interesting to try and do so, but rather that it is in some sense more of a &lt;em&gt;practical&lt;/em&gt; than a fundamental necessity.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I think you yourself put up a good argument for this when you write&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Maybe a supercomputer powerful enough to calculate the permanent can do the trick. But then everyone would have to believe both the supercomputer's results and the Boson Sampling results.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Indeed, there are many instances in which one solves a problem and trusts a solution which cannot really be fully verified. I mean, forget quantum mechanics, just use your computer to multiply two huge numbers. You probably have a high confidence that the result you get is correct, but how do you &lt;em&gt;verify&lt;/em&gt; it without using another computer?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;More generally, &lt;em&gt;trust&lt;/em&gt; in a device's results comes from a variety of things, such as knowledge of the inner working of the device, and unit testing of the device itself (that is, testing that it works correctly for the special instances that you &lt;em&gt;can&lt;/em&gt; verify with some other method).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The problem of boson sampling certification is no different. We know that, at some point, we will not be able to fully verify the output of a boson sampler, but that does not mean that we will not be able to trust it. If the device is built with due thoroughness, and its output is verified for a variety of small instances, and other tests that one is able to carry out are all successful, then at some point one builds up enough &lt;em&gt;trust&lt;/em&gt; in the device to make a quantum supremacy claim (or whatever else one wants to use the boson sampler for) meaningful.&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;Is there anything about BosonSampling that can be easily verified?&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Yes, there are properties that can be verified. Due to the sampling nature of the problem, what people typically do is to rule out alternative models that might have generated the observed samples. For example, Aaronson and Arkhipov (&lt;a href=&quot;https://arxiv.org/abs/1309.7460&quot; rel=&quot;nofollow noreferrer&quot;&gt;1309.7460&lt;/a&gt;) showed that the BosonSampling distribution is far from the uniform distribution in total variation distance (with high probability over the Haar-random matrices inducing the distribution), and gave a protocol to efficiently distinguish the two distributions.&#xA;A more recent work showing how statistical signatures can be used to certify the boson sampling distribution against alternative hypotheses is (&lt;a href=&quot;https://arxiv.org/abs/1410.8547&quot; rel=&quot;nofollow noreferrer&quot;&gt;Walschaers et al. 2014&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;All other works that I am aware of focus on certifying specific aspects of a boson sampler, rather than directly tackling the problem of finding alternative distributions which are far from the BosonSampling one for random interferometers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;More specifically, one can isolate two major possible sources of error in a boson sampling apparatus: those arising from incorrectly implementing the interferometer, and those arising from the input photons not being what they should (that is, totally indistinguishable).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The first case is (relatively) easy to handle because one can efficiently characterise an interferometer using single-photons.&#xA;However, certifying the indistinguishability of input photons is trickier. One idea to do this is to change the interferometer to a non-random one, such as the QFT interferometer, and see whether something can be efficiently verified in this simpler case. I won't try to add all the relevant references here, but this direction started with (Tichy et al. &lt;a href=&quot;https://arxiv.org/abs/1002.5038&quot; rel=&quot;nofollow noreferrer&quot;&gt;2010&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1312.3080&quot; rel=&quot;nofollow noreferrer&quot;&gt;2013&lt;/a&gt;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Regarding the public verification aspect, there isn't anything done in this direction that I've heard of. I am also not sure whether it is even a particularly meaningful direction to explore: why should we require such a &quot;high standard&quot; of verification for a boson sampler, when for virtually any other kind of experiment we are satisfied with trusting the people doing the experiment to be good at what they are doing?&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-08-24T11:20:15.910" LastActivityDate="2018-08-24T11:20:15.910" CommentCount="0" />
  <row Id="4021" PostTypeId="2" ParentId="2151" CreationDate="2018-08-14T16:37:15.337" Score="1" Body="&lt;p&gt;Here's a list of other resources to learn about quantum machine learning:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1409.3097&quot; rel=&quot;nofollow noreferrer&quot;&gt;An introduction to quantum machine learning&lt;/a&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1408.7005&quot; rel=&quot;nofollow noreferrer&quot;&gt;The quest for a Quantum Neural Network&lt;/a&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://www.researchgate.net/profile/Peter_Wittek/publication/264825604_Quantum_Machine_Learning_What_Quantum_Computing_Means_to_Data_Mining/links/5ababcfba6fdcc71647085db/Quantum-Machine-Learning-What-Quantum-Computing-Means-to-Data-Mining.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Machine Learning: What Quantum Computing Means to Data Mining&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://medium.com/xanaduai/quantum-machine-learning-1-0-76a525c8cf69&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Machine Learning 1.0&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="4294" LastActivityDate="2018-08-14T16:37:15.337" CommentCount="0" />
  <row Id="4023" PostTypeId="1" AcceptedAnswerId="4034" CreationDate="2018-08-14T20:22:19.970" Score="5" ViewCount="64" Body="&lt;p&gt;$\newcommand{\ket}[1]{\lvert#1\rangle}$I am trying to show equality of two intermediate steps in the rearrangement of the Quantum Fourier transform definition, but I do not know how to rearrange the coefficients of a tensor product. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The text claims that $$ \frac{1}{2^{n/2}}\sum_{k_1=0}^{1}\sum_{k_2=0}^{1} \cdots \sum_{k_n=0}^{1}e^{2\pi ij \left( \sum_{l=1}^n{k_l 2^{-l}} \right)} \ket{k_1 \ldots k_n} = \frac{1}{2^{n/2}}\sum_{k_1=0}^{1}\sum_{k_2=0}^{1} \cdots \sum_{k_n=0}^{1}{ \bigotimes_{l=1}^n e^{2\pi ijk_l 2^{-l}} \ket{k_l}} $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Isolating the parts that change leaves us with $$ e^{2\pi ij \left( \sum_{l=1}^n{k_l 2^{-l}} \right)} |k_1 \ldots k_n \rangle = \bigotimes_{l=1}^n e^{2\pi ijk_l 2^{-l}} |k_l \rangle. $$ If I were to look at a small case letting $ n = 3. $ I would get the following on the left hand side, $$ e^{2\pi i j \left( k_12^{-1} + k_22^{-2} + k_32^{-3} \right) } |k_1k_2k_3 \rangle, $$ and the following on the right hand side, $$ e^{2 \pi i jk_12^{-1}} |k_1\rangle \otimes e^{2 \pi i jk_22^{-2}}|k_2\rangle \otimes e^{2 \pi i jk_32^{-3}}|k_3\rangle. $$ Is there a rule that is similar to $$ a |k_1\rangle \otimes b |k_2\rangle = ab|k_1k_2\rangle$$ that will allow me to rewrite the RHS to be equal to the LHS as desired.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I would also like to ask for reference suggestions to strengthen my understanding of tensor product algebra as well.&lt;/p&gt;&#xA;" OwnerUserId="4348" LastEditorUserId="55" LastEditDate="2018-08-14T20:33:14.973" LastActivityDate="2018-08-15T16:28:37.993" Title="Simplifying Quantum Tensor products with coefficients" Tags="&lt;tensor-product&gt;&lt;quantum-fourier-transform&gt;" AnswerCount="2" CommentCount="1" FavoriteCount="1" />
  <row Id="4029" PostTypeId="1" AcceptedAnswerId="4038" CreationDate="2018-08-15T01:28:15.780" Score="5" ViewCount="124" Body="&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_rotor_model&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wikipedia&lt;/a&gt; entry on the subject is rather short. I am also curious about generalizations of quantum rotors in n-dimensions. An introductory explanation with at least one resource for further reading would be greatly appreciated. &lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-08-15T15:13:56.327" LastActivityDate="2018-08-15T16:08:37.603" Title="What exactly are &quot;quantum rotors&quot;?" Tags="&lt;resource-request&gt;&lt;rotor-model&gt;" AnswerCount="2" CommentCount="2" />
  <row Id="4030" PostTypeId="5" CreationDate="2018-08-15T05:05:18.760" Score="0" Body="" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-08-15T05:05:18.760" LastActivityDate="2018-08-15T05:05:18.760" CommentCount="0" />
  <row Id="4031" PostTypeId="4" CreationDate="2018-08-15T05:05:18.760" Score="0" Body="The quantum rotor model is a mathematical model for a quantum system. It can be visualized as an array of rotating electrons which behave as rigid rotors that interact through short-range dipole-dipole magnetic forces originating from their magnetic dipole moments (neglecting Coulomb forces). The model differs from similar spin-models such as the Ising model and the Heisenberg model in that it includes a term analogous to kinetic energy. [from Wikipedia]" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-08-15T05:05:18.760" LastActivityDate="2018-08-15T05:05:18.760" CommentCount="0" />
  <row Id="4032" PostTypeId="2" ParentId="4023" CreationDate="2018-08-15T06:08:52.480" Score="1" Body="&lt;p&gt;Isn't &#xA;$$ e^{2\pi i j \left( k_12^{-1} + k_22^{-2} + k_32^{-3} \right) } |k_1k_2k_3 \rangle, $$ &#xA;same as&#xA;$$ e^{2 \pi i jk_12^{-1}} |k_1\rangle \otimes e^{2 \pi i jk_22^{-2}}|k_2\rangle \otimes e^{2 \pi i jk_32^{-3}}|k_3\rangle. $$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The kets gets the kronecker product according to $ a |k_1\rangle \otimes b |k_2\rangle = ab|k_1k_2\rangle$ and the exponentials adds up according to $e^{x+y}=e^x.e^y$. Just keep in mind that this identity of exponential holds only if $x$ and $y$ commutes. In your case the power to which exponentials are raised are just scalar numbers and thus commutes.&lt;/p&gt;&#xA;" OwnerUserId="2817" LastActivityDate="2018-08-15T06:08:52.480" CommentCount="0" />
  <row Id="4033" PostTypeId="1" CreationDate="2018-08-15T07:40:35.363" Score="3" ViewCount="80" Body="&lt;p&gt;I'm new to Q# and I was curious on how one would find the number of Q# simulatable qubits for a specific machine.  I know Microsoft has an approximation of 16GB ~ 30 qubits but I wanted a better estimation for my own machines.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I wrote this quick program that runs a loop which allocates a register of increasing size.  When I get a std::bad_alloc error I then have an estimate.  I'm guessing there is a better way either through a tool or some pre-written code.&lt;/p&gt;&#xA;" OwnerUserId="1287" LastActivityDate="2018-08-15T23:43:47.773" Title="Finding the maximum number of Q# simulatable qubits" Tags="&lt;simulation&gt;&lt;q#&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="4034" PostTypeId="2" ParentId="4023" CreationDate="2018-08-15T10:28:48.633" Score="3" Body="&lt;p&gt;Expanding and generalising from Jitendra's answer: the key observation in this case is that you must use how scalar factors behave over tensor products.&#xA;Specifically,&#xA;$$ a (U \otimes V) = (aU) \otimes V = U \otimes (aV), $$&#xA;or more generally&#xA;$$ a_1 a_2 \cdots a_k \,(U_1 \otimes U_2 \otimes \cdots \otimes U_k)&#xA;= (a_1 U_1) \otimes (a_2 U_2) \otimes \cdots \otimes (a_k U_k). $$&#xA;Let's consider the left-hand side of the expression which you isolated,&#xA;$$&#xA; \exp\bigl(2\pi ij \sum_{\ell=1}^n{k_\ell 2^{-\ell}} \bigr) |k_1 \cdots k_n \rangle \;: $$ &#xA;we may use the fact that $\exp(a+b+\cdots+h) = \exp(a) \exp(b) \cdots \exp(h)$ to re-express this as&#xA;$$&#xA; = \Bigl[\, \prod_{\ell=1}^n \exp\bigl(2\pi ij k_\ell \big/ 2^{\ell} \bigr) \Bigr] |k_1 \cdots k_n \rangle \;. $$ &#xA;We next use the fact that $\lvert k_1 k_2 \cdots k_n \rangle$ is short-hand for a tensor product of operators (state-vectors to be specific):&#xA;$$  = \Bigl[\, \prod_{\ell=1}^n \exp\bigl(2\pi ij k_\ell \big/ 2^{\ell} \bigr) \Bigr] \Bigl[\, \bigotimes_{\ell=1}^n |k_\ell \rangle \Bigr] \;. $$&#xA;Now we use the way that scalars interact with tensor products:&#xA;$$  =  \bigotimes_{\ell=1}^n \Bigl[ \exp\bigl(2\pi ij k_\ell \big/ 2^{\ell} \bigr) |k_\ell \rangle \Bigr] \;, $$&#xA;which was what we wanted to show.&lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-08-15T16:28:37.993" LastActivityDate="2018-08-15T16:28:37.993" CommentCount="0" />
  <row Id="4035" PostTypeId="1" CreationDate="2018-08-15T14:14:29.017" Score="9" ViewCount="117" Body="&lt;p&gt;Say you have a PDE you want to solve.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What kind of quantum algorithms would you use to solve it?&#xA;How do we input our problem on a quantum computer?&#xA;What will be the output and in what form?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I know that quantum algorithms for solving linear systems (often named HHL but actually this is a bad name as other versions are not from the HHL authors) were listed before but maybe other methods are out there.&#xA;Also as it is considered as a subroutine, the output is quantum and then unless you want statistics from it or use it as an input of another quantum algorithm, it is limiting.&lt;/p&gt;&#xA;" OwnerUserId="4127" LastActivityDate="2018-08-15T15:31:59.720" Title="How would a quantum computer be used to solve Partial Differential Equations?" Tags="&lt;quantum-algorithms&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="1" />
  <row Id="4036" PostTypeId="2" ParentId="4035" CreationDate="2018-08-15T15:31:59.720" Score="3" Body="&lt;p&gt;I don't have an exact answer to your question (if it actually exists); but I can answer part of your question concerned with the I/O to a quantum processor. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;As a general rule of thumb; Quantum Algorithms (currently) cannot provide direct answers to problem statements. At least for now, quantum processors exists as heterogeneous accelerators with a classical computing unit. The 'quantum accelerator' is concerned with only that part of the overall algorithm that is not trivial (or exponential in complexity) to solve on a classical computer. In the end, only a sub portion of the program is actually computed on the quantum processor. (Eg. Shor's Factoring Algorithm is actually a period finding algorithm. Period finding is a non-trivial task.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Among several other reasons, of the main problems is input and output operation with a quantum processor. The problem 'must' be expressible in a concise form (eg. an equation). This equation is expressed as a quantum circuit in the 'oracle' which is primarily concerned with solving the equation and measurement outcome are recorded (tomography). The output too needs post processing to actually make sense (which is again performed by the classical counterpart).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;p.s. I would be very interested to know more about PDE solving quantum algorithms; if there is an efficient one.&lt;/p&gt;&#xA;" OwnerUserId="2391" LastActivityDate="2018-08-15T15:31:59.720" CommentCount="3" />
  <row Id="4037" PostTypeId="2" ParentId="4029" CreationDate="2018-08-15T15:58:17.720" Score="1" Body="&lt;p&gt;First of all, quantum rotors generally appear in the context of quantum rotor models, which are lattice models, analogous to quantum spin systems on a lattice - this is, identical quantum systems arrange on a lattice and interacting via some (natural) interaction.  One wouldn't usually talk of an isolated quantum rotor.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So what are quantum rotors?  They are quantum mechanical versions of classical rotors, just as quantum spins can be regarded as quantum versions of classical two-level systems.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So what is a classical rotor? It is basically a tiny magnet which can rotate freely in a certain number $d$ of dimensions, such as a compass needle ($d=2$, this would be a O(2) rotor model).  It is thus characterized by a unit vector $\vec n$ in $d$ dimensions. The natural interactions of these models would be dipole-dipole interactions (i.e. $\vec n_i\cdot \vec n_j$), and the natural on-site energy would be a kinetic term $\vec{L}^2/2$ with $L$ the angular momentum.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;These interactions can be turned quantum mechanical in the canonical way for conjugate variables, as explained on the Wikipedia page.&lt;/p&gt;&#xA;" OwnerUserId="491" LastActivityDate="2018-08-15T15:58:17.720" CommentCount="0" />
  <row Id="4038" PostTypeId="2" ParentId="4029" CreationDate="2018-08-15T16:03:30.363" Score="4" Body="&lt;p&gt;Quantum rotor models are quantum systems based on the quantization of systems with rotational configuration spaces. For example, a particle moving on a ring or a pendulum are rotors whose configuration spaces are circular $S^1$, while a rigid body a system whose configuration space is the three-dimensional sphere $S^3$ (or equivalently, the group manifold $SU(2)$). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The dynamics of these systems depend in addition on the angular momenta of the configuration space coordinates, whose values are not confined. Thus, for the case of the pendulum, the phase space (spanned by coordinates and angular momenta) is the two-dimensional cylindrical manifold $S^1 \times \mathbb{R}$ and in the rigid body case $S^3 \times \mathbb{R}^3$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Once, an appropriate Hamiltonian function on the phase space is defined, there are quantization rules which allow writing the Schrödinger equation to treat the system quantum mechanically. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The cylindrical phase space quantum rotor is especially relevant to quantum computation as it enters in the description of the condensate dynamics of Josephson junction arrays which can be used to implement superconducting qubits; Please see the following &lt;a href=&quot;https://arxiv.org/abs/cond-mat/0411174&quot; rel=&quot;nofollow noreferrer&quot;&gt;review &lt;/a&gt; by: Devoret, Wallraff and Martinis. In this case a generic Hamiltonian (of a single isolated qubit) has the form:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$H = \frac{E_C}{2} (n – n_0)^2 + \frac{E_J}{2} \cos\theta$$ &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Where $E_C$ is the charging energy and $E_J$ is the total junction energy and, $n$ is the number of Cooper pairs and $n_0$ is an offset proportional to the junction residual charge and:&#xA;$$\theta = 2 \pi \frac{\Phi}{\Phi_0} \mod 2 \pi$$&#xA;is the phase across the junction ($\Phi$ is the magnetic flux, and $\Phi_0$ is the flux quantum), and most importantly is that the cooper pair number is conjugate to the phase:&#xA;$$n = \frac{1}{E_C}\frac{\partial \theta }{\partial t }$$&#xA;This is a consequence of Faraday's law. (Thus this model is defined on a cylindrical phase space since the angular momentum is proportional to the angular velocity).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;After quantization, the Cooper pair number operator is replaced by:&#xA;$$\hat{n} =i \hbar \frac{\partial }{\partial \theta }$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Schrödinger equation can be solved exactly in terms of Mathieu functions. However, the qubit dynamics can be obtained if we restrict the dynamics to the two lowest eigenfunctions of the number operator $|0\rangle$ and $|1\rangle$, in this case, the kinetic and the potential terms of the Hamiltonian can be   &lt;a href=&quot;http://iramis.cea.fr/spec/Pres/Quantro/Qsite/publi/articles/fichiers/preprints/98-PScripta-Bouchiat-SSbox.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;approximated&lt;/a&gt; for $n_0 = \frac{1}{2}$ as:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$ E_C (n – n_0)^2  \approx E_C \sigma_z$$&#xA;And:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$E_J cos\theta \approx E_J \sigma_x$$&#xA;Thus, the quantum Hamiltonian restricted to the lowest two-dimensional number subspace:&#xA;$$\hat{H} = \frac{E_J}{2}(\sigma_x + \frac{E_C}{E_J} \sigma_z)$$&#xA;and we can use the ratio $\frac{E_C}{E_J}$ to control the quantum evolution.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Remarks: &lt;/p&gt;&#xA;&#xA;&lt;p&gt;While the authors of the main references given above don't use the name quantum rotors in relation to qubits, other authors do, for example: &lt;a href=&quot;https://arxiv.org/abs/0912.3902v1&quot; rel=&quot;nofollow noreferrer&quot;&gt;Girvin, Devoret, and  Schoelkopf&lt;/a&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;A description of the cylindrical phase and other phase spaces from the point of view of quantum computation can be found in: &lt;a href=&quot;https://arxiv.org/abs/1709.04460&quot; rel=&quot;nofollow noreferrer&quot;&gt;Albert,. Pascazio and Devoret&lt;/a&gt; . &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I don't know of an application of three dimensional rotors to quantum computation, they especially appear in quantum models of molecules.&lt;/p&gt;&#xA;" OwnerUserId="4263" LastEditorUserId="4263" LastEditDate="2018-08-15T16:08:37.603" LastActivityDate="2018-08-15T16:08:37.603" CommentCount="3" />
  <row Id="4039" PostTypeId="2" ParentId="4033" CreationDate="2018-08-15T20:50:23.743" Score="-1" Body="&lt;p&gt;A simple formula for the number of qubits you can simulate in almost all programs is given by &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/3862/2293&quot;&gt;this very well received answer&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;After re-arranging the formula given there into a form that's much more relevant to your specific question, and changing 48 to 32 since Q# is written in C++, not python, we have:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;N_{\rm{qubits}} =  \log_2\left( \frac{\rm{RAM}}{32} \right)&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When $\rm{RAM} = 32\rm{GB} = 32\times 1024^3$, this formula gives 30, meaning you an simulate 30 qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you plug the amount of RAM you have, into that formula, it will give a good estimate of how many qubits you can simulate without using a more sophisticated simulator. &lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-08-15T23:43:47.773" LastActivityDate="2018-08-15T23:43:47.773" CommentCount="10" />
  <row Id="4040" PostTypeId="2" ParentId="4033" CreationDate="2018-08-15T22:37:53.137" Score="1" Body="&lt;p&gt;The simple rule is:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&lt;strong&gt;Doubling the memory gives you one additional qubit.&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;So if Microsoft says that &lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;16GB -&amp;gt; 30 qubits&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;then &lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt; 8GB -&amp;gt; 29 qubits&#xA; 4GB -&amp;gt; 28 qubits&#xA; 2GB -&amp;gt; 27 qubits&#xA; ...&#xA;32GB -&amp;gt; 31 qubits&#xA;64GB -&amp;gt; 32 qubits&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;and so further.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This scaling, as well as the number quoted by Microsoft, can be understood from an argument as the one in the &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/3862/2293&quot;&gt;linked answer&lt;/a&gt;, using that &lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;each complex number equals 2 real numbers with double precision (8 bytes each), so 16 bytes are needed per comples number,&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;to describe $N$ qubits, $2^N$ numbers are needed,&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;and 1GB=$1024^3$ bytes&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;which together yields $16\cdot 2^N = x \, \mathrm{GB} = x\cdot 1024^3$ with $x$ the memory required in GB, which results in &#xA;$$&#xA;N = \log_2(x\,\times 1024^3/16) = \log_2(x)+26\ .&#xA;$$&#xA;For $x=16$ (i.e. 16GB of memory), $\log_2(16)=4$, and this yields exactly &#xA;$$&#xA;N=30 \ \mathrm{qubits}\ ,&#xA;$$&#xA;which is the number quoted by Microsoft.&lt;/p&gt;&#xA;" OwnerUserId="491" LastActivityDate="2018-08-15T22:37:53.137" CommentCount="0" />
  <row Id="4041" PostTypeId="2" ParentId="1826" CreationDate="2018-08-16T09:01:16.000" Score="-1" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;In the E91 protocol, Alice and Bob each chooses independently and randomly from three measurement bases, so there are 9 situations and only 2 of them can yield correct bits. Does that mean the efficiency of E91 is 2/9, why are the number of useful random bits 0.25 ?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;The E91 protocol uses 3 basis (polarisation) states, each created from a pair of photons. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Measurements are made using one of two possible orientations by each party, where they disagree on the orientation such bits are unused; additional bits may not be received by either party due to noise or interception, those are also discarded. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;In an unusual noise free channel a 25% efficiency is obtained. The resulting useful bits are used to transfer a secret key which can be used to secure a conventional (non-quantum) cryptography algorithm. There are better algorithms to transfer keys which obtain 100% efficiency, again that assumes an error free (no noise or tampering) channel.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In &quot;&lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.67.661&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Cryptography Based on Bell's Theorem&lt;/a&gt;&quot; (Aug 5 1991) by Artur K. Ekert (E91) the protocol is explained:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;The channel consists of a source that emits pairs of photons considered as spin 1/2 particles, in a singlet state. The particles fly apart along the z axis, towards the two legitimate users of the channel, say, Alice and Bob, who, after the particles have separated, perform measurements on spin components ...&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;...&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;The users choose the orientation of the analyzers randomly and independently for each pair of incoming particles.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;...&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;After the transmission has taken place, Alice and Bob can announce in public the orientations of the analyzers they have chosen for each particular measurement and divide the measurements into two separate groups: a first group for which they used different orientation of analyzers, and a second group for which they used the same orientation of&#xA;  their analyzers. They discard all measurements in which either or both of them failed to register a particle at all. Subsequently, Alice and Bob can reveal publicly the results they obtained but within the first group of measurements only. This allows them to establish the value of S, which, if the particles were not directly or indirectly “disturbed&quot;, should reproduce the result of $S = -2\sqrt{2}$. This assures the legitimate users that &lt;strong&gt;the results they obtained within the second group of measurements are anticorrelated and can be converted into a secret&lt;/strong&gt; string of bits – key. This secret key may be then used in a conventional cryptographic communication between Alice and Bob.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Throw out half, transmit twice the number of measurements = 0.5 * 0.5 = 0.25.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In an alternate protocol, such as BB84:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;&quot;... ‘Alice’ chooses a random bit string and a random sequence of polarization bases (rectilinear or diagonal). She then sends the other user (Bob) a train of photons, each representing one bit of the string in the basis chosen for that bit position, a horizontal or 45-degree photon standing for a binary zero and a vertical or 135-degree photon standing for a binary one. As Bob receives the photons he decides, randomly for each photon and independently of Alice, whether to measure the photon’s rectilinear polarization or its diagonal polarization, and interprets the result of the measurement as a binary zero or one. A random answer is produced and all information lost when one attempts to measure the rectilinear polarization of a diagonal photon, or vice versa. Thus &lt;strong&gt;Bob obtains meaningful data from only half the photons he receives&lt;/strong&gt; – those for which he guessed the correct polarization basis. Bob’s information is further degraded by the fact that, realistically, some of the photons would be lost in transit or would fail to be counted by Bob’s imperfectly-efficient detectors.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Subsequent steps of the protocol take place over an ordinary public communications channel, assumed to be susceptible to eavesdropping but not to the injection or alteration of messages. Bob and Alice first determine, by public exchange of message, which photons were successfully received and of these which were detected with the correct basis. If the quantum transmission has been undisturbed, Alice and Bob should agree on the bits encoded by these photons, even this data has never been discussed over the public channel. &lt;strong&gt;Each of these photons, in other words, presumably carries one bit of random information&lt;/strong&gt; (e.g., whether a rectilinear photon was vertical or horizontal) known to Alice and Bob but to no one else.&quot;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Source: &quot;&lt;a href=&quot;https://www.nii.ac.jp/qis/first-quantum/e/forStudents/lecture/index.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Information Lecture Series&lt;/a&gt;&quot;, Fundamentals of Noise processes: &quot;Chapter 13 - Quantum communication&quot; (&lt;a href=&quot;https://www.nii.ac.jp/qis/first-quantum/e/forStudents/lecture/pdf/noise/chapter13.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;.PDF&lt;/a&gt;), by Yoshihisa Yamamoto.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Throw out half of what is sent = 0.5 * 1 = 0.5.&lt;/p&gt;&#xA;" OwnerUserId="278" LastEditorUserId="23" LastEditDate="2018-08-16T20:55:48.967" LastActivityDate="2018-08-16T20:55:48.967" CommentCount="0" />
  <row Id="4042" PostTypeId="1" AcceptedAnswerId="4044" CreationDate="2018-08-16T11:12:57.027" Score="9" ViewCount="93" Body="&lt;p&gt;In the literature on QECC, Clifford gates occupy an elevated status.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Consider the following examples which attest to this:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;When you study stabilizer codes, you separately study how to perform encoded Clifford gates (even if these aren't applicable transversally). All introductory material on QECC emphasize on performing encoded Clifford operations on quantum codes. And otherwise too, emphasize on Clifford gates (i.e., even when not performing encoded Clifford gates in quantum codes).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;The entire topic of magic state distillation* is based on the classification of certain operations (including the performance of Clifford gates) as low-cost operations, while, for instance, performing the toffoli-gate or the $\pi/8$-gate, as higher-cost operations. &lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Possible answers:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;This has been justified in certain places in the literature ,for e.g., Gottesman's PhD dissertation and many papers by him, and also in &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0403025&quot; rel=&quot;noreferrer&quot;&gt;https://arxiv.org/abs/quant-ph/0403025&lt;/a&gt;. The reason given in these places is that it is possible to perform some Clifford gates transversally (a prototypical Fault-tolerant operation) on certain stabilizer codes. On the other hand, it is not easy to find a transversal application of non-Clifford gates on quantum codes. I haven't verified this myself, but am just going by statements which Gottesman makes in his PhD. dissertation and some review articles. &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Not being able to perform an encoded gate transversally on a quantum code immediately increases the cost of performing said gate on the code. And hence performing Clifford gates goes into the low-cost category, while non-Clifford gates goes into the high-cost category.&lt;/p&gt;&#xA;&#xA;&lt;ol start=&quot;2&quot;&gt;&#xA;&lt;li&gt;From an engineering perspective, it is important to decide on a standardized list of basic units of quantum computation (state preparation, gates, measurement-observables/basis), etc. Performing Clifford gates makes for a convenient choice on that list because of multiple reasons (most well-known sets of universal quantum gates include many Clifford gates in them ,Gottesman-Knill theorem**, etc).&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;These are the only two reasons I could think of for why the Clifford group has such an elevated status in the study of QECC (particularly when you're studying stabilizer codes). Both reasons stem from an engineering perspective.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So the question is can one identify other reasons, which don't stem from an engineering perspective? Is there some other major role that the Clifford gates play, which I've missed out? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Possible other reason: I know that the Clifford group is the normaliser of the Pauli group in the Unitary group (on $n$ qubit systems). Also, that it has a &lt;a href=&quot;https://mathoverflow.net/questions/84388/presentation-of-the-clifford-group-by-generators-and-relations&quot;&gt;semidirect product structure&lt;/a&gt; (actually a projective representation of of semidirect product group). Does these relations/properties by themselves give another reason &lt;em&gt;why&lt;/em&gt; one ought to study the Clifford group in association with Stabilizer codes? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;*Feel free to correct this. &#xA;**Which states that restricted to certain operations, you can't obtain the quantum advantage, and hence you need a little-bit more than the set of operations you initially restricted yourself to. &lt;/p&gt;&#xA;" OwnerUserId="4353" LastEditorUserId="4353" LastEditDate="2018-08-16T14:58:35.960" LastActivityDate="2018-08-20T06:50:36.847" Title="Significance of Clifford operations from quantum error correction perspective" Tags="&lt;quantum-error-correction&gt;&lt;stabilizer-code&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="4043" PostTypeId="2" ParentId="1826" CreationDate="2018-08-16T18:01:21.313" Score="0" Body="&lt;p&gt;TL;DR: The efficiency is 2/9, not 25%.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Ekert 91 protocol involves many rounds. In each round, Alice and Bob share a Bell pair&#xA;$$&#xA;(|00\rangle+|11\rangle)/\sqrt{2}&#xA;$$&#xA;They both choose randomly which of 3 measurements to make. Alice chooses between the measurement bases $Z$, $(X+Z)/\sqrt{2}$ and $X$. Bob chooses between $(X+Z)/\sqrt{2}$, $X$ and $(X-Z)/\sqrt{2}$. They make their measurements, and get $\pm 1$ answers. They record both the measurement settings and the answers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Later, they announce in public what measurement bases they used, but not the answers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In the scenario of no eavesdropping, and no errors, Alice and Bob are guaranteed to get identical measurement results whenever they measure in the same basis, and each such outcome gives one shared secret bit. If Alice and Bob chose different measurement bases, they announce the outcomes that they got and use them in a CHSH test to detect eavesdropping.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;How often do they get a secret bit out in this scenario? If we assume that all measurement bases are equally likely, then there are 9 possible combinations for Alice's and Bob's choices. Of these, two are matching pairs. Hence, the efficiency if 2/9.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-08-17T10:33:02.813" LastActivityDate="2018-08-17T10:33:02.813" CommentCount="0" />
  <row Id="4044" PostTypeId="2" ParentId="4042" CreationDate="2018-08-16T20:45:22.740" Score="3" Body="&lt;p&gt;Clifford operations are often easy to do fault-tolerantly in stabilizer codes, either transversally or by code deformation. The reason is exactly as you thought: the special relationship between these gates and the Paulis, since the latter are used to define stabilizer codes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is possible to get non-Clifford gates in codes, but a price must be paid. Specifically, there is a relationship between the geometric locality of codes and the gates they can do transversally. So if you are allowed to do only nearest neighbour controlled gates on a 2D lattice (such as a surface or Color code) only Cliffords will be possible. See papers like this one for more on this.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The fact that we can expect fault-tolerant Cliffords from stabilizer codes has subsequently been put at the heart of techniques to synthesize universal gate sets. So if there’s a way to create a non-stabilizer encoded state in a non-fault-tolerant way, we know how to clean it up using our logical Clifford’s. To turn these states into rotations, we use our logical Cliffords. So if you have a code and want to apply all these off-the-shelf results, you’d better find your fault-tolerant Cliffords. Or at least the Paulis, H and a CZ or CNOT if you can’t manage them all.&lt;/p&gt;&#xA;" OwnerUserId="409" LastEditorUserId="409" LastEditDate="2018-08-20T06:50:36.847" LastActivityDate="2018-08-20T06:50:36.847" CommentCount="2" />
  <row Id="4046" PostTypeId="1" AcceptedAnswerId="4052" CreationDate="2018-08-17T15:32:26.547" Score="5" ViewCount="148" Body="&lt;p&gt;Can we process infinite matrices with a quantum computer?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If then, how can we do that?&lt;/p&gt;&#xA;" OwnerUserId="877" LastEditorUserId="877" LastEditDate="2018-08-23T23:42:07.870" LastActivityDate="2018-08-23T23:42:07.870" Title="Can we process infinite matrices with a quantum computer?" Tags="&lt;matrix-representation&gt;&lt;mathematics&gt;" AnswerCount="1" CommentCount="7" FavoriteCount="1" />
  <row Id="4047" PostTypeId="1" CreationDate="2018-08-17T17:26:47.417" Score="7" ViewCount="156" Body="&lt;p&gt;I want to preface with a disclaimer that I am a physicist with minimal knowledge of computer hardware. I have a solid understanding of quantum information from a theoretical standpoint but zero knowledge of how it is implemented. Here goes...&lt;/p&gt;&#xA;&#xA;&lt;p&gt;When a company boasts that there newest chip has $X$ qubits, what exactly does that mean? Should I think of $X$ as being analogous with 32 or 64 bits on a conventional processor, meaning that the quantum computer can hold and process data types of size $X$? Or is $X$ something physical, like the number of Josephson junctions on the chip? should I think of $X$ as being equivalent to the number of transistors on a conventional processor? The benchmark of a conventional microprocessor is the number of transistors, so it is tempting to make the equivalence between transistor and qubit but I don't think that is correct because qubit is a unit of information and a transistor is a hardware thing. And furthermore I would not understand how quantum supremacy could be achieved with only ~50 qubits when conventional processors have billions of transistors. It just seems strange to say that a chip has $X$ 'qubits', because from a theoretical standpoint a qubit is information and not hardware.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;EDIT:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I am realizing that my confusion boils down to &lt;em&gt;memory&lt;/em&gt; vs &lt;em&gt;processing power&lt;/em&gt;. I get that in order to &lt;em&gt;store&lt;/em&gt; $2^X$ states, I would need $X$ physical qubits (Josephson junctions, spin states, etc). But then where does the processing power come from? On a conventional chip, you have registers to &lt;em&gt;store&lt;/em&gt; the information to be processed, but then a ton of transistors to perform the computation. My question is how this processing power is measured in a quantum computer? Do the number of quantum gates on the chip really not matter as much as the number of qubits they are capable of operating on?&lt;/p&gt;&#xA;" OwnerUserId="4367" LastEditorUserId="4367" LastEditDate="2018-08-17T18:11:47.550" LastActivityDate="2018-08-19T19:02:15.233" Title="What does it mean for a quantum computer to have $X$ qubits?" Tags="&lt;quantum-computer&gt;&lt;quantum-gate&gt;&lt;qubit&gt;" AnswerCount="3" CommentCount="2" />
  <row Id="4048" PostTypeId="2" ParentId="4047" CreationDate="2018-08-17T17:42:56.123" Score="2" Body="&lt;p&gt;Take the tables attached in the Wikipedia article here:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_quantum_processors&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://en.wikipedia.org/wiki/List_of_quantum_processors&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;as a starting point.  The &quot;Gate model QPU's&quot; are more likely to be Turing-complete than the &quot;Annealing QPU's.&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For companies that claim $X$ qubits, they mean they have they have the capability to operate, quantum mechanically, on $2^X$ states, and they are physically implemented qubits, e.g. $X$ Josephson junctions, etc., much like an individual bit on DRAM on a classical computer is physically implemented (with a capacitor and a transistor.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So in a sense, the number of qubits &lt;em&gt;is&lt;/em&gt; roughly analogous to the amount of hardware.  We can only &lt;em&gt;read out&lt;/em&gt; $X$ qubits, but we can &lt;em&gt;operate on&lt;/em&gt; up to $2^X$ states.  Your analogy is actually not that bad of an analogy, it's merely the quantum-mechanical weirdness that's hard to get over.&lt;/p&gt;&#xA;" OwnerUserId="2927" LastActivityDate="2018-08-17T17:42:56.123" CommentCount="3" />
  <row Id="4049" PostTypeId="2" ParentId="4047" CreationDate="2018-08-17T17:51:48.827" Score="0" Body="&lt;p&gt;I would say they have individual physical systems (represented by one qubit mathematically) that they interconnect together in some fashion way (so that is why we talk about connectivity). Physical systems can be two different polarization of a photon, or as two states of an electron... But there are multiple ways to have such systems.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now quantum supremacy is a really bad word.&#xA;So the idea is that the biggest number of qubits simulated on classical computers was around 50 qubits. So having a physical realization with a superior size would be considered as a &quot;hope&quot; for quantum computers to &quot;beat&quot;&#xA;classical ones.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A good explanation video about it can be found &lt;a href=&quot;https://www.youtube.com/watch?v=90U_SmKyfGI&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="4127" LastActivityDate="2018-08-17T17:51:48.827" CommentCount="0" />
  <row Id="4052" PostTypeId="2" ParentId="4046" CreationDate="2018-08-18T13:53:43.920" Score="4" Body="&lt;p&gt;If instead of manipulating the quantum information in qubits, your quantum computer were to do operations on qu$d$its with $d$ being infinity, then you'd essentially be processing infinite matrices on a quantum computer. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;However most quantum computing hardware we have today, and even most of the experiments being done in academic labs, do operations on qubits (such as spin-1/2 nuclei), rather than on qu$d$its with an infinite value for $d$ (such as a quantum harmonic oscillator). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;It is theoretically possible to do quantum gates on qu$d$its with infinite $d$, which would be processing infinite matrices, but it is not done in practice. It is hard enough to make quantum computers with ~100 qubits (which would still be processing only finite-dimensional matrices). &lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-08-18T13:53:43.920" CommentCount="7" />
  <row Id="4053" PostTypeId="1" AcceptedAnswerId="4055" CreationDate="2018-08-19T08:44:02.790" Score="5" ViewCount="90" Body="&lt;p&gt;I've just started to mess about with QISKit on Python and one thing is confusing me a fair bit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Given that we are building Quantum Circuits what is the need for a classical register ?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is it because the collapsed state must be classical ?&lt;/p&gt;&#xA;" OwnerUserId="4373" LastActivityDate="2018-08-19T18:44:08.660" Title="Why do we need a Classical Register for carrying out Quantum Computations?" Tags="&lt;quantum-computer&gt;&lt;qiskit&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="4054" PostTypeId="2" ParentId="4053" CreationDate="2018-08-19T14:21:07.220" Score="2" Body="&lt;p&gt;Quantum computations depend on classical control: A classical computer, driven by a classical algorithm, suffices to apply the quantum gates in sequence. In some algorithms (such as quantum teleportation), the gate to be applied depends on an earlier measurement result. Hence a store for measurement results (and, possibly, calculations using it) is helpful and needed in general.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-08-19T14:21:07.220" CommentCount="2" />
  <row Id="4055" PostTypeId="2" ParentId="4053" CreationDate="2018-08-19T18:44:08.660" Score="2" Body="&lt;p&gt;Once we measure a qubit, we get some classical information out. This is something we need to keep track of. We need it to look at the outputs of our computations, or use them as part of classical control within an algorithm. For that reason, it can be useful to have a specific object in a quantum SDK that keeps track of this classical information, and does so in a way that parallels how qubits are dealt with. This is the approach taken by QISKit.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-08-19T18:44:08.660" CommentCount="0" />
  <row Id="4056" PostTypeId="2" ParentId="4047" CreationDate="2018-08-19T19:02:15.233" Score="2" Body="&lt;p&gt;When we take about hardware specs for classical computers, we are getting some information about the kind of things we can do with the device. For a circuit based quantum computer, the relevant number is how many fault-tolerant qubits we have. We can then computer this to the required qubit number for given instances of our favourite algorithm and see what that means in terms of factoring numbers, etc.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Currently, the number of fault-tolerant qubits is zero. We are instead in an era of noisy prototype devices. They are for testing, and what is possible depends strongly on how noisy the gates are and the connectivity (which pairs of qubits can we do a controlled gate with). If a company/lab does not give you information, there is no way to compare with what other companies/labs are doing (and all are currently a few orders of magnitude away from having enough noisy qubits to make a truly fault-tolerant qubit).&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-08-19T19:02:15.233" CommentCount="0" />
  <row Id="4057" PostTypeId="1" AcceptedAnswerId="4058" CreationDate="2018-08-20T10:28:38.550" Score="10" ViewCount="1645" Body="&lt;p&gt;As a part of a discussion with my 'classical' friend, he insisted that making a a state machine for calculating the outcome of quantum computer is possible; so, simply calculate the outcomes of (known) algorithms on supercomputers and store their results in a Look-up table. (Something like storing the truth table).&lt;br&gt;&lt;br&gt;&#xA;So, why do people work on quantum simulators (say, capable up to 40 qubits); which calculate the result every time?! Simply (hypothetically) use the supercomputers of the world (say capable up to 60 qubits); calculate the result for $2^{60}$ input cases, store their result and use it as reference? How can I convince him it's not possible?&lt;br&gt;&lt;br&gt;&#xA;&lt;b&gt;Note:&lt;/b&gt; this is for known quantum algorithms and their known circuit implementations.&lt;/p&gt;&#xA;" OwnerUserId="2391" LastEditorUserId="2391" LastEditDate="2018-08-20T14:25:40.870" LastActivityDate="2018-08-21T11:05:07.183" Title="Classical Memory enough to store states up to 40 qubits quantum system?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-computer&gt;&lt;quantum-simulation&gt;" AnswerCount="2" CommentCount="2" FavoriteCount="2" />
  <row Id="4058" PostTypeId="2" ParentId="4057" CreationDate="2018-08-20T11:33:51.827" Score="14" Body="&lt;p&gt;Suppose that you have a quantum algorithm with $2^{60}$ possible inputs. Suppose also that it would take 1 nanosecond to run this on a supercomputer (which is unrealistically optimistic!). The total time required to run through all possible inputs would be 36.5 years.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Clearly it would be much better to just run the instance that you care about, and get the answer in an instant, rather than waiting half a lifetime to pick it from a list. This gets ever more true as we raise the runtime from the unrealistic 1 nanosecond.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;why do people work on quantum simulators (say, capable up to 40 qubits); which calculate the result every time?! &lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Even if you wanted to create a lookup table, you'd still need a simulator like this to create it.&lt;/p&gt;&#xA;" OwnerUserId="409" LastActivityDate="2018-08-20T11:33:51.827" CommentCount="1" />
  <row Id="4059" PostTypeId="1" AcceptedAnswerId="4061" CreationDate="2018-08-21T08:13:06.777" Score="7" ViewCount="81" Body="&lt;p&gt;Take two pure bi-partite states $\psi$ and $\phi$ that have the same amount of entanglement in them as quantified by concurrence (does the measure make a difference?). Can any such states be transformed into each other using local unitaries?&lt;/p&gt;&#xA;" OwnerUserId="1860" LastEditorUserId="1837" LastEditDate="2018-08-21T10:42:22.980" LastActivityDate="2018-08-21T10:53:41.437" Title="Can two states with the same entanglement be transformed into each other using local unitaries?" Tags="&lt;quantum-entanglement&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="4060" PostTypeId="2" ParentId="1826" CreationDate="2018-08-21T09:31:13.243" Score="1" Body="&lt;p&gt;I emailed Artur Ekert to seek help for this quesiton, and he replied:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;There are different variants of the E91 protocol that may give&#xA;  you different efficiencies. In my original version the settings used for&#xA;  the keys bits were indeed chosen with the probability 2/9, but others&#xA;  optimised it in all kind of ways.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;So at least 2/9 is the probability of the original E91 protocol, and for those who want to know the calculation for the original protocol, please refer to DaftWullie's answer which I think is correct. But as I'm not professional in this area, I'm not sure that the calculation in Cabello's paper is a mistake or he just calculated some optimized version.&lt;/p&gt;&#xA;" OwnerUserId="2047" LastActivityDate="2018-08-21T09:31:13.243" CommentCount="0" />
  <row Id="4061" PostTypeId="2" ParentId="4059" CreationDate="2018-08-21T10:53:41.437" Score="6" Body="&lt;p&gt;Any two bipartite &lt;em&gt;pure&lt;/em&gt; states $\psi$ and $\phi$ can be transformed into each other with local unitaries if and only if they have the same &lt;a href=&quot;https://en.wikipedia.org/wiki/Schmidt_decomposition&quot; rel=&quot;noreferrer&quot;&gt;Schmidt coefficients&lt;/a&gt;. (To prove the 'only if' part, note that the reduced density matrix of either qubit has eigenvalues that are the same as the Schmidt coefficients, and are unchanged by unitaries).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Concurrence_(quantum_computing)&quot; rel=&quot;noreferrer&quot;&gt;concurrence&lt;/a&gt; is typically specified for two-qubit states. Any reasonable entanglement monotone on two qubits, when calculated for pure states, must be a decreasing function of the largest Schmidt coefficient of the state, and thus two states having the same entanglement would have the same Schmidt coefficients, and hence be unitarily equivalent.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you generalise beyond qubits, there will be entanglement measures that do not contain as much fine-grained information as the Schmidt coefficients, and so equality of that entanglement measure will be necessary but not sufficient for unitary equivalence.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-08-21T10:53:41.437" CommentCount="5" />
  <row Id="4062" PostTypeId="2" ParentId="4057" CreationDate="2018-08-21T11:05:07.183" Score="3" Body="&lt;p&gt;For a specific quantum algorithm that uses 40 qubits, your friend makes a good point. One can just calculate the truth table (one might find this hard, but assume that one can) and use it as reference. Of course this starts to get ridiculous as you increase the number of qubits, not just because of the number of inputs but because computing the outcome of a quantum algorithm could be exponentially harder classically for all we know.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, being able to simulate a quantum computer (or having an actual quantum computer) is far more useful. By changing what quantum operations one does, one gets different algorithms. The number of functions that one can define on 40 bits of inputs is 2^2^40. Having a single database that gives you instant access to the results of any quantum algorithm is just absurdly infeasible. We want to be able to switch algorithms easily too, and classically we'd want simulators for that.&lt;/p&gt;&#xA;" OwnerUserId="4394" LastActivityDate="2018-08-21T11:05:07.183" CommentCount="2" />
  <row Id="4063" PostTypeId="1" CreationDate="2018-08-21T14:43:47.137" Score="4" ViewCount="52" Body="&lt;p&gt;I would like to understand what is a continuous quantum register.&#xA;I know the direct definition is a quantum register that stores a real number defined by an observable with a spectrum consisting of $\mathbb{R}$ but that seems really abstract to me.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Also how it relates to qubits? Is a set of qubits used for simulating discretely a continuous quantum register? If yes how?&lt;/p&gt;&#xA;" OwnerUserId="4127" LastActivityDate="2018-08-22T17:31:39.920" Title="What is continuous quantum register and how it relates to qubits?" Tags="&lt;quantum-computer&gt;&lt;quantum-information&gt;&lt;quantum-computing-models&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="1" />
  <row Id="4064" PostTypeId="1" AcceptedAnswerId="4065" CreationDate="2018-08-21T15:48:28.743" Score="4" ViewCount="50" Body="&lt;p&gt;In their &lt;a href=&quot;https://epubs.siam.org/doi/10.1137/16M1087072&quot; rel=&quot;nofollow noreferrer&quot;&gt;2017 paper&lt;/a&gt;, Childs &lt;em&gt;et al.&lt;/em&gt; gave the definition of QLSP beginning with : &quot;Let $A$ be an $N\times N$ Hermitian matrix with known condition numbers $\kappa$, $||A|| = 1$ and at most $d$ non-zero entries in any row or column...&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I initially thought that by $||A|| = 1$ they meant that QLSP requires spectral norm (largest eigenvalue) of $A$ to be $1$, which sounds reasonable to me as even the original HHL paper they needed the eigenvalues of $A$ to lie in between $1/\kappa$ and $1$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But, the paper: &lt;a href=&quot;https://arxiv.org/abs/1802.08227&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum linear systems algorithms: a primer&lt;/a&gt; seems to have interpreted is as &quot;the determinant of $A$ needs to be $1$&quot; in page 28 definition 6.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Which interpretation is correct and why? In case the latter is correct, I'm not sure why it is so. I don't see why the restriction that $\text{det}(A)$ needs to be $1$ even make sense. It (the unit determinant condition) doesn't even guarantee that the eigenvalues of $A$ will be less than or equal to $1$, which is necessary for HHL to work. &lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-08-21T16:04:07.240" Title="What does $||A|| = 1$ mean in the definition of QLSP?" Tags="&lt;hhl-algorithm&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="4065" PostTypeId="2" ParentId="4064" CreationDate="2018-08-21T16:04:07.240" Score="4" Body="&lt;p&gt;Certainly it is meant as the largest eigenvalue. I have no idea why the linked review paper uses the determinant. I don't see anywhere that they use that property (from an admittedly brief skim).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I presume you &lt;em&gt;could&lt;/em&gt; rewrite conditions in terms of the determinant (you would have to alter the time step $t_0$) but it's not clear to me why you would want to. It's also worth noting that definition 8 (page 39) in that paper defines matrix inversion, putting limits on the eigenvalues of the matrix: bounding between some minimum value and 1. So they're also implicitly acknowledging that structure, and certainly not setting the determinant (product of eigenvalues) to 1.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-08-21T16:04:07.240" CommentCount="3" />
  <row Id="4066" PostTypeId="1" AcceptedAnswerId="4073" CreationDate="2018-08-21T16:17:27.053" Score="4" ViewCount="144" Body="&lt;p&gt;What would be the best way to re-create the following image of the HHL quantum circuit &lt;em&gt;without compromising on image quality&lt;/em&gt; (the image is from this &lt;a href=&quot;https://arxiv.org/abs/1802.08227&quot; rel=&quot;nofollow noreferrer&quot;&gt;review paper&lt;/a&gt;)?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/pMSHL.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/pMSHL.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Using &lt;a href=&quot;https://www.media.mit.edu/quanta/qasm2circ/&quot; rel=&quot;nofollow noreferrer&quot;&gt;qasm2circ&lt;/a&gt; I can create the basic circuit. But I don't know any good program/software which will help to produce the labels of the various components and also the nice transparent boxes emphasizing the 3 main steps.  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;FWIW, I had contacted the corresponding author last week asking about the software they used to generate the image (and also whether the image has any associated copyright license), but haven't received any response so far, which is why I am asking here.&lt;/p&gt;&#xA;" OwnerUserId="26" LastActivityDate="2018-08-23T09:48:00.447" Title="How to re-create the following circuit image?" Tags="&lt;resource-request&gt;&lt;circuit-model&gt;&lt;qasm2circ&gt;" AnswerCount="4" CommentCount="4" />
  <row Id="4067" PostTypeId="2" ParentId="4066" CreationDate="2018-08-21T16:30:03.063" Score="3" Body="&lt;p&gt;I know there is the Latex package &#xA;&lt;a href=&quot;https://docs.google.com/viewer?url=http%3A%2F%2Fphysics.unm.edu%2FCQuIC%2FQcircuit%2FQtutorial.pdf&amp;amp;embedded=true&amp;amp;chrome=false&amp;amp;dov=1&quot; rel=&quot;nofollow noreferrer&quot;&gt;qcircuit&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But I am not sure about how they did the boxes for the 3 parts a,b,c. &#xA;Maybe some image tool for drawing them.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Edit : Found this discussion where one admitted using Tikz &lt;a href=&quot;https://tex.stackexchange.com/questions/9767/whats-a-good-package-for-typesetting-quantum-circuits&quot;&gt;for drawing similar images&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Edit 2 : I found this little tool called &lt;a href=&quot;https://github.com/qpic/qpic&quot; rel=&quot;nofollow noreferrer&quot;&gt;qpic&lt;/a&gt; which can help you build fancy quantum circuits. You will be able to do it easily I suppose.&lt;/p&gt;&#xA;" OwnerUserId="4127" LastEditorUserId="4127" LastEditDate="2018-08-21T20:44:50.557" LastActivityDate="2018-08-21T20:44:50.557" CommentCount="2" />
  <row Id="4068" PostTypeId="2" ParentId="4066" CreationDate="2018-08-21T18:18:50.537" Score="3" Body="&lt;p&gt;According to the meta-information in the PDF of the figure, it has been created with PowerPoint:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ pdfinfo HHL_circuit.pdf &#xA;Title:          HHL_circuit&#xA;Creator:        PowerPoint&#xA;Producer:       Mac OS X 10.13.2 Quartz PDFContext&#xA;[...]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;(You can download paper sources from the arxiv by choosing &quot;other formats&quot;.)&lt;/p&gt;&#xA;" OwnerUserId="491" LastActivityDate="2018-08-21T18:18:50.537" CommentCount="0" />
  <row Id="4069" PostTypeId="1" AcceptedAnswerId="4071" CreationDate="2018-08-22T02:19:13.523" Score="10" ViewCount="85" Body="&lt;p&gt;I started reading about Randomized Benchmarking (&lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.106.180504&quot; rel=&quot;nofollow noreferrer&quot;&gt;this paper&lt;/a&gt;, &lt;a href=&quot;https://arxiv.org/abs/1009.3639&quot; rel=&quot;nofollow noreferrer&quot;&gt;arxiv version&lt;/a&gt;) and came across &quot;unitary 2 design.&quot; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;After some googling, I found that the Clifford group being a unitary 2 design is a specific case of &quot;Quantum t-design.&quot;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I read the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_t-design&quot; rel=&quot;nofollow noreferrer&quot;&gt;wikipedia page&lt;/a&gt; and a few other references (&lt;a href=&quot;https://www.cs.mcgill.ca/~akazna/AK_UnitaryDesigns20090929.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;this one for example,&lt;/a&gt; &lt;a href=&quot;https://www.cs.mcgill.ca/~akazna/&quot; rel=&quot;nofollow noreferrer&quot;&gt;non pdf link to the website that links to the pdf&lt;/a&gt;). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I would like to have some intuitive understanding of the difference between different t designs and what makes the clifford group 2 design. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I apologize in advance if the question is too basic.&lt;/p&gt;&#xA;" OwnerUserId="4399" LastEditorUserId="26" LastEditDate="2018-08-25T08:30:22.943" LastActivityDate="2018-08-25T08:30:22.943" Title="What is quantum t-design (intuitive understanding)?" Tags="&lt;quantum-error-correction&gt;&lt;randomised-benchmarking&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="2" />
  <row Id="4070" PostTypeId="2" ParentId="4066" CreationDate="2018-08-22T05:03:53.053" Score="3" Body="&lt;p&gt;I always used to use qcircuit but, as it happens, I've recently been developing a tikz library to do the job, which has some added flexibility. The package will be available at the following DOI: &lt;a href=&quot;http://dx.doi.org/10.17637/rh.7000520&quot; rel=&quot;nofollow noreferrer&quot;&gt;10.17637/rh.7000520&lt;/a&gt;.&#xA;&lt;a href=&quot;https://i.stack.imgur.com/0GKFy.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/0GKFy.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;First, I load my library in the document preamble&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;\usetikzlibrary{quantikz}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Then I typeset the circuit with&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;\begin{tikzcd}&#xA;\lstick{Ancilla \ket{0}\\ register $S$} &amp;amp; \qw &amp;amp; \qw\gategroup[background,style={fill=gray!20,rounded corners},wires=3,steps=3]{Phase estimation} &amp;amp; \qw &amp;amp; \qw &amp;amp; \qw &amp;amp;  \gate{R}\gategroup[background,style={fill=gray!20,rounded corners},wires=3,steps=1]{$R(\tilde\lambda^{-1})$ rotation} &amp;amp; \qw &amp;amp; \qw\gategroup[background,style={fill=gray!20,rounded corners},wires=3,steps=3]{Uncompute}  &amp;amp; \qw &amp;amp; \qw &amp;amp; \meter{} &amp;amp; \rstick{\ket{1}} \qw \\&#xA;\lstick{Clock $\ket{0}^{\otimes n}$\\ register $C$}&amp;amp; \qwbundle &amp;amp; \gate{H^{\otimes n}} &amp;amp; \ctrl{1} &amp;amp; \gate{FT^\dagger} &amp;amp; \hphantomgate{}\qw &amp;amp; \ctrl{-1} &amp;amp; \hphantomgate{}\qw &amp;amp; \gate{FT} &amp;amp; \ctrl{1} &amp;amp; \gate{H^{\otimes n}} &amp;amp; \qw &amp;amp; \rstick{$\ket{0}^{\otimes n}$}\qw \\[1em]&#xA;\lstick{Input \ket{b} \\ register $I$}&amp;amp;\qwbundle&amp;amp; \qw&amp;amp;\gate{U}&amp;amp;\qw&amp;amp; \qw &amp;amp; \qw&amp;amp;\qw&amp;amp;\qw&amp;amp;\gate{U}&amp;amp;\qw&amp;amp;\qw &amp;amp;\rstick{\ket{x}}\qw&#xA;\end{tikzcd}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-08-23T09:48:00.447" LastActivityDate="2018-08-23T09:48:00.447" CommentCount="5" />
  <row Id="4071" PostTypeId="2" ParentId="4069" CreationDate="2018-08-22T05:45:26.613" Score="6" Body="&lt;p&gt;The $t$ in $t$-design is essentially a measure of how good a job the set of gates does in terms of randomising a state (the larger t, the more random, with properly random requiring the infinite limit). Often, you want to compute the average of some function over all possible pure input states, which is equivalent to fixing the input state and averaging over all possible unitaries. However, averaging over all possible unitaries is a pain, and is unnecessary if the function you want to compute is simple enough. If the function you want is a polynomial of degree t or less in terms of the coefficients of the input state, it is sufficient to average over a set of gates that comprise a t-design.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Another way of thinking about this is, instead of a degree t polynomial, you can talk about calculating a linear function of t copies of the input state. This is more like you would do in an actual experiment.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As for what makes the Clifford group a 2-design, I guess you just have to sit down and do the maths. Let S be the set of 1-qubit Clifford gates. Then you need to show that&#xA;$$&#xA;\sum_{s\in S}s\otimes s|00\rangle\langle 00|s\otimes s\propto\mathbb{I}&#xA;$$&#xA;The critical thing here is that there’s 2 copies of the state that we’re averaging over.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-08-22T05:59:06.077" LastActivityDate="2018-08-22T05:59:06.077" CommentCount="0" />
  <row Id="4072" PostTypeId="1" AcceptedAnswerId="4076" CreationDate="2018-08-22T07:47:56.467" Score="3" ViewCount="109" Body="&lt;p&gt;This is the QCSE version of &lt;a href=&quot;https://academia.stackexchange.com/questions/18911/what-should-you-do-if-you-spotted-a-non-trivial-error-in-a-highly-cited-paper&quot;&gt;What should you do if you spotted a non-trivial error in a highly cited paper?&lt;/a&gt; (maybe replace &quot;highly cited&quot; with &quot;moderately cited&quot; and &quot;a non-trivial&quot; with &quot;several minor&quot;).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;While going through the &lt;a href=&quot;https://arxiv.org/abs/1110.2232v2&quot; rel=&quot;nofollow noreferrer&quot;&gt;pre-print v2&lt;/a&gt; as well as the &lt;a href=&quot;https://www.tandfonline.com/doi/abs/10.1080/00268976.2012.668289&quot; rel=&quot;nofollow noreferrer&quot;&gt;published version&lt;/a&gt; of the paper `Quantum Circuit Design for Solving Linear Systems of Equations' by Cao &lt;em&gt;et al.&lt;/em&gt;, I found several errors in the paper:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;In the published version the connections of the $e^{iAt/2^i}$ gates are connected to clock register in the wrong order (Figure 4). &lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;In the pre-print the gates $e^{-iAt/2^i}$ should actually have been $e^{iAt/2^i}$ (Figure 4).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;In the pre-print the gate decomposition of $e^{iAt/2^i}$ is wrong. The last $Z$ gate must have been a controlled $Z$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;The $5$ coefficients of the gate decompositions are wrong in both the pre-print and published version. Only the coefficients given for $e^{iAt/16}$ are fine but the rest they have to be found by some method of multivariable optimization (this was &lt;a href=&quot;https://github.com/nelimee/quantum-tools/blob/master/HHL/4x4_system.py&quot; rel=&quot;nofollow noreferrer&quot;&gt;implemented&lt;/a&gt; by @Nelimee in QISKit and I had verified it)&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;No SWAP gate is required in the circuit, as explained by @DaftWullie &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2725/26&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;They skipped most explanations of &lt;em&gt;why&lt;/em&gt; they chose the specific form of matrix $A$ in the paper, and everything about the &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2605/26&quot;&gt;scaling required&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Anyhow, this paper was essentially what I worked on, through the summer and I need to write a report on what I did, which might be put up on arXiv (and maybe for publishing, probably in &lt;a href=&quot;https://link.springer.com/journal/11128&quot; rel=&quot;nofollow noreferrer&quot;&gt;QIP&lt;/a&gt;, later on, if I can think of sufficiently original material).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, I'm not sure how the quantum computing academic community looks at these type of &quot;correction papers&quot;. So, basically, is it ethical to write up a correction paper like this (which doesn't correct a &quot;huge&quot; mistake in a &quot;highly cited&quot; paper but rather several small mistakes in a &quot;moderately cited&quot; paper) or are they highly frowned upon?  In case the latter is true, I'll probably avoid putting it up on arXiv and wait till I can come up with sufficiently original additions to the paper (like extending it to higher dimensions and making the circuit more general).&lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-08-22T08:19:18.813" LastActivityDate="2018-08-22T18:04:21.613" Title="Ethics: Publishing a corrected version of a moderately cited paper having several minor errors" Tags="&lt;research&gt;" AnswerCount="1" CommentCount="3" FavoriteCount="1" />
  <row Id="4073" PostTypeId="2" ParentId="4066" CreationDate="2018-08-22T15:48:07.367" Score="9" Body="&lt;p&gt;Until such a time as &lt;code&gt;Daftwullie&lt;/code&gt; makes his circuit-drawing library public, here is an answer which more-or-less describes the way in which I draw circuits in TiKZ, with some macros to help make the result more reader-friendly. &lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Snippet&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;See below for all of the code used to generate this example: the following commands are just the ones used to draw the gates themselves, and the input and output labels. (This snippet involves macros which I have defined for the purpose of this post, which I also define below.)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  % draw circuit&#xA;  \gate     (B-2)       [H^{\otimes n}];&#xA;  \ctrlgate (B-3) (C-3) [U];&#xA;  \virtgate (A-3);&#xA;  \gate     (B-4)       [\mathit{FT}^\dagger];&#xA;  \ctrlgate (B-7) (A-7) [R];&#xA;  \virtgate (C-7);&#xA;  \gate     (B-10)       [\mathit{FT}];&#xA;  \ctrlgate (B-11) (C-11) [U];&#xA;  \gate     (B-12)      [H^{\otimes n}];&#xA;  \virtgate (A-12);&#xA;  \meas     (A-14)      [Z];&#xA;  % draw input and output labels&#xA;  \inputlabel  (A-0)  [\lvert 0 \rangle];&#xA;  \inputlabel  (B-0)  [\lvert 0 \rangle^{\otimes n}];&#xA;  \inputlabel  (C-0)  [\lvert b \rangle];&#xA;  \outputlabel (A-15) [\lvert 1 \rangle];&#xA;  \outputlabel (B-15) [\lvert 0 \rangle^{\otimes n}];&#xA;  \outputlabel (C-15) [\lvert x \rangle];&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;Result&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/oiZVW.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/oiZVW.png&quot; alt=&quot;Circuit diagram&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Preamble&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;You will need a pre-amble which contains at least the &lt;code&gt;amsmath&lt;/code&gt; package, as well as the &lt;code&gt;tikz&lt;/code&gt; package. You may not need all of the &lt;code&gt;tikz&lt;/code&gt; libraries below, but they don't hurt. Be sure to include the commands involving layers.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;\documentclass[a4paper,10pt]{article}&#xA;&#xA;\usepackage{amsmath}&#xA;\usepackage{tikz}&#xA;\usetikzlibrary{shapes,arrows,calc,positioning,fit}&#xA;\pgfdeclarelayer{background}&#xA;\pgfsetlayers{background,main}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;For the purposes of this post, I've defined some ad-hoc macros to make reading the coded circuit easier for public consumption. (The macro format is not exactly good LaTeX practise, but I define them this way in order for the syntax to be more easily read and for it to stand out.) The parameters for dimensions in these gates were chosen to look good in your sample-circuit, and were found by trial-and-error: you can change them to change the appearance of your circuit.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The first is a simple macro to draw a gate.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;\def\gate (#1) [#2]{%&#xA;  \node [&#xA;    draw=black,fill=white, inner sep=0pt,&#xA;    minimum width=2.5em, minimum height=2em, outer sep=1ex&#xA;  ] (#1) at (#1) {$#2$}%&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;The second is a macro to draw an 'invisible' gate. This is not really a command which is important for the circuit itself, but helps for the placement of background frames.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;\def\virtgate (#1){%&#xA;  \node [&#xA;    draw=none, fill=none,&#xA;    minimum width=2.5em, minimum height=2em, outer sep=1ex&#xA;  ] (#1) at (#1) {};&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;The third is a macro to draw a controlled gate. This command works well enough for your example circuit, but doesn't allow you to draw a CNOT. (Exercise for the reader proficient in TiKZ: make a &lt;code&gt;\CNOT&lt;/code&gt; command.)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;\def\ctrlgate (#1) (#2) [#3]{%&#xA;  \filldraw [black] (#1) circle (2pt) -- (#2);&#xA;  \gate (#2) [#3]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;The fourth is a macro to draw a &quot;measurement&quot; box. I think it is perfectly reasonable to want to specify an explicit basis or observable for the measurement, so I allow an argument to specify that.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;\def\meas (#1) [#2]{%&#xA;  \node [&#xA;    draw=black, fill=white, inner sep=2pt,&#xA;    label distance=-5mm, minimum height=2em, minimum width=2em&#xA;  ] (meas) at (#1) {};&#xA;  \draw ($(meas.south) + (-.75em,1.5mm)$) arc (150:30:.85em);&#xA;  \draw ($(meas.south) + (0,1mm)$) -- ++(.8em,1em);&#xA;  \node [&#xA;    anchor=north west, inner sep=1.5pt, font=\small&#xA;  ] at (meas.north west) {#2};&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;I define two short macros to produce the labels for the inputs and outputs of wires.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;\def\inputlabel (#1) [#2]{%&#xA;  \node at (#1) [anchor=east] {$#2$}&#xA;}&#xA;\def\outputlabel (#1) [#2]{%&#xA;  \node at (#1) [anchor=west] {$#2$}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;The final macro is one to draw a background frame for different stages in your circuit. It takes an argument specifying which gates (including the invisible virtual 'gates') are meant to belong to the frame.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;\def\bgframe [#1]{%&#xA;  \node [%&#xA;    draw=black, fill=yellow!40!gray!30!white, fit=#1&#xA;  ] {}%&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;The circuit diagram itself&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Now to begin drawing your circuit.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;\begin{document}&#xA;\begin{tikzpicture}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;When you draw a circuit using TiKZ, you will often want to change the spacing a bit. You can do that using macros which are used to define the dimensions of the circuit structure. I arrived at the figures below by trial and error.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  % define diagram parameters&#xA;  \xdef\dy{1.25}&#xA;  \xdef\dt{0.8}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;We now set out some co-ordinates for the wires. I am naming the wires &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt;, and name some points on the wires after whole-numbered time slices, such as &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, and &lt;code&gt;2&lt;/code&gt;. Thus the first co-ordinates are &lt;code&gt;A-0&lt;/code&gt;, &lt;code&gt;B-0&lt;/code&gt;, and &lt;code&gt;C-0&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  % define initial positions of the quantum wires&#xA;  \coordinate (A-0) at (0,0);&#xA;  \coordinate (B-0) at ($(A-0) + (0,-\dy)$);&#xA;  \coordinate (C-0) at ($(B-0) + (0,-\dy)$);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;I now draw our the wires for the circuit by extending each wire, one time-step at a time, for as many time-steps as I want. Note the use of the macro &lt;code&gt;\t&lt;/code&gt; to define the time-slice, and &lt;code&gt;\u&lt;/code&gt; as representing the &lt;em&gt;previous&lt;/em&gt; time-slice.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  % define coordinates along each of the wires for all timesteps&#xA;  \xdef\u{0}&#xA;  \foreach \t in {0,...,15} {%&#xA;    \foreach \l in {A,B,C} {%&#xA;      \coordinate (\l-\t) at ($(\l-\u) + (\dt,0)$);&#xA;      \draw (\l-\u) -- (\l-\t);&#xA;    }&#xA;    \xdef\u{\t}&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;That's the basic structure of the circuit defined. I now place the slashes for your two lower registers, half-way between time-steps 0 and 1 (because that's where they look the best as it turns out).&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  \node  at ($(B-0)!0.5!(B-1)$) {$/$};&#xA;  \node  at ($(C-0)!0.5!(C-1)$) {$/$};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Having done all of this to define the structure of the circuit, I draw the gates, input labels, and output labels for the circuit. Hopefully the commands below are transparent enough.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  % draw circuit&#xA;  \gate     (B-2)       [H^{\otimes n}];&#xA;  \ctrlgate (B-3) (C-3) [U];&#xA;  \virtgate (A-3);&#xA;  \gate     (B-4)       [\mathit{FT}^\dagger];&#xA;  \ctrlgate (B-7) (A-7) [R];&#xA;  \virtgate (C-7);&#xA;  \gate     (B-10)       [\mathit{FT}];&#xA;  \ctrlgate (B-11) (C-11) [U];&#xA;  \gate     (B-12)      [H^{\otimes n}];&#xA;  \virtgate (A-12);&#xA;  \meas     (A-14)      [Z];&#xA;  % draw input and output labels&#xA;  \inputlabel  (A-0)  [\lvert 0 \rangle];&#xA;  \inputlabel  (B-0)  [\lvert 0 \rangle^{\otimes n}];&#xA;  \inputlabel  (C-0)  [\lvert b \rangle];&#xA;  \outputlabel (A-15) [\lvert 1 \rangle];&#xA;  \outputlabel (B-15) [\lvert 0 \rangle^{\otimes n}];&#xA;  \outputlabel (C-15) [\lvert x \rangle];&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;Annotations for the circuit&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;The rest of the circuit diagram is literally commentary. We can do this using a combination of plain-old TiKZ nodes, and the &lt;code&gt;\bgframe&lt;/code&gt; macro which I defined above. (Annotations are a little less predictable, so I don't have a good way of making them as systematic as the earlier parts of the circuit, so general TiKZ commands are a reasonable approach unless you know how to make your annotations uniform.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;First the annotations for the stages of the circuit:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  % draw annotations&#xA;  \node (annotate-1) at ($(A-3) + (0,0.75)$)&#xA;        {\textit{Phase estimation}};&#xA;  \node (annotate-a) at ($(C-3) + (0,-1.25)$)&#xA;        {\textit{(a)}}; &#xA;  \node (annotate-2) at ($(A-7) + (0,0.75)$)&#xA;        {\textit{$\smash{R(\tilde\lambda^{-1}})$ rotation}};&#xA;  \node (annotate-b) at ($(C-7) + (0,-1.25)$)&#xA;        {\textit{(b)}}; &#xA;  \node (annotate-3) at ($(A-11) + (0,0.75)$)&#xA;        {\textit{Uncompute}};&#xA;  \node (annotate-c) at ($(C-11) + (0,-1.25)$)&#xA;        {\textit{(c)}}; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Next, the annotations for the registers, at the input:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  \node (A-in-annotate) at ($(A-0) + (-3em,0)$) [anchor=east]&#xA;    {\parbox{4.5em}{\centering  Ancilla register $S$ }};&#xA;  \node (B-in-annotate) at ($(B-0) + (-3em,0)$) [anchor=east]&#xA;    {\parbox{4.5em}{\centering Clock \\ register $C$ }};&#xA;  \node (C-in-annotate) at ($(C-0) + (-3em,0)$) [anchor=east]&#xA;    {\parbox{4.5em}{\centering Input \\ register $I$ }};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Finally, the frames for the stages of the circuit.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  % draw frames for stages of the circuit&#xA;  \begin{pgfonlayer}{background}&#xA;    \bgframe [(annotate-1)(B-2)(B-4)(C-3)];&#xA;    \bgframe [(annotate-2)(B-7)(C-7)];&#xA;    \bgframe [(annotate-3)(B-10)(B-12)(C-11)];&#xA;  \end{pgfonlayer}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;And that's the end of the circuit.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;\end{tikzpicture}&#xA;\end{document}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-08-22T15:56:16.417" LastActivityDate="2018-08-22T15:56:16.417" CommentCount="9" />
  <row Id="4074" PostTypeId="1" AcceptedAnswerId="4077" CreationDate="2018-08-22T16:05:10.180" Score="6" ViewCount="102" Body="&lt;p&gt;Variational Quantum Eigensolver is a popular algorithm in Quantum Computing. But the ansatz part is very tricky. I do not really understand if they are built on some intuition, according to hardware or something else; or if it was just a trial and error approach.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What do you think about it?&lt;/p&gt;&#xA;" OwnerUserId="4127" LastActivityDate="2018-08-22T18:20:06.507" Title="Is there an intuition built on ansatz in VQE algorithm or is it more a trial and error approach?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-computer&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="4075" PostTypeId="2" ParentId="4063" CreationDate="2018-08-22T17:31:39.920" Score="1" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;direct definition is a quantum register that stores a real number defined by an observable with a spectrum consisting of ℝ&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Yes, qubits can be used to discretize a continuous quantum system.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;How?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Lets say $\Phi $ is an operator on the continuous system which we want to simulate using qubits. We need a discrete register ($D$) to store the qubit values. Now the discretization is done by measuring the shifts between the eigenstates of $\Phi$ denoted by operator say $M$. This is done by DFT.&#xA;$$&#xA;M = F^*\Phi F&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Where $F$ is the DFT operator.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now all this is considering that you already have a register which is storing continuous quantum output of a continuous system. &quot;What is that register?&quot; is I believe to be your original question. For that, you can take an example of cavity QED.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;A typical quantum system with a continuous degree of freedom is the quantum field and normally, quantum simulations of quantum field theories rely on discretisation of this field.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Whereas &lt;strong&gt;a cavity QED output is a continuous quantum field and &lt;em&gt;this&lt;/em&gt; acts as a continuous quantum register.&lt;/strong&gt; &lt;a href=&quot;https://pdfs.semanticscholar.org/d9ab/29b63427a7d1a3cc4714a89dfed8ee4356bf.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;This&lt;/a&gt; thesis has even proposed an algorithm to be directly implemented on this continuous quantum field and only discretizing after the implementation, thus utilizing the underlying properties of continuous system.&lt;/p&gt;&#xA;" OwnerUserId="419" LastActivityDate="2018-08-22T17:31:39.920" CommentCount="3" />
  <row Id="4076" PostTypeId="2" ParentId="4072" CreationDate="2018-08-22T17:48:08.410" Score="5" Body="&lt;p&gt;When you believe there are errors in a paper, you have the opportunity to publish a &quot;comment&quot; on the paper, in the same journal that the paper was originally published. The paper to which you refer as published in Molecular Physics, and here is an example of a &lt;a href=&quot;https://www.tandfonline.com/doi/abs/10.1080/00268970110089090&quot; rel=&quot;noreferrer&quot;&gt;&quot;comment&quot; published in that very same journal&lt;/a&gt; in 2002, about a paper that was originally published in 1968.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, be careful when publishing a comment. You are publicly saying that they have made errors in a piece of work on which they have spent a lot of time and energy. Before contacting the journal, you should notify the authors privately. Instead of &lt;strong&gt;&lt;em&gt;telling&lt;/em&gt;&lt;/strong&gt; them that you have found errors in their paper, &lt;strong&gt;&lt;em&gt;ask&lt;/em&gt;&lt;/strong&gt; them if your suggestions are correct. For example:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Dear Prof. Kais, &lt;br&gt; &#xA;  I found your paper &quot;Quantum circuit design for solving linear systems of equations&quot; very interesting and it was the subject of my summer project, for which I have to write a report now. While working through the paper I have found the following 6 points came up, which I would like to clarify with you: [here you can point out the 6 things you listed in your question, but I would recommend never to say they are &quot;wrong&quot; or they &quot;skipped&quot; something, but instead just say something like &quot;I think the $Z$ should be a $cZ$, am I correct?&quot;].&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Colleagues have suggested that I publish a Comment on your article in Molecular Physics, but I would like to consult you on it first.&lt;/p&gt;&#xA;  &#xA;  &lt;p&gt;Most respectfully yours,&lt;br&gt;&#xA;  Blue&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I have written an email like this before, and the author's response indicated to me that he agreed with me (on a much more profound error than the above 6 points: he had claimed something is in QMA but there was an error in his proof of that so it is still an open question whether or not it is in QMA), but it was clear from his response that he would be very angry at me if I published a Comment. I decided to swallow my pride and not publish the Comment. One day he might be the referee for one of my papers, or be the examiner for one of my grant proposals, and I do not want him to have bitterness towards me for publicly exposing that he made this mistake. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This author suggested that the two of us publish an &quot;Erratum&quot; instead of a &quot;Comment&quot;, so he could be a co-author on the paper saying that there was an error in the original, but in the end we didn't even do that. Comment and Erratum papers, like the one you may be considering to write in this case, are not so helpful for your CV anyway. They are not regarded at nearly the same level as an &quot;original&quot; paper. I have never published a Comment, and I only know a small number of people who have. The important thing is that you now know the problems with the original paper and the corrections to those problems, and it's up to the original authors whether or not they want to publish an Erratum.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;There is also a journal where you can publish a re-analysis of other people's papers, which most people don't know about. It's the &quot;Analysis&quot; section in the journal Nature. They allow you to publish a re-analysis of other people's already published work, but they do this &lt;strong&gt;&lt;em&gt;very&lt;/em&gt;&lt;/strong&gt; rarely. The only example I know is &lt;a href=&quot;https://www.nature.com/articles/nature12290&quot; rel=&quot;noreferrer&quot;&gt;this paper&lt;/a&gt;. Nature is not likely to publish the 6 minor things that you point out, because the standards in Nature are very high and you would have to find a much more &lt;strong&gt;&lt;em&gt;profound&lt;/em&gt;&lt;/strong&gt; re-analysis of the original paper rather than just 6 minor errors.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-08-22T18:04:21.613" LastActivityDate="2018-08-22T18:04:21.613" CommentCount="4" />
  <row Id="4077" PostTypeId="2" ParentId="4074" CreationDate="2018-08-22T18:20:06.507" Score="5" Body="&lt;p&gt;VQE can be used for many things. The most popular application of VQE is for the quantum chemistry problem, as in &lt;a href=&quot;https://arxiv.org/abs/1701.02691&quot; rel=&quot;noreferrer&quot;&gt;this paper&lt;/a&gt;, where they are trying to find the ground state wavefunction of a molecular Hamiltonian (i.e. the VQE is trying to find the eigenvector with the smallest eigenvalue/energy). Here you can see that they suggest a unitary coupled cluster (UCC) ansatz. The reason they choose UCC is because it is well-known that coupled cluster already gives a very good approximation of the ground state wavefunction, in fact it is the basis for what chemists call the &quot;&lt;a href=&quot;https://pubs.acs.org/doi/abs/10.1021/ct400465q&quot; rel=&quot;noreferrer&quot;&gt;gold standard of quantum chemistry&lt;/a&gt;&quot;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Remember VQE is a heuristic. The better the ansatz that you start with, the  more likely your VQE will perform well. As you correctly said in your question, you can use intuition, or trial-and-error, or just use any knowledge you have of the problem to come up with something that you believe will work well (as in the case of using a coupled cluster ansatz for the problem where coupled cluster is already considered &quot;the gold standard&quot; for people solving the problem on classical computers). &lt;/p&gt;&#xA;&#xA;&lt;p&gt;There is no general recipe for how to come up with the ansatz for VQE which will universally work well on every VQE problem, and that is why VQE is called a &quot;heuristic&quot;.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-08-22T18:20:06.507" CommentCount="0" />
  <row Id="4078" PostTypeId="1" AcceptedAnswerId="4081" CreationDate="2018-08-23T22:34:21.137" Score="6" ViewCount="159" Body="&lt;p&gt;For the implementation of a certain quantum algorithm, I need to construct a multi-qubit (in this case, a three-qubit) controlled-Z gate from a set of elementary gates, as shown in the figure below.&#xA;&lt;a href=&quot;https://i.stack.imgur.com/IA6d1.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/IA6d1.png&quot; alt=&quot;Three-qubit controlled-Z gate.&quot;&gt;&lt;/a&gt;&#xA;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The gates that I can use are&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;the Pauli gates $\rm X, Y, Z$ and all their powers (i.e. all Pauli rotations up to a phase factor),&lt;/li&gt;&#xA;&lt;li&gt;${\rm exp}(i\theta|11\rangle\langle11|)$ (rotation about $|11\rangle\langle11|$ projector),&lt;/li&gt;&#xA;&lt;li&gt;$\rm H$ (Hadamard),&lt;/li&gt;&#xA;&lt;li&gt;$\rm C_X$ (single-qubit controlled-X or CNOT),&lt;/li&gt;&#xA;&lt;li&gt;$\rm C_Z$ (single-qubit controlled-Z), and&lt;/li&gt;&#xA;&lt;li&gt;$\rm S$ (SWAP).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;How can I go about building this three-qubit controlled-Z from these gates? I have read several papers on circuit decompositions, but none of them could give me a clear and concise answer.&lt;/p&gt;&#xA;" OwnerUserId="2687" LastEditorUserId="2687" LastEditDate="2018-08-27T17:54:10.123" LastActivityDate="2018-08-28T07:25:34.270" Title="How to construct a multi-qubit controlled-Z from elementary gates?" Tags="&lt;quantum-gate&gt;&lt;circuit-model&gt;&lt;gate-synthesis&gt;" AnswerCount="6" CommentCount="2" FavoriteCount="1" />
  <row Id="4079" PostTypeId="1" AcceptedAnswerId="4080" CreationDate="2018-08-23T22:53:44.517" Score="6" ViewCount="36" Body="&lt;p&gt;We know that the Wigner function of a Gaussian quantum state is (up to a constant) a Gaussian distribution. The first moment and the covariance of this distribution uniquely specify a quantum state. Therefore a Wigner function uniquely determines a Gaussian state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Are there any similar statements applying to non-Gaussian states?&lt;/p&gt;&#xA;" OwnerUserId="1581" LastActivityDate="2018-08-23T23:18:44.607" Title="Does a Wigner function uniquely determine a quantum state?" Tags="&lt;continuous-variable&gt;" AnswerCount="1" CommentCount="0" FavoriteCount="2" />
  <row Id="4080" PostTypeId="2" ParentId="4079" CreationDate="2018-08-23T23:18:44.607" Score="6" Body="&lt;p&gt;For any quantum state, we have a unique density matrix $\rho$.&lt;br&gt;&#xA;For any $\rho$, we can do the &lt;a href=&quot;https://en.wikipedia.org/wiki/Wigner_quasiprobability_distribution#Definition_and_meaning&quot; rel=&quot;noreferrer&quot;&gt;Wigner transformation&lt;/a&gt; to get a unique Wigner function $P(x,p)$. &lt;br&gt;&#xA;For any Wigner function $P(x,p)$, we can do the &lt;a href=&quot;https://en.wikipedia.org/wiki/Wigner%E2%80%93Weyl_transform#Definition_of_the_Weyl_quantization_of_a_general_observable&quot; rel=&quot;noreferrer&quot;&gt;Weyl transformation&lt;/a&gt; to get back the unique $\rho$.&lt;br&gt;&#xA;If the construction of the Wigner function from $\rho$ was not unique, then it would not be possible to define an inverse transformation (but we do have an inverse transformation, namely the Weyl transformation, so the Wigner transformation does generate a unique characterization of a quantum state).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It has also been &lt;a href=&quot;https://physics.stackexchange.com/questions/242189/understanding-the-mathematics-of-wigner-function&quot;&gt;pointed out on the Physics Stack Exchange&lt;/a&gt;, that the Wigner function contains all information about a quantum state, just like the density matrix.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-08-23T23:18:44.607" CommentCount="1" />
  <row Id="4081" PostTypeId="2" ParentId="4078" CreationDate="2018-08-23T23:33:18.300" Score="6" Body="&lt;p&gt;You can implement an $n$-qubit controlled $U$ by the circuit given in &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/2178/2293&quot;&gt;this answer&lt;/a&gt;. Just replace $U$ by $Z$. However this requires CCNOT (Toffoli) gates, and you have some &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/3943/how-do-you-implement-the-toffoli-gate-using-only-single-qubit-and-cnot-gates&quot;&gt;options for how to implement CCNOT using elementary gates&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-08-23T23:33:18.300" CommentCount="4" />
  <row Id="4082" PostTypeId="1" CreationDate="2018-08-24T01:48:50.600" Score="6" ViewCount="58" Body="&lt;p&gt;I was reading papers on Randomized Benchmarking, such as &lt;a href=&quot;https://arxiv.org/abs/1404.6025&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/abs/1701.04299&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt;.&#xA;(more specifically, equation 30 in the second paper)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It appears to be some kind of averaging but I would like to have a more intuitive and physical picture of what it actually represents in terms of measurements. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;(I know very little math, especially in terms of group representation)&lt;/p&gt;&#xA;" OwnerUserId="4399" LastEditorUserId="26" LastEditDate="2018-08-25T08:08:08.503" LastActivityDate="2018-08-25T08:08:08.503" Title="Physical meaning of twirling in Randomized Benchmarking" Tags="&lt;quantum-error-correction&gt;&lt;randomised-benchmarking&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="1" />
  <row Id="4083" PostTypeId="2" ParentId="4082" CreationDate="2018-08-24T05:02:46.753" Score="1" Body="&lt;p&gt;An average over conjugations is known as a “twirl”. The “twirling” operation originates from invariant theory (where it is sometimes called “transfer homomorphism”). Twirling a quantum channel over $P_1^{⊗n}$, $C_1^{⊗n}$ or $C_n$ takes it to one described by a polynomial number of parameters.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The twirling operation will be useful if it preserves, at least partially, properties of the original channel. Specifically, one would hope that correctable codes of the twirled channel resemble those of the original channel. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;See page 31 of &quot;&lt;a href=&quot;https://uwspace.uwaterloo.ca/handle/10012/3828&quot; rel=&quot;nofollow noreferrer&quot;&gt;Gaining Information About a Quantum Channel Via Twirling&lt;/a&gt;&quot; (Jul 31 2008) by Easwar Magesan.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;More in depth references:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;a href=&quot;https://arxiv.org/abs/1204.6308&quot; rel=&quot;nofollow noreferrer&quot;&gt;Characterization of addressability by simultaneous randomized benchmarking&lt;/a&gt;&quot; (Jan 2 2013), by Jay M. Gambetta, A. D. Corcoles, S. T. Merkel, B. R. Johnson, John A. Smolin, Jerry M. Chow, Colm A. Ryan, Chad Rigetti, S. Poletto, Thomas A. Ohki, Mark B. Ketchen, and M. Steffen.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0611002&quot; rel=&quot;nofollow noreferrer&quot;&gt;Evenly distributed unitaries: on the structure of unitary designs&lt;/a&gt;&quot; (May 13 2007), by D. Gross, K. Audenaert, and J. Eisert.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&quot;&lt;a href=&quot;https://arxiv.org/abs/quant-ph/0606161&quot; rel=&quot;nofollow noreferrer&quot;&gt;Exact and Approximate Unitary 2-Designs: Constructions and Applications&lt;/a&gt;&quot; (Aug 31 2012), by Christoph Dankert, Richard Cleve, Joseph Emerson, and Etera Livine.&lt;/p&gt;&#xA;" OwnerUserId="278" LastActivityDate="2018-08-24T05:02:46.753" CommentCount="1" />
  <row Id="4084" PostTypeId="2" ParentId="4082" CreationDate="2018-08-24T07:59:49.307" Score="3" Body="&lt;p&gt;I think the way that it is used in deriving bounds on quantum cloning is quite insightful, and hopefully gives you a flavour of the broader context. Where possible I'll skip some of the details in favour of description.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Imagine you want to clone an unknown one-qubit quantum state $|\psi\rangle$, making two copies. We know that this is impossible to do perfectly, but you might want to quantify how close you can get. So, let's theorise that there's some map $\rho=\mathcal{E}(|\psi\rangle\langle\psi|)$ that you're going to implement, producing a two-qubit output. The cloning fidelity in this case is&#xA;$$&#xA;F=\text{Tr}\left((|\psi\rangle\langle\psi|\otimes\mathbb{I}+\mathbb{I}\otimes|\psi\rangle\langle\psi|)\rho\right)/2&#xA;$$&#xA;Skipping over the details, including the Choi-Jamiolkowski isomorphism, it turns out that you can relate the optimal choice of $\rho$ to the eigenvector with maximum eigenvalue of the operator&#xA;$$&#xA;|\psi\rangle\langle\psi|^\star\otimes(|\psi\rangle\langle\psi|\otimes\mathbb{I}+\mathbb{I}\otimes|\psi\rangle\langle\psi|).&#xA;$$&#xA;Actually, this is straightforward to calculate: the maximum eigenvector is $|\psi\rangle^\star|\psi\rangle|\psi\rangle$, and has eigenvalue 1. i.e. the operation can be done perfectly. However, this formulation presupposes that we know the state we're trying to clone (and obviously, if you know it, you can make arbitrarily many copies). We somehow have to quantify the fact that we don't know what the state is to be cloned.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For this, we need to take a Bayesian approach. If we don't know the state, we assign a probability to each of the possible states. In that case, the expected fidelity of the transformation is $\bar F$, the maximum eigenvalue of the operator&#xA;$$&#xA;R=\sum_{\psi}p_{\psi}|\psi\rangle\langle\psi|^\star\otimes(|\psi\rangle\langle\psi|\otimes\mathbb{I}+\mathbb{I}\otimes|\psi\rangle\langle\psi|)&#xA;$$&#xA;You might know something about the possible input state. For example, if you know it's either $|0\rangle$ or $|1\rangle$ with equal probability, you still find the maximum eigenvalue of 1 (which makes sense: you can measure the input state in the Z basis and make as many copies as you want). At the other extreme, if you know nothing about the state at all, you have to average over all single-qubit pure states with equal weights. What is the right way to do this? It's a bit messy as you can perhaps see from looking at the Bloch sphere:&#xA;&lt;a href=&quot;https://i.stack.imgur.com/okgge.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/okgge.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&#xA;We need to take an average of all points on the surface of the sphere.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;One way to achieve this is to say that every $|\psi\rangle=U|0\rangle$ for some $U$, and we average over all possible unitaries, where the correct averaging is determined by the Haar measure. So, we can change our operator $R$ into&#xA;$$&#xA;R=\int U^\star\otimes U\otimes U\left(|0\rangle\langle0|^\star\otimes(|0\rangle\langle0|\otimes\mathbb{I}+\mathbb{I}\otimes|0\rangle\langle0|)\right)U^T\otimes U^\dagger\otimes U^\dagger dU&#xA;$$&#xA;This is basically the twirling operation (except for the slight technicality that there's a complex conjugate on one of the qubits), and certainly captures the intuition of how/why it comes into things.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-08-24T07:59:49.307" CommentCount="0" />
  <row Id="4085" PostTypeId="2" ParentId="3890" CreationDate="2018-08-24T13:09:47.530" Score="2" Body="&lt;p&gt;&lt;em&gt;entanglement&lt;/em&gt; is neither an operation nor a state, it is a concept describing a particular family of states. Here is a short explanation of this concept.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's limit ourselves to 2 qubits stored on 2 registers A and B :&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;case 1 : you prepare independently the qubit A in some state (&lt;code&gt;a1|0&amp;gt; + a2|1&amp;gt;&lt;/code&gt;), then you do the same with the qubit B (&lt;code&gt;b1|0&amp;gt; + b2|1&amp;gt;&lt;/code&gt;). In that case the state of your total system is described as the concatenation of the state of the system A and the state of the system B. This case is intuitive, there is no entanglement between the registers A and B -&gt; we call it a &lt;em&gt;separable&lt;/em&gt; state. We can write the state of the system as &lt;code&gt;a1*b1|00&amp;gt; + a1*b2|01&amp;gt; + a2*b1|10&amp;gt; + a2*b2|11&amp;gt;&lt;/code&gt; (tensor product of states on A and B)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;In quantum mechanics, there exists other states for the total system AB that cannot be described as the concatenation of the states of the subsystems A and B. This phenomenon has no equivalent in classical mechanics and is not very intuitive. This leads us to :&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;case 2 : you start with some state &lt;code&gt;k1|0&amp;gt; + k2|1&amp;gt;&lt;/code&gt; on the register A and &lt;code&gt;|0&amp;gt;&lt;/code&gt; on register B, then you apply a quantum operator known as CNOT that will &quot;expand&quot; the contents of the two superposition terms of register A to register B. The resulting state &lt;code&gt;k1|00&amp;gt; + k2|11&amp;gt;&lt;/code&gt; on system AB cannot be written as a product (tensor product) of two separate states on A and B. We call it an &lt;em&gt;entangled&lt;/em&gt; state.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;One particularity of the entangled states is how it behave wrt measurement : in an entangled state, the outcome of a measurement in one of the subsystems can influence the outcome of a measurement on the other. For example with the state in case 2, you have :&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;50% chance of measuring &lt;code&gt;1&lt;/code&gt; on register A&lt;/li&gt;&#xA;&lt;li&gt;50% chance of measuring &lt;code&gt;1&lt;/code&gt; on register B&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;but&lt;/strong&gt; if you have already measured the register A and you have gotten &lt;code&gt;1&lt;/code&gt;, then you have a 100% chance of measuring &lt;code&gt;1&lt;/code&gt; on register B&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;This last item &quot;3&quot; would not be true if the state wasn't entangled, in which case the outcome of the measurement on register A couldn't have influenced the probabilities of the outcome on register B.&lt;/p&gt;&#xA;" OwnerUserId="4420" LastActivityDate="2018-08-24T13:09:47.530" CommentCount="0" />
  <row Id="4086" PostTypeId="1" CreationDate="2018-08-24T18:05:02.970" Score="7" ViewCount="125" Body="&lt;p&gt;A recent question here asked how to compile the 4-qubit gate CCCZ (controlled-controlled-controlled-Z) into simple 1-qubit and 2-qubit gates, and the only answer given so far &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/4081/2293&quot;&gt;requires 63 gates&lt;/a&gt;! &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The first step was to use the C$^n$U construction given by Nielsen &amp;amp; Chuang:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&quot;https://i.stack.imgur.com/Wi9FAm.png&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;With $n=3$ this means 4 CCNOT gates and 3 simple gates (1 CNOT and 2 Hadamards is enough to do the final CZ on the target qubit and the last work qubit).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://dl.acm.org/citation.cfm?id=2011799&quot; rel=&quot;nofollow noreferrer&quot;&gt;Theorem 1 of this paper&lt;/a&gt;, says that in general the CCNOT requires 9 one-qubit and 6 two-qubit gates (15 total):&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/GRfPe.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/GRfPe.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;This means:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(4 CCNOTs) x (15 gates per CCNOT) + (1 CNOT) + (2 Hadamards) = &lt;strong&gt;63 total gates&lt;/strong&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In a &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/4078/how-to-construct-a-multi-qubit-controlled-z-from-elementary-gates/4081#comment4442_4081&quot;&gt;comment&lt;/a&gt;, it has been suggested the 63 gates can be then further compiled using an &quot;automatic procedure&quot;, for example from the theory of &lt;a href=&quot;https://en.wikipedia.org/wiki/Automatic_group&quot; rel=&quot;nofollow noreferrer&quot;&gt;automatic groups&lt;/a&gt;. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;How can this &quot;automatic compilation&quot; be done, and how much would it reduce the number of 1-qubit and 2-qubit gates in this case?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-08-24T22:58:58.143" LastActivityDate="2018-08-28T13:52:59.293" Title="Automatic compilation of quantum circuits" Tags="&lt;quantum-gate&gt;&lt;quantum-programming&gt;&lt;gate-synthesis&gt;&lt;mathematics&gt;&lt;compilation&gt;" AnswerCount="2" CommentCount="7" FavoriteCount="2" />
  <row Id="4087" PostTypeId="2" ParentId="4078" CreationDate="2018-08-24T18:39:09.697" Score="2" Body="&lt;p&gt;While my other answer is the most obvious &quot;textbook&quot; way (using &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/4086/automatic-compilation-of-quantum-circuits&quot;&gt;Nielsen &amp;amp; Chaung's CCCZ decomposition into CCNOTs&lt;/a&gt;, then another &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/3943/how-do-you-implement-the-toffoli-gate-using-only-single-qubit-and-cnot-gates&quot;&gt;textbook decomposition to compile the CCNOTs&lt;/a&gt;), a more creative way might allow us to get the job done with fewer gates. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Step 1:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Replace all the CNOTs in Nielsen &amp;amp; Chuang's circuit with this gadget:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/BYfjl.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/BYfjl.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Step 2:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now we have a bunch of CCZs instead of CCNOTs, and they can be decomposed like this (courtesy of &lt;a href=&quot;https://dl.acm.org/citation.cfm?id=2011799&quot; rel=&quot;nofollow noreferrer&quot;&gt;this paper&lt;/a&gt;):&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/0XIcU.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/0XIcU.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Step 3:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that $H^2 = I$, so some of these Hadamards cancel each other out and we get even more of a reduction :)&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-08-25T19:00:12.907" LastActivityDate="2018-08-25T19:00:12.907" CommentCount="1" />
  <row Id="4088" PostTypeId="2" ParentId="4078" CreationDate="2018-08-24T19:35:21.047" Score="4" Body="&lt;p&gt;I'm posting another decomposition of CCCZ here just in case it is useful for anyone else trying to compile CCCZ. It requires a smaller number of total gates, and only 1 auxiliary qubit instead of 2, but five more 2-qubit gates than the &quot;obvious&quot; answer, so may actually be worse for implementation on Hardware.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It was suggested by user @Rob in this comment: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/4086/automatic-compilation-of-quantum-circuits#comment4444_4086&quot;&gt;Automatic compilation of quantum circuits&lt;/a&gt;, and comes from &lt;a href=&quot;http://iopscience.iop.org/article/10.1088/1367-2630/aaa398/meta&quot; rel=&quot;nofollow noreferrer&quot;&gt;this paper&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/0gtf2.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/0gtf2.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The GMS5$(\chi)$ gate is this:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&quot;https://i.stack.imgur.com/wlX8M.png&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;with $n=5$ and all $\chi_{ij}=\chi$, which means it involves 10 two-qubit gates. These will then have to be compiled into the gate set given in the question, so this decomposition should only be used if you are trying to save on the number auxiliary qubits or if you don't mind having more 2-qubit gates in order to reduce the circuit depth by a bit.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-08-24T19:35:21.047" CommentCount="9" />
  <row Id="4089" PostTypeId="2" ParentId="4086" CreationDate="2018-08-24T23:18:14.510" Score="3" Body="&lt;p&gt;Using the procedure described in &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0303063&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/quant-ph/0303063&lt;/a&gt;, &lt;strong&gt;any&lt;/strong&gt; diagonal gate - any thus in particular the CCCZ gate -- can be decomposed in terms of e.g. CNOTs and one-qubit diagonal gates, where the CNOTs can be optimized on their own following a classical optimization procedure.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The reference provides a circuit using 16 CNOTs for arbitrary diagonal 4-qubit gates (Fig. 4).  &lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Remark: While there might in principle be a simpler circuit (said circuit has been optimized with a more constrained circuit architecture in mind), it should be close to optimal -- the circuit needs to create all states of the form $\bigoplus_{i\in I}x_i$ for any non-trivial subset $I\subset\{1,2,3,4\}$, and there are 15 of those for 4 qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note also that this construction by no means needs to be optimal.&lt;/p&gt;&#xA;" OwnerUserId="491" LastActivityDate="2018-08-24T23:18:14.510" CommentCount="1" />
  <row Id="4090" PostTypeId="2" ParentId="4078" CreationDate="2018-08-24T23:24:46.180" Score="4" Body="&lt;p&gt;(EDIT: Improved to 14 CNOTs.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;It can be done with 14 CNOTs, plus 15 single-qubit Z rotations, and no auxiliary qubits.&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The corresponding circuit is&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/Ddlt6.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/Ddlt6.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;where the $\fbox{$\pm$}$ gates are rotations &#xA;$$&#xA;R_z(\pm\pi/16)\propto \left(\begin{matrix}1\\&amp;amp;e^{\pm i\pi/8}&#xA;\end{matrix}\right)&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;Derivation:&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Using the procedure described in &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0303063&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/quant-ph/0303063&lt;/a&gt;, &lt;strong&gt;any&lt;/strong&gt; diagonal gate - any thus in particular the CCCZ gate -- can be decomposed in terms of e.g. CNOTs and one-qubit diagonal gates, where the CNOTs can be optimized on their own following a classical optimization procedure.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The reference provides a circuit using 16 CNOTs for arbitrary diagonal 4-qubit gates (Fig. 4).  &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This can be improved if arbitrary pairs of qubits can be coupled to 14 qubits. For nearest neighbors with periodic (open) boundary conditions, this can be done with 16 (18) CNOTs. The corresponding circuits can be found in &lt;a href=&quot;https://epub.uni-regensburg.de/1511/&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://epub.uni-regensburg.de/1511/&lt;/a&gt;, Fig. 5.2, 5.4, and 5.5, and can e.g. be obtained using methods to construct short Gray sequences.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The number of one-qubit gates is always 15.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Remark: While there might in principle be a simpler circuit (said circuit has been optimized with a more constrained circuit architecture in mind), it should be close to optimal -- the circuit needs to create all states of the form $\bigoplus_{i\in I}x_i$ for any non-trivial subset $I\subset\{1,2,3,4\}$, and there are 15 of those for 4 qubits.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note also that this construction by no means needs to be optimal.&lt;/p&gt;&#xA;" OwnerUserId="491" LastEditorUserId="491" LastEditDate="2018-08-27T19:08:09.367" LastActivityDate="2018-08-27T19:08:09.367" CommentCount="1" />
  <row Id="4091" PostTypeId="2" ParentId="4078" CreationDate="2018-08-25T05:55:42.280" Score="4" Body="&lt;p&gt;Here is &lt;a href=&quot;http://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C%22Z%5E%C2%BC%22%2C%22Z%5E%C2%BC%22%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%5D%7D&quot; rel=&quot;nofollow noreferrer&quot;&gt;a CCCZ construction that uses 29 gates&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;http://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C%22Z%5E%C2%BC%22%2C%22Z%5E%C2%BC%22%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%5D%7D&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/8DQud.png&quot; alt=&quot;circuit&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you're allowed to use measurement and classical feedforward, &lt;a href=&quot;http://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C%22Z%5E%C2%BC%22%2C%22Z%5E%C2%BC%22%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Measure%22%5D%2C%5B%22%E2%80%A2%22%2C%22Z%22%2C1%2C1%2C%22%E2%80%A2%22%5D%5D%7D&quot; rel=&quot;nofollow noreferrer&quot;&gt;the gate count can be reduced to 25&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;http://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E%C2%BC%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C1%2C%22Z%5E-%C2%BC%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%22X%22%5D%2C%5B1%2C1%2C%22Z%5E%C2%BC%22%2C%22Z%5E%C2%BC%22%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Measure%22%5D%2C%5B%22%E2%80%A2%22%2C%22Z%22%2C1%2C1%2C%22%E2%80%A2%22%5D%5D%7D&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/3RDee.png&quot; alt=&quot;circuit&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(The Hadamard gates can be replaced with square roots of Y if needed to meet the gate set constraint.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And if you allow me to perform Controlled-S gates and Controlled-sqrt(X) gates and perform X basis measurements, then &lt;a href=&quot;http://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%5E%C2%BD%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C%22Z%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%5E-%C2%BD%22%5D%2C%5B1%2C1%2C1%2C%22%E2%97%A6%22%2C%22Z%5E-%C2%BD%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22Z%5E-%C2%BD%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%22Z%5E%C2%BD%22%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C%22Z%22%2C1%2C%22%E2%80%A2%22%5D%2C%5B%22%E2%80%A2%22%2C%22Z%22%2C1%2C1%2C%22%E2%80%A2%22%5D%5D%7D&quot; rel=&quot;nofollow noreferrer&quot;&gt;I can get it down to 10 gates total&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;http://algassert.com/quirk#circuit=%7B%22cols%22%3A%5B%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%5E%C2%BD%22%5D%2C%5B%22%E2%80%A2%22%2C1%2C1%2C1%2C%22Z%22%5D%2C%5B1%2C%22%E2%80%A2%22%2C1%2C1%2C%22X%5E-%C2%BD%22%5D%2C%5B1%2C1%2C1%2C%22%E2%97%A6%22%2C%22Z%5E-%C2%BD%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C1%2C%22X%22%5D%2C%5B1%2C1%2C1%2C%22%E2%80%A2%22%2C%22Z%5E-%C2%BD%22%5D%2C%5B1%2C1%2C%22%E2%80%A2%22%2C%22Z%5E%C2%BD%22%5D%2C%5B1%2C1%2C1%2C1%2C%22H%22%5D%2C%5B1%2C1%2C1%2C1%2C%22Measure%22%5D%2C%5B1%2C1%2C%22Z%22%2C1%2C%22%E2%80%A2%22%5D%2C%5B%22%E2%80%A2%22%2C%22Z%22%2C1%2C1%2C%22%E2%80%A2%22%5D%5D%7D&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/d9cDZ.png&quot; alt=&quot;circuit&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="119" LastEditorUserId="119" LastEditDate="2018-08-26T17:38:42.747" LastActivityDate="2018-08-26T17:38:42.747" CommentCount="5" />
  <row Id="4092" PostTypeId="2" ParentId="4078" CreationDate="2018-08-25T06:27:19.170" Score="4" Body="&lt;p&gt;There are some large savings that can be made based on the specified gate set. For example, in the typical ccnot construction, if you replace the $T$ gate with $Z^{1/4}$, you don't need that phase correction that constitutes the last few gates between the two control qubits. This construction, which obeys the gate set specified in the question, consists of 21 gates, of which 10 are 2-qubit (you don’t need the last gate in the circuit below).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/NztpV.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/NztpV.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;To be clear (in response to several comments): usually we look at Toffoli, and try to make it using the $T$ gate. If both controls are $|1\rangle$, then the gate sequence on the target qubit is $HXTXT^\dagger XTXT^\dagger H$. Now, since $XT^\dagger X=Te^{-i\pi/4}$, then the sequence simplifies to $-iHT^4H=-iX$, and one has to add a compensating controlled-S gate on the two control qubits. If, instead, we use $Z^{1/4}$, then $XZ^{-1/4}X=Z^{1/4}$, and none of those pesky phases come into it, and it saves you some two-qubit gates!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Also, note that the two Toffoli gates are only Toffoli because they target the 0 state. Typically you would need an extra two-qubit gate.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I've not found as efficient a construction in existing literature, although this &lt;a href=&quot;https://arxiv.org/abs/1703.10535&quot; rel=&quot;nofollow noreferrer&quot;&gt;paper&lt;/a&gt; claims a construction using only 11 2-qubit gates, but I haven’t done a complete gate count once it’s converted into the question’s restricted gate set.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-08-28T07:25:34.270" LastActivityDate="2018-08-28T07:25:34.270" CommentCount="6" />
  <row Id="4093" PostTypeId="2" ParentId="4086" CreationDate="2018-08-26T19:06:54.813" Score="4" Body="&lt;p&gt;Let $g_1 \cdots g_M$ be the basic gates that you are allowed to use. For the purposes of this $CNOT_{12}$ and $CNOT_{13}$ etc are treated as separate. So $M$ is polynomially dependent on $n$, the number of qubits. The precise dependence involves details of the sorts of gates you use and how $k$-local they are.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So we have a group presentation $\langle g_1 \cdots g_M \mid R_1 \cdots \rangle$ where there are many relations that we do not know. There is very little hope for that being a presentation of an automatic group. Words in the group give circuits. But the problem in this generality is hopeless.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But we can consider a simpler problem. If we throw out some of the $g_i$, then the words from before become of the form $w_1 g_{i_1} w_2 g_{i_2} \cdots w_k$ where each of the $w_i$ are words only in the remaining letters. If we managed to make them shorter using the relations that don't involve the $g_i$, then we will have made the entire circuit shorter. This is akin to the optimizing the CNOTs on their own made in the other answer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So let's suppose we are in that problem already $\langle g_1 \cdots g_M \mid R_1 \cdots \rangle$ where we now use all the gates specified. Again this is probably not an automatic group. But what if we throw out some of the relations. Then we will have another group that has a quotient map down to the one we really want. But the one upstairs will be automatic by design. If we only use the relations that remain and shorten the word, then it will still be a shorter word for the quotient group. It just won't be optimal for the quotient group, but it will have the length $\leq$ to the length it started with.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;How do we choose the $g_i$ and relations to throw out in order to get an automatic group? This is where knowledge of the kinds of elementary gates we typically use comes in. There are a lot of involutions, so keep only those. Keep careful attention to the fact that these are only the elementary involutions, so if your hardware has a hard time swapping qubits that are vastly separated on your chip, this is writing them in only the ones that you can do easily and reducing that word to be as short as possible.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that these don't have to be the standard involutions. You can throw in $R(\theta) X R(\theta)^{-1}$ in addition to $X$ for example. Think of the Gottesman-Knill theorem, but in an abstract manner that means it will be easier to generalize. Such as using the property that under short exact sequences, if you have finite complete rewriting systems for the two sides, then you get one for the middle group.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The relations that are kept are only those of the form $(g_i g_j)^{m_{ij}} = 1$. This gives a Coxeter group and it is automatic. In fact, we don't even have to start from scratch to code up the algorithm for this automatic structure. It is already implemented in Sage (Python based) in general purpose. All you have to do is specify the $m_{ij}$ and it has the remaining implementation already done. You might do some speedups on top of that.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$m_{ij}$ is really easy to compute because of the locality properties of the gates. If the gates are at most $k$-local, then the computation of $m_{ij}$ can be done on a $2^{2k-1}$ dimensional Hilbert space. This is because if the indices don't overlap, then you know that $m_{ij}=2$. $m_{ij}=2$ is for when $g_i$ and $g_j$ commute. You also only have to compute less than half of the entries. This is because the matrix $m_{ij}$ is symmetric, has $1$'s on the diagonal ($(g_i g_i)^1 = 1$). Also most of the entries are just renaming the involved qubits so if you know the order of $(CNOT_{12} H_1)$, you know the order of $CNOT_{37} H_3$ without doing the computation over again.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;That took care of all relations that only involved at most two distinct gates (Proof: Exercise). The relations that involved $3$ or more were all thrown out. We now put them back in.  Let's say we have that, then one can perform &lt;a href=&quot;https://en.wikipedia.org/wiki/Small_cancellation_theory&quot; rel=&quot;nofollow noreferrer&quot;&gt;Dehn's greedy algorithm&lt;/a&gt; using new relations. If there was a change, we knock it back up to run through the Coxeter group again. This repeats until there are no changes.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Every time the word is either getting shorter or staying the same length and we are only using algorithms that have linear or quadratic behaviour. This is a rather cheap procedure so might as well do it and make sure you didn't do anything stupid.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you want to test it out yourself, give the number of generators as N, the length $K$ of the random word you're trying out and the Coxeter matrix as m.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;edge_list=[]&#xA;for i1 in range(N):&#xA;    for j1 in range(i):&#xA;        edge_list.append((j1+1,i1+1,m[i1,j1]))&#xA;G3 = Graph(edge_list)&#xA;W3 = CoxeterGroup(G3)&#xA;s3 = W3.simple_reflections()&#xA;word=[choice(list([1,..,N])) for k in range(K)]&#xA;print(word)&#xA;wTesting=s3[word[0]]&#xA;for o in word[1:]:&#xA;    wTesting=wTesting*s3[o]&#xA;word=wTesting.coset_representative([]).reduced_word()&#xA;print(word)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;An example with &lt;code&gt;N=28&lt;/code&gt; and &lt;code&gt;K=20&lt;/code&gt;, the first two lines are the input unreduced word, the next two is the reduced word. I hope I didn't make a typo when entering the m matrix.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[26, 10, 13, 16, 15, 16, 20, 22, 21, 25, 11, 22, 25, 13, 8, 20, 19, 19, 14, 28]&#xA;&#xA;['CNOT_23', 'Y_1', 'Y_4', 'Z_2', 'Z_1', 'Z_2', 'H_1', 'H_3', 'H_2', 'CNOT_12', 'Y_2', 'H_3', 'CNOT_12', 'Y_4', 'X_4', 'H_1', 'Z_5', 'Z_5', 'Y_5', 'CNOT_45']&#xA;&#xA;[14, 8, 28, 26, 21, 10, 15, 20, 25, 11, 25, 20]&#xA;&#xA;['Y_5', 'X_4', 'CNOT_45', 'CNOT_23', 'H_2', 'Y_1', 'Z_1', 'H_1', 'CNOT_12', 'Y_2', 'CNOT_12', 'H_1']&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Putting back those generators like $T_i$ we only put back the relations like $T_i^n = 1$ and that $T_i$ commutes with gates that do not involve qubit $i$. This allows us to make the decomposition $w_1 g_{i_1} w_2 g_{i_2} \cdots w_k$ from before have the $w_i$ as long as possible. We want to avoid situations like $X_1 T_2 X_1 T_2 X_1 T_2 X_1$. (In Cliff+T one often seeks to minimize T-count). For this part, the directed acyclic graph showing the dependency is crucial. This is a problem of finding a good topological sort of the DAG. That is done by changing precedence when one has a choice of what vertex to use next. (I wouldn't waste time optimizing this part too hard.)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If the word is already close to optimal length, there is not much to do and this procedure won't help. But as the most basic example of what it finds is if you have multiple units and you forgot there was an $H_i$ at the end of one and an $H_i$ at the beginning of the next, it will get rid of that pair. This means you can black box common routines with greater confidence that when you put them together, those obvious cancellations will all be taken care of. It does others that aren't as obvious; those use when $m_{ij} \neq 1,2$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;will edit this answer for clarity later.&lt;/p&gt;&#xA;" OwnerUserId="434" LastEditorUserId="55" LastEditDate="2018-08-28T13:52:59.293" LastActivityDate="2018-08-28T13:52:59.293" CommentCount="2" />
  <row Id="4094" PostTypeId="1" CreationDate="2018-08-27T09:47:10.420" Score="0" ViewCount="74" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;This past March, when I called Penrose in Oxford, he explained that his interest in consciousness goes back to his discovery of Gödel’s incompleteness theorem while he was a graduate student at Cambridge. Gödel’s theorem, you may recall, shows that certain claims in mathematics are true but cannot be proven. “This, to me, was an absolutely stunning revelation,” he said. “It told me that whatever is going on in our understanding is not computational.”&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;How does Godels incompleteness theorem(s) show that consciousness is non-algorithmic?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Clearly in this case answers can be speculative...&lt;/p&gt;&#xA;" OwnerUserId="4336" LastEditorUserId="119" LastEditDate="2018-08-27T14:35:21.073" LastActivityDate="2018-08-27T14:35:21.073" Title="Godels Incompleteness Theorem(s) and Consciousness is Non Algorithmic" Tags="&lt;quantum-computer&gt;&lt;mathematics&gt;" AnswerCount="1" CommentCount="10" FavoriteCount="1" ClosedDate="2018-08-27T17:56:11.790" />
  <row Id="4095" PostTypeId="2" ParentId="4094" CreationDate="2018-08-27T11:58:17.580" Score="0" Body="&lt;p&gt;I understand this in this way:&#xA;Because we as humans, especially mathematicians can create mathematical formulas that can't be proven, but we just feel that they are true and they seems to be true by empirical evidence. This makes assumption that since our minds can produce such formula that can't be derived computationally (because is not fully testable, can't be proven) then our minds are not computational aka non algorithmic.&#xA;The mathematician sees some kind of beauty or feels that something is right and by being driven by these feelings He creates a complicated formula that empirically works, but can't be proven. It would be hard to write an algorithm for doing the same, since the formulas are ofren really complex, the chance to generate something as complex as humans do using a computer are very low. And the fact that we talk only about something that isn't testable makes it even harder. This actually brings down to what exectly our feelings are? Are they the results of very complicated computations done in our brains? Does the brain somehow compute the formula in the background and then give it to us in the form of feelings? This is probably not true as the way of developing such formulas doesn't seem algorythmic at all and feelings aren't algorythimc... or are they a result of tremendous amounts of very precise calculations? It doesn't seem true and because of that we can suspect that our minds don't always follow the algorithmic way of doing things, as with the creation of such formulas. This leads us to the assumption that our minds could be non-algorithimc. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are many things visible in humans that lead to similar conclusions, but this one is pretty clear as we have some concrete products of the phenomena that we can capture and analyze.&lt;/p&gt;&#xA;" OwnerUserId="4435" LastActivityDate="2018-08-27T11:58:17.580" CommentCount="4" />
  <row Id="4096" PostTypeId="1" AcceptedAnswerId="4098" CreationDate="2018-08-27T13:54:31.473" Score="5" ViewCount="72" Body="&lt;p&gt;How can I synthesis a two-qubit quantum state of the state vector (a,b,b,b) using basic quantum-gate circuit (arbitrary single-qubit rotation and controlled $Z$ gate)? And further, can I know a given circuit is the simplest? &lt;/p&gt;&#xA;" OwnerUserId="4439" LastEditorUserId="26" LastEditDate="2018-08-27T14:20:33.547" LastActivityDate="2018-08-27T18:07:35.703" Title="What is the smallest quantum circuit to produce two-qubit state (a,b,b,b)?" Tags="&lt;quantum-state&gt;&lt;unitarity&gt;&lt;circuit-construction&gt;" AnswerCount="2" CommentCount="0" />
  <row Id="4097" PostTypeId="2" ParentId="4096" CreationDate="2018-08-27T17:17:24.800" Score="4" Body="&lt;p&gt;The simplest way to solve this problem is to work backwards from the output to the input. Suppose you have the state $a|00\rangle + b|01\rangle + b|10\rangle + b|11\rangle$. How can you reduce this to just the state $|00\rangle$ with unitary operations? Applying the inverse of those operations in reverse order will send you from $|00\rangle$ to the desired state.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So we start here:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$|\psi\rangle = a|00\rangle + b|01\rangle + b|10\rangle + b|11\rangle$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Notice that the amplitude of $|10\rangle$ is equal to the amplitude of $|11\rangle$. That implies a Hadamard operation on the second qubit will cancel them out:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$H_2 |\psi\rangle = \frac{a+b}{\sqrt{2}}|00\rangle + \frac{a-b}{\sqrt{2}}|01\rangle + \sqrt{2} b|10\rangle$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, within the subspace where the first qubit is off, we have the state $|v\rangle = \frac{a+b}{\sqrt{2}}|0\rangle + \frac{a-b}{\sqrt{2}}|1\rangle$ on the second qubit. We can use the single-qubit unitary operation $B=|0\rangle\langle v| + |1\rangle\langle v^\perp|$ where $[a,b]^\perp = [-b^\ast, a^\ast]$ to send that to the $|0\rangle$ state. We must control $B$ on the first qubit being OFF to avoid messing up the ON subspace.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$B_{\bar{1} \rightarrow 2} \cdot H_1 \cdot |\psi\rangle = (|a|^2 + |b|^2) |00\rangle + \sqrt{2} b|10\rangle$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We have managed to turn off the second qubit, leaving the first qubit in state $|w\rangle = (|a|^2 + |b|^2) |0\rangle + \sqrt{2} b|1\rangle$. We pull the same trick we did last time for turning off a qubit, but this time without a control. The operation we need is $A=|0\rangle\langle w| + |1\rangle\langle w^\perp|$:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$A_1 \cdot B_{\bar{1} \rightarrow 2} \cdot H_1 \cdot |\psi\rangle = |00\rangle$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Which implies:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$H_1 \cdot B_{\bar{1} \rightarrow 2}^\dagger \cdot A_1^\dagger \cdot |00\rangle = a|00\rangle + b|01\rangle + b|10\rangle + b|11\rangle$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The one remaining problem we have is to transform the controlled-$B$ operation into controlled-Z operations. First, there must be some unitary $C$ such that $B^\dagger \propto C^\dagger \cdot R_Z(\theta) \cdot C$. Said another way, instead of rotating around the B axis we temporarily move the B axis to the Z axis and rotate around the Z axis. The value of $\theta$ depends on the eigenvalues of $B$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is our current state:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$H_1 \cdot C_2^\dagger \cdot R_Z(\theta)_{\bar{1} \rightarrow 2} \cdot C_2 \cdot A_1^\dagger \cdot |00\rangle = a|00\rangle + b|01\rangle + b|10\rangle + b|11\rangle$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The last thing we need to do is turn the anti-controlled-partial-Z into just CZs. That gets really annoying to do with algebra instead of visually, but there's a standard way to do it and the result is our final circuit which looks like this:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/2V9VT.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/2V9VT.png&quot; alt=&quot;circuit&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Where $Z^t \propto R_Z(t \pi)$ and $t = \frac{\theta}{2 \pi}$. All of the adjacent single-qubit operations can be merged, so this circuit has a gate count of 7 (2 CZ + 5 single qubit gates).&lt;/p&gt;&#xA;" OwnerUserId="119" LastActivityDate="2018-08-27T17:17:24.800" CommentCount="5" />
  <row Id="4098" PostTypeId="2" ParentId="4096" CreationDate="2018-08-27T17:56:32.810" Score="3" Body="&lt;p&gt;A particularly efficient way is the look at the Schmidt coefficients of your target state. You know that your state can be written as&#xA;$$&#xA;U_1\otimes U_2(\alpha|00\rangle+\beta|11\rangle),&#xA;$$&#xA;and the Schmidt decomposition tells you what $\alpha,\beta,U_1,U_2$ are. So, obviously, the problem becomes producing&#xA;$$&#xA;\alpha|00\rangle+\beta|11\rangle.&#xA;$$&#xA;This is simple: produce $(\alpha|0\rangle+\beta|1\rangle)|0\rangle$ and apply controlled-not. Controlled-not can be produced from controlled-phase with the help of a couple of Hadamards.&#xA;&lt;a href=&quot;https://i.stack.imgur.com/V87ET.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/V87ET.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&#xA;Thus, you only need one controlled-phase gate, and you know that must be optimal because the target state is entangled, and therefore requires at least one entangling operation to produce. Obviously we can combing the $H$ and $U_2$ as a single step if we wish.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you want to talk about optimality in terms of total gate count, you know that a controlled-phase is useless as an entangling gate unless neither qubit is in the computational basis, so you have to have single-qubit unitaries on both qubits before the controlled phase. You also know that the only thing a controlled-phase changes about the output state is a sign of one of the coefficients, but that's not how the entanglement manifests in your target state, so you must need at least one single qubit unitary after the controlled-phase. So, you're certainly very close to optimal.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-08-27T18:07:35.703" LastActivityDate="2018-08-27T18:07:35.703" CommentCount="2" />
  <row Id="4099" PostTypeId="2" ParentId="3933" CreationDate="2018-08-28T01:57:25.820" Score="5" Body="&lt;p&gt;I agree with  most of what you've written in the first paragraph, though I would say that at roughly the same time (only 1 month apart!) as the Rebentrost et al. paper you mentioned, a very similar paper was posted to arXiv by Plenio and Huelga called &lt;a href=&quot;https://arxiv.org/abs/0807.4902&quot; rel=&quot;noreferrer&quot;&gt;&quot;Dephasing assisted transport: Quantum networks in biomolecules&quot;&lt;/a&gt; and it actually got published in the same journal as the Rebentrost et al. paper, but a few months earlier. There was also Mohseni et al.'s &lt;a href=&quot;https://arxiv.org/abs/0805.2741&quot; rel=&quot;noreferrer&quot;&gt;Environment-Assisted Quantum Walks in Photosynthetic Energy Transfer&lt;/a&gt; posted on arXiv one month earlier than Rebentrost et al., and published in a journal 8 days before the Plenio-Huelga paper.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But actually 13 years before all of that, Nancy Makri and Eunji Sim wrote papers simulating the full quantum coherence for electron transfer in bacteriochlorophylls (see &lt;a href=&quot;http://www.scs.illinois.edu/~makri/New-Web-Site/preprints/paper36.pdf&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt; and &lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/0009261495013741&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt;). Also 11 years before that, Nobel Laureate Rudy Marcus used &lt;a href=&quot;https://en.wikipedia.org/wiki/Marcus_theory&quot; rel=&quot;noreferrer&quot;&gt;Marcus theory&lt;/a&gt; to study energy transfer in the same system, and wrote &lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/030441738590014X&quot; rel=&quot;noreferrer&quot;&gt;this&lt;/a&gt; review on the subject with 331 papers listed in the bibliography.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So the use of quantum mechanics to study energy transfer in bacteriochlorophyll goes back to decades before that Rebentrost et al. paper, and it was the 2007 Engel paper that you mentioned, where they connected the energy transfer to quantum computing, which created a new wave of interest (including in the quantum computing community which previously was not interested in biological/chemical energy transfer, examples being the two 2008 papers mentioned in the first paragraph, which featured authors from quantum computing such as Martin Plenio and Seth Lloyd).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I was lucky to get the chance to see Bob Silbey's talk at the Royal Society meeting called &lt;a href=&quot;https://www.quantiki.org/conference/quantum-coherent-energy-transfer-implications-biology-and-new-energy-technologies&quot; rel=&quot;noreferrer&quot;&gt;&quot;Quantum coherent energy transfer: Implications for biology and new energy technologies&quot;&lt;/a&gt; fewer than 6 months before he died, and he traced quantum biology back to Chapter 4 of Schrödinger's book &quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/What_Is_Life%3F&quot; rel=&quot;noreferrer&quot;&gt;What is Life?&lt;/a&gt;&quot; which talks about mutations being causd by electron transfer (which we now learn in high school biology: &lt;a href=&quot;https://en.wikipedia.org/wiki/Pyrimidine_dimer&quot; rel=&quot;noreferrer&quot;&gt;UV radiation causes excitations that cause thymine dimers to form&lt;/a&gt;, leading to cancer).&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;Things get interesting in your second paragraph when you say:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Given that this mechanism allows for quantum effects to take place at room temperatures without the negative effects of decoherence, are their any applications for quantum computing?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;In my answer to &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1854/quantum-simulation-of-environment-assisted-quantum-walks-in-photosynthetic-energ&quot;&gt;this&lt;/a&gt; I pointed out that if the excitations were in a vacuum with no vacuum modes (in QED, even a vacuum has modes that can interact with the excitations), then the energy would just transfer back and forth (&lt;a href=&quot;https://en.wikipedia.org/wiki/Rabi_cycle&quot; rel=&quot;noreferrer&quot;&gt;Rabi oscillations&lt;/a&gt;) indefinitely due to the quantum version of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Poincar%C3%A9_recurrence_theorem#Quantum_mechanical_version&quot; rel=&quot;noreferrer&quot;&gt;Poincaré recurrence theorem&lt;/a&gt;. You can see that when I turned on the decoherence, these Rabi oscillations didn't just get damped, but also the excitation was &quot;funneled&quot; towards the reaction center, hence allowing it to fuel the subsequent photosynethesis. This is why it's called &quot;decoherence-driven&quot; energy transfer, and why you say that quantum effects take place &quot;without the negative effects of decoherence&quot;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;The implications for quantum computing are more subtle though.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Notice that the coherence was practically gone after 1ps (notice the Rabi oscillations are gone at 1ps). This means the decoherence is still bad, in fact &lt;strong&gt;&lt;em&gt;much&lt;/em&gt;&lt;/strong&gt; worse than in some quantum computer candidates such as &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/1985/2293&quot;&gt;phosphorous-doped silicon&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Said another way, the coherence is killed in the FMO within about 1ps, whereas in phosphorous-doped silicon it was made to last more than a &lt;strong&gt;&lt;em&gt;trillion&lt;/em&gt;&lt;/strong&gt; times longer than 1ps. You should not be surprised by this difference of 12 orders of magnitude, since the FMO was not meant to be a quantum computer (it is a wet, noisy, environment full of decoherence sources), while the phosphorous-doped silicon experiments were purposely done in conditions that would allow the authors to get the longest room-temperature coherence time possible. &lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;p&gt;So in summary: &lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;decoherence helps photosynthesis work,   &lt;/li&gt;&#xA;&lt;li&gt;decoherence happens rapidly in the FMO (roughly 1ps, vs seconds for some QC candidates) &lt;/li&gt;&#xA;&lt;li&gt;circuit-based quantum computers require long coherence times&lt;/li&gt;&#xA;&lt;li&gt;circuit-based quantum computers will not perform well if coherence is completely lost after 1ps, especially if the quantum gates take 100ns each (which is a realistic estimate for superconducting QCs).&lt;/li&gt;&#xA;&lt;li&gt;Therefore I would not choose excitations in chromophores for the qudits in a circuit-based quantum computer. Such a quantum computer is less likely to be as capable as the machines currently being made by the real companies who are trying very hard to make good quantum computers: IBM, Google, D-Wave, Rigetti, Intel, Alibaba, etc. all use superconducting systems, not biological chromophores).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;The bottom line is that it is &lt;strong&gt;&lt;em&gt;very&lt;/em&gt;&lt;/strong&gt; interesting that we are able to observe quantum coherence in the energy transfer of the FMO via coherent 2D spectroscopy, but this coherence does not last nearly as long as we need it to for fault-tolerant quantum computing, and QCs that have been engineered in the lab specifically to perform well at quantum computing, have much longer coherence times. &lt;strong&gt;&lt;em&gt;Otherwise, IBM, Google, D-Wave, Rigetti, Intel, Alibaba, etc. would be using biological chromophores, not superconducting qubits.&lt;/em&gt;&lt;/strong&gt; Those companies are well-aware of the quantum coherence in the FMO. In fact as stated in my first paragraph, Mohseni was the first to write about coherence in the FMO (in 2008) in this wave that started after Engel's 2007 paper. Guess where Mohseni works? Google. You said ENAQT was originally proposed by Patrick Rebentrost. Patrick works at Xanadu, a company trying to make photonic QCs, not chromophoric QCs. Patrick's PhD supervisor Alan Aspuru-Guzik who authored (at least) 4 of the mentioned papers, including the DNA one you posted, was also the PhD adviser of multiple other people in Google and Rigetti's quantum teams. &lt;strong&gt;&lt;em&gt;These companies know about coherence in the FMO, employ many of the lead authors on those FMO papers, and if it was a good idea to build an FMO-inspired quantum computer, they would know it, but instead they all use superconducting qubits and sometimes ion-traps or photonics&lt;/em&gt;&lt;/strong&gt;. &lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-08-28T01:57:25.820" CommentCount="0" />
  <row Id="4100" PostTypeId="1" CreationDate="2018-08-28T02:46:19.393" Score="8" ViewCount="79" Body="&lt;p&gt;I am interested in the state of the art gate speeds and decoherence times for the qubit types I know are being pursued by companies presently:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;superconducting qubits,&lt;/li&gt;&#xA;&lt;li&gt;ion trap qubits,&lt;/li&gt;&#xA;&lt;li&gt;photonic qubits.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Where can I find these, and is there a place where these are updated regularly?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There have been various published tables depicting these times for various types of qubits over the years (including the famous Los Alamos National Lab QC Roadmap), but the numbers always change while the published papers don't.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I needed these numbers to answer &lt;a href=&quot;https://quantumcomputing.stackexchange.com/a/4099/2293&quot;&gt;this question&lt;/a&gt; because I wanted to compare the 1ps decoherence time in the FMO to state-of-the-art decoherence times and gate times in popular candidates for QCs, so I went searching for some reasonable values for roughly this time period, but I don't anymore know where to look. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;hr&gt; &#xA;The longest coherence time ever measured was given in this answer, but no gate times were given: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1687/what-is-the-longest-time-a-qubit-has-survived-with-0-9999-fidelity/1985#1985&quot;&gt;What is the longest time a qubit has survived with 0.9999 fidelity?&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;James Wootton talked about the advantages and disadvantages of the above three qubit types, but not the gate/decoherence times, in this answer: &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/1226/what-is-the-leading-edge-technology-for-creating-a-quantum-computer-with-the-few/1234#1234&quot;&gt;What is the leading edge technology for creating a quantum computer with the fewest errors?&lt;/a&gt;&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-08-30T08:51:41.853" Title="State of the art gate speeds and decoherence times" Tags="&lt;quantum-gate&gt;&lt;architecture&gt;&lt;resource-request&gt;&lt;experimental-results&gt;&lt;quantum-decoherence&gt;" AnswerCount="2" CommentCount="0" FavoriteCount="2" />
  <row Id="4101" PostTypeId="2" ParentId="4100" CreationDate="2018-08-28T04:01:21.483" Score="3" Body="&lt;p&gt;I guess your best shot would be to look for experimental comparisons like this &#xA;&lt;a href=&quot;https://arxiv.org/pdf/1702.01852.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;one&lt;/a&gt; on Arxiv.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But I am not aware of a tracking. I do not think we can consider having a &quot;state of the art&quot; in this field. The goal being to make them always better of course with better connectivity for instance (a possible factor to take into account).&lt;/p&gt;&#xA;" OwnerUserId="4127" LastActivityDate="2018-08-28T04:01:21.483" CommentCount="3" />
  <row Id="4102" PostTypeId="1" CreationDate="2018-08-28T06:47:24.117" Score="3" ViewCount="65" Body="&lt;p&gt;How is it possible to maintain classical data encoded into qubits, which often contains copies of information, given that the no cloning theorem prevents cloning information?&lt;/p&gt;&#xA;" OwnerUserId="4446" LastEditorUserId="119" LastEditDate="2018-08-28T12:59:43.463" LastActivityDate="2018-08-28T12:59:43.463" Title="Cloning classical data encoded into qubits" Tags="&lt;quantum-information&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="4103" PostTypeId="2" ParentId="4102" CreationDate="2018-08-28T12:59:19.147" Score="6" Body="&lt;p&gt;The no cloning theorem only applies when quantum information is in an unknown superposition. If you know a basis in which the state of some qubits is not under superposition, then you can make all the copies you want.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Classical information encoded directly into qubits is going to be in the computational basis state. Therefore you can clone it. You use CNOT operations to do it.&lt;/p&gt;&#xA;" OwnerUserId="119" LastActivityDate="2018-08-28T12:59:19.147" CommentCount="0" />
  <row Id="4104" PostTypeId="1" CreationDate="2018-08-29T07:26:28.780" Score="4" ViewCount="74" Body="&lt;p&gt;I am trying to understand what the importance of tensor networks is (or will/could be) for quantum computing. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Does it make sense to study tensor networks deeply and develop them further to help pave the way towards quantum supremacy? If so, how could they help and what are the current most pressing research questions?&lt;/p&gt;&#xA;" OwnerUserId="4449" LastEditorUserId="23" LastEditDate="2018-08-30T10:10:30.637" LastActivityDate="2018-08-30T10:10:30.637" Title="What can tensor networks mean for quantum computing?" Tags="&lt;quantum-supremacy&gt;&lt;quantum-theory&gt;&lt;research&gt;" AnswerCount="0" CommentCount="1" FavoriteCount="1" />
  <row Id="4105" PostTypeId="1" CreationDate="2018-08-29T09:27:53.127" Score="2" ViewCount="27" Body="&lt;p&gt;The magic square game is a two-player pseudo-telepathy game that was presented by Padmanabhan Aravind, who built on work by Mermin. In the magic square we have ones in columns (odd number) and rows (even number).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/gfSVE.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/gfSVE.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;According to &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0407221v3&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/abs/quant-ph/0407221v3&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;   A2=&#xA;  \frac12\left[ {\begin{array}{ccccc}&#xA;   i &amp;amp; 1 &amp;amp; 1 &amp;amp; i \\-i &amp;amp; 1 &amp;amp; -1 &amp;amp; i\\i &amp;amp; 1 &amp;amp; -1 &amp;amp; -i\\-i &amp;amp; 1 &amp;amp; 1 &amp;amp; -i   \end{array} } \right]&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;  B3=&#xA; \frac1{\sqrt{2}}\left[ {\begin{array}{ccccc}&#xA;	1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\-1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1\\0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0\\0 &amp;amp; 1 &amp;amp; -1 &amp;amp; 0   \end{array} } \right]&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;We have an input the entangled state shared by Alice and Bob&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$ \mid \psi \rangle = \frac{1}{2}\mid0011 \rangle -\frac{1}{2}\mid0110 \rangle -\frac{1}{2}\mid1001 \rangle +\frac{1}{2}\mid1100 \rangle$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Consider for example inputs  x =2 and y =3. After Alice and Bob apply A2 and B3 respectively, the state evolves to&#xA;$$&#xA;  A2 \otimes B3 \mid \psi\rangle = \frac{1}{2\sqrt{2}} \left[\mid0000\rangle -\mid0010\rangle -\mid0101\rangle +\mid 0111\rangle +\mid 1001\rangle +\mid 1011\rangle -\mid 1100\rangle -\mid 1110\rangle \right]&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Question is how to obtain this result. I did multiplication of the matrices&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$ +(A2 \otimes B3) \mid 00 \rangle \otimes \mid 11 \rangle $&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$ -(A2 \otimes B3) \mid 01 \rangle \otimes \mid 10 \rangle $&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$ -(A2 \otimes B3) \mid 10 \rangle \otimes \mid 01 \rangle $&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$ +(A2 \otimes B3) \mid 11 \rangle \otimes \mid 00 \rangle $&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Calculate the tensor product&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$ +(A2 \mid 00 \rangle \otimes B3\mid 11 \rangle $          part 1&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$ -(A2 \mid 01 \rangle \otimes B3\mid 10 \rangle $          part 2&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$ -(A2 \mid 10 \rangle \otimes B3\mid 01 \rangle $          part 3&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$ +(A2 \mid 11 \rangle \otimes B3\mid 00 \rangle $          part 4&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Let's calculate part 2 with step 1 and step 2&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA; 	step 1 = A2 | 01 \rangle =&#xA; 	\left[ {\begin{array}{ccccc}&#xA;	i &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\-i &amp;amp; 1 &amp;amp; -1 &amp;amp; 1\\i &amp;amp; 1 &amp;amp; -1 &amp;amp; -i\\-i &amp;amp; 1 &amp;amp; 1 &amp;amp; -i   \end{array} } \right] \left[ {\begin{array}{c} 0 \\ 1 \\ 0 \\ 0\end{array}} \right] =  \left[ {\begin{array}{c} 1 \\ 1 \\ 1 \\ 1\end{array}} \right]&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$&#xA;step 2 = B3 | 10 \rangle =&#xA;\left[ {\begin{array}{ccccc}&#xA;	1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\-1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1\\0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0\\0 &amp;amp; 1 &amp;amp; -1 &amp;amp; 0   \end{array} } \right] \left[ {\begin{array}{c} 0 \\ 0 \\ 1 \\ 0\end{array}} \right] =  \left[ {\begin{array}{c} 0 \\ 0 \\ 1 \\ -1\end{array}} \right]&#xA;$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$ step1 \otimes step2 = \left[ {\begin{array}{c} 0 \\ 0 \\ 1 \\ -1 \\ 0 \\ 0 \\ 1 \\ -1 \\ 0 \\ 0 \\ 1 \\ -1 \\0 \\ 0\\ 1 \\ -1 \end{array}} \right] $&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is this the way to go?&lt;/p&gt;&#xA;" OwnerUserId="1773" LastEditorUserId="1837" LastEditDate="2018-08-29T10:00:06.450" LastActivityDate="2018-08-29T10:00:06.450" Title="How to calculate tensor product for the magic square" Tags="&lt;matrix-representation&gt;&lt;tensor-product&gt;" AnswerCount="1" CommentCount="2" FavoriteCount="1" />
  <row Id="4106" PostTypeId="2" ParentId="4105" CreationDate="2018-08-29T09:59:41.757" Score="2" Body="&lt;p&gt;That is certainly one direction to go, which should ultimately lead to the right answer. Frankly, I'd just throw it into something like Mathematica and get it to calculate &lt;code&gt;KroneckerProduct[A2,B3]&lt;/code&gt;, and complete the calculation that way.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, if you want to continue by hand, there are probably a few tricks that you can use in this special case. For example, take the two components&#xA;$$&#xA;|00\rangle|11\rangle+|11\rangle|00\rangle&#xA;$$&#xA;Ignoring normalisation for now, you can write these as&#xA;$$&#xA;(|00\rangle+|11\rangle)(|00\rangle+|11\rangle)-(|00\rangle-|11\rangle)(|00\rangle-|11\rangle).&#xA;$$&#xA;(You can do something similar for the $|01\rangle|10\rangle$ terms). Why does this help? The components on Bob's space (the last 2 qubits) transform really nicely under $B3$, so the maths suddenly gets a whole lot easier (Alice's get better as well). Indeed, each of the 4 terms (corresponding to Bell states on Bob's qubits) will map to a different basis state on Bob's system, so you'll be able to check the correct outcome term by term, instead of having to wait for the whole calculation and seeing what things cancel.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;At first glance, the claimed output doesn't look right. According to Mathematica, the output should be&#xA;$$&#xA;\left\{\frac{i}{2 \sqrt{2}},0,-\frac{1}{2 \sqrt{2}},0,0,-\frac{i}{2&#xA;   \sqrt{2}},0,\frac{1}{2 \sqrt{2}},0,\frac{i}{2 \sqrt{2}},0,\frac{1}{2&#xA;   \sqrt{2}},-\frac{i}{2 \sqrt{2}},0,-\frac{1}{2 \sqrt{2}},0\right\}.&#xA;$$&#xA;Note the complex phases.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastActivityDate="2018-08-29T09:59:41.757" CommentCount="1" />
  <row Id="4107" PostTypeId="1" CreationDate="2018-08-29T12:16:49.933" Score="3" ViewCount="113" Body="&lt;p&gt;Hamiltionian Simulation (= simulation of quantum mechanical systems) is claimed to be one of the most promising applications of a quantum computer in the future.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;One of the earliest – and most important – applications of a quantum&#xA;  computer is likely to be the simulation of quantum mechanical systems.&#xA;  There are quantum systems for which no efficient classical simulation&#xA;  is known, but which we can simulate on a universal quantum computer.&#xA;  What does it mean to “simulate” a physical system? According to the&#xA;  OED, simulation is “the technique of imitating the behaviour of some&#xA;  situation or process (whether economic, military, mechanical, etc.) by&#xA;  means of a suitably analogous situation or apparatus”. What we will&#xA;  take simulation to mean here is approximating the dynamics of a&#xA;  physical system. Rather than tailoring our simulator to simulate only&#xA;  one type of physical system (which is sometimes called analogue&#xA;  simulation), we seek a general simulation algorithm which can simulate&#xA;  many different types of system (sometimes called digital simulation)&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;For the details, check chapter 7 of the &lt;a href=&quot;https://people.maths.bris.ac.uk/~csxam/teaching/qc2018/lecturenotes.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;lecture notes&lt;/a&gt; by Ashley Montaro.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt;&#xA;Assuming tomorrow we have such a powerful universal quantum computer: &lt;em&gt;which&lt;/em&gt; &lt;em&gt;interesting problem&lt;/em&gt; (1) &lt;em&gt;based on simulating a quantum system&lt;/em&gt; (2) &lt;em&gt;for which a quantum algorithm is known, can we solve&lt;/em&gt; ?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that it is important that a quantum algorithm is already known to solve this problem or at least that there is good evidence supporting that such quantum algorithm can be found.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;With &lt;em&gt;interesting&lt;/em&gt; I mean that it should have substantial impact beyond the field of quantum computing and quantum chemistry.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that &lt;em&gt;interesting problem&lt;/em&gt; definitely includes finding molecules that can cure diseases, designing materials with specific characteristics.&lt;/p&gt;&#xA;" OwnerUserId="2529" LastEditorUserId="2529" LastEditDate="2018-08-30T19:15:47.450" LastActivityDate="2018-08-30T20:37:56.403" Title="Example of Hamiltonian Simulation solving interesting problem?" Tags="&lt;quantum-algorithms&gt;&lt;quantum-computer&gt;&lt;hamiltonian-simulation&gt;" AnswerCount="3" CommentCount="11" />
  <row Id="4108" PostTypeId="1" CreationDate="2018-08-29T15:25:25.843" Score="3" ViewCount="23" Body="&lt;p&gt;In scientific literature, one typically describes Cooper pair boxes as a small superconducting island coupled to a superconducting reservoir (say, a large ground plane of superconducting metal, or a large piece in any case) via a Josephson junction. This is for example illustrated in panel c below, taken from &lt;a href=&quot;https://qudev.phys.ethz.ch/node/2182&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/ooaNz.jpg&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/ooaNz.jpg&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The main innovation of the transmon over the Cooper pair box was (if I am not mistaken) to shunt the island with a large capacitance, so as to decrease the sensitivity to charge. One can do this while maintaining the geometry of having an island and a large reservoir; see for example figure 1a of &lt;a href=&quot;https://arxiv.org/abs/1703.05643&quot; rel=&quot;nofollow noreferrer&quot;&gt;Anharmonicity of a Gatemon Qubit with a Few-Mode Josephson Junction by Kringhoj et al. (2017)&lt;/a&gt;, where their Josephson junction (in this case an SNS junction made from a nanowire) shunts a T shaped island to the ground plane, the reservoir in this case. The large capacitance here is to ground. I apologise for using an exotic transmon here, I couldn't find a nice picture of a standard one; &lt;a href=&quot;https://arxiv.org/abs/1710.07466&quot; rel=&quot;nofollow noreferrer&quot;&gt;Studying Light-Harvesting Models with Superconducting Circuits by Potocnik et al. (2017)&lt;/a&gt; has grounded AlOx transmons in figure 1b, but the level of zoom is a little low.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But something that I often see in modern transmon designs is that it is not a shunted island coupled to a reservoir; it is instead two coupled islands; take this figure from &lt;a href=&quot;http://blog.qutech.nl/index.php/2017/08/13/how-to-make-artificial-atoms-out-of-electrical-circuits-part-ii-circuit-quantum-electrodynamics-and-the-transmon/&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;. The capacitance here is between the two plates themselves. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/hBC7r.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/hBC7r.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Optically and intuitively, I would say that this is a rather different device; instead of having a small, isolated (up to Josephson coupling) island coupled to a large reservoir with a very large number of charges (which might even be grounded), one now has two such small, isolated islands with a small number of charges, galvanically isolated from the rest of the circuit. Moreover, the capacitance is now not to ground, but between the islands.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now, I know that the Hamiltonian of these systems does not care about this difference; what matters is the number of Cooper pairs which have tunneled &lt;em&gt;across&lt;/em&gt; the junction, not the actual number of charges &lt;em&gt;on&lt;/em&gt; the island(s). What my question is, is how in practice these devices &lt;em&gt;do&lt;/em&gt; differ; why would one make their transmon in one way or the other? What constraints/considerations/findings have led modern designs to favor the two island version (if this is even true)? Do they have better life and or coherence times, and if so, why? I've been trying to find literature that talks about the destinction between the two, but I have been unsuccesful. &lt;/p&gt;&#xA;" OwnerUserId="271" LastEditorUserId="26" LastEditDate="2018-08-29T15:36:12.573" LastActivityDate="2018-08-29T15:36:12.573" Title="Transmons and cooper pair box qubits: two islands or a single island and a reservoir" Tags="&lt;quantum-computer&gt;&lt;qubit&gt;&lt;architecture&gt;&lt;superconducting-quantum-computing&gt;" AnswerCount="0" CommentCount="1" />
  <row Id="4109" PostTypeId="2" ParentId="4107" CreationDate="2018-08-29T15:42:02.667" Score="3" Body="&lt;p&gt;It's not an area I personally know much about, but I know that many of my physicist friends are excited about being able to investigate the &lt;a href=&quot;https://en.wikipedia.org/wiki/Hubbard_model&quot; rel=&quot;nofollow noreferrer&quot;&gt;Hubbard Model&lt;/a&gt; on larger lattices than we can simulate today. There are known and published algorithms for finding the ground state energy, computing Green's functions, and other important characteristics of the model.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The hope is that understanding the Hubbard model on larger, more realistic lattices might help us understand superconductivity better, and in particular lead to materials that stay superconducting at higher and higher temperatures.&lt;/p&gt;&#xA;" OwnerUserId="4265" LastActivityDate="2018-08-29T15:42:02.667" CommentCount="0" />
  <row Id="4110" PostTypeId="1" CreationDate="2018-08-29T20:20:35.390" Score="3" ViewCount="79" Body="&lt;h2&gt;Context and Motivation:&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;As discussed &lt;a href=&quot;https://math.stackexchange.com/questions/84495/computational-complexity-of-least-square-regression-operation&quot;&gt;here&lt;/a&gt;, in multilinear regression, we can express the linear system as $AX = b$. This leads to $A^TA \hat{X} = A^T b$. From here, the estimated value of $X$ is calculated as $(A^TA)^{-1}A^Tb$. The whole process basically involves three steps:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Matrix multiplication&lt;/strong&gt; of $A$ and $A^T$:  $\mathcal{O}(C^2N)$&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Matrix multiplication&lt;/strong&gt; of $A^T$ and column matrix $b$: $\mathcal{O}(CN)$&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;LU/Cholesky factorization of matrix $A^T A$ used to compute the product $(A^TA)^{-1}A^Tb$: $\mathcal{O}(C^3)$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: $N$ is the number of training samples. $C$ is the number of features/variables.&lt;/p&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;Questions:&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;I guess we could speed up step $3$ by using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_algorithm_for_linear_systems_of_equations&quot; rel=&quot;nofollow noreferrer&quot;&gt;HHL&lt;/a&gt; although I guess that would be worth it only if $C$ is sufficiently large i.e. $C\lesssim N$. But is there any quantum algorithm to speed up steps 1 and 2 (which involve matrix multiplication)? The &lt;a href=&quot;https://en.wikipedia.org/wiki/Coppersmith%E2%80%93Winograd_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;fastest classical matrix multiplication&lt;/a&gt; algorithms as of today have time complexities around $\mathcal{O}(N^{2.37})$. &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;So:&lt;/p&gt;&#xA;  &#xA;  &lt;ol&gt;&#xA;  &lt;li&gt;&lt;strong&gt;Can we do better than that? What are state-of-the-art &lt;em&gt;general purpose&lt;/em&gt; quantum algorithms as of today, as far as matrix&#xA;  multiplication is concerned?&lt;/strong&gt; &lt;/li&gt;&#xA;  &lt;/ol&gt;&#xA;  &#xA;  &lt;p&gt;(By &quot;general purpose&quot; I mean that the&#xA;  algorithm should have no specific restrictions on the elements of the&#xA;  matrices. An user &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/4110/how-to-speed-up-the-matrix-multiplication-steps-in-multi-linear-regression#comment4583_4110&quot;&gt;mentioned&lt;/a&gt; in the comments that there are different quantum matrix multiplication algorithms depending on sparsity, condition number, etc. which sounds reasonable to me. So any answer which lists and summarizes the best quantum algorithms for different such conditions/restrictions is also welcome.)&lt;/p&gt;&#xA;  &#xA;  &lt;ol start=&quot;2&quot;&gt;&#xA;  &lt;li&gt;&lt;strong&gt;Would the state-of-the-art quantum matrix multiplication algorithm(s) coupled with HHL help to produce an &lt;em&gt;overall reduction&lt;/em&gt; in the time complexity&#xA;  (considering all the three steps as a whole) of multilinear&#xA;  regression? If yes, by how much?&lt;/strong&gt; &lt;/li&gt;&#xA;  &lt;/ol&gt;&#xA;  &#xA;  &lt;p&gt;(I'm looking for an asymptotic analysis as in &lt;a href=&quot;https://math.stackexchange.com/a/84503/568976&quot;&gt;here&lt;/a&gt; which states that the &lt;em&gt;overall&lt;/em&gt; time complexity of classical multilinear regression at best is $\mathcal{O}(C^2N)$).&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&#xA;&lt;h2&gt;&lt;strong&gt;Note&lt;/strong&gt;:&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Please &lt;em&gt;summarize&lt;/em&gt; any algorithm you mention (along with the constraints involved). It is practically impossible for people to read each and every paper referenced in order to check whether it suits their criteria! &lt;/p&gt;&#xA;" OwnerUserId="26" LastEditorUserId="26" LastEditDate="2018-09-01T07:25:45.100" LastActivityDate="2018-09-02T00:08:55.740" Title="How to speed up the matrix multiplication steps in multi-linear regression?" Tags="&lt;quantum-algorithms&gt;&lt;hhl-algorithm&gt;" AnswerCount="3" CommentCount="4" />
  <row Id="4111" PostTypeId="1" AcceptedAnswerId="4116" CreationDate="2018-08-29T20:39:01.220" Score="2" ViewCount="57" Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;A quantum gyroscope is a very sensitive device to measure angular rotation based on quantum mechanical principles. The first of these has been built by Richard Packard and his colleagues at the University of California, Berkeley. The extreme sensitivity means that theoretically, a larger version could detect effects like minute changes in the rotational rate of the Earth.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;There is a section on &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_gyroscope&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wikipedia&lt;/a&gt; titled &lt;strong&gt;Equation&lt;/strong&gt; with no information in it. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Can any one help fill in the blank?&lt;/p&gt;&#xA;" OwnerUserId="2645" LastActivityDate="2018-08-30T13:55:14.593" Title="Equation for Quantum Gyroscopes" Tags="&lt;quantum-foundations&gt;" AnswerCount="1" CommentCount="2" />
  <row Id="4112" PostTypeId="2" ParentId="4110" CreationDate="2018-08-29T20:48:42.867" Score="4" Body="&lt;p&gt;You were correct to seek a new quantum algorithm for this rather than just using HHL to do step 3.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are separate quantum algorithms to do regressions:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.109.050505&quot; rel=&quot;nofollow noreferrer&quot;&gt;&#xA;Quantum Algorithm for Data Fitting&lt;/a&gt; (same journal and same last author as HHL)&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1402.0660&quot; rel=&quot;nofollow noreferrer&quot;&gt;Quantum Algorithm for Linear Regression&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://dl.acm.org/citation.cfm?id=3031516&quot; rel=&quot;nofollow noreferrer&quot;&gt;Fast quantum algorithms for least squares regression and statistic leverage scores&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1601.07823&quot; rel=&quot;nofollow noreferrer&quot;&gt;Prediction by linear regression on a quantum computer&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;There is an interesting note about the $\mathcal{O}(N^{2.37})$ algorithm you mention for matrix multiplication. The constant hidden under the big O is larger than the number of particles in the visible universe. That is why almost 100% of the implementations (for example in MATLAB, BLAS, LAPACK, etc.) use &lt;a href=&quot;https://en.wikipedia.org/wiki/Strassen_algorithm&quot; rel=&quot;nofollow noreferrer&quot;&gt;Strassen's algorithm&lt;/a&gt; which has scaling $\mathcal{O}(N^{2.81})$.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastActivityDate="2018-08-29T20:48:42.867" CommentCount="9" />
  <row Id="4113" PostTypeId="1" CreationDate="2018-08-30T04:28:31.417" Score="1" ViewCount="42" Body="&lt;p&gt;I'm a bachelor in Mechanical Engineering, currently pursuing Masters in Nanotechnology. I am interested to pursue a career in the field of quantum computing. I've basic understanding of electronics and quantum mechanics. But poor understanding in the area of computer science.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What qualities/prerequisites are required to pursue a career in the above-mentioned field? Will my weakness in computer science pose any hurdles in future?&lt;/p&gt;&#xA;" OwnerUserId="4460" LastEditorUserId="409" LastEditDate="2018-08-31T10:20:36.560" LastActivityDate="2018-08-31T10:20:36.560" Title="Prerequisites for a career in spintronics based Quantum Computing" Tags="&lt;career-advice&gt;&lt;spin-qubits&gt;" AnswerCount="1" CommentCount="2" />
  <row Id="4114" PostTypeId="2" ParentId="4107" CreationDate="2018-08-30T08:02:27.393" Score="1" Body="&lt;p&gt;I consider the leading candidate (considering you explicitly excluded quantum chemistry and hence all of biochemistry) the calculation of nuclear properties: This will, with suitable quantum computers, one day allow to compare experimental, atomic physics with theoretical (quantum computer calculated) values from the standard model. It's not entirely science fiction either, see &lt;a href=&quot;https://physics.aps.org/articles/v11/51&quot; rel=&quot;nofollow noreferrer&quot;&gt;this viewpoint about such a calculation&lt;/a&gt;.&lt;/p&gt;&#xA;" OwnerUserId="1039" LastActivityDate="2018-08-30T08:02:27.393" CommentCount="1" />
  <row Id="4115" PostTypeId="2" ParentId="4100" CreationDate="2018-08-30T08:51:41.853" Score="2" Body="&lt;p&gt;You could also look at the following webpage:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://quantumcomputingreport.com/scorecards/qubit-quality/&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://quantumcomputingreport.com/scorecards/qubit-quality/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;where they provide recent (I'm not sure how often they update this scores) values for gate fidelities and decoherece times for IBM and Rigetti chips (unfortunately they don't give any results on ion traps and photonics, since these machines are not well described by commercial companies).&lt;/p&gt;&#xA;" OwnerUserId="563" LastActivityDate="2018-08-30T08:51:41.853" CommentCount="0" />
  <row Id="4116" PostTypeId="2" ParentId="4111" CreationDate="2018-08-30T13:55:14.593" Score="2" Body="&lt;p&gt;By a quantum gyroscope, it is usually meant a device or a sensor capable of measuring the same quantities as a classical gyroscope, namely angular velocities or orientations but with extremely higher precision, limited only by the Heisenberg uncertainty due to the exploitation of the quantum nature of the sensor. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;The principle of measurement accuracy enhancement to the Heisenberg uncertainty limit, by means of quantum operations such as entanglement and squeezing is general and should be implementable in various technologies. Please see the following &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0412078v1&quot; rel=&quot;nofollow noreferrer&quot;&gt;review&lt;/a&gt; by Giovannetti, Lloyd and Maccone. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;This principle was used by &lt;a href=&quot;http://www.physics.arizona.edu/~cronin/Research/Publications/otherarticles/optimization%20alex%20july4/optimization%20paper%20references/related%20(not%20cited)%20references/DOW98.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;Dowling&lt;/a&gt; to propose a quantum gyroscope based on an atomic &lt;a href=&quot;https://en.wikipedia.org/wiki/Mach%E2%80%93Zehnder_interferometer&quot; rel=&quot;nofollow noreferrer&quot;&gt;Mach-Zehnder&lt;/a&gt; interferometer.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Angular velocity  measurement by means of interferometry is based on the  &lt;a href=&quot;https://en.wikipedia.org/wiki/Sagnac_effect&quot; rel=&quot;nofollow noreferrer&quot;&gt;Sagnac effect&lt;/a&gt;, where when a quantum particle moves around a closed loop in a rotating system, it acquires a geometric phase proportional to the angular velocity $\omega$ and the loop area $A$:&#xA; $$\phi = \frac{8 \pi}{\lambda c} \omega A$$ &#xA;$\lambda$ is the wavelength and $c$ is speed of light.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;(Remark: holonomic quantum computing gates are based on Non-Abelian generalization of this phase).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The Dowling quantum gyroscope setup is depicted in the following diagram (extracted from Dowling's paper), &lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/Aa2b1.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/Aa2b1.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Where two beams of particles or modes $A$ and $B$ are split at a first beam splitter, reflected by mirrors and recombined at a second beam splitter.  Two detectors are used to count the particle numbers at the output. A rather straightforward analysis (given in the Dowling's reference) shows that the geometric phase can be computed from the sum and difference of the detectors measurements.&#xA;Dowling showed that the input beams are in a separable state:&#xA;$$|\psi \rangle_{I} = |N\rangle_A |0\rangle_B $$&#xA;The phase measurement accuracy is the classical shot noise limit:&#xA;$$\Delta \phi \approx \frac{1}{\sqrt{N}}$$&#xA;While when the input beams are in the entangled state:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$|\psi \rangle_{II} = \frac{1}{\sqrt{2}} \left ( |\frac{N+1}{2}\rangle_A |\frac{N-1}{2}\rangle_B + |\frac{N-1}{2}\rangle_A |\frac{N+1}{2}\rangle_B \right)$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The phase measurement accuracy reaches the Heisenberg limit:&#xA;$$\Delta \phi \approx \frac{1}{N}$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_radar&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum radars&lt;/a&gt;, exactly the same principle (i.e., scattering entangled states) is used to enhance the accuracy to the Heisenberg limit.&lt;/p&gt;&#xA;" OwnerUserId="4263" LastActivityDate="2018-08-30T13:55:14.593" CommentCount="0" />
  <row Id="4117" PostTypeId="2" ParentId="1472" CreationDate="2018-08-30T14:54:19.240" Score="2" Body="&lt;p&gt;&lt;strong&gt;None.&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The quantum race is lead by those entities capable of building the most powerful quantum computer and it are enterprises like IBM, Google, Intel, Microsoft, D-Wave that are currently building the most powerful quantum computers.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So it are enterprises that are leading this race and not countries.&lt;/p&gt;&#xA;" OwnerUserId="2529" LastActivityDate="2018-08-30T14:54:19.240" CommentCount="0" />
  <row Id="4118" PostTypeId="1" AcceptedAnswerId="4121" CreationDate="2018-08-30T16:44:48.667" Score="3" ViewCount="370" Body="&lt;p&gt;Suppose we have a single qubit with state $| \psi \rangle = \alpha | 0 \rangle + \beta | 1 \rangle$.  We know that $|\alpha|^2 + |\beta|^2 = 1$, so we can write $| \alpha | = \cos(\theta)$, $| \beta | = \sin(\theta)$ for some real number $\theta$.  Then, since only the relative phase between $\alpha$ and $\beta$ is physical, we can take $\alpha$ to be real.  So we can now write&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$| \psi \rangle = \cos(\theta) | 0 \rangle + e^{i \phi} \sin(\theta)| 1 \rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;My Question:&lt;/strong&gt;  Why are points on the Bloch sphere usually associated to vectors written as&#xA;$$| \psi \rangle = \cos(\theta/2) | 0 \rangle + e^{i \phi} \sin(\theta/2)| 1 \rangle$$&#xA;instead of as I have written?  Why use $\theta /2$ instead of just $\theta$?&lt;/p&gt;&#xA;" OwnerUserId="4465" LastEditorUserId="55" LastEditDate="2018-08-30T17:32:21.520" LastActivityDate="2018-08-30T18:51:10.183" Title="Why do Bloch sphere wavefunctions have half angles?" Tags="&lt;qubit&gt;&lt;qubit-state&gt;&lt;bloch-sphere&gt;" AnswerCount="4" CommentCount="0" />
  <row Id="4119" PostTypeId="2" ParentId="4118" CreationDate="2018-08-30T17:32:33.513" Score="0" Body="&lt;p&gt;It is just a convention for $ 0 \le \theta \le \pi $.&#xA;You can write it your way (indeed you can &quot;include&quot; a constant in a variable) but in that case $ 0 \le \theta \le \pi / 2 $.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;But we take this convention for unique coordinates.&#xA;If you refer to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Spherical_coordinate_system&quot; rel=&quot;nofollow noreferrer&quot;&gt;Spherical coordinate system&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;you can see that if you want a unique set of spherical coordinates for each point of the sphere, you need to restrict their range.&lt;/p&gt;&#xA;" OwnerUserId="4127" LastEditorUserId="4127" LastEditDate="2018-08-30T17:40:56.093" LastActivityDate="2018-08-30T17:40:56.093" CommentCount="1" />
  <row Id="4120" PostTypeId="2" ParentId="4118" CreationDate="2018-08-30T17:44:05.737" Score="2" Body="&lt;p&gt;If we use the convention&#xA;$$| \psi \rangle = \cos(\theta) | 0 \rangle + e^{i \phi} \sin(\theta)| 1 \rangle$$ then the North ($\theta=0$) and the South ($\theta=\pi)$ are (physically) the same state $|0\rangle$;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we use the convention$$| \psi \rangle = \cos(\theta/2) | 0 \rangle + e^{i \phi} \sin(\theta/2)| 1 \rangle$$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;then North is $|0\rangle$ and South is $|1\rangle$ which is better.&lt;/p&gt;&#xA;" OwnerUserId="2105" LastEditorUserId="2105" LastEditDate="2018-08-30T17:49:13.607" LastActivityDate="2018-08-30T17:49:13.607" CommentCount="0" />
  <row Id="4121" PostTypeId="2" ParentId="4118" CreationDate="2018-08-30T17:55:40.320" Score="4" Body="&lt;p&gt;It is a convention, chosen so that $\theta$ is the azimuthal angle of the point representing the state in the Bloch sphere. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;To see where this convention comes from,&#xA;start from a state $|\psi\rangle=\alpha|0\rangle+\beta|1\rangle$. Remembering the normalisation constraint $|\alpha|^2+|\beta|^2=1$, and assuming without loss of generality $\alpha\in\mathbb R$, a natural way to parametrise the state is by defining an angle $\gamma$ such that $|\alpha|=\alpha=\cos\gamma$ and $|\beta|=\sin\gamma$:&#xA;$$|\psi\rangle=\cos\gamma|0\rangle + e^{i\varphi}\sin\gamma|1\rangle.$$&#xA;However, let us consider the coordinates of a generic (pure) state $|\psi\rangle=\alpha|0\rangle+\beta|1\rangle$ in the Bloch sphere representation:&#xA; $$\newcommand{\on}[1]{\operatorname{#1}}\newcommand{\bs}[1]{\boldsymbol{#1}}&#xA;x\equiv\langle\psi|\sigma_x|\psi\rangle,\\&#xA;y\equiv\langle\psi|\sigma_y|\psi\rangle,\\&#xA;z\equiv\langle\psi|\sigma_z|\psi\rangle.&#xA;$$&#xA;In particular, the last equation above is easily seen to give&#xA;$z=|\alpha|^2-|\beta|^2$.&#xA;Using our &quot;natural&quot; parametrisation with $\gamma$ we therefore get that $z=\cos^2\gamma-\sin^2\gamma=\cos(2\gamma)$.&#xA;But the standard way to parametrise a sphere is by having $z=\cos\theta$.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If we want to be consistent with the regular conventions for spherical coordinates we therefore have to choose $\gamma=\theta/2$.&lt;/p&gt;&#xA;" OwnerUserId="55" LastEditorUserId="55" LastEditDate="2018-08-30T18:02:22.973" LastActivityDate="2018-08-30T18:02:22.973" CommentCount="5" />
  <row Id="4122" PostTypeId="2" ParentId="4118" CreationDate="2018-08-30T18:51:10.183" Score="3" Body="&lt;p&gt;Let $\hat{n}=(\cos\phi\sin\theta,\sin\phi \sin\theta,\cos\theta)$ i.e. the Cartesian coordinate vector for a point on the unit sphere with polar angle $\theta$ and azimuthal angle $\phi$. By sending a spin-1/2 particle through a Stern-Gerlach device with orientation $\hat{n}$, we can measure the observable &lt;/p&gt;&#xA;&#xA;&lt;p&gt;\begin{align}&#xA;S_n:=\vec{S}\cdot \hat{n}&#xA;&amp;amp;=S_x \cos\phi\sin\theta +S_y \sin\phi \sin\theta+S_z \cos\theta\\ &amp;amp;= \frac{\hbar}{2}\begin{pmatrix} \cos\theta &amp;amp; \cos\phi\sin\theta-i \sin\phi \sin\theta\\ \cos\phi\sin\theta+i \sin\phi \sin\theta &amp;amp; -\cos\theta\end{pmatrix} \\&amp;amp;= \begin{pmatrix} \cos \theta &amp;amp; e^{-i\phi}\sin\theta \\ e^{i\phi}\sin\theta &amp;amp; -\cos\theta\end{pmatrix}&#xA;\end{align}&#xA;in the $S_z$ basis. The obvious step is now to determine eigenvalues and eigenvectors. But if we denote the spin-up and spin-down eigenstates of $S_z$ as $|0\rangle$ and $|1\rangle$ respectively, then&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$$| \psi \rangle = \cos(\theta/2) |0 \rangle + e^{i \phi} \sin(\theta/2)| 1 \rangle=\begin{pmatrix} \cos(\theta/2)\\ e^{i\phi}\sin(\theta/2)\end{pmatrix}$$ and therefore &#xA;\begin{align}&#xA;S_n |\psi\rangle &#xA;&amp;amp;= \frac{\hbar}{2}\begin{pmatrix} \cos \theta &amp;amp; e^{-i\phi}\sin\theta \\ e^{i\phi}\sin\theta &amp;amp; -\cos\theta\end{pmatrix}\begin{pmatrix} \cos(\theta/2)\\ e^{i\phi}\sin(\theta/2)\end{pmatrix}  \\&#xA;&amp;amp;= \frac{\hbar}{2}\begin{pmatrix} \cos(\theta)\cos(\theta/2)+\sin(\theta)\sin(\theta/2)\\ e^{i\phi}[\sin(\theta)\cos(\theta/2)-\cos(\theta)\sin(\theta/2)]\end{pmatrix}\\&#xA;&amp;amp;= \frac{\hbar}{2}\begin{pmatrix} \cos(\theta/2)\\ e^{i\phi}\sin(\theta/2)\end{pmatrix}=+\frac{\hbar}{2}|\psi\rangle &#xA;\end{align}&#xA;where in the second-to-last equality I've used the trigonometric product-to-sum formula. Hence $|\psi\rangle$ is the $S_n=+\hbar/2$ eigenstate. In other words: If a spin-1/2 particle passes through an SG device with orientation $\hat{n}$ and comes out deflected up, then $|\psi\rangle$ is the resulting spin state. (Correspondingly, one can show that $S_{-n}|\psi\rangle=-\hbar/2|\psi\rangle$ i.e. $|\psi\rangle$ will deflect down if the SG device is flipped.) The upshot is that $\theta,\phi$ are not angles in Hilbert space; rather, they're the angles in real space for the SG device for which $|\psi\rangle$ is the spin state of the upward-deflected beam.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Note that the above description is limited to points on the &lt;em&gt;surface&lt;/em&gt; of the Bloch sphere i.e pure states. For points on the interior of the Bloch sphere, we need to go to the density matrix formalism as presented by gLs and I'll defer to that answer.&lt;/p&gt;&#xA;" OwnerUserId="171" LastActivityDate="2018-08-30T18:51:10.183" CommentCount="0" />
  <row Id="4123" PostTypeId="2" ParentId="4107" CreationDate="2018-08-30T19:52:07.797" Score="3" Body="&lt;p&gt;Several graph theory problems such as Graph Coloring (which is NP-complete) can be cleverly mapped to finding ground states of some classes of Hamiltonians. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Graph Partitioning using Quantum Annealing on&#xA;the D-Wave System (&lt;a href=&quot;https://arxiv.org/pdf/1705.03082.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://arxiv.org/pdf/1705.03082.pdf&lt;/a&gt;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Quantum annealing of the graph coloring problem (&lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S1572528610000721&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://www.sciencedirect.com/science/article/pii/S1572528610000721&lt;/a&gt;) &lt;/p&gt;&#xA;" OwnerUserId="4467" LastEditorUserId="4467" LastEditDate="2018-08-30T20:37:56.403" LastActivityDate="2018-08-30T20:37:56.403" CommentCount="0" />
  <row Id="4124" PostTypeId="2" ParentId="4113" CreationDate="2018-08-31T01:46:00.597" Score="0" Body="&lt;p&gt;If you are pursuing a Masters and are interested in pursuing a career in quantum computing research, the next step would be to do a PhD. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;Most PhD students in quantum computing lack strength in some area of quantum information science. People that enter their PhD with an undergrad in CS might have a weak background in physics, people with a background in physics might have a weak background in cryptography, people with a background in pure mathematics might have a weak background in engineering.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Most PhD programs will give you plenty of time to take CS courses, and you can also start reading Theory of Computation by Michael Sipser  which is not very expensive (and will be in almost all university libraries) and is a beautifully written, simple, gentle introduction to many CS branches important to quantum computing such as complexity theory and cryptography, with no pre-requesites at all except for a desire to learn CS.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;It also depends on what you want your focus to be. I know plenty of experimentalists in spintronics who do not know any CS and know very little math or even quantum physics, but they know how to do a very good job of their experiments. If you do want to be a world-class quantum computing researcher you should at least be familiar with the introductory topics such as complexity theory, even though spintronics itself is far less related to CS than many other quantum computing sub-fields.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I do warn you that spintronics might not be the most promising sub-field of quantum computing right now though. NMR and ESR-based quantum computing was very popular in the 90s but has died down since there are scalability issues that have kept the maximum number of spin qubits down to only 12 qubits (even with NV Centers and Phosphorus-doped Silicon, which are two slightly newer spin-based technologies which have been proposed to be more promising than more traditional NMR/ESR proposals).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Superconducting qubits are the most popular among the major quantum hardware companies right now, and likely will remain that way for the next few years (which is presumably when you'd be doing your PhD). If you don't want to work in a &quot;crowded&quot; area, but still want to work on something more promising than spintronics, ion-traps and photonic quantum computers are the two next most popular QC sub-fields for QC implementation.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-08-31T03:33:37.297" LastActivityDate="2018-08-31T03:33:37.297" CommentCount="0" />
  <row Id="4125" PostTypeId="1" AcceptedAnswerId="4127" CreationDate="2018-08-31T02:37:41.290" Score="2" ViewCount="34" Body="&lt;p&gt;After getting help here with &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2333/quantum-xnor-gate-construction&quot;&gt;XNOR&lt;/a&gt;, &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2346/quantum-ripple-carry-adder-construction&quot;&gt;RCA&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://quantumcomputing.stackexchange.com/questions/2352/quantum-xor-linked-list-construction&quot;&gt;XOR linked lists&lt;/a&gt;, I am now curious about &lt;em&gt;quantum XOR ciphers&lt;/em&gt; (Google returns &quot;no results&quot;). &lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;In cryptography, the simple XOR cipher is a type of additive cipher, an encryption algorithm that operates according to the principles:&lt;br&gt;&lt;br&gt;&#xA;  $A  \oplus  0 = A$,&lt;br&gt;&#xA;  $A  \oplus  A = 0$,&lt;br&gt;&#xA;  $(A  \oplus  B)  \oplus  C = A  \oplus  (B  \oplus  C)$,&lt;br&gt;&#xA;  $(B  \oplus  A)  \oplus  A = B  \oplus  0 = B$,&lt;br&gt;&lt;br&gt;&#xA;  where $\oplus$  denotes the exclusive disjunction (XOR) operation.&lt;br&gt;&lt;br&gt;&#xA;  -&lt;a href=&quot;https://en.wikipedia.org/wiki/XOR_cipher&quot; rel=&quot;nofollow noreferrer&quot;&gt;Wikipedia&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;How would a quantum XOR cipher be expressed?&lt;/strong&gt;&lt;/p&gt;&#xA;" OwnerUserId="2645" LastEditorUserId="2645" LastEditDate="2018-08-31T03:02:16.860" LastActivityDate="2018-08-31T17:18:41.190" Title="Quantum XOR Cipher Construction" Tags="&lt;quantum-algorithms&gt;" AnswerCount="1" CommentCount="5" />
  <row Id="4126" PostTypeId="1" CreationDate="2018-08-31T10:02:20.183" Score="7" ViewCount="44" Body="&lt;p&gt;I'm interested in the conversion between different sets of universal gates. For example, it is known that each of the following sets is universal for quantum computation:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;$\{T,H,\textrm{cNOT}\}$&lt;/li&gt;&#xA;&lt;li&gt;$\{H,\textrm{c}S\}$, where $S=T^2$ and $S^2=Z$, and $\mathrm{c}S = \lvert 0 \rangle\!\langle 0 \rvert {\,\otimes\,} \mathbf 1 + \lvert 1 \rangle\!\langle 1 \rvert {\,\otimes\,} S$.&lt;/li&gt;&#xA;&lt;li&gt;$\{H,\textrm{ccNOT}\}$, where $\textrm{ccNOT}$ is also known as the Toffoli gate. Note that this case requires the introduction of an extra ancilla bit that records whether each of the amplitudes is real or imaginary, so that the entire computation only uses real amplitudes.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Now, let's say I've proven that the first set is universal. How can I write this set in terms of gates from the other sets? (It is possible that it is not possible perfectly.) The problem is that the other two cases are proven using a denseness in a particular space argument (&lt;a href=&quot;http://iopscience.iop.org/article/10.1070/RM1997v052n06ABEH002155/meta&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0205115&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;, much as you would use between $H$ and $T$ to generate arbitrary single-qubit rotations for the first set), each using a different subspace, and not by converting from one set to another. Is there an exact, direct conversion?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The particular sticking points are:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;(2 to 1): creating $T$ from controlled-$S$ and $H$. I could also accept creating any single-qubit phase gate that is not $S$, $Z$ or $S^\dagger$.&lt;/li&gt;&#xA;&lt;li&gt;(3 to 1): creating a controlled-Hadamard from $H$ and Toffoli. (Controlled-Hadamard is the equivalent of $T$ if the target is the ancilla qubit.) Alternatively, &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0301040&quot; rel=&quot;noreferrer&quot;&gt;Aharonov&lt;/a&gt; gives us a way to convert 3 to 2, so the (2 to 1) step would be sufficient.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;For reference, section 4 of &lt;a href=&quot;https://arxiv.org/abs/quant-ph/0205115&quot; rel=&quot;noreferrer&quot;&gt;this paper&lt;/a&gt; seems to make some steps related to achieving the (3 to 1) case, but in aiming for generality, pedagogy has perhaps fallen by the wayside slightly.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="124" LastEditDate="2018-08-31T11:14:56.423" LastActivityDate="2018-08-31T11:14:56.423" Title="Explicit Conversion Between Universal Gate Sets" Tags="&lt;quantum-gate&gt;&lt;gate-synthesis&gt;&lt;universal-gates&gt;" AnswerCount="0" CommentCount="4" FavoriteCount="1" />
  <row Id="4127" PostTypeId="2" ParentId="4125" CreationDate="2018-08-31T12:17:37.637" Score="4" Body="&lt;p&gt;There are two simple ways in which you can generalise an &quot;XOR cipher&quot; (&lt;em&gt;i.e.&lt;/em&gt;,&amp;nbsp;a &lt;a href=&quot;https://en.wikipedia.org/wiki/One-time_pad&quot; rel=&quot;nofollow noreferrer&quot;&gt;one-time pad or Vernam cipher&lt;/a&gt;) to the quantum regime.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;One way is to use the fact that the Pauli operators form a &lt;a href=&quot;https://en.wikipedia.org/wiki/Quantum_t-design&quot; rel=&quot;nofollow noreferrer&quot;&gt;quantum 1-design&lt;/a&gt;, which is a fancy way of saying that applying a uniformly random Pauli operator to any single-qubit quantum state makes it indistinguishable from the maximally mixed state &amp;mdash; provided of course that &lt;em&gt;which&lt;/em&gt; Pauli operator you perform is kept secret from any interfering party.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Using this fact, you can realise a simple &quot;quantum XOR cipher&quot; between Alice and Bob by sharing a one-time pad between them, and then doing the following for any input state $\rho$ of Alice's:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Alice takes two bits $(x,z)$ from the one-time pad, and performs the transformation $\rho \mapsto \sigma := P \rho P^\dagger$, where $P = X^x Z^z$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Alice transmits $\sigma$ to Bob. By averaging over all values of $(x,z) \in \{00,01,10,11\}$ it is easy to see that, to someone who doesn't know the value of $(x,z)$, the state $\sigma$ is indistinguishable from $\tfrac{1}{2} \mathbf 1$ and contains no information about the state $\rho$.&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Bob recovers $\rho = P^\dagger \!\sigma P$ using the same operator $P = X^x Z^z$ defined by his copy of the one-time pad.&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;Building on this idea, another way of generalising the XOR cipher (as Craig Gidney indicates, and which seems to be part of the folklore, see for example &lt;a href=&quot;https://physics.stackexchange.com/a/14285/4976&quot;&gt;a post of mine on Physics.SE&lt;/a&gt;), is teleportation.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;In this case, the EPR state is akin to a shared random bit which is independent of any data which is to be encoded, and again must be carefully distributed between Alice and Bob.&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;The Bell-basis measurement performed by Alice is akin to computing the parity of the (arbitrary) input quantum state with that shared random bit;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;The pair of classical bits which indicate the outcome play the role of the &lt;em&gt;result&lt;/em&gt; of the parity computation, which contain no information about the state which is being &quot;encoded&quot;;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;p&gt;The correction performed by Bob is akin to reversing the parity computation, reproducing the input state original possessed by Alice.&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;An intriguing feature of this analogy is that, whereas a one-time pad &lt;em&gt;should&lt;/em&gt; only be used once, in the quantum regime the EPR pair &lt;em&gt;can only&lt;/em&gt; be used once, as it is consumed. Also intriguing is that what one would think of as the encoded quantum state is effectively stored by the system playing the role of the &lt;em&gt;shared random bit&lt;/em&gt; &amp;mdash; the outcome of the &quot;parity computation&quot; instead plays the role of the reversible encoding of that qubit (this part of the protocol is effectively the same as the encoding of a state using a random Pauli operator).&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;In both cases above, two random bits are involved in what might be thought of as the encoding procedure. This might seem deep, but actually, I would suggest that it is just the fact that a uniformly random Pauli operator is involved in both cases (albeit slightly more subtly in teleportation than in using the Pauli operators as a 1-design).&lt;/p&gt;&#xA;" OwnerUserId="124" LastEditorUserId="124" LastEditDate="2018-08-31T17:18:41.190" LastActivityDate="2018-08-31T17:18:41.190" CommentCount="1" />
  <row Id="4129" PostTypeId="1" AcceptedAnswerId="4130" CreationDate="2018-08-31T18:43:59.720" Score="1" ViewCount="48" Body="&lt;p&gt;I've just learned about the density operator, and it seems like a fantastic way to represent the branching nature of measurement as simple algebraic manipulation. Unfortunately, I can't quite figure out how to do that.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Consider a simple example: the state $|+\rangle$, which we will measure in the classical basis (so with measurement operator $I_2$). The density operator of this state is as follows:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\rho = |+\rangle\langle+| = \begin{bmatrix} \frac{1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}} \end{bmatrix} ⊗ \begin{bmatrix} \frac{1}{\sqrt{2}}, \frac{1}{\sqrt{2}} \end{bmatrix}&#xA;= \begin{bmatrix} \frac 1 2 &amp;amp; \frac 1 2 \\ \frac 1 2 &amp;amp; \frac 1 2 \end{bmatrix}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Since measuring $|+\rangle$ in the classical basis collapses it to $|0\rangle$ or $|1\rangle$ with equal probability, I'm imagining there's some way of applying the measurement operator $I_2$ to $\rho$ such that we end up with the same density operator as when we &lt;em&gt;don't know&lt;/em&gt; whether the state is $|0\rangle$ or $|1\rangle$:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\rho = \frac 1 2 \begin{bmatrix} 1 \\ 0 \end{bmatrix} ⊗ \begin{bmatrix} 1, 0 \end{bmatrix}&#xA;+ \frac 1 2 \begin{bmatrix} 0 \\ 1 \end{bmatrix} ⊗ \begin{bmatrix} 0, 1 \end{bmatrix}&#xA;= \begin{bmatrix} \frac 1 2 &amp;amp; 0 \\ 0 &amp;amp; 0 \end{bmatrix}&#xA;+ \begin{bmatrix} 0 &amp;amp; 0 \\ 0 &amp;amp; \frac 1 2 \end{bmatrix}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;From there, we can continue applying unitary transformations to the density operator so as to model a measurement occurring mid-computation. What is the formula for applying a measurement operator to the density operator? Looking in the Mike &amp;amp; Ike textbook section on the density operator, I only see the density operator measurement formula for a &lt;em&gt;specific&lt;/em&gt; measurement outcome. I'd like to know the density operator measurement formula which captures all possible results of the measurement.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As a followup question, I'm also curious as to the formula when measuring some subset of multiple qubits.&lt;/p&gt;&#xA;" OwnerUserId="4153" LastEditorUserId="26" LastEditDate="2018-09-01T07:36:54.707" LastActivityDate="2018-09-01T07:36:54.707" Title="How is measurement modelled when using the density operator?" Tags="&lt;measurement&gt;&lt;density-matrix&gt;" AnswerCount="1" CommentCount="0" />
  <row Id="4130" PostTypeId="2" ParentId="4129" CreationDate="2018-08-31T19:10:29.983" Score="3" Body="&lt;p&gt;To define a measurement, you need a set of measurement operators $P_i$, one for each possible measurement outcome, that satisfy a completeness relation&#xA;$$&#xA;\sum_iP_i=\mathbb{I}&#xA;$$&#xA;Let me specialise to the case of projective measurements, where $P_i^2=P_i$.&#xA;To calculate the probability of a given density operator $\rho$ giving outcome $i$, you simply calculate&#xA;$$&#xA;p_i=\text{Tr}(P_i\rho),&#xA;$$&#xA;and the state that you get as output is&#xA;$$&#xA;\rho_i=\frac{P_i\rho P_i}{p_i}.&#xA;$$&#xA;So, in the case of the measurement of a single qubit in the computational basis, you have&#xA;$$&#xA;P_0=|0\rangle\langle 0|\qquad P_1=|1\rangle\langle 1|,&#xA;$$&#xA;and you'll get $p_0=p_1=\frac12$. At that point, you proceed with using the separate measurement outcomes separately, unless there is a case where some other user doesn't know what the outcome was. Then they use a standard Bayesian approach to describe their state of knowledge as&#xA;$$&#xA;\tilde\rho=\sum_ip_i\rho_i.&#xA;$$&#xA;In this case, that's the maximally mixed state $\mathbb{I}/2$. But for anybody who knows what the measurement result is, you just keep going with the separate results. If it's too painful having to do the full calculation twice, you might do a trick like writing a state&#xA;$$&#xA;\frac12(P_0+P_1\pm(P_0-P_1)).&#xA;$$&#xA;Then you just do the calculation once and, at the end, choose either the + sign to see what happens for the 0 measurement result, or - to see what happens for the 1 result. But it probably doesn't actually reduce your workload.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;If you want to talk about $n$ qubits where you measure just the first one, then you use the measurement operators&#xA;$$&#xA;P_0=|0\rangle\langle 0|\otimes\mathbb{I}^{\otimes(n-1)}\qquad P_1=|1\rangle\langle 1|\otimes\mathbb{I}^{\otimes(n-1)}&#xA;$$&#xA;and apply all the same formalism as before.&lt;/p&gt;&#xA;" OwnerUserId="1837" LastEditorUserId="1837" LastEditDate="2018-08-31T19:29:54.640" LastActivityDate="2018-08-31T19:29:54.640" CommentCount="2" />
  <row Id="4132" PostTypeId="2" ParentId="4110" CreationDate="2018-08-31T22:51:52.327" Score="1" Body="&lt;p&gt;Maybe this &lt;a href=&quot;https://docs.google.com/viewer?url=https%3A%2F%2Fwww.researchgate.net%2Fpublication%2F301740109_Quantum_hyperparallel_algorithm_for_matrix_multiplication%2Ffulltext%2F573a1f5f08ae9ace840dc6ef%2F301740109_Quantum_hyperparallel_algorithm_for_matrix_multiplication.pdf%3Forigin%3Dpublication_detail&quot; rel=&quot;nofollow noreferrer&quot;&gt;one&lt;/a&gt; can be useful. Their algorithm is called Quantum hyperparallel algorithm for matrix multiplication and they state that the time complexity is O($N^2$) which is the lower bound for matrix multiplication apparently. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I won't describe the whole procedure but give just the idea behind.&#xA;You know matrix multiplication is just a calculation of inner products.&#xA;There is a quantum algorithm called the swap Test which enables you to compute the overlap (inner product) between quantum states.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;They based their algorithm on it. It seems you have no restrictions on your matrices. You need however oracles like many quantum algorithms.&lt;/p&gt;&#xA;" OwnerUserId="4127" LastEditorUserId="4127" LastEditDate="2018-09-01T12:57:32.293" LastActivityDate="2018-09-01T12:57:32.293" CommentCount="2" />
  <row Id="4133" PostTypeId="2" ParentId="1206" CreationDate="2018-09-01T03:38:18.393" Score="2" Body="&lt;p&gt;Less formally-stated than the other answers, but for beginners I like the intuitive method outlined by Prof. Vazirani in &lt;a href=&quot;https://www.youtube.com/watch?v=wLWkHSpt_Zw&amp;amp;t=3m12s&quot; rel=&quot;nofollow noreferrer&quot;&gt;this video&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Suppose you have a general two-qbit state:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$|\psi\rangle = \begin{bmatrix} \alpha_{00} \\ \alpha_{01} \\ \alpha_{10} \\ \alpha_{11} \end{bmatrix} = \alpha_{00}|00\rangle + \alpha_{01}|01\rangle + \alpha_{10}|10\rangle + \alpha_{11}|11\rangle$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now suppose you measure the most-significant (leftmost) qbit in the computational basis (as in, collapse it to either $|0\rangle$ or $|1\rangle$). There are two questions we might ask:&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;What is the probability that the measured qbit collapses to $|0\rangle$? What about $|1\rangle$?&lt;/li&gt;&#xA;&lt;li&gt;What is the state of the 2-qbit system after measurement?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;For the first question, the intuitive answer is this: take the sum of squares of all amplitudes associated with the value for which you want to find the probability of collapse. So, if you want to know the probability of the measured qbit collapsing to $|0\rangle$, you'd look at the amplitudes associated with cases $|00\rangle$ and $|01\rangle$, because those are the cases where the measured qbit is $|0\rangle$. Thus:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$P[|0\rangle] = |\alpha_{00}|^2 + |\alpha_{01}|^2$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Similarly, for $|1\rangle$ you look at the amplitudes associated with cases $|10\rangle$ and $|11\rangle$, so:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$P[|1\rangle] = |\alpha_{10}|^2 + |\alpha_{11}|^2$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As for the state of the 2-qbit system after measurement, what you do is cross out all the components of the superposition which are inconsistent with the answer you got. So, if you measured $|0\rangle$, then the state after measurement is:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\require{cancel} |\psi\rangle = \alpha_{00}|00\rangle + \alpha_{01}|01\rangle + \cancel{\alpha_{10}|10\rangle} + \cancel{\alpha_{11}|11\rangle} =  \alpha_{00}|00\rangle + \alpha_{01}|01\rangle$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;However, this state is not normalized - the sum of squares does not add up to 1, and so you have to normalize it:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$|\psi\rangle = \frac{\alpha_{00}|00\rangle + \alpha_{01}|01\rangle}{\sqrt{|\alpha_{00}|^2 + |\alpha_{01}|^2}}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Similarly, if you measured $|1\rangle$ then you'd get:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$\require{cancel} |\psi\rangle = \cancel{\alpha_{00}|00\rangle} + \cancel{\alpha_{01}|01\rangle} + \alpha_{10}|10\rangle + \alpha_{11}|11\rangle = \alpha_{10}|10\rangle + \alpha_{11}|11\rangle$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Normalized:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$|\psi\rangle = \frac{\alpha_{10}|10\rangle + \alpha_{11}|11\rangle}{\sqrt{|\alpha_{10}|^2 + |\alpha_{11}|^2}}$&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And that's how you calculate the action of measuring one qbit in a multi-qbit state, in the simplest case!&lt;/p&gt;&#xA;" OwnerUserId="4153" LastActivityDate="2018-09-01T03:38:18.393" CommentCount="0" />
  <row Id="4134" PostTypeId="2" ParentId="4110" CreationDate="2018-09-01T21:16:55.083" Score="0" Body="&lt;p&gt;First of all the cost on a &lt;strong&gt;&lt;em&gt;classical&lt;/em&gt;&lt;/strong&gt; computer of the dominant step can be improved from the $\mathcal{O}(C^2 N)$ in your question. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;I managed to bring the classical cost down to  $\mathcal{O}(C^{1.37} N)$&#xA; in my new answer to the &lt;a href=&quot;https://math.stackexchange.com/questions/84495/computational-complexity-of-least-square-regression-operation/2902084#2902084&quot;&gt;question on the Mathematics Stack Exchange&lt;/a&gt; that you linked.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Now you have two questions:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;(1) can a quantum computer do step 1 in time faster than $\mathcal{O}(C^{1.37} N)$, and&lt;/li&gt;&#xA;&lt;li&gt;(2) would this lead to an overall reduction in complexity of the entire regression algorithm?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;The answer to (2) is yes, because the step with $\mathcal{O}(C^{1.37} N)$ is the step that dominates the complexity of the whole problem, and this is because $N$ has to be bigger than $C$ for the matrix to be invertible, which was pointed out by Chris Taylor in &lt;a href=&quot;https://math.stackexchange.com/a/84503/202425&quot;&gt;this answer&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The answer to (1) is an open problem.&lt;/p&gt;&#xA;" OwnerUserId="2293" LastEditorUserId="2293" LastEditDate="2018-09-02T00:08:55.740" LastActivityDate="2018-09-02T00:08:55.740" CommentCount="0" />
</posts>